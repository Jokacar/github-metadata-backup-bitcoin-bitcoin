{
  "type": "issue",
  "issue": {
    "id": 2353360477,
    "node_id": "I_kwDOABII586MRW5d",
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288",
    "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
    "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288/labels%7B/name%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288/comments",
    "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288/events",
    "html_url": "https://github.com/bitcoin/bitcoin/issues/30288",
    "number": 30288,
    "state": "open",
    "state_reason": null,
    "title": "RFC: Assumeutxo and large forks and reorgs",
    "body": "(tl;dr This is mainly a question about when an assumeutxo snapshot is loaded, if it makes more sense for the original chainstate to continue downloading and attaching blocks in the normal way, or if it should only download and attach blocks leading up to the snapshot block.)\r\n\r\n---\r\n\r\nIt seems unclear how validation code should behave when an assumeutxo snapshot is loaded, and then new headers are received pointing to a forked chain with more proof of work than any known chain including the snapshot block. This question come up in https://github.com/bitcoin/bitcoin/pull/29519#discussion_r1628436308.\r\n\r\nThis is not an urgent question, because if this situation arose on the network there would be bigger issues to confront than assumeutxo behavior, but it's worth raising because there seem to be different ways of dealing with it that impact that design of validation code, and maybe also have implications in other cases like eclipse attacks.\r\n\r\n### Background\r\n\r\nWhen an assumeutxo snapshot is loaded, a new chainstate object is created. A chainstate is just a UTXO database and a pointer to the last block added to the database.\r\n\r\nSo immediately after the assumeutxo snapshot is loaded there are two chainstates:\r\n\r\n- The original chainstate pointing at the most-work block which has been locally validated. (This block should normally be an ancestor of the snapshot block, but doesn't have to be.)\r\n\r\n- A new snapshot chainstate pointing at the snapshot block, which has been not been locally validated and probably not downloaded, but is assumed-valid.\r\n\r\nAfter this point, because of missing block and undo data before the snapshot, the snapshot chainstate is constrained to only sync to chains including the snapshot block. If headers for chains with more work not including the snapshot block are found, the snapshot chainstate needs to ignore them, because even if it downloaded blocks on those chains, it would lack the undo data needed to reorg and actually validate them.\r\n\r\nIt is less clear whether the original chainstate should also ignore chains not including the snapshot block.\r\n\r\n### Possible behavior: Original chainstate targets the most-work chain\r\n\r\nThis is not what currently happens, but simplest approach might be for the original chainstate to be unaffected by the snapshot chainstate, and to continue to download and attach the same blocks it otherwise would have if no snapshot were loaded. It would just do it more slowly due to a reduced cache size and lower priority for block requests compared to the snapshot chainstate.\r\n\r\n### Current behavior: Original chainstate targets the snapshot block\r\n\r\nCurrently, instead of the original chainstate being unaffected by the snapshot chainstate, it's constrained to only download and blocks that are ancestors of the snapshot block, and ignore other chains.\r\n\r\n### Tradeoffs\r\n\r\nPossible advantages of original chainstate targeting the most work chain:\r\n\r\n- Probably simpler implemenation. If original chainstate behaves the same way whether or not a snapshot is loaded, fewer special cases need to exist when a snapshot is loaded.\r\n- Would sync to most-work chain faster if most-work chain did not include the snapshot block and turned out to be valid (i.e. not a hard fork)\r\n- Maybe more philosophically neutral, because the node continues normal behavior of syncing to the most-work chain, instead of ignoring any chain not including the snapshot block.\r\n\r\nPossible advantages of original chainstate targeting the snapshot block:\r\n\r\n- This what code currently does so would not require further changes.\r\n- Maybe could provide resilience against hard forks that contain more work? If loading a snapshot makes a node temporarily ignore any chain not containing a snapshot block, maybe that is a useful feature if the chain with more work turns out to be invalid.\r\n- Could help in an eclipse attack? If headers or blocks after the snapshot block were withheld, this could temporarily stop the node from syncing to a undesirable fork excluding the snapshot block that seemed to have more work.\r\n- [Maybe other reasons? Personally I'm more inclined towards the first approach, and have a weak understanding of things like forks and eclipse attacks, so I'm struggling to think of advantages to this approach.]\r\n  \r\n### Questions\r\n\r\nAs long as the most-work header chain includes the snapshot block, there should be no real differences in behavior between the two approaches described above. But if the most-work header chain doesn't include the snapshot block, it raises questions about which approach might be preferable. It also raises questions about what other behaviors we should consider implementing if this state is detected, like warning the user, shutting down, changing sync behavior, maybe adjusting relative priorities of the two chainstates. The main question is if we should be doing anything different than we are doing now.",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "locked": false,
    "comments": 3,
    "created_at": "2024-06-14T13:14:57Z",
    "updated_at": "2024-06-15T13:07:11Z"
  },
  "events": [
    {
      "event": "commented",
      "id": 2168444052,
      "node_id": "IC_kwDOABII586BP9SU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168444052",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T17:10:25Z",
      "updated_at": "2024-06-14T17:10:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "> This is not what currently happens, but simplest approach might be for the original chainstate to be unaffected by the snapshot chainstate, and to continue to download and attach the same blocks it otherwise would have if no snapshot were loaded. It would just do it more slowly due to a reduced cache size and lower priority for block requests compared to the snapshot chainstate.\r\n\r\nI think that the concept of the Active Chainstate / Active Tip is important for this this discussion. Currently, it is tied to the snapshot chainstate until the background sync has finished.\r\nIf we keep that logic, having the background chainstate target the most-work block doesn't really achieve anything - if that chain turns out to be valid, we would still never use it for anything meaningful because the snapshot chainstate will remain the active one.\r\nSo in order for targeting the most-work chain to make any sense, we'd also need to introduce the possibility of switching the active chainstate to it without the requirement that the background sync has to finish. Which would lead to other questions: I we don't prioritize syncing the background chainstate towards it anymore, should we keep the now-unused snapshot chainstate around indefinitely and just ignore it exists? Should we be able to switch the active chainstate back to the snapshot chain in case we receive more blocks building on top of it, so that it becomes the most-work chain again?\r\n\r\nConsidering that AssumeUtxo sync is meant to be an optional and temporary optimization, and that large reorgs should be very infrequent, it could also make sense to abandon the AssumeUtxo sync, delete the snapshot chainstate and revert to normal sync as soon as we accept a header on a different chain that has more work than the best header of the snapshot chain.\r\n\r\nI think that pragmatically we shouldn't accept a snapshot in the first place if it's not an ancestor of the most-work header `m_best_header` (I plan on opening a PR for that soon), but that doesn't solve the problem completely because we might only learn about another chain after having loaded the snapshot successfully.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/issues/30288#issuecomment-2168444052",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288"
    },
    {
      "event": "commented",
      "id": 2168713360,
      "node_id": "IC_kwDOABII586BQ_CQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168713360",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T20:23:40Z",
      "updated_at": "2024-06-14T20:23:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I think that the concept of the Active Chainstate / Active Tip is important for this this discussion\r\n\r\nAgree it's worth mentioning. I think decisions about how chainstates are synced are mostly separate from decisions about how they are used and prioritized. But for completeness, I was assuming that if the original chainstate ever had more work than the snapshot chainstate, the snapshot chainstate would be unused and could be deleted, and the original chainstate would become the \"active\" chainstate again. Also, cache and download priority would be shifted to whichever chainstate had headers showing the most-work.\r\n\r\n(Somewhat related to this: I don't think the concept of an \"active\" chainstate is useful, and in #30214 I eliminate many uses of that designation. Right now when a snapshot is loaded, indexes treat the original chainstate as active, while wallets treat the snapshot chainstate as active. RPCs mostly treat the snapshot chainstate as active, but sometimes show information about both chainstates. I think it's better to refer to chainstates as current vs historical, or validated vs. assumed-valid instead of referring more nebulously to an \"active\" chainstate.)\r\n\r\n> it could also make sense to abandon the AssumeUtxo sync, delete the snapshot chainstate and revert to normal sync as soon as we accept a header on a different chain that has more work than the best header of the snapshot chain.\r\n\r\nThat would be a third approach. Keeping the \"Original chainstate targets the snapshot block\" logic, but then abandoning the snapshot and switching back to \"Original chainstate targets the most-work chain\" logic when some condition is detected. I'm not sure this approach has advantages over always targeting the most-work chain, but it could, depending on the implementation details.\r\n\r\nI'm also not sure just the existence of headers with the most work not including the snapshot block is a good enough reason to refuse loading the snapshot, or to delete the snapshot chainstate after a snapshot is loaded. It could be weird if the other chain that seemed to have more work turned out to be invalid, or more headers were received later that actually included the snapshot block allowed loading the snapshot again after it had previously been discarded or refused.\r\n\r\nIn general, just letting original chainstate sync to most-work chain, regardless of whether a snapshot chainstate is loaded seems like the simplest approach with the fewest special cases, and doesn't seem to have significant drawbacks?",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/issues/30288#issuecomment-2168713360",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288"
    },
    {
      "event": "commented",
      "id": 2169559245,
      "node_id": "IC_kwDOABII586BUNjN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2169559245",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-15T13:07:10Z",
      "updated_at": "2024-06-15T13:07:10Z",
      "author_association": "MEMBER",
      "body": "Good discussion question, thanks for raising!\r\n\r\n> Considering that AssumeUtxo sync is meant to be an optional and temporary optimization, and that large reorgs should be very infrequent, it could also make sense to abandon the AssumeUtxo sync, delete the snapshot chainstate and revert to normal sync as soon as we accept a header on a different chain that has more work than the best header of the snapshot chain.\r\n\r\nI think something like this makes more sense than to change how the background sync works.  In my view, the purpose of the assumeutxo optimization is to offer users a different trust model where they can still reasonably safely get online and using the network prior to the background sync finishing.  In the event that there is a competing tip with more work than a tip built on the snapshot, it's impossible for the software to determine which tip is the right one without doing a lot of work, and I think our choices are:\r\n 1. Proceed under the assumption that the assumeutxo snapshot is correct, and effectively \"checkpoint\" the assumeutxo block hash (so that the snapshot chainstate doesn't try to reorg to the most work chain), allowing the user to continue using the network in the meantime.\r\n 2. Abandon the assumeutxo optimization in this scenario and fall back to current sync behavior.\r\n\r\nOption 1 is of course incredibly risky to a user if that assumption is wrong (ie acting as though that is the most valid work chain can result in funds loss). Moreover, the scenario that we'd be optimizing for is a highly unusual one, as we'd be optimizing for faster startup time for assumeutxo users in the event that there's a more-work but consensus invalid fork of the chain.  In that unusual scenario, we could always write new code to optimize for that case -- or do simpler things like invalidating the block hash of the first consensus-invalid block header on that chain to avoid processing it (we could hard code this in future software versions, and perhaps instruct users on how to use invalidateblock as a temporary workaround).\r\n\r\nSo I think option 2 makes more sense for now: let's change our code so that if we ever detect the potential for an assumeutxo snapshot to not be on the most-work chain, just abandon the optimization and proceed without it.  Exactly how we handle that in our software still requires some thought: if a user has already started transacting based on an assumeutxo snapshot, and then we learn about some more work headers chain that forks before the snapshot height, what exactly do we do?  Perhaps we should shut down and throw whatever the biggest warning/error message we can is, requiring a restart that will discard the snapshot chainstate?  Or we could just treat it as a reorg down to a less work tip (ie from the snapshot's tip back to the fully-validated tip), which while not normally allowed is already possible in our code if `invalidateblock` is used, so maybe that works ok too?",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/issues/30288#issuecomment-2169559245",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288"
    }
  ]
}