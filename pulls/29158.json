{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158",
    "id": 1660385595,
    "node_id": "PR_kwDOABII585i93k7",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/29158",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/29158.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/29158.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/ea36af80beeeee0b9de793e52887ba3e164b803c",
    "number": 29158,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "PoC: fuzz chainstate and block managers",
    "user": {
      "login": "darosior",
      "id": 22457751,
      "node_id": "MDQ6VXNlcjIyNDU3NzUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/darosior",
      "html_url": "https://github.com/darosior",
      "followers_url": "https://api.github.com/users/darosior/followers",
      "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
      "organizations_url": "https://api.github.com/users/darosior/orgs",
      "repos_url": "https://api.github.com/users/darosior/repos",
      "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/darosior/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "We don't have a fuzzing harness for our main consensus engine [0]. This PR introduces two new targets which respectively fuzz the `BlockManager` and `ChainstateManager` (process headers, blocks, reorgs and assert some invariants in doing so).\r\n\r\nThere is two main obstacles to achieving this: PoW and io. The blocks and chainstate databases can be stored in memory but blocks still need a valid proof of work and to be stored on disk. Niklas solved the first issue in #28043 by simply introducing a global which makes it possible to mock the PoW check (his commit is cherry-picked here). After considering other approaches, i also used globals to mock disk io.\r\n\r\nI'm interested with this PR in getting feedback on the concept and the approach, but also in suggestions of more invariants to be asserting in the `chainstate` fuzz target.\r\n\r\nRegarding other approaches i tried the most potentially promising was to leverage `ld`'s `--wrap` option to mock the syscalls without having to modify non-test code. But i didn't try too hard to make it work: better to have a demo of what can be achieved first with a more trivial way of mocking filesystem calls. If there is interest in these fuzz targets, i can give this approach another look.\r\n\r\nRegarding efficiency, the chainstate fuzz target is quite slow at the moment but i've at least 2x its performance by rebasing on #28960 and making `CheckBlockIndex` callable externally even if `!ShouldCheckBlockIndex()`. Suggestions for performance improvements welcome too.\r\n\r\n---\r\n\r\n[0] Well there is `utxo_total_supply` but it's very specialized toward exercising a specific past bug.",
    "labels": [
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2023-12-30T10:05:20Z",
    "updated_at": "2024-02-01T16:20:41Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "d16bd8672d18990491d964ffb174fe08ed9f096b",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "darosior:2309_fuzz_chainstate",
      "ref": "2309_fuzz_chainstate",
      "sha": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 168868367,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjg4NjgzNjc=",
        "name": "bitcoin",
        "full_name": "darosior/bitcoin",
        "owner": {
          "login": "darosior",
          "id": 22457751,
          "node_id": "MDQ6VXNlcjIyNDU3NzUx",
          "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/darosior",
          "html_url": "https://github.com/darosior",
          "followers_url": "https://api.github.com/users/darosior/followers",
          "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
          "organizations_url": "https://api.github.com/users/darosior/orgs",
          "repos_url": "https://api.github.com/users/darosior/repos",
          "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/darosior/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/darosior/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/darosior/bitcoin",
        "archive_url": "https://api.github.com/repos/darosior/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/darosior/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/darosior/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/darosior/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/darosior/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/darosior/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/darosior/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/darosior/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/darosior/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/darosior/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/darosior/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/darosior/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/darosior/bitcoin/events",
        "forks_url": "https://api.github.com/repos/darosior/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/darosior/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/darosior/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/darosior/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/darosior/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/darosior/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/darosior/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/darosior/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/darosior/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/darosior/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/darosior/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/darosior/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/darosior/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/darosior/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/darosior/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/darosior/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:darosior/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/darosior/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/darosior/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/darosior/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/darosior/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/darosior/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/darosior/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/darosior/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/darosior/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/darosior/bitcoin/hooks",
        "svn_url": "https://github.com/darosior/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 228395,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-01-13T12:43:47Z",
        "created_at": "2019-02-02T19:20:27Z",
        "updated_at": "2023-11-07T12:50:46Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "4b1196a9855dcd188a24f393aa2fa21e2d61f061",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36658,
        "stargazers_count": 73654,
        "watchers_count": 73654,
        "size": 248114,
        "default_branch": "master",
        "open_issues_count": 686,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-02-01T16:36:22Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-02-01T16:17:37Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
      }
    },
    "author_association": "MEMBER",
    "draft": true,
    "additions": 800,
    "deletions": 7,
    "changed_files": 10,
    "commits": 6,
    "review_comments": 8,
    "comments": 6
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ1N2VmZjExODMzNDVlYzM0MGFhNTYwZDAwY2MwZjlkZDllOTMzZWE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/457eff1183345ec340aa560d00cc0f9dd9e933ea",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/457eff1183345ec340aa560d00cc0f9dd9e933ea",
      "tree": {
        "sha": "258c08586cc01890d08a36343824b7241cfb928c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/258c08586cc01890d08a36343824b7241cfb928c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 258c08586cc01890d08a36343824b7241cfb928c\nparent c840dea27edfcfc67beb756ca6eda27b319f93d5\nauthor dergoegge <n.goeggi@gmail.com> 1688725335 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1702907255 +0100\n\nAllow mocking CheckProofOfWork\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmWATXcACgkQ4T/BRc0/\nQwT+ggv+Oea5PfQ8FcRDTz87pEQqx1hA8QEygpPISfK5o90lqVg1AcNyQ16N4Mjk\nF7OhDafHS0vrbik+sL0n75LBCpPZA7Xw+EZCvVc6Ibz4hY/9Iu/AID9Id96n5Y21\nL/ldUh+/zWKxjNwRIFrZzlf1jz53t62RvtG1vrs2PVuB3JcDZjce9r6zvDhcf9Jz\nzkYWn7Wa5SQZrlBKwgRzerzANA/FpSxx1gSYw7rHmKoZM8w3S5u/GERE93XqsZ/n\ncKkIY/eVNYjBESetnPv3mgreiXjGdQqwBhCcOF9/8uiRi/s9R+xUzrm4tql5X4Ml\nt2uMbBHIlsjrV6DDlj3ld7K27GXThoI23ycp0IihoFPhVH8KVHczcTsSCeQ1sCHI\nbuaQKs6k9i0+nix6SrYqodaAOk5Y58ewo4OhTlcbfkeIH6Uatgzv5Sc4WMRcTdTm\n9v7hWZncwb1IL86rvUSGYumg2slT5SiAdhkEQ8xQJhGmHEjG7hw6Ty3nwnIF7CcG\nrsZIuiqM\n=FQv8\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c840dea27edfcfc67beb756ca6eda27b319f93d5",
          "sha": "c840dea27edfcfc67beb756ca6eda27b319f93d5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c840dea27edfcfc67beb756ca6eda27b319f93d5"
        }
      ],
      "message": "Allow mocking CheckProofOfWork",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-18T13:47:35Z"
      },
      "author": {
        "name": "dergoegge",
        "email": "n.goeggi@gmail.com",
        "date": "2023-07-07T10:22:15Z"
      },
      "sha": "457eff1183345ec340aa560d00cc0f9dd9e933ea"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJkYjA4NWUzMmQ5NDliN2M4MjIzMTI2OWE0MTY1YTNlNjJjM2RkOTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bdb085e32d949b7c82231269a4165a3e62c3dd96",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bdb085e32d949b7c82231269a4165a3e62c3dd96",
      "tree": {
        "sha": "dc0fde2679c1d02114cbf509c4cbb31ecc088c8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dc0fde2679c1d02114cbf509c4cbb31ecc088c8d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree dc0fde2679c1d02114cbf509c4cbb31ecc088c8d\nparent 457eff1183345ec340aa560d00cc0f9dd9e933ea\nauthor Antoine Poinsot <darosior@protonmail.com> 1703353324 +0100\ncommitter Antoine Poinsot <darosior@protonmail.com> 1703846204 +0100\n\n[PoC] fs: make some filesystem utilities mockable\n\nThe ones used indirectly by the chainstate-related fuzz targets introduced in later commits.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmWOoTwACgkQ4T/BRc0/\nQwR6XgwApMJPbxffUwSgiJ85b7Hl5RqwpD2Wsn3oULHOjXkE0/96BgACykO1OZdP\n/l1hNqMlPxOfQl1ose4WrsDmKES5ArLG3eliUj8lyKjtW+TR37ubK8joNQcBqe13\nA11Nr9plhlgWkKbeBOPPTfi5fzaxVSc41WMG3IuBcMQ7s64mWCzz4T+TFHZVYEJt\nGgFGQWDME96iAifFvPuyBBQ7KjpgRczBnlspysrti/t/BMV5gNgDMC+uCQda0l5G\nnFwWiTPbABp6GXL7fj7b8BuhoDd4Q5v82Aa34NlNxB3jRO7o9kwlZrZQYXXXLnlq\n2rgM/PvMP6fyxTZHAGMz9X6fXHsDvxoV3W24U2j3MNTIsJ5U/6/soBwGgQgEUkJC\nkDyD2kVnhFaeU7wB7Z0U6lTGvZWIyUsAlUmXONGc465s7pju3nP0yobS/wQT2pc5\n5udWDjV6owgku/CM81omKcPi3OGgLO2tx77oQJum7fU3ZzLzFS97besCKsOdISMp\nnWRdRv1D\n=yMs7\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/457eff1183345ec340aa560d00cc0f9dd9e933ea",
          "sha": "457eff1183345ec340aa560d00cc0f9dd9e933ea",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/457eff1183345ec340aa560d00cc0f9dd9e933ea"
        }
      ],
      "message": "[PoC] fs: make some filesystem utilities mockable\n\nThe ones used indirectly by the chainstate-related fuzz targets introduced in later commits.",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-29T10:36:44Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-23T17:42:04Z"
      },
      "sha": "bdb085e32d949b7c82231269a4165a3e62c3dd96"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU5NzRhZjcxYjRmNjBmNjc3YTZmNjQ0NTBkZWQzYTJiNTczNDlkOTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5974af71b4f60f677a6f64450ded3a2b57349d95",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5974af71b4f60f677a6f64450ded3a2b57349d95",
      "tree": {
        "sha": "fed813fca33b02c33b14e882b20549b67e008489",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fed813fca33b02c33b14e882b20549b67e008489"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree fed813fca33b02c33b14e882b20549b67e008489\nparent bdb085e32d949b7c82231269a4165a3e62c3dd96\nauthor Antoine Poinsot <darosior@protonmail.com> 1703353762 +0100\ncommitter Antoine Poinsot <darosior@protonmail.com> 1703846244 +0100\n\n[PoC] fs: make std re[name,move] mockable\n\nNot in fsbridge because it would be a much larger diff: would have to\noverwrite all fs::rename and fs::remove to fsbridge::re[name,move].\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmWOoWQACgkQ4T/BRc0/\nQwS2jAv/XAsgniTePIRvnUzTtsBcj1XN/Uu8h0KDLwvLYx+DAIYjgaFznwsbrmbB\nt7g3ZU7Fm2OgTfE1TFhGgHnEJXKPLGCCkiftOSI0pTHAZ12wGwgEO2QrKMzKm8CL\nK+4y5JXe/BuZMPG2H32Z2/IEH9c/Y0Wi90vYBt7XHHvYR0zH2nceIKe8oBEsjlK9\nbvghw6TI5Gwhplw8FWCACC82zdzVjoSaycM0SyoWj9Q5T1DojqKHiNPmKfjszs56\nPZNtyXcl7U7+LZnEsmvQ5Yobw+z+Q83bIDQAJkTjARK/P1oyvqb/35w0l901r49z\ngznTtr+kUe5Az/T2qx2maTXUOj505aUuT2LvXUmetfS8+w2aKWd+22VtdsoVLYgq\nZdEjgJY+boTe/SI71X8zxIb16rz2xhspqYUynIEEmC1w++SK+5LF8Q1zKiYpvePy\nwkf12t/9WGbA3yGphbrFPY4ev+d/rudhencJlhMN5gkFwaO/zd6Xxc1PEk+Npp5l\nKcFWjLuT\n=0tds\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bdb085e32d949b7c82231269a4165a3e62c3dd96",
          "sha": "bdb085e32d949b7c82231269a4165a3e62c3dd96",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bdb085e32d949b7c82231269a4165a3e62c3dd96"
        }
      ],
      "message": "[PoC] fs: make std re[name,move] mockable\n\nNot in fsbridge because it would be a much larger diff: would have to\noverwrite all fs::rename and fs::remove to fsbridge::re[name,move].",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-29T10:37:24Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-23T17:49:22Z"
      },
      "sha": "5974af71b4f60f677a6f64450ded3a2b57349d95"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY0ZTA3ZWY2Y2E2MzQ2OTc0NWVhNmU1MTljMTk5YWY2MThkM2Q4NWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f4e07ef6ca63469745ea6e519c199af618d3d85d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f4e07ef6ca63469745ea6e519c199af618d3d85d",
      "tree": {
        "sha": "e110b12f37d722595f9a69f3ad54f08a817571ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e110b12f37d722595f9a69f3ad54f08a817571ef"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e110b12f37d722595f9a69f3ad54f08a817571ef\nparent 5974af71b4f60f677a6f64450ded3a2b57349d95\nauthor Antoine Poinsot <darosior@protonmail.com> 1694877706 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1703846246 +0100\n\nfs_helpers: make more filesystem utilities mockable.\n\nFrom `man fmemopen`:\n> There  is  no  file  descriptor  associated with the file stream\nreturned by this function (i.e., fileno(3) will return an error if\ncalled on the returned stream).\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmWOoWYACgkQ4T/BRc0/\nQwT04Qv/dwj2BY/9tF9JBXsdXgHWggIPH9yEiEYMz8DLsplyUH1oK9P6DRmDobkQ\nlW8m+c1oLi1b6A89ATigzgwHYBo/8Deqe7dsi5gB9aoXSu6uAMdbshs6kkWj2wFZ\nDAkeGBggKaDw30//P+tgxOcAQfPb3+fDe/uz9lMQgtL+yEK7KS6rok5LSw67vGHX\n3mdjR/Ix0B/d/gJBd9XQT4F7WyxhXSDuf/4y+vF/BweZkWlJ5XnXQtwMNQgsT7Zx\nwxZY9I1nBxLj4qNrXLSPdjtpET31P3Ud13+hAvGjRC3WHivD5nYxeYeX5hyXWxHZ\n9wGX+u14GK0pQiYiEz4wtqxZ24lITKOb3Yi5sIzcf3a1VtUf1rZAY5vQfmMmqT/0\n4oCfgS6J+FgQaECY/VQ+A0b5JALgqFJuiPHoTkXROyg9S7ITcOeRNjQ3rATQFmaG\nqK056ExhSRfZP8/hjCzIj/xRFLQDPbq4BqKZxMUBXVHfXMk2G1/YsD8JhQEIFTgd\nhYBh3vxN\n=rt7o\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5974af71b4f60f677a6f64450ded3a2b57349d95",
          "sha": "5974af71b4f60f677a6f64450ded3a2b57349d95",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5974af71b4f60f677a6f64450ded3a2b57349d95"
        }
      ],
      "message": "fs_helpers: make more filesystem utilities mockable.\n\nFrom `man fmemopen`:\n> There  is  no  file  descriptor  associated with the file stream\nreturned by this function (i.e., fileno(3) will return an error if\ncalled on the returned stream).",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-29T10:37:26Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-09-16T15:21:46Z"
      },
      "sha": "f4e07ef6ca63469745ea6e519c199af618d3d85d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg4NTVkN2M1NDcwNTJmY2JhYjgxZjJjOGYzZjg5YzRjZDk0Yjc0ZTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8855d7c547052fcbab81f2c8f3f89c4cd94b74e9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8855d7c547052fcbab81f2c8f3f89c4cd94b74e9",
      "tree": {
        "sha": "a72271c7724ede083b1a319cf761141671f3f5e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a72271c7724ede083b1a319cf761141671f3f5e5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree a72271c7724ede083b1a319cf761141671f3f5e5\nparent f4e07ef6ca63469745ea6e519c199af618d3d85d\nauthor Antoine Poinsot <darosior@protonmail.com> 1699886435 +0100\ncommitter Antoine Poinsot <darosior@protonmail.com> 1703854682 +0100\n\nfuzz: add a target for the BlockManager\n\nExercise (most of) the public interface of the BlockManager and assert\nsome invariants. Notably, try to mimick block arrival whether its header\nwas announced first or not.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmWOwloACgkQ4T/BRc0/\nQwRlPAv+LW0ukBmX/MhPLLeXhMiC4t/LoYkKyqFUD6KHOdJ5IwwDfMmq1W1fbUIn\nqEtIcBNDbFynclSmYXvfECmq50524OgtZMQ3xE+XbviwtADSoXTLjmd4asCaQFXa\nyvd8o8VVi62nDN+5iypv4h6oWQ0FPQzxvm+dvka7fNrhc8INQidURODnR+01NrDc\nFCMYRfwtGDi2jZWSct53YL3scs2CTzW9FilboiqMddvlFr/TwheY6zBrqfFBAzms\nF3CYvtlDkppioMecrO9LCI7vj3ReJXz8bOmvaKFAr2Wx5xZeu65dXT+tKB1mHEZx\nenNPocKwYsOe1SLQ4grq2Fe5X+crtTsvBeidhr+bD5WdwkRX9M5H85QoK47PSD/o\n4XxeZw+AnaXNHKXRNmKlzltv/TH8XcDaBgRpFSnJimT/O6La8KQ96iy+LrscjOcC\nvdLAbO5wZioCoatXOboiosz95b6vcg6ETwbm9loDYVq5/tpMTpK6vpzpBQI6w6y7\n87uhsdXs\n=RhyZ\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f4e07ef6ca63469745ea6e519c199af618d3d85d",
          "sha": "f4e07ef6ca63469745ea6e519c199af618d3d85d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f4e07ef6ca63469745ea6e519c199af618d3d85d"
        }
      ],
      "message": "fuzz: add a target for the BlockManager\n\nExercise (most of) the public interface of the BlockManager and assert\nsome invariants. Notably, try to mimick block arrival whether its header\nwas announced first or not.",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-29T12:58:02Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-11-13T14:40:35Z"
      },
      "sha": "8855d7c547052fcbab81f2c8f3f89c4cd94b74e9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVhMzZhZjgwYmVlZWVlMGI5ZGU3OTNlNTI4ODdiYTNlMTY0YjgwM2M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ea36af80beeeee0b9de793e52887ba3e164b803c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ea36af80beeeee0b9de793e52887ba3e164b803c",
      "tree": {
        "sha": "8338bd46d7767292eb702bbf5a8f0c044163ffa8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8338bd46d7767292eb702bbf5a8f0c044163ffa8"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 8338bd46d7767292eb702bbf5a8f0c044163ffa8\nparent 8855d7c547052fcbab81f2c8f3f89c4cd94b74e9\nauthor Antoine Poinsot <darosior@protonmail.com> 1694866386 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1703855996 +0100\n\nfuzz: add a target for the ChainstateManager\n\nExercise header and block processing, asserting some invariants. Also\nthe reorg logic.\n\nThere is some low hanging fruits to optimize this targets. Namely\ncalling CheckBlockIndex() externally in a CallOneOf callback instead\nof internally after every operation, and making it possible to not use a\nthread for the notification interface (done by opened PR 28960).\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmWOx4MACgkQ4T/BRc0/\nQwSMZwwAt/CkkAs/4KOjfOmzr5/IOdjRwI2i4knoRcR4noNpGwVKQCcUHtlJgQv4\nHHd4dgAzyqscS5O2TUIrnMrOwbqgqFCGY/tbtjfYZBpZozom2bfzlHuDW/gj/xkH\nkFwarQoog7L99Oywx+eh1wUkoDE3nddbgC7XqNZX2M56QtfOWpkI8MB1BOnIf/OT\niClIdmpsFLRkBw18ah9wXybJvlOc/4H4HauZM+d7nzj5aGQ0+hzsPM4l1sxmKPrB\n9mHt8Dx/Y1pmaaRipCjAaS+dTE7gvWeG66bfi6TG39HAieHhkMJy07z0D3IzFF0o\n65iuGQyUvodkIForRt9MAbVzRcJVB03hdNmDnudpc00K5cG24NJnR6QwSdHz1Ic0\nJgh1tJdu0pUBtVqhrcAqwAHUUX/p/PxCeueJqi3NVFaoZ8Mu9+wqnVdej9gLxOjK\n3k3mvsm+RzxqaoqmupPhmiD8sbeoN97vKi1Uv4+NCjoXV31yIprBzWJmccrqdvOK\n5Jc9Kt1N\n=BAkM\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8855d7c547052fcbab81f2c8f3f89c4cd94b74e9",
          "sha": "8855d7c547052fcbab81f2c8f3f89c4cd94b74e9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8855d7c547052fcbab81f2c8f3f89c4cd94b74e9"
        }
      ],
      "message": "fuzz: add a target for the ChainstateManager\n\nExercise header and block processing, asserting some invariants. Also\nthe reorg logic.\n\nThere is some low hanging fruits to optimize this targets. Namely\ncalling CheckBlockIndex() externally in a CallOneOf callback instead\nof internally after every operation, and making it possible to not use a\nthread for the notification interface (done by opened PR 28960).",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-29T13:19:56Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-09-16T12:13:06Z"
      },
      "sha": "ea36af80beeeee0b9de793e52887ba3e164b803c"
    },
    {
      "event": "commented",
      "id": 1872496827,
      "node_id": "IC_kwDOABII585vnAi7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1872496827",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-30T10:05:22Z",
      "updated_at": "2024-02-01T16:20:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/29158).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [TheCharlatan](https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1875751255), [jamesob](https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-1812003162) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29307](https://github.com/bitcoin/bitcoin/pull/29307) (util: check for errors after close and read in AutoFile by vasild)\n* [#29236](https://github.com/bitcoin/bitcoin/pull/29236) (log: Nuke error(...) by maflcko)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1872496827",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "labeled",
      "id": 11359797222,
      "node_id": "LE_lADOABII5856080BzwAAAAKlGL_m",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11359797222",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-30T10:53:38Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1800561385,
      "node_id": "PRR_kwDOABII585rUmLp",
      "url": null,
      "actor": null,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-1800561385",
      "submitted_at": "2024-01-02T15:03:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    },
    {
      "event": "commented",
      "id": 1874196101,
      "node_id": "IC_kwDOABII585vtfaF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1874196101",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-02T15:46:43Z",
      "updated_at": "2024-01-02T15:46:43Z",
      "author_association": "MEMBER",
      "body": "Cool, this is a great thing to investigate. I'll be giving the approach a look this week.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1874196101",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "commented",
      "id": 1874318288,
      "node_id": "IC_kwDOABII585vt9PQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1874318288",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-02T17:22:14Z",
      "updated_at": "2024-01-02T17:22:14Z",
      "author_association": "MEMBER",
      "body": "Thanks for working on this!\r\n\r\nOne alternative that I have considered before (for chainstate fuzzing) is to abstract and further modularize `BlockManager`, which would allow us to have an `InMemoryBlockManager` for tests (especially useful for fuzzing but also nice in unit tests).\r\n\r\nThis would require a bunch of work:\r\n* Breaking up the friendship between `BlockManager`, `Chainstate` &  `ChainstateManager`\r\n* Abstracting `BlockManager`'s interface away from being file based\r\n* Hiding access to `BlockManager`'s internal fields\r\n* Probably more...\r\n\r\nThis approach would avoid filesystem syscalls entirely, as well as the large block file allocations.\r\n\r\n---\r\n\r\nThe coinbase maturity also seems relevant because you can't spend any coins in the test until you've mined 100 blocks. Mining 100 blocks every fuzz iteration ends up being pretty slow. Maybe we can use assumeutxo to avoid that? (or snapshot fuzzing)",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1874318288",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "commented",
      "id": 1875711592,
      "node_id": "IC_kwDOABII585vzRZo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1875711592",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-03T17:21:25Z",
      "updated_at": "2024-01-03T17:21:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Nice one! ",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1875711592",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "commented",
      "id": 1875751255,
      "node_id": "IC_kwDOABII585vzbFX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1875751255",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-03T17:54:38Z",
      "updated_at": "2024-01-03T17:54:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1875751255",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "reviewed",
      "id": 1812003162,
      "node_id": "PRR_kwDOABII585sAPla",
      "url": null,
      "actor": null,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK; midway through review and trying to resolve some of the CI issues.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-1812003162",
      "submitted_at": "2024-01-10T16:20:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    },
    {
      "event": "commented",
      "id": 1885310514,
      "node_id": "IC_kwDOABII585wX44y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1885310514",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-10T17:38:48Z",
      "updated_at": "2024-01-10T17:38:48Z",
      "author_association": "MEMBER",
      "body": "Pushed three additional commits to my branch that may make a dent in the CI issues:\r\n- make `fs::path` hashable: https://github.com/jamesob/bitcoin/commit/8f5fdf8ad3d5102e4afaae415e004d4cf6c667cc\r\n- avoid use of `std::filesystem::path` where possible: https://github.com/jamesob/bitcoin/commit/4ef785749ff1c481b5681739653c5b153637e44e\r\n- update linter for mockable filesystem ops: https://github.com/jamesob/bitcoin/commit/face876d55711299c2679aad59b24ee04aa892f0",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1885310514",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-11T18:42:57Z",
      "updated_at": "2024-01-11T18:42:57Z",
      "source": {
        "issue": {
          "id": 2077350644,
          "node_id": "PR_kwDOABII585j2G0b",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29236",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29236/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29236/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29236/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/29236",
          "number": 29236,
          "state": "open",
          "state_reason": null,
          "title": "log: Nuke error(...)",
          "body": "`error(...)` has many issues:\r\n\r\n* It is often used in the context of `return error(...)`, implying that it has a \"fancy\" type, creating confusion with `util::Result/Error`\r\n* `-logsourcelocations` does not work with it, because it will pretend the error happened inside of `logging.h`\r\n* The log line contains `ERROR: `, as opposed to `[error]`, like for other errors logged with `LogError`.\r\n\r\nFix all issues by removing it.",
          "user": {
            "login": "maflcko",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/maflcko",
            "html_url": "https://github.com/maflcko",
            "followers_url": "https://api.github.com/users/maflcko/followers",
            "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
            "organizations_url": "https://api.github.com/users/maflcko/orgs",
            "repos_url": "https://api.github.com/users/maflcko/repos",
            "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/maflcko/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29236",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/29236",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/29236.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/29236.patch"
          },
          "created_at": "2024-01-11T18:29:58Z",
          "updated_at": "2024-02-01T16:06:00Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-12T20:06:46Z",
      "updated_at": "2024-01-12T20:06:46Z",
      "source": {
        "issue": {
          "id": 2014832404,
          "node_id": "PR_kwDOABII585gk1DX",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28960",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28960/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28960/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28960/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28960",
          "number": 28960,
          "state": "open",
          "state_reason": null,
          "title": "kernel: Remove dependency on CScheduler",
          "body": "By defining a virtual interface class for the scheduler client, users of the kernel can now define their own event consuming infrastructure, without having to spawn threads or rely on the scheduler design.\r\n\r\nRemoving `CScheduler` also allows removing the thread and exception modules from the kernel library. \r\n\r\nTo make the `CMainSignals` class easier to use from a kernel library perspective, remove its global instantiation and adopt RAII practices.\r\n\r\nRenames `CMainSignals` to `ValidationSignals`, which more accurately describes its purpose and scope.\r\n\r\nAlso make the `ValidationSignals` in the `ChainstateManager` and CTxMemPool` optional. This could be useful in the future for using or testing these classes without having to instantiate any form of signal handling.\r\n\r\n---\r\n\r\nThis PR is part of the [libbitcoinkernel project](https://github.com/bitcoin/bitcoin/issues/27587). It improves the kernel API and removes two modules from the kernel library.",
          "user": {
            "login": "TheCharlatan",
            "id": 8421793,
            "node_id": "MDQ6VXNlcjg0MjE3OTM=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/TheCharlatan",
            "html_url": "https://github.com/TheCharlatan",
            "followers_url": "https://api.github.com/users/TheCharlatan/followers",
            "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
            "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
            "repos_url": "https://api.github.com/users/TheCharlatan/repos",
            "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 23,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28960",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28960",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28960.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28960.patch"
          },
          "created_at": "2023-11-28T16:27:42Z",
          "updated_at": "2024-02-01T15:03:18Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-24T21:18:36Z",
      "updated_at": "2024-01-24T21:18:36Z",
      "source": {
        "issue": {
          "id": 2098407857,
          "node_id": "PR_kwDOABII585k9cr9",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29307",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29307/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29307/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29307/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/29307",
          "number": 29307,
          "state": "open",
          "state_reason": null,
          "title": "util: check for errors after close and read in AutoFile",
          "body": "1. `fclose(3)` may fail to flush the previously written data to disk, thus a failing `fclose(3)` is as serious as a failing `fwrite(3)`. Previously the code ignored `fclose(3)` failures. This PR improves the explicit callers to check whether it failed. However there is a design issue that `fclose(3)` is also called from the `AutoFile` destructor. There is no good way to signal a failure to the caller from the destructor. Maybe one of:\r\n  1.1. `fflush(3)` after each write to the file (and throw if it fails from the `AutoFile::write()` method) and hope that `fclose(3)` will then always succeed. Assert that it succeeds from the destructor :roll_eyes:. Will hurt performance.\r\n  1.2. Throw nevertheless from the destructor. Exception within the exception in C++ I think results in terminating the program. Better to `assert()` explicitly because it will at least print a meaningful error message before crashing.\r\n  1.3. Only log an error and continue (with a possibly corrupt file :roller_skate:). We don't even know the file name in `AutoFile`.\r\n  1.4. Redesign `AutoFile` so that its destructor cannot fail. Adjust _all_ its users :sob:.\r\n\r\n3. Check for `ferror(3)` after calls to `fread(3)`.",
          "user": {
            "login": "vasild",
            "id": 266751,
            "node_id": "MDQ6VXNlcjI2Njc1MQ==",
            "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vasild",
            "html_url": "https://github.com/vasild",
            "followers_url": "https://api.github.com/users/vasild/followers",
            "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
            "organizations_url": "https://api.github.com/users/vasild/orgs",
            "repos_url": "https://api.github.com/users/vasild/repos",
            "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/vasild/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 3,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29307",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/29307",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/29307.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/29307.patch"
          },
          "created_at": "2024-01-24T14:35:29Z",
          "updated_at": "2024-01-29T11:32:55Z"
        },
        "type": "issue"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439533284",
      "pull_request_review_id": 1800561385,
      "id": 1439533284,
      "node_id": "PRRC_kwDOABII585VzYjk",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 85,
      "original_position": 85,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Have you checked if using `fmemopen` is better/faster than using a ram disk?",
      "created_at": "2024-01-02T15:03:27Z",
      "updated_at": "2024-01-02T15:03:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1439533284",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439533284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 85,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439796296",
      "pull_request_review_id": 1800974871,
      "id": 1439796296,
      "node_id": "PRRC_kwDOABII585V0YxI",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 85,
      "original_position": 85,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I haven't. Can we use a ramdisk at oss-fuzz?",
      "created_at": "2024-01-02T20:33:30Z",
      "updated_at": "2024-01-02T20:33:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1439796296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439796296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 85,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1440301216",
      "pull_request_review_id": 1801749930,
      "id": 1440301216,
      "node_id": "PRRC_kwDOABII585V2UCg",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 85,
      "original_position": 85,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Afaict oss-fuzz already uses a ram disk for its environments: https://github.com/google/clusterfuzz/blob/c461a961d8fb2afe47fb4af5eee3d1434a324a40/docker/base/setup_clusterfuzz.sh#L38 (i.e. `/tmp` is mounted in ram).",
      "created_at": "2024-01-03T10:35:58Z",
      "updated_at": "2024-01-03T10:35:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1440301216",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1440301216"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 85,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1441013417",
      "pull_request_review_id": 1803140054,
      "id": 1441013417,
      "node_id": "PRRC_kwDOABII585V5B6p",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 85,
      "original_position": 85,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://joshua.hu/fuzzing-with-memfd-createfd-fmemopen-syscall-function\n\nThe author of this post found that a ram disk is slower🚀\n\nI/O syscalls are avoided with fmempopen and everything simply happens in userland.",
      "created_at": "2024-01-03T22:12:06Z",
      "updated_at": "2024-01-03T22:12:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1441013417",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1441013417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 85,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1442215861",
      "pull_request_review_id": 1804915877,
      "id": 1442215861,
      "node_id": "PRRC_kwDOABII585V9ne1",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 85,
      "original_position": 85,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting. I was aware of `open_memstream` but not `memfd_create`. It's slower but could actually be helpful to get rid of the `128 MiB` allocs and make it possible to reindex.",
      "created_at": "2024-01-04T20:21:16Z",
      "updated_at": "2024-01-04T20:21:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1442215861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1442215861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 85,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446610769",
      "pull_request_review_id": 1812003162,
      "id": 1446610769,
      "node_id": "PRRC_kwDOABII585WOYdR",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_files.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_files.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_files.extract(old_p).key() = new_p;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_file_commit = [&](FILE* f) {\n+        return fflush(f) == 0;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_dir_commit = [&](std::filesystem::path) {};\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_truncate_file = [&](FILE*, unsigned int) {\n+        return true;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_allocate_file_range = [&](FILE*, unsigned int, unsigned int) {\n+        return true;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0, nullptr)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height, nullptr)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // Get 10 spendable UTxOs.\n+    g_initial_blockchain = CreateBlockChain(110, Params());\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    const fs::path datadir{\"\"};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;\n+\n+    CScheduler scheduler;\n+    GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+    scheduler.m_service_thread = std::thread(util::TraceThread, \"scheduler\", [&] { scheduler.serviceQueue(); });\n+\n+    // Create the chainstate..\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = datadir / \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = chainparams,\n+        .datadir = \"\",\n+        .adjusted_time_callback = NodeClock::now,\n+        // TODO: make it possible to call CheckBlockIndex() without having set it here, call it in CallOneOf().\n+        .check_block_index = true,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_notifications,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+\n+    // ..And then load it.\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 2 << 20;\n+    cache_sizes.coins_db = 2 << 22;\n+    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);\n+    node::ChainstateLoadOptions load_opts {\n+        .block_tree_db_in_memory = true,\n+        .coins_db_in_memory = true,\n+        .prune = prune_target > 0,\n+        .require_full_verification = false,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    // Activate the initial chain.\n+    BlockValidationState dummy_valstate;\n+    for (Chainstate* chainstate : chainman.GetAll()) {\n+        assert(chainstate->ActivateBestChain(dummy_valstate, nullptr));\n+    }\n+    for (const auto& block : g_initial_blockchain) {\n+        bool new_block{false};\n+        assert(chainman.ProcessNewBlock(block, true, true, &new_block));\n+        assert(new_block);\n+    }\n+\n+    std::vector<CBlock> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        // Every so often, update our cache used to create non-coinbase txs.\n+        if (_count % 100 == 0) AppendUtxos(chainman, utxos);\n+\n+        CallOneOf(fuzzed_data_provider,\n+            // Process a list of headers. Most of the time make it process the header of a valid block\n+            // cached for future processing.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                std::vector<CBlockHeader> headers;\n+\n+                // In 1% of the cases, generate a random list of headers to be processed. Otherwise, create a single\n+                // valid block.\n+                // TODO: make it possible to generate a chain of more than one valid block.\n+                const bool is_random{fuzzed_data_provider.ConsumeIntegralInRange(0, 99) == 99};\n+                const int headers_count{is_random ? fuzzed_data_provider.ConsumeIntegralInRange(1, MAX_HEADERS_RESULTS) : 1};\n+                headers.reserve(headers_count);\n+\n+                if (is_random) {\n+                    for (int i = 0; i < headers_count; ++i) {\n+                        headers.push_back(CreateBlockHeader(fuzzed_data_provider, RandomPrevBlock(fuzzed_data_provider), /*set_merkle=*/true).first);\n+                    }\n+                } else {\n+                    // In 10% of the cases branch off a random header.\n+                    const bool extend_tip{fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 9) > 0};\n+                    // The unspent coins to be used to create transactions beside the coinbase in the block to be created.\n+                    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> empty_utxos;\n+                    auto& coins{extend_tip ? utxos : empty_utxos};\n+                    CBlockIndex* prev_block{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                        // Sometimes extend the best validated chain, sometimes the best header chain.\n+                        if (extend_tip) {\n+                            return fuzzed_data_provider.ConsumeBool() ? chainman.ActiveTip() : chainman.m_best_header;\n+                        }\n+                        return &PickValue(fuzzed_data_provider, chainman.m_blockman.m_block_index).second;\n+                    }()};\n+                    blocks_in_flight.push_back(CreateValidBlock(fuzzed_data_provider, chainparams.GetConsensus(), prev_block, coins));",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 551,
      "original_position": 551,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "When generating a valid block (here and below) do we want to do some kind of assertion that the block was actually considered valid? I could see the test code silently generating only invalid blocks and (afaik) there wouldn't be an indication of it here.",
      "created_at": "2024-01-09T21:04:10Z",
      "updated_at": "2024-01-10T16:20:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1446610769",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446610769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 551,
      "original_line": 551,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446611692",
      "pull_request_review_id": 1812003162,
      "id": 1446611692,
      "node_id": "PRRC_kwDOABII585WOYrs",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_files.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_files.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_files.extract(old_p).key() = new_p;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_file_commit = [&](FILE* f) {\n+        return fflush(f) == 0;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_dir_commit = [&](std::filesystem::path) {};\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_truncate_file = [&](FILE*, unsigned int) {\n+        return true;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_allocate_file_range = [&](FILE*, unsigned int, unsigned int) {\n+        return true;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0, nullptr)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height, nullptr)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // Get 10 spendable UTxOs.\n+    g_initial_blockchain = CreateBlockChain(110, Params());\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    const fs::path datadir{\"\"};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 460,
      "original_position": 460,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This type comes up often enough in this file that it might be worth an alias.",
      "created_at": "2024-01-09T21:05:16Z",
      "updated_at": "2024-01-10T16:44:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1446611692",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446611692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 460,
      "original_line": 460,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447615580",
      "pull_request_review_id": 1812003162,
      "id": 1447615580,
      "node_id": "PRRC_kwDOABII585WSNxc",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 85,
      "original_position": 85,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/29158/commits/ea36af80beeeee0b9de793e52887ba3e164b803c\r\n\r\n`fmemopen` is Linux-specific; here's a fixup commit that `ifdef`s it out and fixes some of the CI errors if you want it: https://github.com/jamesob/bitcoin/commit/26b9c9d48e3ec16e69d550266c7f27f4db9cb9f8",
      "created_at": "2024-01-10T16:19:27Z",
      "updated_at": "2024-01-10T16:20:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1447615580",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447615580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 85,
      "original_line": 85,
      "side": "RIGHT"
    }
  ]
}