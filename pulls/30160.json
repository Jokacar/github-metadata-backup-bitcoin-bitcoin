{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
    "id": 1884900870,
    "node_id": "PR_kwDOABII585wWU4G",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30160",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30160.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30160.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/c99063e902c810dde1742696b3140610120d391c",
    "number": 30160,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "util: add BitSet",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Extracted from #30126.\r\n\r\nThis introduces the `BitSet` data structure, inspired by `std::bitset`, but with a few features that cannot be implemented on top without efficiency loss:\r\n* Finding the first set bit (`First`)\r\n* Finding the last set bit (`Last`)\r\n* Iterating over all set bits (`begin` and `end`).\r\n\r\nAnd a few other operators/member functions that help readability for #30126:\r\n* `operator-` for set subtraction\r\n* `Overlaps()` for testing whether intersection is non-empty\r\n* `IsSupersetOf()` for testing (non-strict) supersetness\r\n* `IsSubsetOf()` for testing (non-strict) subsetness\r\n* `Fill()` to construct a set with all numbers from 0 to n-1, inclusive\r\n* `Singleton()` to construct a set with one specific element.\r\n\r\nEverything is tested through a simulation-based fuzz test that compares the behavior with normal `std::bitset` equivalent operations.\r\n",
    "labels": [
      {
        "id": 241832923,
        "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
        "name": "Utils/log/libs",
        "description": "",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 6861582155,
        "node_id": "LA_kwDOABII588AAAABmPtvSw",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20CMake%20port",
        "name": "Needs CMake port",
        "description": "",
        "color": "0e8a16",
        "default": false
      }
    ],
    "created_at": "2024-05-23T15:42:28Z",
    "updated_at": "2024-06-07T16:07:40Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "a02b4a4f78b4c4e2bf5166f03abe96fa81334670",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202405_bitset",
      "ref": "202405_bitset",
      "sha": "c99063e902c810dde1742696b3140610120d391c",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 21,
        "stargazers_count": 86,
        "watchers_count": 86,
        "size": 240475,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-06-07T15:20:39Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-06-02T01:19:44Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "d39f15a8a5b06d68070a3434a81c6840d4f87715",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35484,
        "stargazers_count": 76818,
        "watchers_count": 76818,
        "size": 260235,
        "default_branch": "master",
        "open_issues_count": 687,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-06-07T16:46:50Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-06-07T16:31:30Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 843,
    "deletions": 0,
    "changed_files": 5,
    "commits": 2,
    "review_comments": 39,
    "comments": 4
  },
  "events": [
    {
      "event": "commented",
      "id": 2127454745,
      "node_id": "IC_kwDOABII585-zmIZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127454745",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:42:31Z",
      "updated_at": "2024-06-07T00:13:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30160).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [cbergqvist](https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2103029469) |\n| Concept ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2082445138), [hebasto](https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2147744433), [instagibbs](https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2148037183) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29625](https://github.com/bitcoin/bitcoin/pull/29625) (Several randomness improvements by sipa)\n* [#28676](https://github.com/bitcoin/bitcoin/pull/28676) ([WIP] Cluster mempool implementation by sdaftuar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2127454745",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "labeled",
      "id": 12911543348,
      "node_id": "LE_lADOABII586J4VcvzwAAAAMBloQ0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911543348",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:42:33Z",
      "label": {
        "name": "Utils/log/libs",
        "color": "5319e7"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:48:15Z",
      "updated_at": "2024-05-23T15:48:15Z",
      "source": {
        "issue": {
          "id": 2301284495,
          "node_id": "PR_kwDOABII585vttq-",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
          "number": 30126,
          "state": "open",
          "state_reason": null,
          "title": "Low-level cluster linearization code",
          "body": "Depends on #30160 and #30161. Eventually #28676 will end up being based on this.\r\n\r\nThis introduces low-level optimized cluster linearization code, including tests and some benchmarks. It is currently not hooked up to anything.\r\n\r\nRoughly the commits are organized into 3 groups:\r\n* Repeat of part of #29625.\r\n* Introduce unoptimized versions of candidate finding and linearizations, plus benchmarks and tests.\r\n* Add various optimizations step by step.\r\n\r\nUltimately, what this PR adds is functions `Linearize`, `PostLinearize`, and `MergeLinearizations` which operate on instances of `DepGraph` (instances of which represent pre-processed transaction clusters) to produce and/or improve linearizations for that cluster.\r\n\r\nAlong the way two new data structures are introduced (`util/bitset.h` and `util/ringbuffer.h`), which could be useful more broadly. They have their own commits, which include tests.\r\n\r\n---\r\n\r\nTo provide assurance, the code heavily relies on fuzz tests. A novel approach is used here, where the fuzz input is parsed using the serialization.h framework rather than `FuzzedDataProvider`, with a custom serializer/deserializer for `DepGraph` objects. By including serialization, it's possible to ascertain that the format can represent every relevant cluster, as well as potentially permitting the construction of ad-hoc fuzz inputs from clusters (not included in this PR, but used during development).\r\n\r\n---\r\n\r\nThe `Linearize(depgraph, iteration_limit, rng_seed, old_linearization)` function is an implementation of the (single) [LIMO](https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825) algorithm, with the $S$ in every iteration found as the best out of (a) the best remaining ancestor set and (b) randomized computationally-bounded search. It incrementally builds up a linearization by finding good topologically-valid subsets to move to the front, in such a way that the resulting linearization has a diagram that is at least as good as the `old_linearization` passed in (if any).\r\n* Despite using both best ancestor set and search, this is not Double LIMO, as no intersections between these are involved; just the best of the two.\r\n* The `iteration_limit` and `rng_seed` only control the (b) randomized search. Even with 0 iterations, the result will be as good as the old linearization, and the included sets at every point will have a feerate at least as high as the best remaining ancestor set at that point.\r\n\r\nThe search algorithm used in the (b) step above largely follows Section 2 of [How to linearize your cluster](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-2-finding-high-feerate-subsets-5), though with a few changes:\r\n* Connected component analysis is performed inside the search algorithm (creating initial work items per component for each candidate), rather than once at a higher level. This duplicates some work but is significantly simpler in implementation.\r\n* No ancestor-set based presplitting inside the search is performed; instead, the `best` value is initialized with the best topologically valid set known to the LIMO algorithm before search starts: the better one out of the highest-feerate remaining ancestor set, and the highest-feerate prefix of remaining transactions in `old_linearization`.\r\n* Work items are represented using an included set *inc* and an undefined set *und*, rather than included and excluded.\r\n* Potential sets *pot* are not computed for work items with empty *inc*.\r\n\r\nAt a high level, the only missing optimization from that post is bottleneck analysis; my thinking is that it only really helps with clusters that are already relatively cheap to linearize (doing so would need to be done at a higher level, not inside the search algorithm).\r\n\r\nThe `PostLinearize(depgraph, linearization)` function performs an in-place improvement of `linearization`, using two iterations of the [Linearization post-processing](https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201/8) algorithm. The first running from back to front, the second from front to back.\n\nThe `MergeLinearizations(depgraph, linearization1, linearization2)` function computes a new linearization for the provided cluster, given two existing linearizations for that cluster, which is at least as good as both inputs. The algorithm is described at a high level in [merging incomparable linearizations](https://delvingbitcoin.org/t/merging-incomparable-linearizations/209).\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 164208572,
              "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
              "name": "Mempool",
              "color": "fef2c0",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/30126.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/30126.patch"
          },
          "created_at": "2024-05-16T20:29:15Z",
          "updated_at": "2024-06-07T15:20:40Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12913402292,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMBsuG0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913402292",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T17:55:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12913691028,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMBt0mU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913691028",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:23:57Z"
    },
    {
      "event": "reviewed",
      "id": 2074881667,
      "node_id": "PRR_kwDOABII5857rC6D",
      "url": null,
      "actor": null,
      "commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2074881667",
      "submitted_at": "2024-05-23T19:55:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "reviewed",
      "id": 2074894349,
      "node_id": "PRR_kwDOABII5857rGAN",
      "url": null,
      "actor": null,
      "commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2074894349",
      "submitted_at": "2024-05-23T20:03:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T00:35:24Z",
      "updated_at": "2024-05-24T00:35:24Z",
      "source": {
        "issue": {
          "id": 2180060071,
          "node_id": "PR_kwDOABII585pS0SQ",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29625",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29625/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29625/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29625/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/29625",
          "number": 29625,
          "state": "open",
          "state_reason": null,
          "title": "Several randomness improvements",
          "body": "This PR contains a number of vaguely-related improvements to the random module.\r\n\r\nThe specific changes and more detailed rationale is in the commit messages, but the highlights are:\r\n\r\n* `XoRoShiRo128PlusPlus` (previously a test-only RNG) moves to random.h and becomes `InsecureRandomContext`, which is even faster than `FastRandomContext` but non-cryptographic. It also gets all helper randomness functions (`randrange`, `fillrand`, ...), making it a lot more succinct to use.\r\n* During tests, **all** randomness is made deterministic (except for `GetStrongRandBytes`) but non-repeating (like `GetRand()` used to be when `g_mock_deterministic_tests` was used), either fixed, or from a random seed (overridden by env var).\r\n* Several infrequently used top-level functions (`GetRandMillis`, `GetRandMicros`, `GetExponentialRand`) are converted into member functions of `FastRandomContext` (and `InsecureRandomContext`).\r\n* `GetRand<T>()` (without argument) can now return the maximum value of the type (previously e.g. `GetRand<uint32_t>()` would never return 0xffffffff).",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 14,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29625",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/29625",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/29625.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/29625.patch"
          },
          "created_at": "2024-03-11T19:36:49Z",
          "updated_at": "2024-06-06T14:43:17Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12925383411,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMCabLz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12925383411",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T13:48:25Z"
    },
    {
      "event": "reviewed",
      "id": 2077061355,
      "node_id": "PRR_kwDOABII5857zXDr",
      "url": null,
      "actor": null,
      "commit_id": "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2077061355",
      "submitted_at": "2024-05-24T14:17:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12926722640,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMCfiJQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12926722640",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T15:35:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934056317,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMC7gl9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934056317",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T22:07:52Z"
    },
    {
      "event": "labeled",
      "id": 12945169502,
      "node_id": "LE_lADOABII586J4VcvzwAAAAMDl5xe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12945169502",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:09:59Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "reviewed",
      "id": 2076257466,
      "node_id": "PRR_kwDOABII5857wSy6",
      "url": null,
      "actor": null,
      "commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Looked at 3bc131a85ce826aa171f0328c014ea51b8740fed\r\n\r\nConcept: Bummer that `std::countr_zero` and `std::countl_zero` aren't implemented for `std::bitset`. And for iterating it seems like one would be using `std::vector<bool>` and hoping for the best in terms of implementation. So makes sense to introduce `BitSet`.\r\n\r\nSummary still mentions `operator/` instead of `operator-`.\r\n\r\n(Fuzz-code is too new to me to comment).",
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2076257466",
      "submitted_at": "2024-05-28T11:52:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "reviewed",
      "id": 2082445138,
      "node_id": "PRR_kwDOABII5858H5dS",
      "url": null,
      "actor": null,
      "commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2082445138",
      "submitted_at": "2024-05-28T12:20:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12957008979,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMETERT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12957008979",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T12:39:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12973968539,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMFTwyb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12973968539",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T15:44:58Z"
    },
    {
      "event": "commented",
      "id": 2137732304,
      "node_id": "IC_kwDOABII585_azTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2137732304",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T15:46:03Z",
      "updated_at": "2024-05-29T15:46:03Z",
      "author_association": "MEMBER",
      "body": "Added additional `Assume()`s to prevent `operator++` on iterators past the end:\r\n\r\n```diff\r\n--- a/src/util/bitset.h\r\n+++ b/src/util/bitset.h\r\n@@ -101,6 +101,7 @@ class IntBitSet\r\n         /** Progress to the next 1 bit (only if != IteratorEnd). */\r\n         constexpr Iterator& operator++() noexcept\r\n         {\r\n+            Assume(m_val != 0);\r\n             m_val &= m_val - I{1U};\r\n             if (m_val != 0) m_pos = std::countr_zero(m_val);\r\n             return *this;\r\n@@ -272,6 +273,7 @@ class MultiIntBitSet\r\n         /** Progress to the next 1 bit (only if != IteratorEnd). */\r\n         constexpr Iterator& operator++() noexcept\r\n         {\r\n+            Assume(m_idx < N);\r\n             m_val &= m_val - I{1U};\r\n             if (m_val == 0) {\r\n                 while (true) {\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2137732304",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "reviewed",
      "id": 2088636268,
      "node_id": "PRR_kwDOABII5858fg9s",
      "url": null,
      "actor": null,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2088636268",
      "submitted_at": "2024-06-03T20:41:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "reviewed",
      "id": 2096649215,
      "node_id": "PRR_kwDOABII5858-FP_",
      "url": null,
      "actor": null,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2096649215",
      "submitted_at": "2024-06-04T14:49:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "commented",
      "id": 2147744433,
      "node_id": "IC_kwDOABII586AA_qx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2147744433",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T14:54:00Z",
      "updated_at": "2024-06-04T14:54:00Z",
      "author_association": "MEMBER",
      "body": "Concept ACK.",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2147744433",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDlhZmY0Y2I5NDQ2ZmVkZjk5ZThlMjEyY2UxZGI4MjNjOWRkMGQwM2M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "tree": {
        "sha": "d08c87735f3cb0fb783ce95e1e71af0bfa1b14f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d08c87735f3cb0fb783ce95e1e71af0bfa1b14f0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d39f15a8a5b06d68070a3434a81c6840d4f87715",
          "sha": "d39f15a8a5b06d68070a3434a81c6840d4f87715",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d39f15a8a5b06d68070a3434a81c6840d4f87715"
        }
      ],
      "message": "util: add BitSet\n\nThis adds a bitset module that implements a BitSet<N> class, a variant\nof std::bitset with a few additional features that cannot be implemented\nin a wrapper without performance loss (specifically, finding first and\nlast bit set, or iterating over all set bits).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-04T15:54:18Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-01-22T00:20:06Z"
      },
      "sha": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM5OTA2M2U5MDJjODEwZGRlMTc0MjY5NmIzMTQwNjEwMTIwZDM5MWM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c99063e902c810dde1742696b3140610120d391c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c99063e902c810dde1742696b3140610120d391c",
      "tree": {
        "sha": "af3cd82688822c7b8e42bfd3ad00b073ccd9da24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/af3cd82688822c7b8e42bfd3ad00b073ccd9da24"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
          "sha": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9aff4cb9446fedf99e8e212ce1db823c9dd0d03c"
        }
      ],
      "message": "tests: add fuzz tests for BitSet",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-04T15:54:18Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-23T15:32:05Z"
      },
      "sha": "c99063e902c810dde1742696b3140610120d391c"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13038752534,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMJK5MW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13038752534",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T15:56:48Z"
    },
    {
      "event": "commented",
      "id": 2148037183,
      "node_id": "IC_kwDOABII586ACHI_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148037183",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T17:19:38Z",
      "updated_at": "2024-06-04T17:19:38Z",
      "author_association": "MEMBER",
      "body": "concept ACK\r\n\r\nrequested changes were included, will continue review\r\n\r\n`git range-diff master 18ec3fc c99063e`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2148037183",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T17:48:12Z",
      "updated_at": "2024-06-06T17:48:12Z",
      "source": {
        "issue": {
          "id": 1950437953,
          "node_id": "PR_kwDOABII585dLamZ",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28676",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28676/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28676/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28676/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28676",
          "number": 28676,
          "state": "open",
          "state_reason": null,
          "title": "[WIP] Cluster mempool implementation",
          "body": "This is a draft implementation of the cluster mempool design described in #27677.  I'm opening this as a draft PR now to share the branch I'm working on with others, so that we can start to think about in-progress projects (like package relay, package validation, and package rbf) in the context of this design.  Also, I can use some help from others for parts of this work, including the interaction between the mempool and the wallet, and also reworking some of our existing test cases to fit a cluster-mempool world.\r\n\r\nNote that the design of this implementation is subject to change as I continue to iterate on the code (to make the code more hygienic and robust, in particular). At this point though I think the performance is pretty reasonable and I'm not currently aware of any bugs.  There are some microbenchmarks added here, and some improved fuzz tests; it would be great if others ran both of those on their own hardware as well and reported back on any findings.\r\n\r\nThis branch implements the following observable behavior changes:\r\n\r\n- Maintains a partitioning of the mempool into connected clusters\r\n- Each cluster is sorted (\"linearized\") either using an optimal sort, or an ancestor-feerate-based one, depending on the size of the cluster (thanks to @sipa for this logic)\r\n- Transaction selection for mining is updated to use the cluster linearizations\r\n- Mempool eviction is updated to use the cluster linearizations\r\n- The RBF rules are updated to drop the requirement that no new inputs are introduced, and to change the feerate requirement to instead check that the mining score of a replacement transaction exceed the mining score of the conflicted transactions\r\n- The CPFP carveout rule is eliminated (it doesn't make sense in a cluster-limited mempool)\r\n- The ancestor and descendant limits are no longer enforced.\r\n- New cluster count/cluster vsize limits are now enforced instead.\r\n\r\nSome less observable behavior changes:\r\n- The cached ancestor and descendant data are dropped from the mempool, along with the multi_index indices that were maintained to sort the mempool by ancestor and descendant feerates. For compatibility (eg with wallet behavior or RPCs exposing this), this information is now calculated dynamically instead.\r\n- The ancestor and descendant walking algorithms are now implemented using `epoch`s (resulting in a significant performance improvement, according to the benchmarks I've looked at)\r\n\r\nStill to do:\r\n\r\n- [ ] More comparisons between this branch and master on historical data to compare validation speed (accepting loose transactions, processing RBF transactions, validating a block/postprocessing, updating the mempool for a reorg).\r\n- [x] More historical data analysis to try to evaluate the likely impact of setting the cluster size limits to varying values (to motivate what values we should ultimately pick). [DONE, see [this post](https://delvingbitcoin.org/t/research-into-the-effects-of-a-cluster-size-limited-mempool-in-2023/794/1)]\r\n- [ ] Updating wallet code to be cluster-aware (including mini_miner and coin selection)\r\n- [ ] Rework many of our functional tests to be cluster-aware\r\n- [ ] Figure out what package validation and package RBF rules should be in this design\r\n- [ ] Rework the `partially_downloaded_block` fuzz target to not add duplicate transactions to the mempool (#29990).\r\n- [ ] Update RBF logic to ensure that replacements always strictly improve the mempool.\r\n- [ ] Figure out how we want to document our RBF policy (preserve historical references to BIP 125 or previous Bitcoin Core behaviors vs clean slate documentation?)\r\n\r\nFor discussion/feedback:\r\n\r\n - How significant is it to be dropping the CPFP carveout rule?  Does that affect how we will ultimately want to stage new mempool deployment?\r\n - How well do the proposed RBF rules meet everyone's use cases?\r\n - What design improvements can we make to the cluster tracking implementation?\r\n - The ZMQ callbacks that occur when a block is found will happen in a slightly different order, because we now will fully remove all transactions occurring in a block from the mempool before removing any conflicts. Is this a problem?",
          "user": {
            "login": "sdaftuar",
            "id": 7463573,
            "node_id": "MDQ6VXNlcjc0NjM1NzM=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sdaftuar",
            "html_url": "https://github.com/sdaftuar",
            "followers_url": "https://api.github.com/users/sdaftuar/followers",
            "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
            "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
            "repos_url": "https://api.github.com/users/sdaftuar/repos",
            "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 164208572,
              "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
              "name": "Mempool",
              "color": "fef2c0",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28676",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28676",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28676.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28676.patch"
          },
          "created_at": "2023-10-18T18:59:37Z",
          "updated_at": "2024-06-07T06:04:28Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 2103029469,
      "node_id": "PRR_kwDOABII5859Wa7d",
      "url": null,
      "actor": null,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK c99063e902c810dde1742696b3140610120d391c\r\n\r\n(Ran `git range-diff 3bc131a~2..3bc131a c99063e~2..c99063e`).",
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2103029469",
      "submitted_at": "2024-06-06T19:29:26Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "review_requested",
      "id": 13071383541,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMLHXv1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13071383541",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T19:29:29Z",
      "requested_reviewer": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 13071383668,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMLHXx0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13071383668",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T19:29:30Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 13071383798,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMLHXz2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13071383798",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T19:29:30Z",
      "requested_reviewer": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 2104783238,
      "node_id": "PRR_kwDOABII5859dHGG",
      "url": null,
      "actor": null,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "c99063e902c810dde1742696b3140610120d391c seems to need `swap` fuzz coverage\r\n\r\nrest of comments are nits\r\n\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2104783238",
      "submitted_at": "2024-06-07T16:07:37Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "review_requested",
      "id": 13083012605,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMLzu39",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13083012605",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T16:07:40Z",
      "requested_reviewer": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612232560",
      "pull_request_review_id": 2074881667,
      "id": 1612232560,
      "node_id": "PRRC_kwDOABII585gGLdw",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 144,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`std::bitset` throws for these if pos is out of range.\r\n\r\nMaybe add `Assume()`s? Or were you trying to keep the header self-contained?",
      "created_at": "2024-05-23T19:55:17Z",
      "updated_at": "2024-05-23T19:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612232560",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612232560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612240218",
      "pull_request_review_id": 2074894349,
      "id": 1612240218,
      "node_id": "PRRC_kwDOABII585gGNVa",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 172,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I know you like dense code, but...\r\n\r\nI suspect function names would make reviewing uses of this easier than operators. Especially for the non-obvious ones like `&&` that `std::bitset` doesn't support.\r\n\r\nI know that personally I'd have an easier time reviewing `a.intersects(b)`.",
      "created_at": "2024-05-23T20:03:01Z",
      "updated_at": "2024-05-23T20:03:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612240218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612240218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613105680",
      "pull_request_review_id": 2076257466,
      "id": 1613105680,
      "node_id": "PRRC_kwDOABII585gJgoQ",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "path": "src/util/bitset.h",
      "position": 527,
      "original_position": 461,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Have you considered using `__int128`, `__int256` etc when available, before falling back to `MultiIntBitSet`? Maybe something for a follow-up PR.",
      "created_at": "2024-05-24T08:44:43Z",
      "updated_at": "2024-05-28T11:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613105680",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613105680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 526,
      "original_start_line": 460,
      "start_side": "RIGHT",
      "line": 527,
      "original_line": 527,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613223825",
      "pull_request_review_id": 2076257466,
      "id": 1613223825,
      "node_id": "PRRC_kwDOABII585gJ9eR",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "path": "src/util/bitset.h",
      "position": 368,
      "original_position": 309,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Superfluous `I()`",
      "created_at": "2024-05-24T10:05:10Z",
      "updated_at": "2024-05-28T11:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613223825",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613223825"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 368,
      "original_line": 368,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613558242",
      "pull_request_review_id": 2077061355,
      "id": 1613558242,
      "node_id": "PRRC_kwDOABII585gLPHi",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 212,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`.Subset()` and `.Superset()`?\r\n\r\nWithout these comments, I would have to guess at the meanings (and I would have guessed wrong).",
      "created_at": "2024-05-24T14:17:56Z",
      "updated_at": "2024-05-24T14:17:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613558242",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613558242"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674776",
      "pull_request_review_id": 2077267486,
      "id": 1613674776,
      "node_id": "PRRC_kwDOABII585gLrkY",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 144,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": 1612232560,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T15:37:28Z",
      "updated_at": "2024-05-24T15:37:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613674776",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674776"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675392",
      "pull_request_review_id": 2077268563,
      "id": 1613675392,
      "node_id": "PRRC_kwDOABII585gLruA",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 172,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": 1612240218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Replaced with `Overlaps()`.",
      "created_at": "2024-05-24T15:37:50Z",
      "updated_at": "2024-05-24T15:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675392",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675392"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675918",
      "pull_request_review_id": 2077269480,
      "id": 1613675918,
      "node_id": "PRRC_kwDOABII585gLr2O",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 212,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "in_reply_to_id": 1613558242,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Replaced with `IsSubsetOf()` and `IsSupersetOf()`.",
      "created_at": "2024-05-24T15:38:09Z",
      "updated_at": "2024-05-24T15:38:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675918",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617026499",
      "pull_request_review_id": 2082445138,
      "id": 1617026499,
      "node_id": "PRRC_kwDOABII585gYd3D",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 393,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "beb535680b85b511709240a8e1f7de59864b3524",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's a bit scary that `MultiIntBitSet::{First,Last}` lead to buffer over/under-reads if no bit is set. I understand that we wouldn't want to do assert for `Any` in production for performance reasons, but it's maybe worth it do it for debug builds, e.g. with somethink like the `ASSERT_IF_DEBUG` construct used in src/span.h.",
      "created_at": "2024-05-28T11:01:55Z",
      "updated_at": "2024-05-28T12:20:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617026499",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617026499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617040989",
      "pull_request_review_id": 2076257466,
      "id": 1617040989,
      "node_id": "PRRC_kwDOABII585gYhZd",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 247,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: `ptr` could be passed as a reference to signify non-nullness. (But the member still needs to be a pointer). Not at all significant as it is a private function.",
      "created_at": "2024-05-28T11:13:46Z",
      "updated_at": "2024-05-28T11:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617040989",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617040989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617148751",
      "pull_request_review_id": 2082633346,
      "id": 1617148751,
      "node_id": "PRRC_kwDOABII585gY7tP",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "path": "src/util/bitset.h",
      "position": 527,
      "original_position": 461,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613105680,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have not benchmarked this, but I have a hard time imagining how that can be faster, as common hardware doesn't have general-purpose registers bigger than `size_t`, so `__int128` operations get simulated using multiple variables anyway. Some architectures do have vector extensions (SSE, AVX, ...) which introduce native 128-, 256-, or 512-bit registers, but those generally only support operations of units up to 32 to 64 bits in them (including leading-zero counting, or popcount, which we need here).",
      "created_at": "2024-05-28T12:21:47Z",
      "updated_at": "2024-05-28T12:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617148751",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617148751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 526,
      "original_start_line": 460,
      "start_side": "RIGHT",
      "line": 527,
      "original_line": 527,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617153576",
      "pull_request_review_id": 2082640599,
      "id": 1617153576,
      "node_id": "PRRC_kwDOABII585gY84o",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "path": "src/util/bitset.h",
      "position": 368,
      "original_position": 309,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613223825,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't believe this is superfluous. If `I` is smaller than an `int` (e.g. `I = uint16_t`) then `~I{0}` undergoes [integer promotion](https://en.cppreference.com/w/c/language/conversion) to `int`, and right-shifting that would sign-extend, which would incorrect here. The `I(...)` around it forces it to be unsigned before the right-shift.",
      "created_at": "2024-05-28T12:25:11Z",
      "updated_at": "2024-05-28T12:25:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617153576",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617153576"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 368,
      "original_line": 368,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175155",
      "pull_request_review_id": 2082674196,
      "id": 1617175155,
      "node_id": "PRRC_kwDOABII585gZCJz",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 393,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "beb535680b85b511709240a8e1f7de59864b3524",
      "in_reply_to_id": 1617026499,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added `Assume()`s in `First()` and `Last()` to avoid this.",
      "created_at": "2024-05-28T12:39:37Z",
      "updated_at": "2024-05-28T12:39:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175155",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175296",
      "pull_request_review_id": 2082674439,
      "id": 1617175296,
      "node_id": "PRRC_kwDOABII585gZCMA",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 247,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "in_reply_to_id": 1617040989,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-28T12:39:44Z",
      "updated_at": "2024-05-28T12:39:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190868",
      "pull_request_review_id": 2082699927,
      "id": 1617190868,
      "node_id": "PRRC_kwDOABII585gZF_U",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "path": "src/util/bitset.h",
      "position": 527,
      "original_position": 461,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613105680,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd consider SSE supporting CPUs quite common. Seems like using such instructions can offer efficiency gains but are sufficiently complex to write papers about - https://stackoverflow.com/a/42675620, something for the future maybe.",
      "created_at": "2024-05-28T12:50:32Z",
      "updated_at": "2024-05-28T12:50:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617190868",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 526,
      "original_start_line": 460,
      "start_side": "RIGHT",
      "line": 527,
      "original_line": 527,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618814697",
      "pull_request_review_id": 2085289550,
      "id": 1618814697,
      "node_id": "PRRC_kwDOABII585gfSbp",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "path": "src/util/bitset.h",
      "position": 368,
      "original_position": 309,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613223825,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added `std::conditional_t<(BITS <= 16), bitset_detail::IntBitSet<uint16_t>, ... ` and removed the `I()`, wrote unit test in bc36241f5a0a23d16645155eb819e94b0db2813e, and it indeed proves you are correct. Right now it cannot occur since `IntBitSet<uint32_t>` is the smallest we go, but better not to leave loaded footguns lying around.\r\n\r\n<details>\r\n<summary>Test Log</summary>\r\n\r\n```\r\n$ src/test/test_bitcoin -t bitset_tests\r\n...\r\nRunning 1 test case...\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [1 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [2 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [3 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [4 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [5 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [6 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [7 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [8 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [9 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [10 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [11 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [12 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [13 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [14 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [15 != 16]\r\n```\r\n</details>",
      "created_at": "2024-05-29T12:41:44Z",
      "updated_at": "2024-05-29T12:41:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1618814697",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618814697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 368,
      "original_line": 368,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620960269",
      "pull_request_review_id": 2088636268,
      "id": 1620960269,
      "node_id": "PRRC_kwDOABII585gneQN",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 32,
      "original_position": 28,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can you motivate this seed in a comment?",
      "created_at": "2024-05-30T15:30:30Z",
      "updated_at": "2024-06-03T20:41:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1620960269",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620960269"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 32,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621072544",
      "pull_request_review_id": 2088636268,
      "id": 1621072544,
      "node_id": "PRRC_kwDOABII585gn5qg",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */\n+        if (sim[idx].any()) {\n+            assert(first == real[idx].First());\n+            assert(last == real[idx].Last());\n+        }\n+        /* Count */\n+        assert(sim[idx].count() == real[idx].Count());\n+    };\n+\n+    LIMITED_WHILE(buffer.size() > 0, 1000) {\n+        int command = ReadByte(buffer) % 64;\n+        unsigned args = ReadByte(buffer);\n+        unsigned dest = ((args & 7) * sim.size()) >> 3;\n+        unsigned src = (((args >> 3) & 7) * sim.size()) >> 3;\n+        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 78,
      "original_position": 72,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If this is true, this helps my understanding of the code to follow, knowing that each loop below will eventually terminate.\r\n```Suggestion\r\n        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;\r\n        // Args are in range for non-empty sim, or sim is completely empty and will be grown\r\n        assert((sim.empty() && dest == 0 && src == 0 && aux == 0) ||\r\n            (!sim.empty() &&  dest < sim.size() && src < sim.size() && aux < sim.size()));\r\n\r\n```",
      "created_at": "2024-05-30T16:41:44Z",
      "updated_at": "2024-06-03T20:41:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1621072544",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621072544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621275746",
      "pull_request_review_id": 2088636268,
      "id": 1621275746,
      "node_id": "PRRC_kwDOABII585gorRi",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */",
      "path": "src/util/bitset.h",
      "position": 194,
      "original_position": 190,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could we add `Assume()`/`Assert()`s rather than comments here and above?",
      "created_at": "2024-05-30T18:40:27Z",
      "updated_at": "2024-06-03T20:41:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1621275746",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621275746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1624946699",
      "pull_request_review_id": 2088636268,
      "id": 1624946699,
      "node_id": "PRRC_kwDOABII585g2rgL",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)",
      "path": "src/util/bitset.h",
      "position": 38,
      "original_position": 38,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "did you consider using `std::popcount` instead?",
      "created_at": "2024-06-03T19:30:57Z",
      "updated_at": "2024-06-03T20:41:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1624946699",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1624946699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626157391",
      "pull_request_review_id": 2096649215,
      "id": 1626157391,
      "node_id": "PRRC_kwDOABII585g7TFP",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */\n+        if (sim[idx].any()) {\n+            assert(first == real[idx].First());\n+            assert(last == real[idx].Last());\n+        }\n+        /* Count */\n+        assert(sim[idx].count() == real[idx].Count());\n+    };\n+\n+    LIMITED_WHILE(buffer.size() > 0, 1000) {\n+        int command = ReadByte(buffer) % 64;\n+        unsigned args = ReadByte(buffer);\n+        unsigned dest = ((args & 7) * sim.size()) >> 3;\n+        unsigned src = (((args >> 3) & 7) * sim.size()) >> 3;\n+        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;\n+        // Loop until command reaches 0. This way, every iteration will cause one operation",
      "path": "src/test/fuzz/bitset.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I like the comment in the VecDeque PR better if you'd care to just copy it here: https://github.com/bitcoin/bitcoin/pull/30161/commits/ecb278bb19c53b007380e262fa86d809255eeb49#diff-1f28310f089eac74210ecbc0db2083279282ade962dc464bd31448480dc5563dR59",
      "created_at": "2024-06-04T14:49:18Z",
      "updated_at": "2024-06-04T14:49:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626157391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626157391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264025",
      "pull_request_review_id": 2096825133,
      "id": 1626264025,
      "node_id": "PRRC_kwDOABII585g7tHZ",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 32,
      "original_position": 28,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": 1620960269,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, let me know if this is better.",
      "created_at": "2024-06-04T15:57:06Z",
      "updated_at": "2024-06-04T15:57:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626264025",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 32,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264244",
      "pull_request_review_id": 2096825466,
      "id": 1626264244,
      "node_id": "PRRC_kwDOABII585g7tK0",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */\n+        if (sim[idx].any()) {\n+            assert(first == real[idx].First());\n+            assert(last == real[idx].Last());\n+        }\n+        /* Count */\n+        assert(sim[idx].count() == real[idx].Count());\n+    };\n+\n+    LIMITED_WHILE(buffer.size() > 0, 1000) {\n+        int command = ReadByte(buffer) % 64;\n+        unsigned args = ReadByte(buffer);\n+        unsigned dest = ((args & 7) * sim.size()) >> 3;\n+        unsigned src = (((args >> 3) & 7) * sim.size()) >> 3;\n+        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 78,
      "original_position": 72,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": 1621072544,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added.",
      "created_at": "2024-06-04T15:57:16Z",
      "updated_at": "2024-06-04T15:57:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626264244",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264244"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264403",
      "pull_request_review_id": 2096825758,
      "id": 1626264403,
      "node_id": "PRRC_kwDOABII585g7tNT",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */",
      "path": "src/util/bitset.h",
      "position": 194,
      "original_position": 190,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": 1621275746,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-04T15:57:22Z",
      "updated_at": "2024-06-04T15:57:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626264403",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626265719",
      "pull_request_review_id": 2096828139,
      "id": 1626265719,
      "node_id": "PRRC_kwDOABII585g7th3",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)",
      "path": "src/util/bitset.h",
      "position": 38,
      "original_position": 38,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": 1624946699,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes; but on GCC/stdlibc++, `std::popcount` just uses `__builtin_popcount`, which in benchmarks seems to perform worse than the code here. The I've updated the comment to reflect that (it was written before the C++20 switch which introduced `std::popcount`).",
      "created_at": "2024-06-04T15:58:17Z",
      "updated_at": "2024-06-04T15:58:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626265719",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626265719"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626266141",
      "pull_request_review_id": 2096828845,
      "id": 1626266141,
      "node_id": "PRRC_kwDOABII585g7tod",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */\n+        if (sim[idx].any()) {\n+            assert(first == real[idx].First());\n+            assert(last == real[idx].Last());\n+        }\n+        /* Count */\n+        assert(sim[idx].count() == real[idx].Count());\n+    };\n+\n+    LIMITED_WHILE(buffer.size() > 0, 1000) {\n+        int command = ReadByte(buffer) % 64;\n+        unsigned args = ReadByte(buffer);\n+        unsigned dest = ((args & 7) * sim.size()) >> 3;\n+        unsigned src = (((args >> 3) & 7) * sim.size()) >> 3;\n+        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;\n+        // Loop until command reaches 0. This way, every iteration will cause one operation",
      "path": "src/test/fuzz/bitset.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": 1626157391,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. Credit to @glozow.",
      "created_at": "2024-06-04T15:58:37Z",
      "updated_at": "2024-06-04T15:58:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626266141",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626266141"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626267484",
      "pull_request_review_id": 2096831131,
      "id": 1626267484,
      "node_id": "PRRC_kwDOABII585g7t9c",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)",
      "path": "src/util/bitset.h",
      "position": 38,
      "original_position": 38,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": 1624946699,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "figured as much based on my investigation thanks",
      "created_at": "2024-06-04T15:59:36Z",
      "updated_at": "2024-06-04T15:59:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626267484",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626267484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627806235",
      "pull_request_review_id": 2099239010,
      "id": 1627806235,
      "node_id": "PRRC_kwDOABII585hBlob",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 32,
      "original_position": 28,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": 1620960269,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "perfect thanks",
      "created_at": "2024-06-05T13:38:39Z",
      "updated_at": "2024-06-05T13:38:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1627806235",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627806235"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 32,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1630102455",
      "pull_request_review_id": 2103029469,
      "id": 1630102455,
      "node_id": "PRRC_kwDOABII585hKWO3",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);",
      "path": "src/util/bitset.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why not use the ability to put the descriptions inside the `static_assert()`s here and elsewhere?\r\n```suggestion\r\n    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2,\r\n        \"Only binary, unsigned, integer, types allowed.\");\r\n```",
      "created_at": "2024-06-06T19:21:05Z",
      "updated_at": "2024-06-06T19:29:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1630102455",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1630102455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 64,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1630120206",
      "pull_request_review_id": 2103053367,
      "id": 1630120206,
      "node_id": "PRRC_kwDOABII585hKakO",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);",
      "path": "src/util/bitset.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "in_reply_to_id": 1630102455,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the condition is sufficiently self-descriptive that this isn't really needed (the compiler error emitted will report the line causing it anyway). And I still like to have a comment on all top-level statements/definitions inside a class, even if it's trivial, just for organization purposes.",
      "created_at": "2024-06-06T19:34:46Z",
      "updated_at": "2024-06-06T19:34:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1630120206",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1630120206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 64,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631335816",
      "pull_request_review_id": 2104783238,
      "id": 1631335816,
      "node_id": "PRRC_kwDOABII585hPDWI",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */",
      "path": "src/util/bitset.h",
      "position": 128,
      "original_position": 128,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    /** Assign from a list of positional values. */\r\n```",
      "created_at": "2024-06-07T14:49:46Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631335816",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631335816"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 128,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631369553",
      "pull_request_review_id": 2104783238,
      "id": 1631369553,
      "node_id": "PRRC_kwDOABII585hPLlR",
      "diff_hunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    /** This fuzz test's design is based on the assumption that the actual bits stored in the\n+     *  bitsets and their simulations do not matter for the purpose of detecting edge cases, thus\n+     *  these are taken from a deterministically-seeded RNG instead. To provide some level of\n+     *  variation however, pick the seed based on the buffer size and size of the chosen bitset. */\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 62,
      "original_position": 62,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n        /* First / Last */\r\n```",
      "created_at": "2024-06-07T15:17:16Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631369553",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631369553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 62,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631393064",
      "pull_request_review_id": 2104783238,
      "id": 1631393064,
      "node_id": "PRRC_kwDOABII585hPRUo",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }",
      "path": "src/util/bitset.h",
      "position": 225,
      "original_position": 225,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "lacks coverage? \r\n\r\nmy local coverage generation is kinda screwed up, but fuzz coverage should be computed :pray: ",
      "created_at": "2024-06-07T15:37:19Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631393064",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631393064"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 225,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631403413",
      "pull_request_review_id": 2104783238,
      "id": 1631403413,
      "node_id": "PRRC_kwDOABII585hPT2V",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;",
      "path": "src/util/bitset.h",
      "position": 134,
      "original_position": 134,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Set(i)?",
      "created_at": "2024-06-07T15:46:37Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631403413",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631403413"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 134,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631403529",
      "pull_request_review_id": 2104783238,
      "id": 1631403529,
      "node_id": "PRRC_kwDOABII585hPT4J",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;",
      "path": "src/util/bitset.h",
      "position": 123,
      "original_position": 123,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Set(i)",
      "created_at": "2024-06-07T15:46:43Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631403529",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631403529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 123,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631406724",
      "pull_request_review_id": 2104783238,
      "id": 1631406724,
      "node_id": "PRRC_kwDOABII585hPUqE",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);",
      "path": "src/util/bitset.h",
      "position": 168,
      "original_position": 168,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe just use conditional `Set`?",
      "created_at": "2024-06-07T15:49:30Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631406724",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631406724"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631406944",
      "pull_request_review_id": 2104783238,
      "id": 1631406944,
      "node_id": "PRRC_kwDOABII585hPUtg",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    // Cannot be empty.\n+    static_assert(N > 0);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>& ref) noexcept : m_ptr(&ref), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_idx < N);\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept",
      "path": "src/util/bitset.h",
      "position": 338,
      "original_position": 338,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe just use conditional `Set`?",
      "created_at": "2024-06-07T15:49:43Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631406944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631406944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 338,
      "original_line": 338,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631408015",
      "pull_request_review_id": 2104783238,
      "id": 1631408015,
      "node_id": "PRRC_kwDOABII585hPU-P",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    // Cannot be empty.\n+    static_assert(N > 0);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>& ref) noexcept : m_ptr(&ref), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_idx < N);\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept",
      "path": "src/util/bitset.h",
      "position": 350,
      "original_position": 350,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "stick with `pos` for arg names?",
      "created_at": "2024-06-07T15:50:34Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631408015",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631408015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 350,
      "original_line": 350,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631411035",
      "pull_request_review_id": 2104783238,
      "id": 1631411035,
      "node_id": "PRRC_kwDOABII585hPVtb",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    // Cannot be empty.\n+    static_assert(N > 0);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>& ref) noexcept : m_ptr(&ref), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_idx < N);\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept",
      "path": "src/util/bitset.h",
      "position": 390,
      "original_position": 390,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "just check `!None()`?",
      "created_at": "2024-06-07T15:53:18Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631411035",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631411035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 390,
      "original_line": 390,
      "side": "RIGHT"
    }
  ]
}