{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126",
    "id": 1874254526,
    "node_id": "PR_kwDOABII585vttq-",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30126.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30126.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
    "number": 30126,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "cluster mempool: cluster linearization algorithm",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Part of cluster mempool: #30289 \r\n\r\n\r\nThis introduces low-level cluster linearization code, including tests and some benchmarks. It is currently not hooked up to anything.\r\n\r\nUltimately, what this PR adds is a function `Linearize` which operates on instances of `DepGraph` (instances of which represent pre-processed transaction clusters) to produce and/or improve linearizations for that cluster.\r\n\r\nTo provide assurance, the code heavily relies on fuzz tests. A novel approach is used here, where the fuzz input is parsed using the serialization.h framework rather than `FuzzedDataProvider`, with a custom serializer/deserializer for `DepGraph` objects. By including serialization, it's possible to ascertain that the format can represent every relevant cluster, as well as potentially permitting the construction of ad-hoc fuzz inputs from clusters (not included in this PR, but used during development).\r\n\r\n---\r\n\r\nThe `Linearize(depgraph, iteration_limit, rng_seed, old_linearization)` function is an implementation of the (single) LIMO algorithm, with the $S$ in every iteration found as the best out of (a) the best remaining ancestor set and (b) randomized computationally-bounded search. It incrementally builds up a linearization by finding good topologically-valid subsets to move to the front, in such a way that the resulting linearization has a diagram that is at least as good as the `old_linearization` passed in (if any).\r\n* Despite using both best ancestor set and search, this is not Double LIMO, as no intersections between these are involved; just the best of the two.\r\n* The `iteration_limit` and `rng_seed` only control the (b) randomized search. Even with 0 iterations, the result will be as good as the old linearization, and the included sets at every point will have a feerate at least as high as the best remaining ancestor set at that point.\r\n\r\nThe search algorithm used in the (b) step is very basic, and largely matches Section 2.1 of [How to Linearize your Cluster.](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-21-searching-6). See #30286 for optimizations to make it more efficient.\r\n\r\nFor background and references, see [Introduction to cluster linearization](https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032).",
    "labels": [
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      },
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2024-05-16T20:29:15Z",
    "updated_at": "2024-07-11T12:36:40Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "17eeded4531074f8cf7fc68cda5d17576c5b828b",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202405_clusterlin",
      "ref": "202405_clusterlin",
      "sha": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 22,
        "stargazers_count": 86,
        "watchers_count": 86,
        "size": 242091,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-11T12:39:10Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-06-02T01:19:44Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "9b480f7a25a737c9c4ebc33401e94d66c2da9ec3",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35627,
        "stargazers_count": 77154,
        "watchers_count": 77154,
        "size": 262781,
        "default_branch": "master",
        "open_issues_count": 684,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-11T12:39:13Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-07-11T12:42:00Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 2079,
    "deletions": 0,
    "changed_files": 9,
    "commits": 13,
    "review_comments": 140,
    "comments": 17
  },
  "events": [
    {
      "event": "commented",
      "id": 2116123949,
      "node_id": "IC_kwDOABII585-IX0t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116123949",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T20:29:17Z",
      "updated_at": "2024-07-11T04:33:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30126).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2116123949",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "labeled",
      "id": 12840661156,
      "node_id": "LE_lADOABII586JKtCPzwAAAAL9XPCk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12840661156",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T22:28:58Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2116307861,
      "node_id": "IC_kwDOABII585-JEuV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116307861",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T22:28:59Z",
      "updated_at": "2024-05-16T22:28:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25072594213</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2116307861",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12841939086,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9cHCO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12841939086",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T02:20:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12841977041,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9cQTR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12841977041",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T02:25:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12841998527,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9cVi_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12841998527",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T02:28:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12847794028,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9ycds",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12847794028",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T12:38:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12848600848,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL91hcQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12848600848",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T13:38:24Z"
    },
    {
      "event": "unlabeled",
      "id": 12849722556,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAL95zS8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12849722556",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T14:53:37Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 12852777283,
      "node_id": "LE_lADOABII586JKtCPzwAAAAL-FdFD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12852777283",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T19:54:02Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12859897701,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL-gndl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12859897701",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T01:34:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12859902015,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL-gog_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12859902015",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T01:35:33Z"
    },
    {
      "event": "labeled",
      "id": 12860230371,
      "node_id": "LE_lADOABII586JKtCPzwAAAAL-h4rj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12860230371",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T02:43:26Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 12868212799,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAL_AVg_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12868212799",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T16:03:14Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12869818131,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL_GdcT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12869818131",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T18:49:29Z"
    },
    {
      "event": "commented",
      "id": 2121018386,
      "node_id": "IC_kwDOABII585-bCwS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2121018386",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T18:53:52Z",
      "updated_at": "2024-05-20T19:16:50Z",
      "author_association": "MEMBER",
      "body": "Benchmarks on my Ryzen 5950X system:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|            2,373.94 |          421,240.11 |    0.1% |      1.10 | `LinearizeNoIters16TxWorstCase`\r\n|            7,530.22 |          132,798.26 |    0.0% |      1.07 | `LinearizeNoIters32TxWorstCase`\r\n|           16,585.34 |           60,294.20 |    0.1% |      1.10 | `LinearizeNoIters48TxWorstCase`\r\n|           28,591.70 |           34,975.18 |    0.1% |      1.10 | `LinearizeNoIters64TxWorstCase`\r\n|           53,918.56 |           18,546.49 |    0.0% |      1.10 | `LinearizeNoIters75TxWorstCase`\r\n|           93,589.21 |           10,684.99 |    0.1% |      1.10 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               45.36 |       22,045,550.98 |    0.5% |      1.10 | `LinearizePerIter16TxWorstCase`\r\n|               35.57 |       28,111,376.58 |    0.1% |      1.10 | `LinearizePerIter32TxWorstCase`\r\n|               33.04 |       30,262,951.89 |    0.0% |      1.10 | `LinearizePerIter48TxWorstCase`\r\n|               33.21 |       30,107,745.17 |    0.1% |      1.10 | `LinearizePerIter64TxWorstCase`\r\n|               75.98 |       13,161,530.63 |    0.4% |      1.07 | `LinearizePerIter75TxWorstCase`\r\n|               76.62 |       13,051,066.77 |    0.5% |      1.08 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              332.97 |        3,003,274.74 |    0.0% |      1.10 | `PostLinearize16TxWorstCase`\r\n|            1,121.92 |          891,330.77 |    0.0% |      1.10 | `PostLinearize32TxWorstCase`\r\n|            3,358.33 |          297,767.01 |    0.3% |      1.13 | `PostLinearize48TxWorstCase`\r\n|            5,826.72 |          171,623.05 |    0.5% |      1.11 | `PostLinearize64TxWorstCase`\r\n|            7,453.31 |          134,168.55 |    0.1% |      1.07 | `PostLinearize75TxWorstCase`\r\n|           12,476.44 |           80,151.09 |    0.1% |      1.10 | `PostLinearize99TxWorstCase`\r\n\r\nThis means that for a 64-transaction cluster, it should be possible to linearize (28.59 µs) with 100 candidate search iterations (3.32 µs) plus postlinearize (5.83 µs), within a total of 37.74 µs, on my system.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2121018386",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12871304039,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL_MINn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12871304039",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T21:33:55Z"
    },
    {
      "event": "labeled",
      "id": 12884960646,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMAAOWG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12884960646",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T20:09:26Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "reviewed",
      "id": 2074233399,
      "node_id": "PRR_kwDOABII5857oko3",
      "url": null,
      "actor": null,
      "commit_id": "316e2044aad16e1ed8d024d3325bfcee8c04cd1f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2074233399",
      "submitted_at": "2024-05-23T14:55:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12911183405,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMBkQYt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911183405",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:15:40Z"
    },
    {
      "event": "commented",
      "id": 2127404990,
      "node_id": "IC_kwDOABII585-zZ--",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127404990",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:18:30Z",
      "updated_at": "2024-05-23T15:19:11Z",
      "author_association": "MEMBER",
      "body": "I've dropped the dependency on #29625, and switched to using FastRandomContext instead; there is a measurable slowdown from using the (ChaCha20-based) FastRandomContext over the (xoroshiro128++-based) InsecureRandomContext introduced there, but it's no more than 1-2%. I can switch back to that approach if 29625 were to make it in.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2127404990",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12911356100,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMBk6jE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911356100",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:28:02Z"
    },
    {
      "event": "unlabeled",
      "id": 12911651125,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMBmCk1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911651125",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:48:19Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12913685226,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMBtzLq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913685226",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:23:24Z"
    },
    {
      "event": "commented",
      "id": 2127799066,
      "node_id": "IC_kwDOABII585-06Ma",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127799066",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:33:11Z",
      "updated_at": "2024-05-23T18:33:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--9cd9c72976c961c55c7acef8f6ba82cd-->\n### Guix builds (on x86_64) [untrusted test-only build, possibly unsafe, not for production use]\n\n| File | commit 83ae1bac9d3e01de994734b4bc7002deaf19bc67<br>(master) | commit e5cbc2372efc917784b6cae4175b8653a20517c4<br>(master and this pull) |\n|--|--|--|\n| SHA256SUMS.part | [`24fd016e03e8c7da...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/SHA256SUMS.part) | [`15fae3483445e33b...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/SHA256SUMS.part) |\n| *-aarch64-linux-gnu-debug.tar.gz | [`94942cf7dedf3604...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-aarch64-linux-gnu-debug.tar.gz) | [`23eeccf77ee5799d...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-aarch64-linux-gnu-debug.tar.gz) |\n| *-aarch64-linux-gnu.tar.gz | [`4b30ca93b6788f48...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-aarch64-linux-gnu.tar.gz) | [`ed8e5024d960f53e...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-aarch64-linux-gnu.tar.gz) |\n| *-arm-linux-gnueabihf-debug.tar.gz | [`a0f57c45e5f02bb1...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm-linux-gnueabihf-debug.tar.gz) | [`f22f89c1eba49dda...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm-linux-gnueabihf-debug.tar.gz) |\n| *-arm-linux-gnueabihf.tar.gz | [`9f0376baaf54b988...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm-linux-gnueabihf.tar.gz) | [`17da8a968635c492...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm-linux-gnueabihf.tar.gz) |\n| *-arm64-apple-darwin-unsigned.tar.gz | [`9b952b32db70d099...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm64-apple-darwin-unsigned.tar.gz) | [`16d805ab4bcf8d54...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm64-apple-darwin-unsigned.tar.gz) |\n| *-arm64-apple-darwin-unsigned.zip | [`d49361bbbc5529fc...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm64-apple-darwin-unsigned.zip) | [`e225d79a24b058a5...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm64-apple-darwin-unsigned.zip) |\n| *-arm64-apple-darwin.tar.gz | [`34e9cf4b79cbc190...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm64-apple-darwin.tar.gz) | [`29b28e6d57761201...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm64-apple-darwin.tar.gz) |\n| *-powerpc64-linux-gnu-debug.tar.gz | [`5f322a7b213e244e...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-powerpc64-linux-gnu-debug.tar.gz) | [`cb5f37b036b5c52c...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-powerpc64-linux-gnu-debug.tar.gz) |\n| *-powerpc64-linux-gnu.tar.gz | [`bb57b46482c5b1e6...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-powerpc64-linux-gnu.tar.gz) | [`57adf954458a27d5...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-powerpc64-linux-gnu.tar.gz) |\n| *-riscv64-linux-gnu-debug.tar.gz | [`d1a3a405c5b45fff...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-riscv64-linux-gnu-debug.tar.gz) | [`237eb467f8547d22...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-riscv64-linux-gnu-debug.tar.gz) |\n| *-riscv64-linux-gnu.tar.gz | [`68d7e6671e2dba30...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-riscv64-linux-gnu.tar.gz) | [`29d9f1e9052e96d3...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-riscv64-linux-gnu.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.tar.gz | [`6fb22000e8c14c40...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-apple-darwin-unsigned.tar.gz) | [`67e5bd5b86483c8a...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-apple-darwin-unsigned.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.zip | [`1c5f2a216e87cbf5...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-apple-darwin-unsigned.zip) | [`abdbca97fafc146f...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-apple-darwin-unsigned.zip) |\n| *-x86_64-apple-darwin.tar.gz | [`66f17a574163ecaf...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-apple-darwin.tar.gz) | [`f002830b4b8da330...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-apple-darwin.tar.gz) |\n| *-x86_64-linux-gnu-debug.tar.gz | [`a5044f956a824228...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-linux-gnu-debug.tar.gz) | [`0791685e39e80672...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-linux-gnu-debug.tar.gz) |\n| *-x86_64-linux-gnu.tar.gz | [`23af1dc6cb921b37...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-linux-gnu.tar.gz) | [`ff9625165c3f19c2...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-linux-gnu.tar.gz) |\n| *.tar.gz | [`caac4a182deb1e04...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e.tar.gz) | [`ba8abeef4165dafb...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc.tar.gz) |\n| guix_build.log | [`c7cc0190f7085f04...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/guix_build.log) | [`100da60c2f0e6686...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/guix_build.log) |\n| guix_build.log.diff |  | [`7c460aa3b1aafc32...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/guix_build.log.diff) |\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2127799066",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12926701844,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCfdEU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12926701844",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T15:33:59Z"
    },
    {
      "event": "commented",
      "id": 2129982443,
      "node_id": "IC_kwDOABII585-9PPr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129982443",
      "actor": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T16:49:21Z",
      "updated_at": "2024-05-24T16:49:21Z",
      "author_association": "MEMBER",
      "body": "Some more benchmarks.\r\n\r\nMacBook M3 Max:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|            1,678.30 |          595,841.56 |    0.4% |      1.11 | `LinearizeNoIters16TxWorstCase`\r\n|            4,975.16 |          200,998.49 |    0.1% |      1.10 | `LinearizeNoIters32TxWorstCase`\r\n|           10,624.85 |           94,118.94 |    0.1% |      1.10 | `LinearizeNoIters48TxWorstCase`\r\n|           18,570.63 |           53,848.46 |    0.1% |      1.10 | `LinearizeNoIters64TxWorstCase`\r\n|           38,962.09 |           25,665.97 |    0.1% |      1.10 | `LinearizeNoIters75TxWorstCase`\r\n|           65,933.96 |           15,166.69 |    0.1% |      1.06 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               37.31 |       26,803,657.99 |    0.1% |      1.10 | `LinearizePerIter16TxWorstCase`\r\n|               26.62 |       37,561,209.12 |    0.2% |      1.10 | `LinearizePerIter32TxWorstCase`\r\n|               25.79 |       38,768,485.22 |    0.2% |      1.10 | `LinearizePerIter48TxWorstCase`\r\n|               26.05 |       38,392,847.23 |    0.1% |      1.10 | `LinearizePerIter64TxWorstCase`\r\n|               37.99 |       26,322,699.89 |    0.2% |      1.09 | `LinearizePerIter75TxWorstCase`\r\n|               38.21 |       26,169,082.76 |    0.1% |      1.10 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              375.76 |        2,661,273.20 |    0.3% |      1.11 | `PostLinearize16TxWorstCase`\r\n|            1,295.00 |          772,200.32 |    0.1% |      1.10 | `PostLinearize32TxWorstCase`\r\n|            2,850.98 |          350,756.38 |    0.0% |      1.10 | `PostLinearize48TxWorstCase`\r\n|            5,155.30 |          193,975.14 |    0.0% |      1.10 | `PostLinearize64TxWorstCase`\r\n|            6,804.84 |          146,954.16 |    0.1% |      1.06 | `PostLinearize75TxWorstCase`\r\n|           11,696.22 |           85,497.68 |    0.0% |      1.10 | `PostLinearize99TxWorstCase`\r\n\r\nRaspberry Pi 4 (arm32):\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|           24,979.12 |           40,033.43 |    0.1% |       62,303.01 |       37,432.31 |  1.664 |      1.10 | `LinearizeNoIters16TxWorstCase`\r\n|           79,796.77 |           12,531.84 |    0.0% |      199,042.69 |      119,579.10 |  1.665 |      1.08 | `LinearizeNoIters32TxWorstCase`\r\n|          206,049.75 |            4,853.20 |    0.0% |      514,152.74 |      308,732.11 |  1.665 |      1.10 | `LinearizeNoIters48TxWorstCase`\r\n|          339,314.40 |            2,947.12 |    0.0% |      866,686.12 |      508,414.12 |  1.705 |      1.10 | `LinearizeNoIters64TxWorstCase`\r\n|          574,288.94 |            1,741.28 |    0.0% |    1,309,819.21 |      860,366.98 |  1.522 |      1.10 | `LinearizeNoIters75TxWorstCase`\r\n|          983,808.56 |            1,016.46 |    0.0% |    2,278,204.68 |    1,474,149.12 |  1.545 |      1.10 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |       ins/iters |       cyc/iters |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|              362.94 |        2,755,255.49 |    0.1% |          862.03 |          543.89 |  1.585 |      1.10 | `LinearizePerIter16TxWorstCase`\r\n|              290.11 |        3,446,974.76 |    0.2% |          692.02 |          434.73 |  1.592 |      1.10 | `LinearizePerIter32TxWorstCase`\r\n|              529.35 |        1,889,094.80 |    0.1% |        1,319.02 |          793.26 |  1.663 |      1.11 | `LinearizePerIter48TxWorstCase`\r\n|              530.00 |        1,886,788.68 |    0.2% |        1,324.44 |          794.26 |  1.668 |      1.11 | `LinearizePerIter64TxWorstCase`\r\n|              782.35 |        1,278,197.39 |    0.5% |        2,079.81 |        1,172.37 |  1.774 |      1.06 | `LinearizePerIter75TxWorstCase`\r\n|              737.95 |        1,355,112.46 |    0.5% |        1,684.40 |        1,105.59 |  1.524 |      1.07 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|            5,010.36 |          199,586.29 |    0.8% |       10,606.00 |        7,506.09 |  1.413 |      1.10 | `PostLinearize16TxWorstCase`\r\n|           14,365.91 |           69,609.26 |    0.0% |       34,330.00 |       21,530.90 |  1.594 |      1.09 | `PostLinearize32TxWorstCase`\r\n|           32,751.91 |           30,532.57 |    0.0% |       76,671.01 |       49,085.98 |  1.562 |      1.10 | `PostLinearize48TxWorstCase`\r\n|           55,794.83 |           17,922.81 |    0.0% |      131,423.02 |       83,621.11 |  1.572 |      1.10 | `PostLinearize64TxWorstCase`\r\n|           81,534.00 |           12,264.82 |    1.6% |      210,784.02 |      120,341.56 |  1.752 |      1.09 | `PostLinearize75TxWorstCase`\r\n|          144,665.53 |            6,912.50 |    0.0% |      399,573.04 |      216,805.74 |  1.843 |      1.10 | `PostLinearize99TxWorstCase`\r\n\r\nRaspberry Pi 4 (aarch64):\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|           13,765.93 |           72,643.09 |    0.1% |       37,001.00 |       20,625.64 |  1.794 |     11.01 | `LinearizeNoIters16TxWorstCase`\r\n|           41,091.94 |           24,335.67 |    0.2% |      107,447.00 |       61,567.66 |  1.745 |     10.99 | `LinearizeNoIters32TxWorstCase`\r\n|           73,005.68 |           13,697.56 |    0.1% |      210,986.00 |      109,380.97 |  1.929 |     10.67 | `LinearizeNoIters48TxWorstCase`\r\n|          118,418.69 |            8,444.61 |    0.0% |      348,914.00 |      177,423.52 |  1.967 |     11.01 | `LinearizeNoIters64TxWorstCase`\r\n|          229,345.84 |            4,360.23 |    0.0% |      618,749.67 |      343,589.10 |  1.801 |     11.01 | `LinearizeNoIters75TxWorstCase`\r\n|          377,809.11 |            2,646.84 |    0.0% |    1,021,644.01 |      565,996.91 |  1.805 |     11.00 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |       ins/iters |       cyc/iters |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|              231.99 |        4,310,566.43 |    0.0% |          643.14 |          347.59 |  1.850 |     11.00 | `LinearizePerIter16TxWorstCase`\r\n|              190.47 |        5,250,207.80 |    0.1% |          525.81 |          285.35 |  1.843 |     11.03 | `LinearizePerIter32TxWorstCase`\r\n|              175.35 |        5,702,969.82 |    0.1% |          492.10 |          262.75 |  1.873 |     11.01 | `LinearizePerIter48TxWorstCase`\r\n|              175.70 |        5,691,481.30 |    0.1% |          494.56 |          263.25 |  1.879 |     11.00 | `LinearizePerIter64TxWorstCase`\r\n|              293.22 |        3,410,384.42 |    0.2% |          763.38 |          439.30 |  1.738 |     11.01 | `LinearizePerIter75TxWorstCase`\r\n|              293.55 |        3,406,519.94 |    0.1% |          766.88 |          439.77 |  1.744 |     11.01 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|            2,915.23 |          343,026.59 |    0.1% |        5,325.00 |        4,368.47 |  1.219 |     11.01 | `PostLinearize16TxWorstCase`\r\n|            9,830.26 |          101,726.71 |    0.0% |       17,247.00 |       14,729.95 |  1.171 |     11.00 | `PostLinearize32TxWorstCase`\r\n|           20,550.14 |           48,661.46 |    0.0% |       35,742.00 |       30,794.09 |  1.161 |     11.00 | `PostLinearize48TxWorstCase`\r\n|           35,211.73 |           28,399.62 |    0.0% |       61,199.00 |       52,763.93 |  1.160 |     11.00 | `PostLinearize64TxWorstCase`\r\n|           31,801.73 |           31,444.83 |    0.0% |       95,378.00 |       47,653.77 |  2.001 |     11.00 | `PostLinearize75TxWorstCase`\r\n|           52,955.80 |           18,883.67 |    0.0% |      162,443.00 |       79,349.66 |  2.047 |     11.00 | `PostLinearize99TxWorstCase`",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2129982443",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927624409,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCi-TZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927624409",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:03:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927882366,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCj9R-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927882366",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:30:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927934896,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCkKGw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927934896",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:36:57Z"
    },
    {
      "event": "labeled",
      "id": 12927935505,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMCkKQR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927935505",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:37:01Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2130060489,
      "node_id": "IC_kwDOABII585-9iTJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130060489",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:37:02Z",
      "updated_at": "2024-05-24T17:37:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25390396918</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2130060489",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2130129883,
      "node_id": "IC_kwDOABII585-9zPb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130129883",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T18:26:06Z",
      "updated_at": "2024-05-24T18:26:06Z",
      "author_association": "MEMBER",
      "body": "> Ancestor-set based presplitting inside the search is replaced with using the best ancestor set as one of the LIMO set choices.\r\n\r\nCan this be elaborated a bit? I've taken a few minutes looking at the commits and it wasn't immediately clear how this all maps to existing public discussions and the comments:\r\n\r\n```\r\n        // This is an implementation of the (single) LIMO algorithm:\r\n        // https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\r\n        // where S is instantiated to be the result of a bounded search, which itself is seeded\r\n        // with the best prefix of what remains of the input linearization, or the best ancestor set.\r\n```\r\nthanks!",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2130129883",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2130187888,
      "node_id": "IC_kwDOABII585--BZw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130187888",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:05:02Z",
      "updated_at": "2024-05-24T19:16:08Z",
      "author_association": "MEMBER",
      "body": "@instagibbs I've expanded the explanation in the PR description. Happy to elaborate more if things are unclear.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2130187888",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "mentioned",
      "id": 12928689814,
      "node_id": "MEE_lADOABII586JKtCPzwAAAAMCnCaW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12928689814",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:05:04Z"
    },
    {
      "event": "subscribed",
      "id": 12928689822,
      "node_id": "SE_lADOABII586JKtCPzwAAAAMCnCae",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12928689822",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:05:04Z"
    },
    {
      "event": "unlabeled",
      "id": 12930191775,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMCsxGf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12930191775",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T22:47:36Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934054913,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMC7gQB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934054913",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T22:07:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934290395,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMC8Zvb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934290395",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T23:42:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934323825,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMC8h5x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934323825",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-26T00:00:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12936811909,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMDGBWF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12936811909",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-26T13:32:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12958045312,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMEXBSA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12958045312",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T13:50:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12975512592,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMFZpwQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12975512592",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T18:06:13Z"
    },
    {
      "event": "commented",
      "id": 2138188901,
      "node_id": "IC_kwDOABII585_cixl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2138188901",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T20:14:05Z",
      "updated_at": "2024-05-29T20:14:05Z",
      "author_association": "MEMBER",
      "body": "I've added support for merging linearizations to this PR (`MergeLinearizations()` function), plus benchmarks and tests.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2138188901",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "labeled",
      "id": 12980402065,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMFsTeR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12980402065",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T05:55:09Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2138735594,
      "node_id": "IC_kwDOABII585_eoPq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2138735594",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T05:55:10Z",
      "updated_at": "2024-05-30T05:55:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25568469819</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2138735594",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12985679275,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMGAb2r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12985679275",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T12:52:10Z"
    },
    {
      "event": "unlabeled",
      "id": 12991846022,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMGX9aG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12991846022",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T21:07:01Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2077166958,
      "node_id": "PRR_kwDOABII5857zw1u",
      "url": null,
      "actor": null,
      "commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "glanced in the context of checking what of VecDeque/BitSet actually required",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2077166958",
      "submitted_at": "2024-06-06T14:13:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13070771117,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMLFCOt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13070771117",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T18:33:20Z"
    },
    {
      "event": "referenced",
      "id": 13081030834,
      "node_id": "REFE_lADOABII586JKtCPzwAAAAMLsLCy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13081030834",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "feab35189bc00bc4cf15e9dcb5cf6b34ff3a1e91",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/feab35189bc00bc4cf15e9dcb5cf6b34ff3a1e91",
      "created_at": "2024-06-07T13:33:20Z"
    },
    {
      "event": "labeled",
      "id": 13082095784,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMLwPCo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13082095784",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T14:44:39Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13082513580,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMLx1Cs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13082513580",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T15:20:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13084466690,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAML5R4C",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13084466690",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T18:52:51Z"
    },
    {
      "event": "unlabeled",
      "id": 13084572312,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAML5rqY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13084572312",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T19:04:25Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13085738874,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAML-Id6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13085738874",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T21:37:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13093283115,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMMa6Ur",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13093283115",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-10T00:28:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13109045660,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMNXCmc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13109045660",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T00:58:52Z"
    },
    {
      "event": "labeled",
      "id": 13110771411,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMNdn7T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13110771411",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T05:11:18Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2159806599,
      "node_id": "IC_kwDOABII586AvAiH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2159806599",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T05:11:19Z",
      "updated_at": "2024-06-11T05:11:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26052313359</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2159806599",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13115580682,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMNv-EK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13115580682",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T11:23:21Z"
    },
    {
      "event": "unlabeled",
      "id": 13117085849,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMN1tiZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13117085849",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T13:15:11Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13122043976,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMOIoBI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122043976",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T19:51:04Z"
    },
    {
      "event": "referenced",
      "id": 13122953655,
      "node_id": "REFE_lADOABII586JKtCPzwAAAAMOMGG3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122953655",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "91e0beede2859dea987ba6db746e95dca0ceb024",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91e0beede2859dea987ba6db746e95dca0ceb024",
      "created_at": "2024-06-11T21:28:58Z"
    },
    {
      "event": "labeled",
      "id": 13123639969,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMOOtqh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13123639969",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T23:12:20Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13123652095,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMOOwn_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13123652095",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T23:14:29Z"
    },
    {
      "event": "unlabeled",
      "id": 13124366874,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMORfIa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13124366874",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T01:17:30Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13137473518,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPDe_u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13137473518",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T21:14:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13137755681,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPEj4h",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13137755681",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T21:47:11Z"
    },
    {
      "event": "labeled",
      "id": 13143080877,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMPY3-t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13143080877",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T08:57:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2165049648,
      "node_id": "IC_kwDOABII586BDAkw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2165049648",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T08:57:46Z",
      "updated_at": "2024-06-13T08:57:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26153096652</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2165049648",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13147233559,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPot0X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13147233559",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T13:49:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13148811159,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPuu-X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13148811159",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T15:26:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13150112020,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPzskU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13150112020",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T17:01:33Z"
    },
    {
      "event": "unlabeled",
      "id": 13151725563,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMP52f7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13151725563",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T19:14:32Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13151774954,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMP6Cjq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13151774954",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T19:19:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13154448696,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMQEPU4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13154448696",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T01:47:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13154557139,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMQEpzT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13154557139",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T02:05:33Z"
    },
    {
      "event": "renamed",
      "id": 13160829573,
      "node_id": "RTE_lADOABII586JKtCPzwAAAAMQclKF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13160829573",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T13:12:50Z",
      "rename": {
        "from": "Low-level cluster linearization code",
        "to": "cluster mempool: cluster linearization algorithm"
      }
    },
    {
      "event": "commented",
      "id": 2168024936,
      "node_id": "IC_kwDOABII586BOW9o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168024936",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T13:17:11Z",
      "updated_at": "2024-06-14T13:17:11Z",
      "author_association": "MEMBER",
      "body": "I have split off the optimizations for candidate search to PR #30286, and the merging & postprocessing algorithms to PR #30285, and renamed the PR. It is now focused on just adding the `Linearize()` function, with its eventual interface (including passing in an old linearization, and a randomization seed), but without optimizations beyond that.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2168024936",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13235415708,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMU5Gqc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13235415708",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-20T23:08:33Z"
    },
    {
      "event": "commented",
      "id": 2181689921,
      "node_id": "IC_kwDOABII586CCfJB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181689921",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-20T23:09:06Z",
      "updated_at": "2024-06-20T23:09:06Z",
      "author_association": "MEMBER",
      "body": "Added a big description about the fuzzer serialization format for DepGraph objects.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2181689921",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "reviewed",
      "id": 2116172410,
      "node_id": "PRR_kwDOABII585-Ijp6",
      "url": null,
      "actor": null,
      "commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "couldn't find any logic issues in the parts I complete understood, I've run the fuzzer on each commit and reviewed through  https://github.com/bitcoin/bitcoin/pull/30126/commits/9633b40722fd9295b93baaf9914b31b9dec96f45\r\n\r\na couple general comments:\r\n\r\n1) The bespoke DepGraphFormatter is pretty artisanal and as a reviewer I'm relying heavily on the cluster->depgraph->check depgraph matches -> serialization round-trip for asserting correctness. Unit tests-as-documentation is one thing I'm kind of missing, especially with the more involved parts.\r\n2) Matching the actual LIMO commit with the LIMO literature/theory available is difficult for me(e.g., what's sufficient vs necessary). I know there's a new writeup coming, so I'll wait for that before investigating further.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2116172410",
      "submitted_at": "2024-06-27T15:02:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13323909917,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMaKrsd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13323909917",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:57:19Z"
    },
    {
      "event": "commented",
      "id": 2195728404,
      "node_id": "IC_kwDOABII586C4CgU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2195728404",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:59:06Z",
      "updated_at": "2024-06-27T21:59:06Z",
      "author_association": "MEMBER",
      "body": "Addressed some of @instagibbs' comments, which involved moving some of the `src/test/fuzz/cluster_linearize.cpp` code to a common `src/test/util/cluster_linearize.h`, where it is also available to a newly-added (but pretty barebones) `src/test/cluster_linearize_tests.cpp`.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2195728404",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "mentioned",
      "id": 13323922870,
      "node_id": "MEE_lADOABII586JKtCPzwAAAAMaKu22",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13323922870",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:59:08Z"
    },
    {
      "event": "subscribed",
      "id": 13323922878,
      "node_id": "SE_lADOABII586JKtCPzwAAAAMaKu2-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13323922878",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:59:08Z"
    },
    {
      "event": "commented",
      "id": 2195825414,
      "node_id": "IC_kwDOABII586C4aMG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2195825414",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T23:27:50Z",
      "updated_at": "2024-06-27T23:27:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26783773668</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2195825414",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "labeled",
      "id": 13324461892,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMaMydE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13324461892",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T23:27:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13326060235,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMaS4rL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13326060235",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-28T03:53:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13326149312,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMaTObA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13326149312",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-28T04:09:31Z"
    },
    {
      "event": "unlabeled",
      "id": 13326607204,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMaU-Nk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13326607204",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-28T05:25:03Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13335385605,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMa2dYF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13335385605",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-28T19:21:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13343634959,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMbV7YP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13343634959",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-01T00:56:32Z"
    },
    {
      "event": "labeled",
      "id": 13362254729,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMcc9OJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13362254729",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-02T08:47:38Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 13366998273,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMcvDUB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13366998273",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-02T14:16:55Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13371378031,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMc_wlv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13371378031",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-02T20:20:20Z"
    },
    {
      "event": "reviewed",
      "id": 2151679554,
      "node_id": "PRR_kwDOABII586AQAZC",
      "url": null,
      "actor": null,
      "commit_id": "48e83f9521050e150aa52c0e949ac4746ac30340",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Just reviewed through the first 3 commits so far.",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2151679554",
      "submitted_at": "2024-07-03T20:23:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "reviewed",
      "id": 2160552969,
      "node_id": "PRR_kwDOABII586Ax2wJ",
      "url": null,
      "actor": null,
      "commit_id": "48e83f9521050e150aa52c0e949ac4746ac30340",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2160552969",
      "submitted_at": "2024-07-05T12:20:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13417499895,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMfvsz3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13417499895",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T04:36:02Z"
    },
    {
      "event": "reviewed",
      "id": 2118340933,
      "node_id": "PRR_kwDOABII585-Q1FF",
      "url": null,
      "actor": null,
      "commit_id": "dc46e54606ca42dd34fb66ae5e3deb1a95e9589e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Looked at the first 4 commits so far, just doing code review and trying the algos out in `MiniMiner`.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2118340933",
      "submitted_at": "2024-07-08T15:34:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13429537844,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMgdnw0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13429537844",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T20:35:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13432484821,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMgo3PV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13432484821",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T02:53:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13449420292,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMhpd4E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13449420292",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T03:32:11Z"
    },
    {
      "event": "labeled",
      "id": 13449848675,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMhrGdj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13449848675",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T04:51:42Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13455435119,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMiAaVv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13455435119",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T12:32:55Z"
    },
    {
      "event": "reviewed",
      "id": 2169903436,
      "node_id": "PRR_kwDOABII586BVhlM",
      "url": null,
      "actor": null,
      "commit_id": "41e31ce727ebb80c083255f53e109fc413e2d39f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2169903436",
      "submitted_at": "2024-07-10T18:12:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13461439023,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMiXUIv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13461439023",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T20:04:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13462199005,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMiaNrd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13462199005",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T20:49:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13464507559,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMijBSn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13464507559",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T01:10:52Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc1YzRmZmRlZTNjNGU4Nzg4YTIzNDU2YzVkMTY4ZGEwZjRkZjBmZjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75c4ffdee3c4e8788a23456c5d168da0f4df0ff1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/75c4ffdee3c4e8788a23456c5d168da0f4df0ff1",
      "tree": {
        "sha": "4b814eb160e929061e7e04ffcb06bad7baa1774a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b814eb160e929061e7e04ffcb06bad7baa1774a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b480f7a25a737c9c4ebc33401e94d66c2da9ec3",
          "sha": "9b480f7a25a737c9c4ebc33401e94d66c2da9ec3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9b480f7a25a737c9c4ebc33401e94d66c2da9ec3"
        }
      ],
      "message": "clusterlin: introduce cluster_linearize.h with Cluster and DepGraph types\n\nThis primarily adds the DepGraph class, which encapsulates precomputed\nancestor/descendant information for a given transaction cluster, with a\nnumber of utility features (inspectors for set feerates, computing\nreduced parents/children, adding transactions, adding dependencies), which\nwill become needed in future commits.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:12:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-01-30T03:05:53Z"
      },
      "sha": "75c4ffdee3c4e8788a23456c5d168da0f4df0ff1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQzZWRmYjhlYWIyZGU4YTFmMzAyZDY2ZmNhNDIyOTVmNzNhMDE0MDk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d3edfb8eab2de8a1f302d66fca42295f73a01409",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d3edfb8eab2de8a1f302d66fca42295f73a01409",
      "tree": {
        "sha": "c9390577e45c8da9f44d4429a2307f45f395b266",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c9390577e45c8da9f44d4429a2307f45f395b266"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75c4ffdee3c4e8788a23456c5d168da0f4df0ff1",
          "sha": "75c4ffdee3c4e8788a23456c5d168da0f4df0ff1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/75c4ffdee3c4e8788a23456c5d168da0f4df0ff1"
        }
      ],
      "message": "tests: framework for testing DepGraph class\n\nThis introduces a bespoke fuzzing-focused serialization format for DepGraphs,\nand then tests that this format can represent any graph, roundtrips, and then\nuses that to test the correctness of DepGraph itself.\n\nThis forms the basis for future fuzz tests that need to work with interesting\ngraphs.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:12:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-09T00:52:56Z"
      },
      "sha": "d3edfb8eab2de8a1f302d66fca42295f73a01409"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRlNGEyZjYxMDcxMjlhYjUzZTZkYjM4MGZiNGFjMTNjNzgwNGViYmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de4a2f6107129ab53e6db380fb4ac13c7804ebba",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/de4a2f6107129ab53e6db380fb4ac13c7804ebba",
      "tree": {
        "sha": "2aa0d295b3c53da9ad761268ff7e12eead110c32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2aa0d295b3c53da9ad761268ff7e12eead110c32"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d3edfb8eab2de8a1f302d66fca42295f73a01409",
          "sha": "d3edfb8eab2de8a1f302d66fca42295f73a01409",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d3edfb8eab2de8a1f302d66fca42295f73a01409"
        }
      ],
      "message": "clusterlin: add AncestorCandidateFinder class\n\nThis is a class that encapsulates precomputed ancestor set feerates, and\npresents an interface for getting the best remaining ancestor set.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:12:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-08T22:56:59Z"
      },
      "sha": "de4a2f6107129ab53e6db380fb4ac13c7804ebba"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg4MDBkMjQ0NTc1OTEzYWJkNDhkNDRjZTBmNDNhOTc3NjhmYjNlNjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8800d244575913abd48d44ce0f43a97768fb3e69",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8800d244575913abd48d44ce0f43a97768fb3e69",
      "tree": {
        "sha": "6b738f1eeeceb3fa6c62a4cbc8c3f22ef25b0fce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6b738f1eeeceb3fa6c62a4cbc8c3f22ef25b0fce"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de4a2f6107129ab53e6db380fb4ac13c7804ebba",
          "sha": "de4a2f6107129ab53e6db380fb4ac13c7804ebba",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/de4a2f6107129ab53e6db380fb4ac13c7804ebba"
        }
      ],
      "message": "clusterlin: add SearchCandidateFinder class\n\nSimilar to AncestorCandidateFinder, this encapsulates the state needed for\nfinding good candidate sets using a search algorithm.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:12:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-08T22:09:34Z"
      },
      "sha": "8800d244575913abd48d44ce0f43a97768fb3e69"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM3ZGFlMzgxYTYxNDZlMzNkZmVlYjk0ODY1OTBkOWFhZGI3ODJmZDQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37dae381a6146e33dfeeb9486590d9aadb782fd4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/37dae381a6146e33dfeeb9486590d9aadb782fd4",
      "tree": {
        "sha": "997533e7376f76341f35b5d03e752598ded3d198",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/997533e7376f76341f35b5d03e752598ded3d198"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8800d244575913abd48d44ce0f43a97768fb3e69",
          "sha": "8800d244575913abd48d44ce0f43a97768fb3e69",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8800d244575913abd48d44ce0f43a97768fb3e69"
        }
      ],
      "message": "clusterlin: add chunking algorithm\n\nA fuzz test is added which verifies various of its expected properties, including\ncorrectness",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:12:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-10T00:38:12Z"
      },
      "sha": "37dae381a6146e33dfeeb9486590d9aadb782fd4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkxNzA5ZmIwNTYxMzBmMzExMmRhYWIxNzdhYzE5ZjkwYjQ5NTRkMmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91709fb056130f3112daab177ac19f90b4954d2b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/91709fb056130f3112daab177ac19f90b4954d2b",
      "tree": {
        "sha": "0749d668a18a4328711bf7b1529700f6db89bfb8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0749d668a18a4328711bf7b1529700f6db89bfb8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37dae381a6146e33dfeeb9486590d9aadb782fd4",
          "sha": "37dae381a6146e33dfeeb9486590d9aadb782fd4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/37dae381a6146e33dfeeb9486590d9aadb782fd4"
        }
      ],
      "message": "clusterlin: add Linearize function\n\nThis adds a first version of the overall linearization interface, which given\na DepGraph constructs a good linearization, by incrementally including good\ncandidate sets (found using AncestorCandidateFinder and SearchCandidateFinder).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:12:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-08T21:28:39Z"
      },
      "sha": "91709fb056130f3112daab177ac19f90b4954d2b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI4ZDA5ZTdlNjA2ZDY0NTM2ZWM1YzAyMzVkNzc1NGM5Mzg4NGRlOTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/28d09e7e606d64536ec5c0235d7754c93884de95",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/28d09e7e606d64536ec5c0235d7754c93884de95",
      "tree": {
        "sha": "d90f81dcedfedd556e5622534a98750730a1a64a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d90f81dcedfedd556e5622534a98750730a1a64a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91709fb056130f3112daab177ac19f90b4954d2b",
          "sha": "91709fb056130f3112daab177ac19f90b4954d2b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/91709fb056130f3112daab177ac19f90b4954d2b"
        }
      ],
      "message": "bench: Candidate finding and linearization benchmarks\n\nAdd benchmarks for known bad graphs for the purpose of search (as\nan upper bound on work per search iterations) and ancestor sorting\n(as an upper bound on linearization work with no search iterations).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:12:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-16T01:09:31Z"
      },
      "sha": "28d09e7e606d64536ec5c0235d7754c93884de95"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMwYTc4ZDYzYmM2MjFlMmZkMDZjMjdiZjc3ZmMyMWUyYzhjZmZiNjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/30a78d63bc621e2fd06c27bf77fc21e2c8cffb69",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/30a78d63bc621e2fd06c27bf77fc21e2c8cffb69",
      "tree": {
        "sha": "376cef92eca27c4fb925c87084be443d3d1ad8d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/376cef92eca27c4fb925c87084be443d3d1ad8d9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/28d09e7e606d64536ec5c0235d7754c93884de95",
          "sha": "28d09e7e606d64536ec5c0235d7754c93884de95",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/28d09e7e606d64536ec5c0235d7754c93884de95"
        }
      ],
      "message": "clusterlin: use bounded BFS exploration (optimization)\n\nSwitch to BFS exploration of the search tree in SearchCandidateFinder\ninstead of DFS exploration. This appears to behave better for real\nworld clusters.\n\nAs BFS has the downside of needing far larger search queues, switch\nback to DFS temporarily when the queue grows too large.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:12:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-09T15:53:02Z"
      },
      "sha": "30a78d63bc621e2fd06c27bf77fc21e2c8cffb69"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFmNzFjYzRmMTIzZDU2MjYwOGQ2Y2I2NmFlYzM3Y2VmMTc4Y2EzOTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af71cc4f123d562608d6cb66aec37cef178ca398",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/af71cc4f123d562608d6cb66aec37cef178ca398",
      "tree": {
        "sha": "7745511a09ec8f1f4d48bf021caa546c87da454b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7745511a09ec8f1f4d48bf021caa546c87da454b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/30a78d63bc621e2fd06c27bf77fc21e2c8cffb69",
          "sha": "30a78d63bc621e2fd06c27bf77fc21e2c8cffb69",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/30a78d63bc621e2fd06c27bf77fc21e2c8cffb69"
        }
      ],
      "message": "clusterlin: randomize the SearchCandidateFinder search order\n\nTo make search non-deterministic, change the BFS logic from always picking\nthe first queue item to randomly picking the first or second queue item.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:12:19Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-10T01:41:52Z"
      },
      "sha": "af71cc4f123d562608d6cb66aec37cef178ca398"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13470969521,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMi7q6x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13470969521",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T12:24:05Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVjZDgwZDlhOTliMjQxMjE2MmY1MzM5NTJjNjU1ZjNmNDJlZjZmNjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ecd80d9a99b2412162f533952c655f3f42ef6f63",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ecd80d9a99b2412162f533952c655f3f42ef6f63",
      "tree": {
        "sha": "b41456b90e5af952d183e3c798c369e877f28e18",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b41456b90e5af952d183e3c798c369e877f28e18"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af71cc4f123d562608d6cb66aec37cef178ca398",
          "sha": "af71cc4f123d562608d6cb66aec37cef178ca398",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/af71cc4f123d562608d6cb66aec37cef178ca398"
        }
      ],
      "message": "clusterlin: add LinearizationChunking class\n\nIt encapsulates a given linearization in chunked form, permitting arbitrary\nsubsets of transactions to be removed from the linearization. Its purpose\nis Intersect function which it exposes, which is a crucial operation that will\nbe used in a further commit to make Linearize improve existing linearizations.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:35:54Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-10T15:08:42Z"
      },
      "sha": "ecd80d9a99b2412162f533952c655f3f42ef6f63"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGViMzVlMTdkZTVjNjA0M2NiM2JhMGY2MTQwYzY3OTBlZTQ0ZTA4NDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb35e17de5c6043cb3ba0f6140c6790ee44e0845",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/eb35e17de5c6043cb3ba0f6140c6790ee44e0845",
      "tree": {
        "sha": "b5faba70c96297e4f40c1596a43bff140fae4903",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5faba70c96297e4f40c1596a43bff140fae4903"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ecd80d9a99b2412162f533952c655f3f42ef6f63",
          "sha": "ecd80d9a99b2412162f533952c655f3f42ef6f63",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ecd80d9a99b2412162f533952c655f3f42ef6f63"
        }
      ],
      "message": "clusterlin: permit passing in existing linearization to Linearize\n\nThis implements the LIMO algorithm for linearizing by improving an existing\nlinearization. See\nhttps://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging\nfor details.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:36:28Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-09T13:02:18Z"
      },
      "sha": "eb35e17de5c6043cb3ba0f6140c6790ee44e0845"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk1OGEwMWVhMmJjMDcyYTkzZTEzOTdlMGI1YjdhNzY1OWY5N2JjODE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/958a01ea2bc072a93e1397e0b5b7a7659f97bc81",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/958a01ea2bc072a93e1397e0b5b7a7659f97bc81",
      "tree": {
        "sha": "73378f0654bb14842584f165b74c6996181b102e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/73378f0654bb14842584f165b74c6996181b102e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb35e17de5c6043cb3ba0f6140c6790ee44e0845",
          "sha": "eb35e17de5c6043cb3ba0f6140c6790ee44e0845",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/eb35e17de5c6043cb3ba0f6140c6790ee44e0845"
        }
      ],
      "message": "clusterlin: optimize rechunking in LinearizationChunking\n\nWhen the transactions being marked done exactly match the first chunk of\nwhat remains of the linearization, we can just remember to skip that\nchunk instead of computing a full rechunking.\n\nFurther, chop off prefixes of the input linearization that are already done,\nso they don't need to be reconsidered for further rechunkings.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:36:28Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-10T19:56:17Z"
      },
      "sha": "958a01ea2bc072a93e1397e0b5b7a7659f97bc81"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGEwMGMxY2EyNDA1Y2EwMTZjYjNiODA3ZTFiNWM0ZDc3NTllZmU0MjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "tree": {
        "sha": "b82f658a7c4e03e339751ace79d80bc8d0d349fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b82f658a7c4e03e339751ace79d80bc8d0d349fa"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/958a01ea2bc072a93e1397e0b5b7a7659f97bc81",
          "sha": "958a01ea2bc072a93e1397e0b5b7a7659f97bc81",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/958a01ea2bc072a93e1397e0b5b7a7659f97bc81"
        }
      ],
      "message": "clusterlin: add algorithms for connectedness/connected components\n\nAdd utility functions to DepGraph for finding connected components.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-11T12:36:28Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-15T12:37:12Z"
      },
      "sha": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13471126723,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMi8RTD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13471126723",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T12:36:40Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611851597",
      "pull_request_review_id": 2074233399,
      "id": 1611851597,
      "node_id": "PRRC_kwDOABII585gEudN",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+#ifdef _MSC_VER\n+#  include <intrin.h>",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 15,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "316e2044aad16e1ed8d024d3325bfcee8c04cd1f",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why is this needed?",
      "created_at": "2024-05-23T14:55:40Z",
      "updated_at": "2024-05-23T14:55:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1611851597",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611851597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611885584",
      "pull_request_review_id": 2074291321,
      "id": 1611885584,
      "node_id": "PRRC_kwDOABII585gE2wQ",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+#ifdef _MSC_VER\n+#  include <intrin.h>",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 15,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "316e2044aad16e1ed8d024d3325bfcee8c04cd1f",
      "in_reply_to_id": 1611851597,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Remnant of a long-lost pre-C++20 past. Gone.",
      "created_at": "2024-05-23T15:16:07Z",
      "updated_at": "2024-05-23T15:16:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1611885584",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611885584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613617080",
      "pull_request_review_id": 2077166958,
      "id": 1613617080,
      "node_id": "PRRC_kwDOABII585gLde4",
      "diff_hunk": "@@ -469,6 +485,56 @@ class SearchCandidateFinder\n     }\n };\n \n+/** Improve a linearization of a cluster.\n+ *\n+ * @param[in]     depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in,out] iteration_limit    On input, an upper bound on the number of optimization steps\n+ *                                   that will be performed in order to find a good linearization.\n+ *                                   On output the number will be reduced by the number of actually\n+ *                                   performed optimization steps. If that number is nonzero, the\n+ *                                   linearization is optimal.\n+ */\n+template<typename S>\n+std::vector<ClusterIndex> Linearize(const DepGraph<S>& depgraph, uint64_t& iteration_limit) noexcept\n+{\n+    auto todo = S::Fill(depgraph.TxCount());\n+    std::vector<ClusterIndex> linearization;\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    SearchCandidateFinder src_finder(depgraph);\n+    linearization.reserve(depgraph.TxCount());\n+    bool perfect = true;\n+\n+    while (todo.Any()) {\n+        // Initialize best to be either the best ancestor set.\n+        auto best = anc_finder.FindCandidateSet();\n+\n+        // Invoke bounded search to update best, with up to half of our remaining iterations as\n+        // limit.\n+        uint64_t iterations = (iteration_limit + 1) / 2;\n+        iteration_limit -= iterations;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 54,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "f6deff9f4c5dbb379fd4f099f17e09387de27efc",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in/out args for iterations is kinda spooky and made these few lines really hard to read, could `FindCandidateSet` just return a `std::pair` or similar?",
      "created_at": "2024-05-24T14:59:17Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1613617080",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613617080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 825,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622515654",
      "pull_request_review_id": 2077166958,
      "id": 1622515654,
      "node_id": "PRRC_kwDOABII585gtZ_G",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For this operator are `S ancestors` and `S descendants` ordered? Is it just compared via `m_val` for `BitSets`? Is ordering by these elements meaningful?",
      "created_at": "2024-05-31T14:31:45Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622515654",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622515654"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622564714",
      "pull_request_review_id": 2077166958,
      "id": 1622564714,
      "node_id": "PRRC_kwDOABII585gtl9q",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);",
      "path": "src/cluster_linearize.h",
      "position": 77,
      "original_position": 75,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it crashes once it hits `S::Singleton` if violated but maybe an earlier crash is more immediately informative\r\n```suggestion\r\n        Assume(ntx <= S::Size());\r\n        entries.resize(ntx);\r\n```",
      "created_at": "2024-05-31T15:04:38Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622564714",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622564714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 77,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622574793",
      "pull_request_review_id": 2077166958,
      "id": 1622574793,
      "node_id": "PRRC_kwDOABII585gtobJ",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 123,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "to avoid an OOB access regression\r\n```suggestion\r\n        Assert(mapping.size() == depgraph.TxCount());\r\n        // Fill in fee, size, ancestors.\r\n```",
      "created_at": "2024-05-31T15:13:10Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622574793",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622574793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622667577",
      "pull_request_review_id": 2077166958,
      "id": 1622667577,
      "node_id": "PRRC_kwDOABII585gt_E5",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 34,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "not super important but can we use a more descriptive typename since our use-case is pretty narrow? I'm mentally substituting `S` everywhere with `bitset` which is a fair mental leap and it's relatively difficult to grep for being so short.\r\n\r\n`S_bitset`? I don't know why the conventions are the way they are :sweat_smile: ",
      "created_at": "2024-05-31T16:16:35Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622667577",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622667577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626377280",
      "pull_request_review_id": 2077166958,
      "id": 1626377280,
      "node_id": "PRRC_kwDOABII585g8IxA",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            const auto& input = depgraph.entries[i];\n+            auto& output = entries[mapping[i]];\n+            output.feerate = input.feerate;\n+            for (auto j : input.ancestors) output.ancestors.Set(mapping[j]);\n+        }\n+        // Fill in descendant information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the mutable feerate of a given transaction i. Complexity: O(1). */\n+    FeeFrac& FeeRate(ClusterIndex i) noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const S& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const S& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, S::Singleton(new_idx), S::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const S& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Find some connected component within the subset \"left\" of this graph.\n+     *\n+     * Complexity: O(ret.Count()).\n+     */\n+    S FindConnectedComponent(const S& left) const noexcept\n+    {\n+        if (left.None()) return left;\n+        auto first = left.First();\n+        S ret = Descendants(first) | Ancestors(first);\n+        ret &= left;\n+        S to_add = ret;\n+        to_add.Reset(first);\n+        do {\n+            S old = ret;\n+            for (auto add : to_add) {\n+                ret |= Descendants(add);\n+                ret |= Ancestors(add);\n+            }\n+            ret &= left;\n+            to_add = ret - old;\n+        } while (to_add.Any());\n+        return ret;\n+    }\n+\n+    /** Determine if a subset is connected.\n+     *\n+     * Complexity: O(subset.Count()).\n+     */\n+    bool IsConnected(const S& subset) const noexcept\n+    {\n+        return FindConnectedComponent(subset) == subset;\n+    }\n+\n+    /** Determine if this entire graph is connected.\n+     *\n+     * Complexity: O(TxCount()).\n+     */\n+    bool IsConnected() const noexcept { return IsConnected(S::Fill(TxCount())); }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const S& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename S>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<S>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    S m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<S>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{S::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            S anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(S select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename S>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** m_sorted_to_original[i] is the original position that sorted transaction position i had. */\n+    std::vector<ClusterIndex> m_sorted_to_original;\n+    /** m_original_to_sorted[i] is the sorted position original transaction position i has. */\n+    std::vector<ClusterIndex> m_original_to_sorted;\n+    /** Internal dependency graph for the cluster (with transactions in decreasing individual\n+     *  feerate order). */\n+    DepGraph<S> m_depgraph;\n+    /** Which transactions are left to do (indices in m_depgraph's sorted order). */\n+    S m_todo;\n+\n+    static uint256 GetRNGKey(uint64_t rng_seed) noexcept\n+    {\n+        uint256 rng_key;\n+        WriteLE64(rng_key.data(), rng_seed);\n+        return rng_key;\n+    }\n+\n+    /** Given a set of transactions with sorted indices, get their original indices. */\n+    S SortedToOriginal(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_sorted_to_original[pos]);\n+        return ret;\n+    }\n+\n+    /** Given a set of transactions with original indices, get their sorted indices. */\n+    S OriginalToSorted(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_original_to_sorted[pos]);\n+        return ret;\n+    }\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.Count().\n+     */\n+    SearchCandidateFinder(const DepGraph<S>& depgraph, uint64_t rng_seed) noexcept :\n+        m_rng(GetRNGKey(rng_seed)),\n+        m_sorted_to_original(depgraph.TxCount()),\n+        m_original_to_sorted(depgraph.TxCount())\n+    {\n+        // Determine reordering mapping, by sorting by decreasing feerate.\n+        std::iota(m_sorted_to_original.begin(), m_sorted_to_original.end(), ClusterIndex{0});\n+        std::sort(m_sorted_to_original.begin(), m_sorted_to_original.end(), [&](auto a, auto b) {\n+            auto feerate_cmp = depgraph.FeeRate(a) <=> depgraph.FeeRate(b);\n+            if (feerate_cmp == 0) return a < b;\n+            return feerate_cmp > 0;\n+        });\n+        // Compute reverse mapping.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            m_original_to_sorted[m_sorted_to_original[i]] = i;\n+        }\n+        // Compute reordered dependency graph.\n+        m_depgraph = DepGraph(depgraph, m_original_to_sorted);\n+        // Set todo to the entire graph.\n+        m_todo = S::Fill(depgraph.TxCount());\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in,out] iterations_left    On input, an upper bound on the number of optimization\n+     *                                   steps that can be performed. On output, that number is\n+     *                                   reduced by the number of actually performed optimization\n+     *                                   steps.\n+     * @param[in] best                   A set/feerate pair with an already-known good candidate.\n+     *                                   This can be empty.\n+     * @return                           The best (highest feerate, smallest size as tiebreaker)\n+     *                                   topologically-valid subset of what remains of the cluster\n+     *                                   that was encountered during search. If iterations_left is\n+     *                                   nonzero on output, it is the absolute best such subset. If\n+     *                                   not, the feerate of the returned set will be at least as\n+     *                                   good as the best passed in.\n+     *\n+     * Complexity: possibly O(N * min(iterations_left, sqrt(2^N))) where N=depgraph.TxCount().\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet(uint64_t& iterations_left, std::pair<S, FeeFrac> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        if (best.second.IsEmpty()) {\n+            // Set best to the entire remainder if not provided.\n+            best.first = m_todo;\n+            best.second = m_depgraph.FeeRate(m_todo);\n+        } else {\n+            // Otherwise convert to internal sorted indices.\n+            best.first = OriginalToSorted(best.first);\n+        }\n+        Assume(!best.second.IsEmpty());\n+        Assume(best.first.Any());\n+        Assume(best.first.IsSubsetOf(m_todo));\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included. This must be a subset of m_todo, and be\n+             *  topologically valid (includes all in-m_todo ancestors of itself). */\n+            S inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            S und;\n+            /** (Only when inc is not empty) The subset with the best feerate of any superset of\n+             *  inc that is also a subset of (inc | und), without requiring it to be topologically\n+             *  valid. If the real best such feerate does not exceed best.second, then this value\n+             *  is not guaranteed to be accurate. */\n+            S pot;\n+            /** Equal to m_depgraph.FeeRate(inc). */\n+            FeeFrac inc_feerate;\n+            /** Equal to m_depgraph.FeeRate(pot). It forms a conservative upper bound on how good\n+             *  a set this work item can give rise to, unless that's known to be below best.second.\n+             */\n+            FeeFrac pot_feerate;\n+            /** Construct a new work item. */\n+            WorkItem(S&& i, S&& u, S&& p, FeeFrac&& i_f, FeeFrac&& p_f) noexcept :\n+                inc(std::move(i)), und(std::move(u)), pot(std::move(p)),\n+                inc_feerate(std::move(i_f)), pot_feerate(std::move(p_f)) {}\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+                swap(pot, other.pot);\n+                swap(inc_feerate, other.inc_feerate);\n+                swap(pot_feerate, other.pot_feerate);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        /** The set of transactions in m_todo which have feerate > best_feerate. */\n+        S imp = m_todo;\n+        while (imp.Any()) {\n+            ClusterIndex check = imp.Last();\n+            if (m_depgraph.FeeRate(check) >> best.second) break;\n+            imp.Reset(check);\n+        }\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iteration_limit = iterations_left;\n+\n+        /** Internal function to add a work item, possibly improving it before doing so.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         * - pot: a subset of the \"pot\" value for the new work item (but a superset of inc).\n+         *        It does not need to be the full pot value; missing pot transactions will be added\n+         *        to it by add_fn.\n+         * - inc_feerate: equal to m_depgraph.FeeRate(inc)\n+         * - pot_feerate: equal to m_depgraph.FeeRate(pot)\n+         * - grow_inc: whether to attempt moving transactions from und to inc, if it can be proven\n+         *             that they must be a part of the best topologically valid superset of inc and\n+         *             subset of (inc | und). Transactions that are missing from pot are always\n+         *             considered, regardless of grow_inc. It only makes sense to enable this if\n+         *             transactions were added to inc.\n+         */\n+        auto add_fn = [&](S inc, S und, S pot, FeeFrac inc_feerate, FeeFrac pot_feerate, bool grow_inc) noexcept {\n+            Assume(inc.IsSubsetOf(m_todo));\n+            Assume(und.IsSubsetOf(m_todo));\n+            Assume(!inc.Overlaps(und));\n+            Assume(pot.IsSupersetOf(inc));\n+            Assume(pot.IsSubsetOf(inc | und));\n+            Assume(pot.None() == inc.None());\n+\n+            if (!inc_feerate.IsEmpty()) {\n+                /** Which transactions to consider adding to inc. */\n+                S consider_inc = grow_inc ? pot - inc : S{};\n+                // Add entries to pot (and pot_feerate). We iterate over all undecided transactions\n+                // whose feerate is higher than best_feerate, and aren't already part of pot. While\n+                // undecided transactions of lower feerate may improve pot still, if they do, the\n+                // resulting pot_feerate cannot possibly exceed best.second (resulting in the item\n+                // being skipped in split_fn).\n+                for (auto pos : (imp & und) - pot) {\n+                    // Determine if adding transaction pos to pot (ignoring topology) would improve it. If\n+                    // not, we're done updating pot. This relies on the fact that m_depgraph, and\n+                    // thus the set iterated over, is in decreasing individual feerate order.\n+                    if (!(m_depgraph.FeeRate(pos) >> pot_feerate)) break;\n+                    pot_feerate += m_depgraph.FeeRate(pos);\n+                    pot.Set(pos);\n+                    consider_inc.Set(pos);\n+                }\n+\n+                // The \"jump ahead\" optimization: whenever pot has a topologically-valid subset,\n+                // that subset can be added to inc. Any subset of (pot - inc) has the property that\n+                // its feerate exceeds that of any set compatible with this work item (superset of\n+                // inc, subset of (inc | und)). Thus, if T is a topological subset of pot, and B is\n+                // the best topologically-valid set compatible with this work item, and (T - B) is\n+                // non-empty, then (T | B) is better than B and also topological. This is in\n+                // contradiction with the assumption that B is best. Thus, (T - B) must be empty,\n+                // or T must be a subset of B.\n+                //\n+                // See https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303 section 2.4.\n+                const S init_inc = inc;\n+                for (auto pos : consider_inc) {\n+                    // If the transaction's ancestors are a subset of pot, we can add it together\n+                    // with its ancestors to inc.\n+                    auto anc_todo = m_depgraph.Ancestors(pos) & m_todo;\n+                    if (anc_todo.IsSubsetOf(pot)) inc |= anc_todo;\n+                }\n+                // Finally update und and inc_feerate to account for the added transactions.\n+                und -= inc;\n+                inc_feerate += m_depgraph.FeeRate(inc - init_inc);\n+\n+                // If inc_feerate is better than best_feerate, remember inc as our new best.\n+                if (inc_feerate > best.second) {\n+                    best = {inc, inc_feerate};\n+                    // See if we can remove any entries from imp now.\n+                    while (imp.Any()) {\n+                        ClusterIndex check = imp.Last();\n+                        if (m_depgraph.FeeRate(check) >> best.second) break;\n+                        imp.Reset(check);\n+                    }\n+                }\n+\n+                // If no potential transactions exist beyond the already included ones, no improvement\n+                // is possible anymore.\n+                if (pot == inc) return;\n+                // At this point und must be non-empty. If it were empty then pot would equal inc.\n+                Assume(und.Any());\n+            } else {\n+                // If inc is empty, we just make sure there are undecided transactions left to\n+                // split on.\n+                if (und.None()) return;\n+            }\n+\n+            // Actually construct new work item on the queue.\n+            Assume(queue.size() < queue.capacity());",
      "path": "src/cluster_linearize.h",
      "position": 634,
      "original_position": 558,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "is this for ensuring no allocations are going to take place? How do we know this?",
      "created_at": "2024-06-04T17:29:25Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1626377280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626377280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 634,
      "original_line": 634,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631584746",
      "pull_request_review_id": 2105193198,
      "id": 1631584746,
      "node_id": "PRRC_kwDOABII585hQAHq",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 34,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622667577,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've renamed it to `SetType` everywhere. While it's expected to be instantiated with `BitSet`, that's not a necessity, and I expect that for certain temporarily-very-large clusters in TxGraph we'll need some algorithms instantiated by another type (something using an `std::set` or a sorted vector, for example).",
      "created_at": "2024-06-07T18:54:41Z",
      "updated_at": "2024-06-07T18:54:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1631584746",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631584746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631724039",
      "pull_request_review_id": 2105418287,
      "id": 1631724039,
      "node_id": "PRRC_kwDOABII585hQiIH",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622515654,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think any attempt to invoke this comparison operator would just have failed, as `BitSet` doesn't have an `operator<=>` (it did at some point, but I had dropped it). I've just removed the operator here too.",
      "created_at": "2024-06-07T21:41:58Z",
      "updated_at": "2024-06-07T21:41:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1631724039",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631724039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102449",
      "pull_request_review_id": 2114235927,
      "id": 1637102449,
      "node_id": "PRRC_kwDOABII585hlDNx",
      "diff_hunk": "@@ -469,6 +485,56 @@ class SearchCandidateFinder\n     }\n };\n \n+/** Improve a linearization of a cluster.\n+ *\n+ * @param[in]     depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in,out] iteration_limit    On input, an upper bound on the number of optimization steps\n+ *                                   that will be performed in order to find a good linearization.\n+ *                                   On output the number will be reduced by the number of actually\n+ *                                   performed optimization steps. If that number is nonzero, the\n+ *                                   linearization is optimal.\n+ */\n+template<typename S>\n+std::vector<ClusterIndex> Linearize(const DepGraph<S>& depgraph, uint64_t& iteration_limit) noexcept\n+{\n+    auto todo = S::Fill(depgraph.TxCount());\n+    std::vector<ClusterIndex> linearization;\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    SearchCandidateFinder src_finder(depgraph);\n+    linearization.reserve(depgraph.TxCount());\n+    bool perfect = true;\n+\n+    while (todo.Any()) {\n+        // Initialize best to be either the best ancestor set.\n+        auto best = anc_finder.FindCandidateSet();\n+\n+        // Invoke bounded search to update best, with up to half of our remaining iterations as\n+        // limit.\n+        uint64_t iterations = (iteration_limit + 1) / 2;\n+        iteration_limit -= iterations;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 54,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "f6deff9f4c5dbb379fd4f099f17e09387de27efc",
      "in_reply_to_id": 1613617080,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. I've encapsulated the `std::pair<SetType, FeeFrac>` for representing sets with their feerates into a new `SetInfo<SetType>` type, and changed the return type of candidate finders which count iterations to be `std::pair<SetInfo<SetType>, uint64_t>`, representing the found candidate and the number of performed iterations. I've also changed the Linearization functions to just return a `bool optimal`, rather than an iteration count (as it wasn't used anywhere anyway).",
      "created_at": "2024-06-12T21:16:57Z",
      "updated_at": "2024-06-12T21:16:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637102449",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102449"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 825,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102621",
      "pull_request_review_id": 2114236128,
      "id": 1637102621,
      "node_id": "PRRC_kwDOABII585hlDQd",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);",
      "path": "src/cluster_linearize.h",
      "position": 77,
      "original_position": 75,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622564714,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-12T21:17:06Z",
      "updated_at": "2024-06-12T21:17:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637102621",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102621"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 77,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102708",
      "pull_request_review_id": 2114236246,
      "id": 1637102708,
      "node_id": "PRRC_kwDOABII585hlDR0",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 123,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622574793,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-12T21:17:11Z",
      "updated_at": "2024-06-12T21:17:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637102708",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637103088",
      "pull_request_review_id": 2114236678,
      "id": 1637103088,
      "node_id": "PRRC_kwDOABII585hlDXw",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            const auto& input = depgraph.entries[i];\n+            auto& output = entries[mapping[i]];\n+            output.feerate = input.feerate;\n+            for (auto j : input.ancestors) output.ancestors.Set(mapping[j]);\n+        }\n+        // Fill in descendant information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the mutable feerate of a given transaction i. Complexity: O(1). */\n+    FeeFrac& FeeRate(ClusterIndex i) noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const S& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const S& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, S::Singleton(new_idx), S::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const S& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Find some connected component within the subset \"left\" of this graph.\n+     *\n+     * Complexity: O(ret.Count()).\n+     */\n+    S FindConnectedComponent(const S& left) const noexcept\n+    {\n+        if (left.None()) return left;\n+        auto first = left.First();\n+        S ret = Descendants(first) | Ancestors(first);\n+        ret &= left;\n+        S to_add = ret;\n+        to_add.Reset(first);\n+        do {\n+            S old = ret;\n+            for (auto add : to_add) {\n+                ret |= Descendants(add);\n+                ret |= Ancestors(add);\n+            }\n+            ret &= left;\n+            to_add = ret - old;\n+        } while (to_add.Any());\n+        return ret;\n+    }\n+\n+    /** Determine if a subset is connected.\n+     *\n+     * Complexity: O(subset.Count()).\n+     */\n+    bool IsConnected(const S& subset) const noexcept\n+    {\n+        return FindConnectedComponent(subset) == subset;\n+    }\n+\n+    /** Determine if this entire graph is connected.\n+     *\n+     * Complexity: O(TxCount()).\n+     */\n+    bool IsConnected() const noexcept { return IsConnected(S::Fill(TxCount())); }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const S& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename S>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<S>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    S m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<S>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{S::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            S anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(S select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename S>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** m_sorted_to_original[i] is the original position that sorted transaction position i had. */\n+    std::vector<ClusterIndex> m_sorted_to_original;\n+    /** m_original_to_sorted[i] is the sorted position original transaction position i has. */\n+    std::vector<ClusterIndex> m_original_to_sorted;\n+    /** Internal dependency graph for the cluster (with transactions in decreasing individual\n+     *  feerate order). */\n+    DepGraph<S> m_depgraph;\n+    /** Which transactions are left to do (indices in m_depgraph's sorted order). */\n+    S m_todo;\n+\n+    static uint256 GetRNGKey(uint64_t rng_seed) noexcept\n+    {\n+        uint256 rng_key;\n+        WriteLE64(rng_key.data(), rng_seed);\n+        return rng_key;\n+    }\n+\n+    /** Given a set of transactions with sorted indices, get their original indices. */\n+    S SortedToOriginal(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_sorted_to_original[pos]);\n+        return ret;\n+    }\n+\n+    /** Given a set of transactions with original indices, get their sorted indices. */\n+    S OriginalToSorted(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_original_to_sorted[pos]);\n+        return ret;\n+    }\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.Count().\n+     */\n+    SearchCandidateFinder(const DepGraph<S>& depgraph, uint64_t rng_seed) noexcept :\n+        m_rng(GetRNGKey(rng_seed)),\n+        m_sorted_to_original(depgraph.TxCount()),\n+        m_original_to_sorted(depgraph.TxCount())\n+    {\n+        // Determine reordering mapping, by sorting by decreasing feerate.\n+        std::iota(m_sorted_to_original.begin(), m_sorted_to_original.end(), ClusterIndex{0});\n+        std::sort(m_sorted_to_original.begin(), m_sorted_to_original.end(), [&](auto a, auto b) {\n+            auto feerate_cmp = depgraph.FeeRate(a) <=> depgraph.FeeRate(b);\n+            if (feerate_cmp == 0) return a < b;\n+            return feerate_cmp > 0;\n+        });\n+        // Compute reverse mapping.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            m_original_to_sorted[m_sorted_to_original[i]] = i;\n+        }\n+        // Compute reordered dependency graph.\n+        m_depgraph = DepGraph(depgraph, m_original_to_sorted);\n+        // Set todo to the entire graph.\n+        m_todo = S::Fill(depgraph.TxCount());\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in,out] iterations_left    On input, an upper bound on the number of optimization\n+     *                                   steps that can be performed. On output, that number is\n+     *                                   reduced by the number of actually performed optimization\n+     *                                   steps.\n+     * @param[in] best                   A set/feerate pair with an already-known good candidate.\n+     *                                   This can be empty.\n+     * @return                           The best (highest feerate, smallest size as tiebreaker)\n+     *                                   topologically-valid subset of what remains of the cluster\n+     *                                   that was encountered during search. If iterations_left is\n+     *                                   nonzero on output, it is the absolute best such subset. If\n+     *                                   not, the feerate of the returned set will be at least as\n+     *                                   good as the best passed in.\n+     *\n+     * Complexity: possibly O(N * min(iterations_left, sqrt(2^N))) where N=depgraph.TxCount().\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet(uint64_t& iterations_left, std::pair<S, FeeFrac> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        if (best.second.IsEmpty()) {\n+            // Set best to the entire remainder if not provided.\n+            best.first = m_todo;\n+            best.second = m_depgraph.FeeRate(m_todo);\n+        } else {\n+            // Otherwise convert to internal sorted indices.\n+            best.first = OriginalToSorted(best.first);\n+        }\n+        Assume(!best.second.IsEmpty());\n+        Assume(best.first.Any());\n+        Assume(best.first.IsSubsetOf(m_todo));\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included. This must be a subset of m_todo, and be\n+             *  topologically valid (includes all in-m_todo ancestors of itself). */\n+            S inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            S und;\n+            /** (Only when inc is not empty) The subset with the best feerate of any superset of\n+             *  inc that is also a subset of (inc | und), without requiring it to be topologically\n+             *  valid. If the real best such feerate does not exceed best.second, then this value\n+             *  is not guaranteed to be accurate. */\n+            S pot;\n+            /** Equal to m_depgraph.FeeRate(inc). */\n+            FeeFrac inc_feerate;\n+            /** Equal to m_depgraph.FeeRate(pot). It forms a conservative upper bound on how good\n+             *  a set this work item can give rise to, unless that's known to be below best.second.\n+             */\n+            FeeFrac pot_feerate;\n+            /** Construct a new work item. */\n+            WorkItem(S&& i, S&& u, S&& p, FeeFrac&& i_f, FeeFrac&& p_f) noexcept :\n+                inc(std::move(i)), und(std::move(u)), pot(std::move(p)),\n+                inc_feerate(std::move(i_f)), pot_feerate(std::move(p_f)) {}\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+                swap(pot, other.pot);\n+                swap(inc_feerate, other.inc_feerate);\n+                swap(pot_feerate, other.pot_feerate);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        /** The set of transactions in m_todo which have feerate > best_feerate. */\n+        S imp = m_todo;\n+        while (imp.Any()) {\n+            ClusterIndex check = imp.Last();\n+            if (m_depgraph.FeeRate(check) >> best.second) break;\n+            imp.Reset(check);\n+        }\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iteration_limit = iterations_left;\n+\n+        /** Internal function to add a work item, possibly improving it before doing so.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         * - pot: a subset of the \"pot\" value for the new work item (but a superset of inc).\n+         *        It does not need to be the full pot value; missing pot transactions will be added\n+         *        to it by add_fn.\n+         * - inc_feerate: equal to m_depgraph.FeeRate(inc)\n+         * - pot_feerate: equal to m_depgraph.FeeRate(pot)\n+         * - grow_inc: whether to attempt moving transactions from und to inc, if it can be proven\n+         *             that they must be a part of the best topologically valid superset of inc and\n+         *             subset of (inc | und). Transactions that are missing from pot are always\n+         *             considered, regardless of grow_inc. It only makes sense to enable this if\n+         *             transactions were added to inc.\n+         */\n+        auto add_fn = [&](S inc, S und, S pot, FeeFrac inc_feerate, FeeFrac pot_feerate, bool grow_inc) noexcept {\n+            Assume(inc.IsSubsetOf(m_todo));\n+            Assume(und.IsSubsetOf(m_todo));\n+            Assume(!inc.Overlaps(und));\n+            Assume(pot.IsSupersetOf(inc));\n+            Assume(pot.IsSubsetOf(inc | und));\n+            Assume(pot.None() == inc.None());\n+\n+            if (!inc_feerate.IsEmpty()) {\n+                /** Which transactions to consider adding to inc. */\n+                S consider_inc = grow_inc ? pot - inc : S{};\n+                // Add entries to pot (and pot_feerate). We iterate over all undecided transactions\n+                // whose feerate is higher than best_feerate, and aren't already part of pot. While\n+                // undecided transactions of lower feerate may improve pot still, if they do, the\n+                // resulting pot_feerate cannot possibly exceed best.second (resulting in the item\n+                // being skipped in split_fn).\n+                for (auto pos : (imp & und) - pot) {\n+                    // Determine if adding transaction pos to pot (ignoring topology) would improve it. If\n+                    // not, we're done updating pot. This relies on the fact that m_depgraph, and\n+                    // thus the set iterated over, is in decreasing individual feerate order.\n+                    if (!(m_depgraph.FeeRate(pos) >> pot_feerate)) break;\n+                    pot_feerate += m_depgraph.FeeRate(pos);\n+                    pot.Set(pos);\n+                    consider_inc.Set(pos);\n+                }\n+\n+                // The \"jump ahead\" optimization: whenever pot has a topologically-valid subset,\n+                // that subset can be added to inc. Any subset of (pot - inc) has the property that\n+                // its feerate exceeds that of any set compatible with this work item (superset of\n+                // inc, subset of (inc | und)). Thus, if T is a topological subset of pot, and B is\n+                // the best topologically-valid set compatible with this work item, and (T - B) is\n+                // non-empty, then (T | B) is better than B and also topological. This is in\n+                // contradiction with the assumption that B is best. Thus, (T - B) must be empty,\n+                // or T must be a subset of B.\n+                //\n+                // See https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303 section 2.4.\n+                const S init_inc = inc;\n+                for (auto pos : consider_inc) {\n+                    // If the transaction's ancestors are a subset of pot, we can add it together\n+                    // with its ancestors to inc.\n+                    auto anc_todo = m_depgraph.Ancestors(pos) & m_todo;\n+                    if (anc_todo.IsSubsetOf(pot)) inc |= anc_todo;\n+                }\n+                // Finally update und and inc_feerate to account for the added transactions.\n+                und -= inc;\n+                inc_feerate += m_depgraph.FeeRate(inc - init_inc);\n+\n+                // If inc_feerate is better than best_feerate, remember inc as our new best.\n+                if (inc_feerate > best.second) {\n+                    best = {inc, inc_feerate};\n+                    // See if we can remove any entries from imp now.\n+                    while (imp.Any()) {\n+                        ClusterIndex check = imp.Last();\n+                        if (m_depgraph.FeeRate(check) >> best.second) break;\n+                        imp.Reset(check);\n+                    }\n+                }\n+\n+                // If no potential transactions exist beyond the already included ones, no improvement\n+                // is possible anymore.\n+                if (pot == inc) return;\n+                // At this point und must be non-empty. If it were empty then pot would equal inc.\n+                Assume(und.Any());\n+            } else {\n+                // If inc is empty, we just make sure there are undecided transactions left to\n+                // split on.\n+                if (und.None()) return;\n+            }\n+\n+            // Actually construct new work item on the queue.\n+            Assume(queue.size() < queue.capacity());",
      "path": "src/cluster_linearize.h",
      "position": 634,
      "original_position": 558,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1626377280,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed. I've added a comment. LMK whether it's clearer now.",
      "created_at": "2024-06-12T21:17:31Z",
      "updated_at": "2024-06-12T21:17:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637103088",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637103088"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 634,
      "original_line": 634,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638438741",
      "pull_request_review_id": 2116172410,
      "id": 1638438741,
      "node_id": "PRRC_kwDOABII585hqJdV",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 266,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`Cluster<TestBitSet> cluster(num_tx, std::make_pair(FeeFrac{0, 1}, TestBitSet()));` should work?",
      "created_at": "2024-06-13T15:43:33Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638438741",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638438741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638450101",
      "pull_request_review_id": 2116172410,
      "id": 1638450101,
      "node_id": "PRRC_kwDOABII585hqMO1",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 270,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    // Read (parent, child) pairs, and add them to the cluster and depgraph.\r\n```",
      "created_at": "2024-06-13T15:51:50Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638450101",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638450101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638465834",
      "pull_request_review_id": 2116172410,
      "id": 1638465834,
      "node_id": "PRRC_kwDOABII585hqQEq",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 147,
      "original_position": 141,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we `Assume()`/short-circuit if `parent == child`",
      "created_at": "2024-06-13T16:00:24Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638465834",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638465834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638472774",
      "pull_request_review_id": 2116172410,
      "id": 1638472774,
      "node_id": "PRRC_kwDOABII585hqRxG",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 126,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Where does the amortization come in?",
      "created_at": "2024-06-13T16:03:29Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638472774",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638472774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638488625",
      "pull_request_review_id": 2116172410,
      "id": 1638488625,
      "node_id": "PRRC_kwDOABII585hqVox",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 271,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    LIMITED_WHILE(provider.remaining_bytes() > 0, TestBitSet::Size() * TestBitSet::Size()) {\r\n```",
      "created_at": "2024-06-13T16:15:47Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638488625",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638488625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 530,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1639799588",
      "pull_request_review_id": 2118340933,
      "id": 1639799588,
      "node_id": "PRRC_kwDOABII585hvVsk",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 88,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In the docs, maybe instead of \"best remaining ancestor set\", say \"highest feerate ancestor set\" ?\r\n\r\nSide note - I was thinking that this was a replica of the ancestor set algo in `BlockAssembler` but this isn't the minimum of individual and ancestor feerate.",
      "created_at": "2024-06-14T13:06:16Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1639799588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1639799588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 339,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177227",
      "pull_request_review_id": 2116172410,
      "id": 1640177227,
      "node_id": "PRRC_kwDOABII585hwx5L",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could leave an assert to this effect right after this",
      "created_at": "2024-06-14T18:00:33Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1640177227",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177309",
      "pull_request_review_id": 2116172410,
      "id": 1640177309,
      "node_id": "PRRC_kwDOABII585hwx6d",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 159,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could leave an assert to this effect right after this",
      "created_at": "2024-06-14T18:00:38Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1640177309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644451932",
      "pull_request_review_id": 2118340933,
      "id": 1644451932,
      "node_id": "PRRC_kwDOABII585iBFhc",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 116,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe mention that caller must ensure inc includes `Ancestors(inc)`",
      "created_at": "2024-06-18T13:17:17Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644451932",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644451932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644863011",
      "pull_request_review_id": 2116172410,
      "id": 1644863011,
      "node_id": "PRRC_kwDOABII585iCp4j",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];",
      "path": "src/cluster_linearize.h",
      "position": 456,
      "original_position": 61,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n                Assume(!m_ancestor_set_feerates[first].IsEmpty());\r\n                anc_feerate = m_ancestor_set_feerates[first];\r\n```",
      "created_at": "2024-06-18T18:04:46Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644863011",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644863011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 456,
      "original_line": 456,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644905104",
      "pull_request_review_id": 2116172410,
      "id": 1644905104,
      "node_id": "PRRC_kwDOABII585iC0KQ",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {",
      "path": "src/cluster_linearize.h",
      "position": 507,
      "original_position": 96,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "belt and suspenders nit prior to a comparison\r\n```Suggestion\r\n            if (best.has_value()) {\r\n                Assume(!m_ancestor_set_feerates[i].IsEmpty());\r\n```",
      "created_at": "2024-06-18T18:46:31Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644905104",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644905104"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 507,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644945090",
      "pull_request_review_id": 2116172410,
      "id": 1644945090,
      "node_id": "PRRC_kwDOABII585iC97C",
      "diff_hunk": "@@ -346,3 +364,49 @@ FUZZ_TARGET(clusterlin_depgraph_serialization)\n     // Verify the graph is a DAG.\n     assert(IsAcyclic(depgraph));\n }\n+\n+FUZZ_TARGET(clusterlin_ancestor_finder)\n+{\n+    // Verify that AncestorCandidateFinder works as expected.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // Call the ancestor finder's FindCandidateSet for what remains of the graph.\n+        auto best_anc = anc_finder.FindCandidateSet();\n+        // Sanity check the result.\n+        assert(best_anc.transactions.Any());\n+        assert(best_anc.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(best_anc.transactions) == best_anc.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : best_anc.transactions) {\n+            assert((depgraph.Ancestors(i) & todo).IsSubsetOf(best_anc.transactions));\n+        }\n+\n+        // Compute all remaining ancestor sets.\n+        std::optional<SetInfo<TestBitSet>> real_best_anc;\n+        for (auto i : todo) {\n+            SetInfo info(depgraph, todo & depgraph.Ancestors(i));\n+            if (!real_best_anc.has_value() || info.feerate > real_best_anc->feerate) {\n+                real_best_anc = info;\n+            }\n+        }\n+        // The set returned by anc_finder must equal the real best ancestor sets.\n+        assert(real_best_anc.has_value());\n+        assert(*real_best_anc == best_anc);\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use best_anc itself, because we should remove something.\n+        if (del_set.None()) del_set = best_anc.transactions;\n+        todo -= del_set;\n+        anc_finder.MarkDone(del_set);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 430,
      "original_position": 72,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it'd be worth it to have `del_set` be sometimes overcomplete, including random subsets of `~todo` which should be handled internally by being dropped. Alternatively it could be disallowed via `Assume()`?",
      "created_at": "2024-06-18T19:26:19Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644945090",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644945090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 430,
      "original_line": 430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644952136",
      "pull_request_review_id": 2116172410,
      "id": 1644952136,
      "node_id": "PRRC_kwDOABII585iC_pI",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A top-level description of what this is useful for would be appreciated.",
      "created_at": "2024-06-18T19:33:51Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644952136",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644952136"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644963760",
      "pull_request_review_id": 2116172410,
      "id": 1644963760,
      "node_id": "PRRC_kwDOABII585iDCew",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.\n+            if (todo.Count() <= 12) {\n+                auto exhaustive = exh_finder.FindCandidateSet();\n+                assert(exhaustive.feerate == found.feerate);\n+                // Also compare ExhaustiveCandidateFinder with SimpleCandidateFinder (this is more\n+                // a test for SimpleCandidateFinder's correctness).\n+                assert(exhaustive.feerate >= simple.feerate);\n+                if (simple_iters < 0x3ffff) assert(exhaustive.feerate == simple.feerate);\n+            }\n+        }\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use found_set itself, because we should remove something.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 185,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`found_set` doesn't exist",
      "created_at": "2024-06-18T19:45:42Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644963760",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644963760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966180",
      "pull_request_review_id": 2116172410,
      "id": 1644966180,
      "node_id": "PRRC_kwDOABII585iDDEk",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "SimpleCandidateFinder",
      "created_at": "2024-06-18T19:48:05Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644966180",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966317",
      "pull_request_review_id": 2116172410,
      "id": 1644966317,
      "node_id": "PRRC_kwDOABII585iDDGt",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ExhaustiveCandidateFinder",
      "created_at": "2024-06-18T19:48:15Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644966317",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966317"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644982295",
      "pull_request_review_id": 2116172410,
      "id": 1644982295,
      "node_id": "PRRC_kwDOABII585iDHAX",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 164,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "please consti-fy `0x3ffff` since it's use 3x",
      "created_at": "2024-06-18T20:00:54Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644982295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644982295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649155445",
      "pull_request_review_id": 2116172410,
      "id": 1649155445,
      "node_id": "PRRC_kwDOABII585iTB11",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "useful note in code would be this is the only critical check to ensure fuzzer doesn't generate a cyclical graph, and the other checks are optimizations? ",
      "created_at": "2024-06-21T15:59:58Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649155445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649155445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649205112",
      "pull_request_review_id": 2116172410,
      "id": 1649205112,
      "node_id": "PRRC_kwDOABII585iTN94",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I can't make an example that causes this clause to fail which hinders my understanding of what it's doing.\r\n\r\nThis is where having static unit test for this case firing would be helpful to step through.",
      "created_at": "2024-06-21T16:46:08Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649205112",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649205112"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649232974",
      "pull_request_review_id": 2116172410,
      "id": 1649232974,
      "node_id": "PRRC_kwDOABII585iTUxO",
      "diff_hunk": "@@ -452,3 +552,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If we're checking against exhaustive we can avoid using the other finders?",
      "created_at": "2024-06-21T17:10:41Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649232974",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649232974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 446,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649259334",
      "pull_request_review_id": 2116172410,
      "id": 1649259334,
      "node_id": "PRRC_kwDOABII585iTbNG",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 86,
      "original_position": 100,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "double-checking: In this and other candidate set finders it seems like `max_iterations - iterations_left` could be zero even if it was optimal on the very last step?",
      "created_at": "2024-06-21T17:36:53Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649259334",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649259334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649287854",
      "pull_request_review_id": 2116172410,
      "id": 1649287854,
      "node_id": "PRRC_kwDOABII585iTiKu",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 84,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this needs coverage or should be disallowed entirely",
      "created_at": "2024-06-21T18:08:55Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649287854",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649287854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 398,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649300280",
      "pull_request_review_id": 2116172410,
      "id": 1649300280,
      "node_id": "PRRC_kwDOABII585iTlM4",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can we call this split rather than pivot since it only occurs here in the codebase?",
      "created_at": "2024-06-21T18:22:57Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649300280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649300280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649308286",
      "pull_request_review_id": 2116172410,
      "id": 1649308286,
      "node_id": "PRRC_kwDOABII585iTnJ-",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         */\n+        auto add_fn = [&](SetInfo<SetType> inc, SetType und) noexcept {\n+            if (!inc.feerate.IsEmpty()) {\n+                // If inc's feerate is better than best's, remember it as our new best.\n+                if (inc.feerate > best.feerate) {\n+                    best = inc;\n+                }\n+            }",
      "path": "src/cluster_linearize.h",
      "position": 626,
      "original_position": 125,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n            } else {\r\n                Assume(inc.transactions.None())\r\n            }\r\n```",
      "created_at": "2024-06-21T18:32:10Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649308286",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649308286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 626,
      "original_line": 626,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649373379",
      "pull_request_review_id": 2116172410,
      "id": 1649373379,
      "node_id": "PRRC_kwDOABII585iT3DD",
      "diff_hunk": "@@ -635,3 +688,68 @@ FUZZ_TARGET(clusterlin_search_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_linearize)\n+{\n+    // Verify the behavior of Linearize().\n+\n+    // Retrieve an iteration count, and a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    uint64_t iter_count{0};\n+    try {\n+        reader >> VARINT(iter_count) >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Invoke Linearize().\n+    iter_count &= 0x7ffff;\n+    auto [linearization, optimal] = Linearize(depgraph, iter_count);\n+    SanityCheck(depgraph, linearization);\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+\n+    // If the iteration count is sufficiently high, an optimal linearization must be found.\n+    // Each linearization step can use up to 2^k iterations, with steps k=1..n. That sum is\n+    // 2 * (2^n - 1)\n+    const uint64_t n = depgraph.TxCount();\n+    if (n <= 18 && iter_count > 2U * ((uint64_t{1} << n) - 1U)) {\n+        assert(optimal);\n+    }\n+\n+    // If Linearize claims optimal result, run quality tests.\n+    if (optimal) {\n+        // It must be as good as SimpleLinearize.\n+        auto [simple_linearization, simple_optimal] = SimpleLinearize(depgraph, 0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 115,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "a34467001c258adf6b6f6d5d626221e7f89d38df",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`0x3ffff` should be explained",
      "created_at": "2024-06-21T19:53:05Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649373379",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649373379"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 541,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649396138",
      "pull_request_review_id": 2116172410,
      "id": 1649396138,
      "node_id": "PRRC_kwDOABII585iT8mq",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 94,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "a little confused what this is trying to say",
      "created_at": "2024-06-21T20:22:14Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649396138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649396138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649399637",
      "pull_request_review_id": 2116172410,
      "id": 1649399637,
      "node_id": "PRRC_kwDOABII585iT9dV",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.\n+        uint64_t iters = 10;\n+        Linearize(depgraph, iters);\n+    });\n+}\n+\n+} // namespace\n+\n+static void LinearizePerIter16TxWorstCase(benchmark::Bench& bench) { BenchLinearizePerIterWorstCase<BitSet<16>>(16, bench); }",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "if each benchmark matches the BitSet::Size(), no need for `ntx` args?",
      "created_at": "2024-06-21T20:25:27Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649399637",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649399637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649401042",
      "pull_request_review_id": 2116172410,
      "id": 1649401042,
      "node_id": "PRRC_kwDOABII585iT9zS",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "having trouble understanding what `PerIter` and `NoIter` mean",
      "created_at": "2024-06-21T20:27:22Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649401042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649401042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651203077",
      "pull_request_review_id": 2116172410,
      "id": 1651203077,
      "node_id": "PRRC_kwDOABII585ia1wF",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 27,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you add a description of how it's inherently difficult and what these two types of topologies are achieving? \r\n",
      "created_at": "2024-06-24T15:09:14Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651203077",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651203077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651302872",
      "pull_request_review_id": 2116172410,
      "id": 1651302872,
      "node_id": "PRRC_kwDOABII585ibOHY",
      "diff_hunk": "@@ -351,7 +352,8 @@ class SearchCandidateFinder\n         };\n \n         /** The queue of work items. */\n-        std::vector<WorkItem> queue;\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));",
      "path": "src/cluster_linearize.h",
      "position": 602,
      "original_position": 14,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think 256 is ever exceeded in bench(99)/fuzz(32) cases?\r\n\r\nIIUC If the other value were ever exercised, it has to at least be `m_todo.Count() + 1`",
      "created_at": "2024-06-24T16:18:03Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651302872",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651302872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 602,
      "original_line": 602,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651468145",
      "pull_request_review_id": 2116172410,
      "id": 1651468145,
      "node_id": "PRRC_kwDOABII585ib2dx",
      "diff_hunk": "@@ -411,10 +416,36 @@ class SearchCandidateFinder\n         };\n \n         // Work processing loop.\n+        //\n+        // New work items are always added at the back of the queue, but items to process use a\n+        // hybrid approach where they can be taken from the front or the back.\n+        //\n+        // Depth-first search (DFS) corresponds to always taking from the back of the queue. This\n+        // is very memory-efficient (linear in the number of transactions). Breadth-first search\n+        // (BFS) corresponds to always taking from the front, which potentially uses more memory\n+        // (up to exponential in the transaction count), but seems to work better in practice.\n+        //\n+        // The approach here combines the two: use BFS until the queue grows too large, at which\n+        // point we temporarily switch to DFS until the size shrinks again.\n         while (!queue.empty()) {\n+            // See if processing the first queue item (BFS) is possible without exceeding the queue\n+            // capacity(), assuming we process the last queue items (DFS) after that.\n+            const auto queuesize_for_front = queue.capacity() - queue.front().und.Count();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe this is all correct and understand reasoning for flow, but I don't really understand what `queuesize_for_front` name is meant to convey. It took me a while to convince myself this section was correct fwiw\r\n\r\n",
      "created_at": "2024-06-24T18:40:00Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651468145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651468145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651471330",
      "pull_request_review_id": 2116172410,
      "id": 1651471330,
      "node_id": "PRRC_kwDOABII585ib3Pi",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            const auto& input = depgraph.entries[i];\n+            auto& output = entries[mapping[i]];\n+            output.feerate = input.feerate;\n+            for (auto j : input.ancestors) output.ancestors.Set(mapping[j]);\n+        }\n+        // Fill in descendant information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the mutable feerate of a given transaction i. Complexity: O(1). */\n+    FeeFrac& FeeRate(ClusterIndex i) noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const S& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const S& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, S::Singleton(new_idx), S::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const S& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Find some connected component within the subset \"left\" of this graph.\n+     *\n+     * Complexity: O(ret.Count()).\n+     */\n+    S FindConnectedComponent(const S& left) const noexcept\n+    {\n+        if (left.None()) return left;\n+        auto first = left.First();\n+        S ret = Descendants(first) | Ancestors(first);\n+        ret &= left;\n+        S to_add = ret;\n+        to_add.Reset(first);\n+        do {\n+            S old = ret;\n+            for (auto add : to_add) {\n+                ret |= Descendants(add);\n+                ret |= Ancestors(add);\n+            }\n+            ret &= left;\n+            to_add = ret - old;\n+        } while (to_add.Any());\n+        return ret;\n+    }\n+\n+    /** Determine if a subset is connected.\n+     *\n+     * Complexity: O(subset.Count()).\n+     */\n+    bool IsConnected(const S& subset) const noexcept\n+    {\n+        return FindConnectedComponent(subset) == subset;\n+    }\n+\n+    /** Determine if this entire graph is connected.\n+     *\n+     * Complexity: O(TxCount()).\n+     */\n+    bool IsConnected() const noexcept { return IsConnected(S::Fill(TxCount())); }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const S& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename S>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<S>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    S m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<S>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{S::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            S anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(S select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename S>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** m_sorted_to_original[i] is the original position that sorted transaction position i had. */\n+    std::vector<ClusterIndex> m_sorted_to_original;\n+    /** m_original_to_sorted[i] is the sorted position original transaction position i has. */\n+    std::vector<ClusterIndex> m_original_to_sorted;\n+    /** Internal dependency graph for the cluster (with transactions in decreasing individual\n+     *  feerate order). */\n+    DepGraph<S> m_depgraph;\n+    /** Which transactions are left to do (indices in m_depgraph's sorted order). */\n+    S m_todo;\n+\n+    static uint256 GetRNGKey(uint64_t rng_seed) noexcept\n+    {\n+        uint256 rng_key;\n+        WriteLE64(rng_key.data(), rng_seed);\n+        return rng_key;\n+    }\n+\n+    /** Given a set of transactions with sorted indices, get their original indices. */\n+    S SortedToOriginal(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_sorted_to_original[pos]);\n+        return ret;\n+    }\n+\n+    /** Given a set of transactions with original indices, get their sorted indices. */\n+    S OriginalToSorted(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_original_to_sorted[pos]);\n+        return ret;\n+    }\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.Count().\n+     */\n+    SearchCandidateFinder(const DepGraph<S>& depgraph, uint64_t rng_seed) noexcept :\n+        m_rng(GetRNGKey(rng_seed)),\n+        m_sorted_to_original(depgraph.TxCount()),\n+        m_original_to_sorted(depgraph.TxCount())\n+    {\n+        // Determine reordering mapping, by sorting by decreasing feerate.\n+        std::iota(m_sorted_to_original.begin(), m_sorted_to_original.end(), ClusterIndex{0});\n+        std::sort(m_sorted_to_original.begin(), m_sorted_to_original.end(), [&](auto a, auto b) {\n+            auto feerate_cmp = depgraph.FeeRate(a) <=> depgraph.FeeRate(b);\n+            if (feerate_cmp == 0) return a < b;\n+            return feerate_cmp > 0;\n+        });\n+        // Compute reverse mapping.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            m_original_to_sorted[m_sorted_to_original[i]] = i;\n+        }\n+        // Compute reordered dependency graph.\n+        m_depgraph = DepGraph(depgraph, m_original_to_sorted);\n+        // Set todo to the entire graph.\n+        m_todo = S::Fill(depgraph.TxCount());\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in,out] iterations_left    On input, an upper bound on the number of optimization\n+     *                                   steps that can be performed. On output, that number is\n+     *                                   reduced by the number of actually performed optimization\n+     *                                   steps.\n+     * @param[in] best                   A set/feerate pair with an already-known good candidate.\n+     *                                   This can be empty.\n+     * @return                           The best (highest feerate, smallest size as tiebreaker)\n+     *                                   topologically-valid subset of what remains of the cluster\n+     *                                   that was encountered during search. If iterations_left is\n+     *                                   nonzero on output, it is the absolute best such subset. If\n+     *                                   not, the feerate of the returned set will be at least as\n+     *                                   good as the best passed in.\n+     *\n+     * Complexity: possibly O(N * min(iterations_left, sqrt(2^N))) where N=depgraph.TxCount().\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet(uint64_t& iterations_left, std::pair<S, FeeFrac> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        if (best.second.IsEmpty()) {\n+            // Set best to the entire remainder if not provided.\n+            best.first = m_todo;\n+            best.second = m_depgraph.FeeRate(m_todo);\n+        } else {\n+            // Otherwise convert to internal sorted indices.\n+            best.first = OriginalToSorted(best.first);\n+        }\n+        Assume(!best.second.IsEmpty());\n+        Assume(best.first.Any());\n+        Assume(best.first.IsSubsetOf(m_todo));\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included. This must be a subset of m_todo, and be\n+             *  topologically valid (includes all in-m_todo ancestors of itself). */\n+            S inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            S und;\n+            /** (Only when inc is not empty) The subset with the best feerate of any superset of\n+             *  inc that is also a subset of (inc | und), without requiring it to be topologically\n+             *  valid. If the real best such feerate does not exceed best.second, then this value\n+             *  is not guaranteed to be accurate. */\n+            S pot;\n+            /** Equal to m_depgraph.FeeRate(inc). */\n+            FeeFrac inc_feerate;\n+            /** Equal to m_depgraph.FeeRate(pot). It forms a conservative upper bound on how good\n+             *  a set this work item can give rise to, unless that's known to be below best.second.\n+             */\n+            FeeFrac pot_feerate;\n+            /** Construct a new work item. */\n+            WorkItem(S&& i, S&& u, S&& p, FeeFrac&& i_f, FeeFrac&& p_f) noexcept :\n+                inc(std::move(i)), und(std::move(u)), pot(std::move(p)),\n+                inc_feerate(std::move(i_f)), pot_feerate(std::move(p_f)) {}\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+                swap(pot, other.pot);\n+                swap(inc_feerate, other.inc_feerate);\n+                swap(pot_feerate, other.pot_feerate);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        /** The set of transactions in m_todo which have feerate > best_feerate. */\n+        S imp = m_todo;\n+        while (imp.Any()) {\n+            ClusterIndex check = imp.Last();\n+            if (m_depgraph.FeeRate(check) >> best.second) break;\n+            imp.Reset(check);\n+        }\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iteration_limit = iterations_left;\n+\n+        /** Internal function to add a work item, possibly improving it before doing so.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         * - pot: a subset of the \"pot\" value for the new work item (but a superset of inc).\n+         *        It does not need to be the full pot value; missing pot transactions will be added\n+         *        to it by add_fn.\n+         * - inc_feerate: equal to m_depgraph.FeeRate(inc)\n+         * - pot_feerate: equal to m_depgraph.FeeRate(pot)\n+         * - grow_inc: whether to attempt moving transactions from und to inc, if it can be proven\n+         *             that they must be a part of the best topologically valid superset of inc and\n+         *             subset of (inc | und). Transactions that are missing from pot are always\n+         *             considered, regardless of grow_inc. It only makes sense to enable this if\n+         *             transactions were added to inc.\n+         */\n+        auto add_fn = [&](S inc, S und, S pot, FeeFrac inc_feerate, FeeFrac pot_feerate, bool grow_inc) noexcept {\n+            Assume(inc.IsSubsetOf(m_todo));\n+            Assume(und.IsSubsetOf(m_todo));\n+            Assume(!inc.Overlaps(und));\n+            Assume(pot.IsSupersetOf(inc));\n+            Assume(pot.IsSubsetOf(inc | und));\n+            Assume(pot.None() == inc.None());\n+\n+            if (!inc_feerate.IsEmpty()) {\n+                /** Which transactions to consider adding to inc. */\n+                S consider_inc = grow_inc ? pot - inc : S{};\n+                // Add entries to pot (and pot_feerate). We iterate over all undecided transactions\n+                // whose feerate is higher than best_feerate, and aren't already part of pot. While\n+                // undecided transactions of lower feerate may improve pot still, if they do, the\n+                // resulting pot_feerate cannot possibly exceed best.second (resulting in the item\n+                // being skipped in split_fn).\n+                for (auto pos : (imp & und) - pot) {\n+                    // Determine if adding transaction pos to pot (ignoring topology) would improve it. If\n+                    // not, we're done updating pot. This relies on the fact that m_depgraph, and\n+                    // thus the set iterated over, is in decreasing individual feerate order.\n+                    if (!(m_depgraph.FeeRate(pos) >> pot_feerate)) break;\n+                    pot_feerate += m_depgraph.FeeRate(pos);\n+                    pot.Set(pos);\n+                    consider_inc.Set(pos);\n+                }\n+\n+                // The \"jump ahead\" optimization: whenever pot has a topologically-valid subset,\n+                // that subset can be added to inc. Any subset of (pot - inc) has the property that\n+                // its feerate exceeds that of any set compatible with this work item (superset of\n+                // inc, subset of (inc | und)). Thus, if T is a topological subset of pot, and B is\n+                // the best topologically-valid set compatible with this work item, and (T - B) is\n+                // non-empty, then (T | B) is better than B and also topological. This is in\n+                // contradiction with the assumption that B is best. Thus, (T - B) must be empty,\n+                // or T must be a subset of B.\n+                //\n+                // See https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303 section 2.4.\n+                const S init_inc = inc;\n+                for (auto pos : consider_inc) {\n+                    // If the transaction's ancestors are a subset of pot, we can add it together\n+                    // with its ancestors to inc.\n+                    auto anc_todo = m_depgraph.Ancestors(pos) & m_todo;\n+                    if (anc_todo.IsSubsetOf(pot)) inc |= anc_todo;\n+                }\n+                // Finally update und and inc_feerate to account for the added transactions.\n+                und -= inc;\n+                inc_feerate += m_depgraph.FeeRate(inc - init_inc);\n+\n+                // If inc_feerate is better than best_feerate, remember inc as our new best.\n+                if (inc_feerate > best.second) {\n+                    best = {inc, inc_feerate};\n+                    // See if we can remove any entries from imp now.\n+                    while (imp.Any()) {\n+                        ClusterIndex check = imp.Last();\n+                        if (m_depgraph.FeeRate(check) >> best.second) break;\n+                        imp.Reset(check);\n+                    }\n+                }\n+\n+                // If no potential transactions exist beyond the already included ones, no improvement\n+                // is possible anymore.\n+                if (pot == inc) return;\n+                // At this point und must be non-empty. If it were empty then pot would equal inc.\n+                Assume(und.Any());\n+            } else {\n+                // If inc is empty, we just make sure there are undecided transactions left to\n+                // split on.\n+                if (und.None()) return;\n+            }\n+\n+            // Actually construct new work item on the queue.\n+            Assume(queue.size() < queue.capacity());",
      "path": "src/cluster_linearize.h",
      "position": 634,
      "original_position": 558,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1626377280,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes, took me a while to convince myself, but the claim is clear",
      "created_at": "2024-06-24T18:43:01Z",
      "updated_at": "2024-06-27T15:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651471330",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651471330"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 634,
      "original_line": 634,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651482096",
      "pull_request_review_id": 2116172410,
      "id": 1651482096,
      "node_id": "PRRC_kwDOABII585ib53w",
      "diff_hunk": "@@ -77,8 +77,9 @@ void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n {",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 1,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "2228113dbbdd356aaaad385fd3e46a71308392aa commit message nit:\r\n\r\ns/item,/item to/",
      "created_at": "2024-06-24T18:53:07Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651482096",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651482096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651484882",
      "pull_request_review_id": 2116172410,
      "id": 1651484882,
      "node_id": "PRRC_kwDOABII585ib6jS",
      "diff_hunk": "@@ -467,6 +495,7 @@ class SearchCandidateFinder\n  *\n  * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n  * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed        A random number seed to control search order.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 86,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I presume the non-determinism is helpful to reduce the influence other nodes have on your linearization? Or maybe the idea that you could run linearizatio algo intermittently and make improvements? Other motivations?",
      "created_at": "2024-06-24T18:55:22Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651484882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651484882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 498,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652892335",
      "pull_request_review_id": 2116172410,
      "id": 1652892335,
      "node_id": "PRRC_kwDOABII585ihSKv",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n ",
      "path": "src/cluster_linearize.h",
      "position": 740,
      "original_position": 44,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n\r\n    Assume(old_linearization.empty() || old_linearization.size() == depgraph.TxCount());\r\n```",
      "created_at": "2024-06-25T14:08:01Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1652892335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652892335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 740,
      "original_line": 740,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652946934",
      "pull_request_review_id": 2116172410,
      "id": 1652946934,
      "node_id": "PRRC_kwDOABII585ihff2",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n \n+    // Precompute chunking of the existing linearization.\n+    std::vector<SetInfo<SetType>> chunks;\n+    for (auto i : old_linearization) {\n+        SetInfo new_chunk(depgraph, i);\n+        while (!chunks.empty() && new_chunk.feerate >> chunks.back().feerate) {\n+            new_chunk |= chunks.back();\n+            chunks.pop_back();\n+        }\n+        chunks.push_back(std::move(new_chunk));\n+    }\n+\n     AncestorCandidateFinder anc_finder(depgraph);\n     SearchCandidateFinder src_finder(depgraph, rng_seed);\n     linearization.reserve(depgraph.TxCount());\n     bool optimal = true;\n \n     while (todo.Any()) {\n-        // Initialize best as the best remaining ancestor set.\n-        auto best = anc_finder.FindCandidateSet();\n+        // This is an implementation of the (single) LIMO algorithm:\n+        // https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\n+        // where S is instantiated to be the result of a bounded search, which itself is seeded\n+        // with the best prefix of what remains of the input linearization, or the best ancestor set.\n+\n+        // Find the highest-feerate prefix of remainder of original chunks.\n+        SetInfo<SetType> best_prefix, best_prefix_acc;\n+        for (const auto& chunk : chunks) {\n+            SetType intersect = chunk.transactions & todo;\n+            if (intersect.Any()) {\n+                best_prefix_acc |= SetInfo(depgraph, intersect);\n+                if (best_prefix.feerate.IsEmpty() || best_prefix_acc.feerate > best_prefix.feerate) {\n+                    best_prefix = best_prefix_acc;\n+                }\n+            }\n+        }\n+\n+        // Then initialize best to be either the best remaining ancestor set, or the first chunk.\n+        auto best_anc = anc_finder.FindCandidateSet();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 82,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`best_anc` seems unneeded since it's only read once next line?",
      "created_at": "2024-06-25T14:28:52Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1652946934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652946934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 617,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652960236",
      "pull_request_review_id": 2116172410,
      "id": 1652960236,
      "node_id": "PRRC_kwDOABII585ihivs",
      "diff_hunk": "@@ -527,6 +563,24 @@ std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>\n \n         if (iterations_done_now == max_iterations_now) {\n             optimal = false;\n+            // If the search result is not (guaranteed to be) optimal, run intersections to make\n+            // sure we don't pick something that makes us unable to reach further diagram points\n+            // of the old linearization.\n+            if (best.transactions != best_prefix.transactions) {",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 95,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this section bears further elaboration, or direct citation to a good explanation of what this is necessary for correctness.",
      "created_at": "2024-06-25T14:36:53Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1652960236",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652960236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 687,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653136174",
      "pull_request_review_id": 2116172410,
      "id": 1653136174,
      "node_id": "PRRC_kwDOABII585iiNsu",
      "diff_hunk": "@@ -464,6 +464,37 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Given a dependency graph, construct any valid linearization for it, reading from a SpanReader. */\n+template<typename BS>\n+std::vector<ClusterIndex> ReadLinearization(const DepGraph<BS>& depgraph, SpanReader& reader)\n+{\n+    std::vector<ClusterIndex> linearization;\n+    TestBitSet todo = TestBitSet::Fill(depgraph.TxCount());\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`i` is never used, which was confusing for me, perhaps this?\r\n```Suggestion\r\n    while (todo.Any()) {\r\n```\r\n\r\nalong with asserting that `todo.Count()` is going down for each iteration of the loop to avoid infinite loops ala `assert(todo.Count() < todo_count);`?",
      "created_at": "2024-06-25T16:17:12Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1653136174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653136174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653168294",
      "pull_request_review_id": 2116172410,
      "id": 1653168294,
      "node_id": "PRRC_kwDOABII585iiVim",
      "diff_hunk": "@@ -166,6 +166,45 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"left\" of this graph.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 4,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I kept reading \"Left\" and is left vs right, since it was taking the `First` bit. \"todo\" probably matches better.",
      "created_at": "2024-06-25T16:39:59Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1653168294",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653168294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653204539",
      "pull_request_review_id": 2116172410,
      "id": 1653204539,
      "node_id": "PRRC_kwDOABII585iieY7",
      "diff_hunk": "@@ -427,6 +427,21 @@ void SanityCheck(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin\n     }\n }\n \n+/** Stitch connected components together in a DepGraph, guaranteeing its corresponding cluster is connected. */\n+template<typename BS>\n+void MakeConnected(DepGraph<BS>& depgraph)\n+{\n+    auto todo = BS::Fill(depgraph.TxCount());\n+    auto comp = depgraph.FindConnectedComponent(todo);\n+    todo -= comp;\n+    while (todo.Any()) {\n+        auto nextcomp = depgraph.FindConnectedComponent(todo);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 172,
      "original_position": 12,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n        Assume(!depgraph.IsConnected());\r\n        auto nextcomp = depgraph.FindConnectedComponent(todo);\r\n```",
      "created_at": "2024-06-25T16:57:19Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1653204539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653204539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657303810",
      "pull_request_review_id": 2116172410,
      "id": 1657303810,
      "node_id": "PRRC_kwDOABII585iyHMC",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 read children.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if\n+    // it is a DAG, it can be serialized as a DepGraph in a way that roundtrips. This guarantees\n+    // that any acyclic cluster has a corresponding DepGraph serialization.\n+\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    // Construct a cluster in a naive way (using a FuzzedDataProvider-based serialization).\n+    Cluster<TestBitSet> cluster;\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(1, 32);\n+    cluster.resize(num_tx);\n+    for (ClusterIndex i = 0; i < num_tx; ++i) {\n+        cluster[i].first.size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+        cluster[i].first.fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+        for (ClusterIndex j = 0; j < num_tx; ++j) {\n+            if (i == j) continue;\n+            if (provider.ConsumeBool()) cluster[i].second.Set(j);\n+        }\n+    }\n+\n+    // Construct dependency graph. The sanity check here includes a round-trip check.\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+\n+    // Verify that ancestry is computed correctly.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 291,
      "original_position": 353,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "for assurance shouldn't we also be checking the descendants are being computed as expected? Or is that covered somewhere else?",
      "created_at": "2024-06-27T15:01:17Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657303810",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657303810"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 291,
      "original_line": 291,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657850742",
      "pull_request_review_id": 2146569823,
      "id": 1657850742,
      "node_id": "PRRC_kwDOABII585i0Mt2",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 147,
      "original_position": 141,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": 1638465834,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think there is a need for that. If `parent == child` then this is a no-op (every transaction is already an ancestor and descendant of itself).",
      "created_at": "2024-06-27T21:48:39Z",
      "updated_at": "2024-06-27T21:48:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657850742",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657850742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857264",
      "pull_request_review_id": 2146580224,
      "id": 1657857264,
      "node_id": "PRRC_kwDOABII585i0OTw",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 266,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": 1638438741,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:25Z",
      "updated_at": "2024-06-27T21:57:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857264",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857307",
      "pull_request_review_id": 2146580297,
      "id": 1657857307,
      "node_id": "PRRC_kwDOABII585i0OUb",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 270,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": 1638450101,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:30Z",
      "updated_at": "2024-06-27T21:57:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857307",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857391",
      "pull_request_review_id": 2146580422,
      "id": 1657857391,
      "node_id": "PRRC_kwDOABII585i0OVv",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 126,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": 1638472774,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment.",
      "created_at": "2024-06-27T21:57:38Z",
      "updated_at": "2024-06-27T21:57:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857455",
      "pull_request_review_id": 2146580502,
      "id": 1657857455,
      "node_id": "PRRC_kwDOABII585i0OWv",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 271,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": 1638488625,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:42Z",
      "updated_at": "2024-06-27T21:57:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 530,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857579",
      "pull_request_review_id": 2146580710,
      "id": 1657857579,
      "node_id": "PRRC_kwDOABII585i0OYr",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 159,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": 1640177309,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done with a `static_assert`.",
      "created_at": "2024-06-27T21:57:53Z",
      "updated_at": "2024-06-27T21:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857631",
      "pull_request_review_id": 2146580809,
      "id": 1657857631,
      "node_id": "PRRC_kwDOABII585i0OZf",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];",
      "path": "src/cluster_linearize.h",
      "position": 456,
      "original_position": 61,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": 1644863011,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:58Z",
      "updated_at": "2024-06-27T21:57:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857631",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 456,
      "original_line": 456,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857760",
      "pull_request_review_id": 2146581040,
      "id": 1657857760,
      "node_id": "PRRC_kwDOABII585i0Obg",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": 1640177227,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done with a `static_assert`.",
      "created_at": "2024-06-27T21:58:11Z",
      "updated_at": "2024-06-27T21:58:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857760",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659216405",
      "pull_request_review_id": 2148798778,
      "id": 1659216405,
      "node_id": "PRRC_kwDOABII585i5aIV",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.\n+        uint64_t iters = 10;\n+        Linearize(depgraph, iters);\n+    });\n+}\n+\n+} // namespace\n+\n+static void LinearizePerIter16TxWorstCase(benchmark::Bench& bench) { BenchLinearizePerIterWorstCase<BitSet<16>>(16, bench); }",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": 1649399637,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`BitSet<N>::Size()` may differ from `N`.",
      "created_at": "2024-06-28T19:20:43Z",
      "updated_at": "2024-06-28T19:20:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659216405",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659216405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659217667",
      "pull_request_review_id": 2148801193,
      "id": 1659217667,
      "node_id": "PRRC_kwDOABII585i5acD",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {",
      "path": "src/cluster_linearize.h",
      "position": 507,
      "original_position": 96,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": 1644905104,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-28T19:21:35Z",
      "updated_at": "2024-06-28T19:21:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659217667",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659217667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 507,
      "original_line": 507,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218218",
      "pull_request_review_id": 2148802168,
      "id": 1659218218,
      "node_id": "PRRC_kwDOABII585i5akq",
      "diff_hunk": "@@ -346,3 +364,49 @@ FUZZ_TARGET(clusterlin_depgraph_serialization)\n     // Verify the graph is a DAG.\n     assert(IsAcyclic(depgraph));\n }\n+\n+FUZZ_TARGET(clusterlin_ancestor_finder)\n+{\n+    // Verify that AncestorCandidateFinder works as expected.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // Call the ancestor finder's FindCandidateSet for what remains of the graph.\n+        auto best_anc = anc_finder.FindCandidateSet();\n+        // Sanity check the result.\n+        assert(best_anc.transactions.Any());\n+        assert(best_anc.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(best_anc.transactions) == best_anc.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : best_anc.transactions) {\n+            assert((depgraph.Ancestors(i) & todo).IsSubsetOf(best_anc.transactions));\n+        }\n+\n+        // Compute all remaining ancestor sets.\n+        std::optional<SetInfo<TestBitSet>> real_best_anc;\n+        for (auto i : todo) {\n+            SetInfo info(depgraph, todo & depgraph.Ancestors(i));\n+            if (!real_best_anc.has_value() || info.feerate > real_best_anc->feerate) {\n+                real_best_anc = info;\n+            }\n+        }\n+        // The set returned by anc_finder must equal the real best ancestor sets.\n+        assert(real_best_anc.has_value());\n+        assert(*real_best_anc == best_anc);\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use best_anc itself, because we should remove something.\n+        if (del_set.None()) del_set = best_anc.transactions;\n+        todo -= del_set;\n+        anc_finder.MarkDone(del_set);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 430,
      "original_position": 72,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": 1644945090,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've outlawed `MarkDone()` with `select` not a subset of `todo`.",
      "created_at": "2024-06-28T19:21:56Z",
      "updated_at": "2024-06-28T19:21:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 430,
      "original_line": 430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218521",
      "pull_request_review_id": 2148802769,
      "id": 1659218521,
      "node_id": "PRRC_kwDOABII585i5apZ",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644952136,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added, please have a look if this is what you meant.",
      "created_at": "2024-06-28T19:22:09Z",
      "updated_at": "2024-06-28T19:22:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218521",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218637",
      "pull_request_review_id": 2148802983,
      "id": 1659218637,
      "node_id": "PRRC_kwDOABII585i5arN",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.\n+            if (todo.Count() <= 12) {\n+                auto exhaustive = exh_finder.FindCandidateSet();\n+                assert(exhaustive.feerate == found.feerate);\n+                // Also compare ExhaustiveCandidateFinder with SimpleCandidateFinder (this is more\n+                // a test for SimpleCandidateFinder's correctness).\n+                assert(exhaustive.feerate >= simple.feerate);\n+                if (simple_iters < 0x3ffff) assert(exhaustive.feerate == simple.feerate);\n+            }\n+        }\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use found_set itself, because we should remove something.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 185,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644963760,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-06-28T19:22:14Z",
      "updated_at": "2024-06-28T19:22:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218637",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218822",
      "pull_request_review_id": 2148803329,
      "id": 1659218822,
      "node_id": "PRRC_kwDOABII585i5auG",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644966180,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-06-28T19:22:22Z",
      "updated_at": "2024-06-28T19:22:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218822",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218822"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218927",
      "pull_request_review_id": 2148803534,
      "id": 1659218927,
      "node_id": "PRRC_kwDOABII585i5avv",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 14,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644966317,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-06-28T19:22:27Z",
      "updated_at": "2024-06-28T19:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659218927",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659218927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659219435",
      "pull_request_review_id": 2148804406,
      "id": 1659219435,
      "node_id": "PRRC_kwDOABII585i5a3r",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 164,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644982295,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, named it `MAX_SIMPLE_ITERATIONS` (and used more readable number 300000).",
      "created_at": "2024-06-28T19:22:49Z",
      "updated_at": "2024-06-28T19:22:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659219435",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659219435"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659219716",
      "pull_request_review_id": 2148804813,
      "id": 1659219716,
      "node_id": "PRRC_kwDOABII585i5a8E",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1649155445,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-28T19:22:58Z",
      "updated_at": "2024-06-28T19:22:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659219716",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659219716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220190",
      "pull_request_review_id": 2148805579,
      "id": 1659220190,
      "node_id": "PRRC_kwDOABII585i5bDe",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1649205112,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "See new unit test.",
      "created_at": "2024-06-28T19:23:14Z",
      "updated_at": "2024-06-28T19:23:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659220190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220493",
      "pull_request_review_id": 2148805988,
      "id": 1659220493,
      "node_id": "PRRC_kwDOABII585i5bIN",
      "diff_hunk": "@@ -452,3 +552,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649232974,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd rather not. The point of `ExhaustiveCandidateFinder` is really testing the correctness of `SimpleCandidateFinder` (whose correctness may not be obvious to reviewers), so that `SimpleCandidateFinder` on its turn can be used to test `SearchCandidateFinder`. I added comments to explain that.\r\n\r\nBoth of these are done within the same fuzz test, which is perhaps confusing? I could split up the tests (an exhaustive-vs-simple test, and a simple-vs-search test).",
      "created_at": "2024-06-28T19:23:22Z",
      "updated_at": "2024-06-28T19:23:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659220493",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 446,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220875",
      "pull_request_review_id": 2148806518,
      "id": 1659220875,
      "node_id": "PRRC_kwDOABII585i5bOL",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 86,
      "original_position": 100,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649259334,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed. I don't think 1 iteration matters.",
      "created_at": "2024-06-28T19:23:33Z",
      "updated_at": "2024-06-28T19:23:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659220875",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659220875"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221292",
      "pull_request_review_id": 2148807122,
      "id": 1659221292,
      "node_id": "PRRC_kwDOABII585i5bUs",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 84,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649287854,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Disallowed.",
      "created_at": "2024-06-28T19:23:47Z",
      "updated_at": "2024-06-28T19:23:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659221292",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 398,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221511",
      "pull_request_review_id": 2148807474,
      "id": 1659221511,
      "node_id": "PRRC_kwDOABII585i5bYH",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649300280,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-28T19:23:55Z",
      "updated_at": "2024-06-28T19:23:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659221511",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221511"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221633",
      "pull_request_review_id": 2148807726,
      "id": 1659221633,
      "node_id": "PRRC_kwDOABII585i5baB",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         */\n+        auto add_fn = [&](SetInfo<SetType> inc, SetType und) noexcept {\n+            if (!inc.feerate.IsEmpty()) {\n+                // If inc's feerate is better than best's, remember it as our new best.\n+                if (inc.feerate > best.feerate) {\n+                    best = inc;\n+                }\n+            }",
      "path": "src/cluster_linearize.h",
      "position": 626,
      "original_position": 125,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649308286,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-28T19:24:02Z",
      "updated_at": "2024-06-28T19:24:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659221633",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659221633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 626,
      "original_line": 626,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659222412",
      "pull_request_review_id": 2148808767,
      "id": 1659222412,
      "node_id": "PRRC_kwDOABII585i5bmM",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 94,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": 1649396138,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was trying to explain why using 10 iterations instead of 0 made sense. I have instead just changed it to 0 iterations.",
      "created_at": "2024-06-28T19:24:38Z",
      "updated_at": "2024-06-28T19:24:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659222412",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659222412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659228321",
      "pull_request_review_id": 2148816572,
      "id": 1659228321,
      "node_id": "PRRC_kwDOABII585i5dCh",
      "diff_hunk": "@@ -411,10 +416,36 @@ class SearchCandidateFinder\n         };\n \n         // Work processing loop.\n+        //\n+        // New work items are always added at the back of the queue, but items to process use a\n+        // hybrid approach where they can be taken from the front or the back.\n+        //\n+        // Depth-first search (DFS) corresponds to always taking from the back of the queue. This\n+        // is very memory-efficient (linear in the number of transactions). Breadth-first search\n+        // (BFS) corresponds to always taking from the front, which potentially uses more memory\n+        // (up to exponential in the transaction count), but seems to work better in practice.\n+        //\n+        // The approach here combines the two: use BFS until the queue grows too large, at which\n+        // point we temporarily switch to DFS until the size shrinks again.\n         while (!queue.empty()) {\n+            // See if processing the first queue item (BFS) is possible without exceeding the queue\n+            // capacity(), assuming we process the last queue items (DFS) after that.\n+            const auto queuesize_for_front = queue.capacity() - queue.front().und.Count();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651468145,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It means \"what the **queue size** needs to be before we can process an element from the **front**\".",
      "created_at": "2024-06-28T19:29:27Z",
      "updated_at": "2024-06-28T19:29:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1659228321",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1659228321"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660345204",
      "pull_request_review_id": 2150238176,
      "id": 1660345204,
      "node_id": "PRRC_kwDOABII585i9tt0",
      "diff_hunk": "@@ -467,6 +495,7 @@ class SearchCandidateFinder\n  *\n  * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n  * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed        A random number seed to control search order.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 86,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": 1651484882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, it is to reduce the ability for peers to construct cases that just happen to be worst case for the exact search order they know we're going to try.",
      "created_at": "2024-07-01T00:42:03Z",
      "updated_at": "2024-07-01T00:42:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660345204",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660345204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 498,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349106",
      "pull_request_review_id": 2150244036,
      "id": 1660349106,
      "node_id": "PRRC_kwDOABII585i9uqy",
      "diff_hunk": "@@ -635,3 +688,68 @@ FUZZ_TARGET(clusterlin_search_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_linearize)\n+{\n+    // Verify the behavior of Linearize().\n+\n+    // Retrieve an iteration count, and a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    uint64_t iter_count{0};\n+    try {\n+        reader >> VARINT(iter_count) >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Invoke Linearize().\n+    iter_count &= 0x7ffff;\n+    auto [linearization, optimal] = Linearize(depgraph, iter_count);\n+    SanityCheck(depgraph, linearization);\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+\n+    // If the iteration count is sufficiently high, an optimal linearization must be found.\n+    // Each linearization step can use up to 2^k iterations, with steps k=1..n. That sum is\n+    // 2 * (2^n - 1)\n+    const uint64_t n = depgraph.TxCount();\n+    if (n <= 18 && iter_count > 2U * ((uint64_t{1} << n) - 1U)) {\n+        assert(optimal);\n+    }\n+\n+    // If Linearize claims optimal result, run quality tests.\n+    if (optimal) {\n+        // It must be as good as SimpleLinearize.\n+        auto [simple_linearization, simple_optimal] = SimpleLinearize(depgraph, 0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 115,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "a34467001c258adf6b6f6d5d626221e7f89d38df",
      "in_reply_to_id": 1649373379,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, named as `MAX_SIMPLE_ITERATIONS`.",
      "created_at": "2024-07-01T00:56:56Z",
      "updated_at": "2024-07-01T00:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349106",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349106"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 541,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349184",
      "pull_request_review_id": 2150244105,
      "id": 1660349184,
      "node_id": "PRRC_kwDOABII585i9usA",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": 1649401042,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added comments.",
      "created_at": "2024-07-01T00:57:05Z",
      "updated_at": "2024-07-01T00:57:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349184",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349260",
      "pull_request_review_id": 2150244251,
      "id": 1660349260,
      "node_id": "PRRC_kwDOABII585i9utM",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 27,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": 1651203077,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have no idea! Added a comment that it was found empirically.",
      "created_at": "2024-07-01T00:57:22Z",
      "updated_at": "2024-07-01T00:57:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349260",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349260"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349319",
      "pull_request_review_id": 2150244330,
      "id": 1660349319,
      "node_id": "PRRC_kwDOABII585i9uuH",
      "diff_hunk": "@@ -77,8 +77,9 @@ void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n {",
      "path": "src/bench/clusterlin.cpp",
      "position": null,
      "original_position": 1,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": 1651482096,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-01T00:57:32Z",
      "updated_at": "2024-07-01T00:57:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349319",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349319"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349373",
      "pull_request_review_id": 2150244420,
      "id": 1660349373,
      "node_id": "PRRC_kwDOABII585i9uu9",
      "diff_hunk": "@@ -467,6 +495,7 @@ class SearchCandidateFinder\n  *\n  * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n  * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed        A random number seed to control search order.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 86,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": 1651484882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment to `Linearize` to reflect this.",
      "created_at": "2024-07-01T00:57:46Z",
      "updated_at": "2024-07-01T00:57:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349373",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349373"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 498,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349427",
      "pull_request_review_id": 2150244485,
      "id": 1660349427,
      "node_id": "PRRC_kwDOABII585i9uvz",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n ",
      "path": "src/cluster_linearize.h",
      "position": 740,
      "original_position": 44,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1652892335,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-01T00:57:53Z",
      "updated_at": "2024-07-01T00:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1660349427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1660349427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 740,
      "original_line": 740,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1661222360",
      "pull_request_review_id": 2151679554,
      "id": 1661222360,
      "node_id": "PRRC_kwDOABII585jBD3Y",
      "diff_hunk": "@@ -132,6 +132,7 @@ BITCOIN_CORE_H = \\\n   chainparamsseeds.h \\",
      "path": "src/Makefile.am",
      "position": 1,
      "original_position": 1,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: noticed a couple typos in the commit message, if you end up touching this again:\r\n```\r\nThis primarily adds the DepGraph class, which encapsulated precomputed\r\n```\r\nencapsulate**s**\r\n\r\n```\r\nnumber of a utility features (inspectors for set feerates, computing\r\n```\r\n~~a~~",
      "created_at": "2024-07-01T15:27:09Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1661222360",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1661222360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1661239839",
      "pull_request_review_id": 2151679554,
      "id": 1661239839,
      "node_id": "PRRC_kwDOABII585jBIIf",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": 48,
      "original_position": 43,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is this only used for verifying whether two DepGraph objects are identical, eg in the serialization/deserialization tests in the next commit?\r\n\r\nIt occurred to me that there might be some contexts where an equality operator for two Entry objects might want to be defined differently -- eg because you could have two Entry's in the same DepGraph with identical feerate and ancestor/descendant state, but still treat them as different objects -- but I'm guessing that is not the case for any of the uses currently contemplated?",
      "created_at": "2024-07-01T15:41:01Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1661239839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1661239839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662746393",
      "pull_request_review_id": 2151679554,
      "id": 1662746393,
      "node_id": "PRRC_kwDOABII585jG38Z",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: O(1) (amortized, due to resizing of backing vector).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();",
      "path": "src/cluster_linearize.h",
      "position": 136,
      "original_position": 130,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should this function be checking that we haven't exceeded the capacity of the SetType?",
      "created_at": "2024-07-02T15:25:15Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662746393",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662746393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 136,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662798441",
      "pull_request_review_id": 2151679554,
      "id": 1662798441,
      "node_id": "PRRC_kwDOABII585jHEpp",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 79,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: \"satisyfy\" --> \"satisfy\"",
      "created_at": "2024-07-02T16:01:29Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662798441",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662798441"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662822694",
      "pull_request_review_id": 2151679554,
      "id": 1662822694,
      "node_id": "PRRC_kwDOABII585jHKkm",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 176,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was really confused about why we need to use `CanAddDependency` here -- as far as I can understand, it's basically about compression, so that we get shorter serializations?  And conceptually, the reason compression is helpful is in the context of serializations that are produced by a fuzzer being as meaningful as possible?\r\n\r\nI guess compression doesn't hurt here, but just to verify my understanding: would all this logic work just fine if we dropped the use of `CanAddDependency` in the serializer, but left it in place in the deserializer?  Or are there cases where that difference would result in the round trip of serializing/deserializing to not result in the same graph?  (And if so, could you provide such an example so I can try to better understand this logic?)",
      "created_at": "2024-07-02T16:20:50Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662822694",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662822694"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662824605",
      "pull_request_review_id": 2151679554,
      "id": 1662824605,
      "node_id": "PRRC_kwDOABII585jHLCd",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 160,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should this say \"serializer\" instead of \"deserializer\"?",
      "created_at": "2024-07-02T16:22:32Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662824605",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662824605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662836077",
      "pull_request_review_id": 2151679554,
      "id": 1662836077,
      "node_id": "PRRC_kwDOABII585jHN1t",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 102,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Left another comment down below regarding `CanAddDependency()` in the serializer -- it makes sense to me to use it in the deserializer in the context of having a fuzzer produce random bytes which we try to deserialize into a graph, but I don't follow why it's necessary in the serializer.",
      "created_at": "2024-07-02T16:29:45Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662836077",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662836077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662861895",
      "pull_request_review_id": 2151679554,
      "id": 1662861895,
      "node_id": "PRRC_kwDOABII585jHUJH",
      "diff_hunk": "@@ -0,0 +1,80 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);\n+\n+    // Test that deserializing that encoding yields depgraph.\n+    SpanReader reader(encoding);\n+    DepGraph<SetType> depgraph_read;\n+    reader >> Using<DepGraphFormatter>(depgraph_read);\n+    BOOST_CHECK(depgraph == depgraph_read);\n+}\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(depgraph_ser_tests)\n+{\n+    // Empty cluster.\n+    TestDepGraphSerialization<TestBitSet>({}, \"00\");\n+\n+    // Transactions: A(fee=0,size=1).\n+    TestDepGraphSerialization<TestBitSet>({{{0, 1}, {}}}, \"010000\");\n+\n+    // Transactions: A(fee=42,size=11), B(fee=-13,size=7), B depends on A.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{42, 11}, {}}, {{-13, 7}, {0}}},\n+        \"0b5407190100\");",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": null,
      "original_position": 64,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is the best way to review this code to manually check that the encoding is as described in the serialization code?",
      "created_at": "2024-07-02T16:46:18Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662861895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662861895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662966890",
      "pull_request_review_id": 2151679554,
      "id": 1662966890,
      "node_id": "PRRC_kwDOABII585jHtxq",
      "diff_hunk": "@@ -0,0 +1,80 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);\n+\n+    // Test that deserializing that encoding yields depgraph.\n+    SpanReader reader(encoding);\n+    DepGraph<SetType> depgraph_read;\n+    reader >> Using<DepGraphFormatter>(depgraph_read);\n+    BOOST_CHECK(depgraph == depgraph_read);\n+}\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(depgraph_ser_tests)\n+{\n+    // Empty cluster.\n+    TestDepGraphSerialization<TestBitSet>({}, \"00\");\n+\n+    // Transactions: A(fee=0,size=1).\n+    TestDepGraphSerialization<TestBitSet>({{{0, 1}, {}}}, \"010000\");\n+\n+    // Transactions: A(fee=42,size=11), B(fee=-13,size=7), B depends on A.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{42, 11}, {}}, {{-13, 7}, {0}}},\n+        \"0b5407190100\");\n+\n+    // Transactions: A(64,128), B(128,256), C(1,1), C depends on A and B.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{64, 128}, {}}, {{128, 256}, {}}, {{1, 1}, {0, 1}}},\n+        \"8000800081008100000102010100\");\n+\n+    // Transactions: A(-58,113), B(36,114), C(-59,115), D(37,116). Deps: B->A, C->A, D->C, in order",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": null,
      "original_position": 71,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: The fee/size values in this comment don't seem to match the fee/size values in the test below.",
      "created_at": "2024-07-02T18:12:14Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1662966890",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1662966890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663121757",
      "pull_request_review_id": 2154795931,
      "id": 1663121757,
      "node_id": "PRRC_kwDOABII585jITld",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 read children.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if\n+    // it is a DAG, it can be serialized as a DepGraph in a way that roundtrips. This guarantees\n+    // that any acyclic cluster has a corresponding DepGraph serialization.\n+\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    // Construct a cluster in a naive way (using a FuzzedDataProvider-based serialization).\n+    Cluster<TestBitSet> cluster;\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(1, 32);\n+    cluster.resize(num_tx);\n+    for (ClusterIndex i = 0; i < num_tx; ++i) {\n+        cluster[i].first.size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+        cluster[i].first.fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+        for (ClusterIndex j = 0; j < num_tx; ++j) {\n+            if (i == j) continue;\n+            if (provider.ConsumeBool()) cluster[i].second.Set(j);\n+        }\n+    }\n+\n+    // Construct dependency graph. The sanity check here includes a round-trip check.\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+\n+    // Verify that ancestry is computed correctly.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 291,
      "original_position": 353,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1657303810,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's covered in `SanityCheck`.",
      "created_at": "2024-07-02T20:19:24Z",
      "updated_at": "2024-07-02T20:19:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663121757",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663121757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 291,
      "original_line": 291,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663124799",
      "pull_request_review_id": 2154801669,
      "id": 1663124799,
      "node_id": "PRRC_kwDOABII585jIUU_",
      "diff_hunk": "@@ -351,7 +352,8 @@ class SearchCandidateFinder\n         };\n \n         /** The queue of work items. */\n-        std::vector<WorkItem> queue;\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));",
      "path": "src/cluster_linearize.h",
      "position": 602,
      "original_position": 14,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651302872,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The way the bound was computed was inaccurate; I have fixed that (256 does get reached (but not exceeded) now in the bench(99) benchmark if you increase the iteration count to 100000). I've also rewritten the comments and computation a bit.",
      "created_at": "2024-07-02T20:21:37Z",
      "updated_at": "2024-07-08T14:09:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663124799",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663124799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 602,
      "original_line": 602,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663124892",
      "pull_request_review_id": 2154801917,
      "id": 1663124892,
      "node_id": "PRRC_kwDOABII585jIUWc",
      "diff_hunk": "@@ -411,10 +416,36 @@ class SearchCandidateFinder\n         };\n \n         // Work processing loop.\n+        //\n+        // New work items are always added at the back of the queue, but items to process use a\n+        // hybrid approach where they can be taken from the front or the back.\n+        //\n+        // Depth-first search (DFS) corresponds to always taking from the back of the queue. This\n+        // is very memory-efficient (linear in the number of transactions). Breadth-first search\n+        // (BFS) corresponds to always taking from the front, which potentially uses more memory\n+        // (up to exponential in the transaction count), but seems to work better in practice.\n+        //\n+        // The approach here combines the two: use BFS until the queue grows too large, at which\n+        // point we temporarily switch to DFS until the size shrinks again.\n         while (!queue.empty()) {\n+            // See if processing the first queue item (BFS) is possible without exceeding the queue\n+            // capacity(), assuming we process the last queue items (DFS) after that.\n+            const auto queuesize_for_front = queue.capacity() - queue.front().und.Count();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": 1651468145,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have rewritten this.",
      "created_at": "2024-07-02T20:21:44Z",
      "updated_at": "2024-07-02T20:21:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663124892",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663124892"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663125068",
      "pull_request_review_id": 2154802227,
      "id": 1663125068,
      "node_id": "PRRC_kwDOABII585jIUZM",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n \n+    // Precompute chunking of the existing linearization.\n+    std::vector<SetInfo<SetType>> chunks;\n+    for (auto i : old_linearization) {\n+        SetInfo new_chunk(depgraph, i);\n+        while (!chunks.empty() && new_chunk.feerate >> chunks.back().feerate) {\n+            new_chunk |= chunks.back();\n+            chunks.pop_back();\n+        }\n+        chunks.push_back(std::move(new_chunk));\n+    }\n+\n     AncestorCandidateFinder anc_finder(depgraph);\n     SearchCandidateFinder src_finder(depgraph, rng_seed);\n     linearization.reserve(depgraph.TxCount());\n     bool optimal = true;\n \n     while (todo.Any()) {\n-        // Initialize best as the best remaining ancestor set.\n-        auto best = anc_finder.FindCandidateSet();\n+        // This is an implementation of the (single) LIMO algorithm:\n+        // https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\n+        // where S is instantiated to be the result of a bounded search, which itself is seeded\n+        // with the best prefix of what remains of the input linearization, or the best ancestor set.\n+\n+        // Find the highest-feerate prefix of remainder of original chunks.\n+        SetInfo<SetType> best_prefix, best_prefix_acc;\n+        for (const auto& chunk : chunks) {\n+            SetType intersect = chunk.transactions & todo;\n+            if (intersect.Any()) {\n+                best_prefix_acc |= SetInfo(depgraph, intersect);\n+                if (best_prefix.feerate.IsEmpty() || best_prefix_acc.feerate > best_prefix.feerate) {\n+                    best_prefix = best_prefix_acc;\n+                }\n+            }\n+        }\n+\n+        // Then initialize best to be either the best remaining ancestor set, or the first chunk.\n+        auto best_anc = anc_finder.FindCandidateSet();",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 82,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1652946934,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Gone.",
      "created_at": "2024-07-02T20:21:53Z",
      "updated_at": "2024-07-02T20:21:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663125068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663125068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 617,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663125681",
      "pull_request_review_id": 2154803367,
      "id": 1663125681,
      "node_id": "PRRC_kwDOABII585jIUix",
      "diff_hunk": "@@ -527,6 +563,24 @@ std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>\n \n         if (iterations_done_now == max_iterations_now) {\n             optimal = false;\n+            // If the search result is not (guaranteed to be) optimal, run intersections to make\n+            // sure we don't pick something that makes us unable to reach further diagram points\n+            // of the old linearization.\n+            if (best.transactions != best_prefix.transactions) {",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 95,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1652960236,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think my in-progress delving post will cover this. I will postpone addressing this until that's out.",
      "created_at": "2024-07-02T20:22:25Z",
      "updated_at": "2024-07-02T20:22:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663125681",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663125681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 687,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663126806",
      "pull_request_review_id": 2154805782,
      "id": 1663126806,
      "node_id": "PRRC_kwDOABII585jIU0W",
      "diff_hunk": "@@ -464,6 +464,37 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Given a dependency graph, construct any valid linearization for it, reading from a SpanReader. */\n+template<typename BS>\n+std::vector<ClusterIndex> ReadLinearization(const DepGraph<BS>& depgraph, SpanReader& reader)\n+{\n+    std::vector<ClusterIndex> linearization;\n+    TestBitSet todo = TestBitSet::Fill(depgraph.TxCount());\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1653136174,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. I've added an `assert(todo[j]);` before `todo.Reset(j);` to make sure infinite iteration is not possible.",
      "created_at": "2024-07-02T20:23:32Z",
      "updated_at": "2024-07-02T20:23:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663126806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663126806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663126949",
      "pull_request_review_id": 2154805987,
      "id": 1663126949,
      "node_id": "PRRC_kwDOABII585jIU2l",
      "diff_hunk": "@@ -166,6 +166,45 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"left\" of this graph.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 4,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": 1653168294,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-02T20:23:37Z",
      "updated_at": "2024-07-02T20:23:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663126949",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663126949"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663127067",
      "pull_request_review_id": 2154806208,
      "id": 1663127067,
      "node_id": "PRRC_kwDOABII585jIU4b",
      "diff_hunk": "@@ -427,6 +427,21 @@ void SanityCheck(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin\n     }\n }\n \n+/** Stitch connected components together in a DepGraph, guaranteeing its corresponding cluster is connected. */\n+template<typename BS>\n+void MakeConnected(DepGraph<BS>& depgraph)\n+{\n+    auto todo = BS::Fill(depgraph.TxCount());\n+    auto comp = depgraph.FindConnectedComponent(todo);\n+    todo -= comp;\n+    while (todo.Any()) {\n+        auto nextcomp = depgraph.FindConnectedComponent(todo);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 172,
      "original_position": 12,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": 1653204539,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-02T20:23:43Z",
      "updated_at": "2024-07-02T20:23:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1663127067",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1663127067"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664681970",
      "pull_request_review_id": 2151679554,
      "id": 1664681970,
      "node_id": "PRRC_kwDOABII585jOQfy",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 read children.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if\n+    // it is a DAG, it can be serialized as a DepGraph in a way that roundtrips. This guarantees\n+    // that any acyclic cluster has a corresponding DepGraph serialization.\n+\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    // Construct a cluster in a naive way (using a FuzzedDataProvider-based serialization).\n+    Cluster<TestBitSet> cluster;\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(1, 32);\n+    cluster.resize(num_tx);\n+    for (ClusterIndex i = 0; i < num_tx; ++i) {\n+        cluster[i].first.size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+        cluster[i].first.fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+        for (ClusterIndex j = 0; j < num_tx; ++j) {\n+            if (i == j) continue;\n+            if (provider.ConsumeBool()) cluster[i].second.Set(j);\n+        }\n+    }\n+\n+    // Construct dependency graph. The sanity check here includes a round-trip check.\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+\n+    // Verify that ancestry is computed correctly.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 291,
      "original_position": 353,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1657303810,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think `SanityCheck` is already checking that the ancestors and descendants are consistent with each other, so it's sufficient here to check that the ancestors are correct.",
      "created_at": "2024-07-03T19:49:05Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1664681970",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664681970"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 291,
      "original_line": 291,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664704882",
      "pull_request_review_id": 2151679554,
      "id": 1664704882,
      "node_id": "PRRC_kwDOABII585jOWFy",
      "diff_hunk": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_CLUSTER_LINEARIZE_H",
      "path": "src/cluster_linearize.h",
      "position": 5,
      "original_position": 1,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ca6f49dd0de718d1e29060e2ef2f0d6a48f7dcc4",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: if you touch up this commit, I think the commit message has a couple typos:\r\n\r\n`This is a class that encapsulated precomputes ancestor set feerates, and`\r\n\r\nshould read \"encapsulates precomputed ancestor set feerates\"\r\n",
      "created_at": "2024-07-03T20:03:34Z",
      "updated_at": "2024-07-03T20:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1664704882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664704882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5,
      "original_line": 5,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664822525",
      "pull_request_review_id": 2157483747,
      "id": 1664822525,
      "node_id": "PRRC_kwDOABII585jOyz9",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 176,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662822694,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, it is needed, for the simple reason that the serializer needs to predict what the deserializer state will be when reading this, or they will go out of sync. If they disagree about which dependencies are possible, the delta-encoded differences between them will be off, resulting in possibly widely different DepGraphs on decoding. An example where this matters is in the 4th unit test (specifically constructed for that, suggested by @instagibbs).\r\n\r\nI am considering a simplification for the encoding format however, but I'm not sure yet if it'll be an improvement. I'll try pushing a commit that switches things over in the next few days. Perhaps it's worth holding off reviewing the encoding format and associated logic until then.",
      "created_at": "2024-07-03T21:19:11Z",
      "updated_at": "2024-07-03T21:19:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1664822525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664822525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1666706287",
      "pull_request_review_id": 2160552969,
      "id": 1666706287,
      "node_id": "PRRC_kwDOABII585jV-tv",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": 48,
      "original_position": 43,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": 1661239839,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`Entry` struct does not have any other distinguishing information, are you suggesting adding txid to `Entry`?",
      "created_at": "2024-07-05T11:42:04Z",
      "updated_at": "2024-07-05T12:20:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1666706287",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1666706287"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1666706550",
      "pull_request_review_id": 2160552969,
      "id": 1666706550,
      "node_id": "PRRC_kwDOABII585jV-x2",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 51,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "e27797600418ffc2d7ecf70134d7fcc778204d85",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "which order?",
      "created_at": "2024-07-05T11:42:24Z",
      "updated_at": "2024-07-05T12:20:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1666706550",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1666706550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667779316",
      "pull_request_review_id": 2161937780,
      "id": 1667779316,
      "node_id": "PRRC_kwDOABII585jaEr0",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 160,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662824605,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, the serializer is serializing the `this` object; the `rebuild` object represents what the deserializer already knows when it has deserialized up to whatever has been serialized already.",
      "created_at": "2024-07-07T22:41:16Z",
      "updated_at": "2024-07-07T22:41:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667779316",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667779316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667979626",
      "pull_request_review_id": 2162243522,
      "id": 1667979626,
      "node_id": "PRRC_kwDOABII585ja1lq",
      "diff_hunk": "@@ -132,6 +132,7 @@ BITCOIN_CORE_H = \\\n   chainparamsseeds.h \\",
      "path": "src/Makefile.am",
      "position": 1,
      "original_position": 1,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": 1661222360,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-08T04:36:09Z",
      "updated_at": "2024-07-08T04:36:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667979626",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667979626"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980741",
      "pull_request_review_id": 2162245632,
      "id": 1667980741,
      "node_id": "PRRC_kwDOABII585ja13F",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": 48,
      "original_position": 43,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": 1661239839,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "From the perspective of a `DepGraph`, transactions are identified by their position in the entry vector (which matches their position in the `Cluster` they came from). `DepGraph`'s equality tests whether every transaction in every position matches; there is nothing else it knows about.\r\n\r\nI've added a comment to `DepGraph::operator==` to indicate it's primarily for testing.",
      "created_at": "2024-07-08T04:38:28Z",
      "updated_at": "2024-07-08T04:38:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667980741",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 48,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980882",
      "pull_request_review_id": 2162245813,
      "id": 1667980882,
      "node_id": "PRRC_kwDOABII585ja15S",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: O(1) (amortized, due to resizing of backing vector).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();",
      "path": "src/cluster_linearize.h",
      "position": 136,
      "original_position": 130,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "2ab345e52c55590c489dcdc1a1945f123d692a44",
      "in_reply_to_id": 1662746393,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added an `Assume` for that.",
      "created_at": "2024-07-08T04:38:39Z",
      "updated_at": "2024-07-08T04:38:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667980882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 136,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980947",
      "pull_request_review_id": 2162245908,
      "id": 1667980947,
      "node_id": "PRRC_kwDOABII585ja16T",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 79,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662798441,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-08T04:38:45Z",
      "updated_at": "2024-07-08T04:38:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667980947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667980947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981357",
      "pull_request_review_id": 2162246612,
      "id": 1667981357,
      "node_id": "PRRC_kwDOABII585ja2At",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 176,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662822694,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've pushed this simplification; it works a lot different now, but `CanAddDependency`, `GetReducedParents`, and  `GetReducedChildren` are gone.",
      "created_at": "2024-07-08T04:39:27Z",
      "updated_at": "2024-07-08T04:39:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981357",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981485",
      "pull_request_review_id": 2162246858,
      "id": 1667981485,
      "node_id": "PRRC_kwDOABII585ja2Ct",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 102,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662836077,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's gone.",
      "created_at": "2024-07-08T04:39:40Z",
      "updated_at": "2024-07-08T04:39:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981485",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981485"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981720",
      "pull_request_review_id": 2162247252,
      "id": 1667981720,
      "node_id": "PRRC_kwDOABII585ja2GY",
      "diff_hunk": "@@ -0,0 +1,80 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);\n+\n+    // Test that deserializing that encoding yields depgraph.\n+    SpanReader reader(encoding);\n+    DepGraph<SetType> depgraph_read;\n+    reader >> Using<DepGraphFormatter>(depgraph_read);\n+    BOOST_CHECK(depgraph == depgraph_read);\n+}\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(depgraph_ser_tests)\n+{\n+    // Empty cluster.\n+    TestDepGraphSerialization<TestBitSet>({}, \"00\");\n+\n+    // Transactions: A(fee=0,size=1).\n+    TestDepGraphSerialization<TestBitSet>({{{0, 1}, {}}}, \"010000\");\n+\n+    // Transactions: A(fee=42,size=11), B(fee=-13,size=7), B depends on A.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{42, 11}, {}}, {{-13, 7}, {0}}},\n+        \"0b5407190100\");",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": null,
      "original_position": 64,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662861895,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "With the format change, I've documented every byte of the encoding in the tests here.",
      "created_at": "2024-07-08T04:40:07Z",
      "updated_at": "2024-07-08T04:40:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981720",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981720"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981849",
      "pull_request_review_id": 2162247446,
      "id": 1667981849,
      "node_id": "PRRC_kwDOABII585ja2IZ",
      "diff_hunk": "@@ -0,0 +1,80 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <test/util/cluster_linearize.h>\n+#include <test/util/setup_common.h>\n+#include <util/bitset.h>\n+#include <util/strencodings.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(cluster_linearize_tests, BasicTestingSetup)\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+template<typename SetType>\n+void TestDepGraphSerialization(const Cluster<SetType>& cluster, const std::string& hexenc)\n+{\n+    DepGraph depgraph(cluster);\n+\n+    // Test that depgraph has all the fees/sizes/parents required by cluster.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        BOOST_CHECK(depgraph.FeeRate(i) == cluster[i].first);\n+        for (ClusterIndex par : cluster[i].second) {\n+            BOOST_CHECK(depgraph.Ancestors(i)[par]);\n+            BOOST_CHECK(depgraph.Descendants(par)[i]);\n+        }\n+    }\n+\n+    // Run normal sanity checks on depgraph.\n+    SanityCheck(depgraph);\n+\n+    // Test that the serialization of depgraph matches hexenc.\n+    std::vector<unsigned char> encoding;\n+    VectorWriter writer(encoding, 0);\n+    writer << Using<DepGraphFormatter>(depgraph);\n+    BOOST_CHECK_EQUAL(HexStr(encoding), hexenc);\n+\n+    // Test that deserializing that encoding yields depgraph.\n+    SpanReader reader(encoding);\n+    DepGraph<SetType> depgraph_read;\n+    reader >> Using<DepGraphFormatter>(depgraph_read);\n+    BOOST_CHECK(depgraph == depgraph_read);\n+}\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(depgraph_ser_tests)\n+{\n+    // Empty cluster.\n+    TestDepGraphSerialization<TestBitSet>({}, \"00\");\n+\n+    // Transactions: A(fee=0,size=1).\n+    TestDepGraphSerialization<TestBitSet>({{{0, 1}, {}}}, \"010000\");\n+\n+    // Transactions: A(fee=42,size=11), B(fee=-13,size=7), B depends on A.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{42, 11}, {}}, {{-13, 7}, {0}}},\n+        \"0b5407190100\");\n+\n+    // Transactions: A(64,128), B(128,256), C(1,1), C depends on A and B.\n+    TestDepGraphSerialization<TestBitSet>(\n+        {{{64, 128}, {}}, {{128, 256}, {}}, {{1, 1}, {0, 1}}},\n+        \"8000800081008100000102010100\");\n+\n+    // Transactions: A(-58,113), B(36,114), C(-59,115), D(37,116). Deps: B->A, C->A, D->C, in order",
      "path": "src/test/cluster_linearize_tests.cpp",
      "position": null,
      "original_position": 71,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662966890,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch, fixed.",
      "created_at": "2024-07-08T04:40:17Z",
      "updated_at": "2024-07-08T04:40:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981849",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981943",
      "pull_request_review_id": 2162247601,
      "id": 1667981943,
      "node_id": "PRRC_kwDOABII585ja2J3",
      "diff_hunk": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_CLUSTER_LINEARIZE_H",
      "path": "src/cluster_linearize.h",
      "position": 5,
      "original_position": 1,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ca6f49dd0de718d1e29060e2ef2f0d6a48f7dcc4",
      "in_reply_to_id": 1664704882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-08T04:40:25Z",
      "updated_at": "2024-07-08T04:40:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667981943",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667981943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5,
      "original_line": 5,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667982100",
      "pull_request_review_id": 2162247783,
      "id": 1667982100,
      "node_id": "PRRC_kwDOABII585ja2MU",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 51,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "e27797600418ffc2d7ecf70134d7fcc778204d85",
      "in_reply_to_id": 1666706550,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment.",
      "created_at": "2024-07-08T04:40:34Z",
      "updated_at": "2024-07-08T04:40:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1667982100",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1667982100"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668526162",
      "pull_request_review_id": 2118340933,
      "id": 1668526162,
      "node_id": "PRRC_kwDOABII585jc7BS",
      "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/cluster_linearize.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    Cluster<TestBitSet> cluster(num_tx, std::pair{FeeFrac{0, 1}, TestBitSet{}});\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and depgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, TestBitSet::Size() * TestBitSet::Size()) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4b1e978b2bafd9da564aa52d2ce64a723cf64036",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4b1e978b2bafd9da564aa52d2ce64a723cf64036 nit:\r\n```suggestion\r\n    // Verify that any graph of transactions has its ancestry correctly computed by DepGraph, and if\r\n```",
      "created_at": "2024-07-08T12:21:40Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668526162",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668526162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668545670",
      "pull_request_review_id": 2118340933,
      "id": 1668545670,
      "node_id": "PRRC_kwDOABII585jc_yG",
      "diff_hunk": "@@ -163,6 +164,110 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.IsSubsetOf(m_todo));",
      "path": "src/cluster_linearize.h",
      "position": 476,
      "original_position": 87,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334\r\nmay be helpful context\r\n```suggestion\r\n        // Never MarkDone the same transaction more than once as this function\r\n        // blindly subtracts the transaction's feerate from m_ancestor_set_feerates\r\n        Assume(select.IsSubsetOf(m_todo));\r\n```",
      "created_at": "2024-07-08T12:33:11Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668545670",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668545670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 476,
      "original_line": 476,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668665030",
      "pull_request_review_id": 2118340933,
      "id": 1668665030,
      "node_id": "PRRC_kwDOABII585jdc7G",
      "diff_hunk": "@@ -163,6 +164,110 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;",
      "path": "src/cluster_linearize.h",
      "position": 433,
      "original_position": 47,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For each of the `CandidateFinder`s, would it be helpful to expose a `AllDone()` function? Seems slightly inconvenient for the caller to separately keep track of `todo` for a `while(todo.Any())` loop. `FindCandidateSet()` Assumes that todo isn't empty, so we can't use that to query.",
      "created_at": "2024-07-08T13:44:59Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668665030",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668665030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 433,
      "original_line": 433,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668712676",
      "pull_request_review_id": 2163448624,
      "id": 1668712676,
      "node_id": "PRRC_kwDOABII585jdojk",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": 1649205112,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually, all this code is gone now.",
      "created_at": "2024-07-08T14:09:54Z",
      "updated_at": "2024-07-08T14:09:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668712676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668712676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668716016",
      "pull_request_review_id": 2118340933,
      "id": 1668716016,
      "node_id": "PRRC_kwDOABII585jdpXw",
      "diff_hunk": "@@ -268,6 +288,155 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone().\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called to perform a search\n+ * over the set of topologically-valid subsets of that remainder, with a limit on how many\n+ * combinations are tried.\n+ */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster (which must\n+     *  be non-empty).\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept",
      "path": "src/cluster_linearize.h",
      "position": 573,
      "original_position": 90,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "5661fcdb15244bc6d602379c294276c7ec686505",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note to reviewers: pseudocode for the function when first introduced in 5661fcdb15244bc6d602379c294276c7ec686505 can be found [here](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-21-searching-6)",
      "created_at": "2024-07-08T14:11:26Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668716016",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668716016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 573,
      "original_line": 573,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668724062",
      "pull_request_review_id": 2118340933,
      "id": 1668724062,
      "node_id": "PRRC_kwDOABII585jdrVe",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 86,
      "original_position": 100,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649259334,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "And I suppose it's not problematic if it is optimal but didn't claim to be so?",
      "created_at": "2024-07-08T14:15:30Z",
      "updated_at": "2024-07-08T15:34:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1668724062",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668724062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669007098",
      "pull_request_review_id": 2163929984,
      "id": 1669007098,
      "node_id": "PRRC_kwDOABII585jewb6",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 86,
      "original_position": 100,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649259334,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm assuming that it's only used for stronger invariants checks in the fuzz/test harness",
      "created_at": "2024-07-08T17:15:03Z",
      "updated_at": "2024-07-08T17:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669007098",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669007098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669189198",
      "pull_request_review_id": 2164222586,
      "id": 1669189198,
      "node_id": "PRRC_kwDOABII585jfc5O",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+#define BITCOIN_TEST_UTIL_CLUSTER_LINEARIZE_H\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    /** Test whether adding a dependency between parent and child is valid and meaningful. */\n+    template<typename SetType>\n+    static bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // If child is already an ancestor of parent, the dependency would cause a cycle. Without\n+        // this condition, it would be possible for DepGraphFormatter to deserialize to a cyclic\n+        // graph.\n+        if (depgraph.Ancestors(parent)[child]) return false;\n+        // If child is already a descendant of parent, the dependency would be redundant. This is\n+        // an optimization whose goal is maximizing the probability to changes to the encoding map\n+        // to semantically distinct graphs.\n+        if (depgraph.Descendants(parent)[child]) return false;\n+        // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+        // that dependency will have been redundant if a dependency between parent and child is\n+        // added. This is also just an optimization.\n+        const auto& descendants = depgraph.Descendants(child);\n+        for (auto i : depgraph.Ancestors(parent)) {\n+            if (descendants.Overlaps(depgraph.Descendants(i))) {\n+                if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */",
      "path": "src/test/util/cluster_linearize.h",
      "position": null,
      "original_position": 160,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "ecfbe2ce7a831117c59218c61c201c8ee86e727c",
      "in_reply_to_id": 1662824605,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This code is gone.",
      "created_at": "2024-07-08T19:38:30Z",
      "updated_at": "2024-07-08T19:38:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669189198",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669189198"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669280166",
      "pull_request_review_id": 2164363044,
      "id": 1669280166,
      "node_id": "PRRC_kwDOABII585jfzGm",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 88,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": 1639799588,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've changed it to \"Find the best (highest-feerate, smallest among those in case of a tie) ancestor set among the remaining transactions.\", because \"best\" is a bit more specific than highest-feerate.\r\n\r\nRegarding the side note: that rule in `BlockAssembler` is an optimization, as it avoids looking at child transactions with higher ancestor feerate, because the ancestors will have been picked earlier anyway. The same optimization could be made in `AncestorCandidateFinder`, but because it's an $\\mathcal{O}(n)$ algorithm that iterates over all transactions once anyway, there is nothing to be gained from doing so.",
      "created_at": "2024-07-08T20:40:14Z",
      "updated_at": "2024-07-08T20:40:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669280166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669280166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 339,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669281361",
      "pull_request_review_id": 2164364747,
      "id": 1669281361,
      "node_id": "PRRC_kwDOABII585jfzZR",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 116,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": 1644451932,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a comment that inc needs to be topological (a term which is defined in the `WorkItem` definition above).",
      "created_at": "2024-07-08T20:41:01Z",
      "updated_at": "2024-07-08T20:41:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669281361",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669281361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 449,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669281468",
      "pull_request_review_id": 2164364940,
      "id": 1669281468,
      "node_id": "PRRC_kwDOABII585jfza8",
      "diff_hunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/cluster_linearize.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    Cluster<TestBitSet> cluster(num_tx, std::pair{FeeFrac{0, 1}, TestBitSet{}});\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and depgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, TestBitSet::Size() * TestBitSet::Size()) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "4b1e978b2bafd9da564aa52d2ce64a723cf64036",
      "in_reply_to_id": 1668526162,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-07-08T20:41:06Z",
      "updated_at": "2024-07-08T20:41:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669281468",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669281468"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669282068",
      "pull_request_review_id": 2164365793,
      "id": 1669282068,
      "node_id": "PRRC_kwDOABII585jfzkU",
      "diff_hunk": "@@ -163,6 +164,110 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                Assume(!anc_feerate.IsEmpty());\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        Assume(select.IsSubsetOf(m_todo));",
      "path": "src/cluster_linearize.h",
      "position": 476,
      "original_position": 87,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334",
      "in_reply_to_id": 1668545670,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a short comment to the docstring of the function instead.",
      "created_at": "2024-07-08T20:41:30Z",
      "updated_at": "2024-07-08T20:41:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669282068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669282068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 476,
      "original_line": 476,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669283836",
      "pull_request_review_id": 2164368522,
      "id": 1669283836,
      "node_id": "PRRC_kwDOABII585jfz_8",
      "diff_hunk": "@@ -163,6 +164,110 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set.\n+ *\n+ * It is initialized for an entire DepGraph, and parts of the graph can be dropped by calling\n+ * MarkDone.\n+ *\n+ * As long as any part of the graph remains, FindCandidateSet() can be called which will return a\n+ * SetInfo with the highest-feerate ancestor set that remains (an ancestor set is a single\n+ * transaction together with all its remaining ancestors).\n+ */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;",
      "path": "src/cluster_linearize.h",
      "position": 433,
      "original_position": 47,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "304d3cb23ba9f084b98f9f29b47e3dfbb61ca334",
      "in_reply_to_id": 1668665030,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, good idea. Avoiding a separate copy `m_todo` in `Linearize` forced me to rewrite some of the code, which turned out to simplify the LIMO logic slightly.",
      "created_at": "2024-07-08T20:42:44Z",
      "updated_at": "2024-07-08T20:42:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669283836",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669283836"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 433,
      "original_line": 433,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669288946",
      "pull_request_review_id": 2164376301,
      "id": 1669288946,
      "node_id": "PRRC_kwDOABII585jf1Py",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 86,
      "original_position": 100,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": 1649259334,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@glozow Indeed. Even if this function was changed to return an explicit `optimal`, it would remain quite possible that it returns the optimal without *knowing* it's optimal (because it's possible that the `best` passed in for example was already optimal, but it requires a ton of iterations to exhaust the search space to prove nothing better exists).\r\n\r\n@instagibbs Well I think we may want to cache in the mempool clusters whether or not the linearization for them is known to be optimal too, so that a hypothetical background cluster-improver thread could know to skip it.",
      "created_at": "2024-07-08T20:46:19Z",
      "updated_at": "2024-07-08T20:46:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1669288946",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1669288946"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1671191613",
      "pull_request_review_id": 2167425998,
      "id": 1671191613,
      "node_id": "PRRC_kwDOABII585jnFw9",
      "diff_hunk": "@@ -527,6 +563,24 @@ std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>\n \n         if (iterations_done_now == max_iterations_now) {\n             optimal = false;\n+            // If the search result is not (guaranteed to be) optimal, run intersections to make\n+            // sure we don't pick something that makes us unable to reach further diagram points\n+            // of the old linearization.\n+            if (best.transactions != best_prefix.transactions) {",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 95,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": 1652960236,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032",
      "created_at": "2024-07-09T20:20:05Z",
      "updated_at": "2024-07-09T20:20:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1671191613",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1671191613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 687,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1672749601",
      "pull_request_review_id": 2169903436,
      "id": 1672749601,
      "node_id": "PRRC_kwDOABII585jtCIh",
      "diff_hunk": "@@ -0,0 +1,644 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/cluster_linearize.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+\n+/** A simple finder class for candidate sets.\n+ *\n+ * This class matches SearchCandidateFinder in interface and behavior, though with fewer\n+ * optimizations.\n+ */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Determine whether unlinearized transactions remain. */\n+    bool AllDone() const noexcept { return m_todo.None(); }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto split : und) {\n+                // If inc is empty, consider any split transaction. Otherwise only consider\n+                // transactions that share ancestry with inc so far (which means only connected\n+                // sets will be considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(split))) {\n+                    // Add a queue entry with split included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(split)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with split excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(split));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};\n+    }\n+};\n+\n+/** A very simple finder class for optimal candidate sets, which tries every subset.\n+ *\n+ * It is even simpler than SimpleCandidateFinder, and is primarily included here to test the\n+ * correctness of SimpleCandidateFinder, which is then used to test the correctness of\n+ * SearchCandidateFinder.\n+ */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an ExhaustiveCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Determine whether unlinearized transactions remain. */\n+    bool AllDone() const noexcept { return m_todo.None(); }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple linearization algorithm.\n+ *\n+ * This matches Linearize() in interface and behavior, though with fewer optimizations, lacking\n+ * the ability to pass in an existing linearization, and using just SimpleCandidateFinder rather\n+ * than AncestorCandidateFinder and SearchCandidateFinder.\n+ */\n+template<typename SetType>\n+std::pair<std::vector<ClusterIndex>, bool> SimpleLinearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations)\n+{\n+    std::vector<ClusterIndex> linearization;\n+    SimpleCandidateFinder finder(depgraph);\n+    SetType todo = SetType::Fill(depgraph.TxCount());\n+    bool optimal = true;\n+    while (todo.Any()) {\n+        auto [candidate, iterations_done] = finder.FindCandidateSet(max_iterations);\n+        if (iterations_done == max_iterations) optimal = false;\n+        depgraph.AppendTopo(linearization, candidate.transactions);\n+        todo -= candidate.transactions;\n+        finder.MarkDone(candidate.transactions);\n+        max_iterations -= iterations_done;\n+    }\n+    return {std::move(linearization), optimal};\n+}\n+\n+/** Stitch connected components together in a DepGraph, guaranteeing its corresponding cluster is connected. */\n+template<typename BS>\n+void MakeConnected(DepGraph<BS>& depgraph)\n+{\n+    auto todo = BS::Fill(depgraph.TxCount());\n+    auto comp = depgraph.FindConnectedComponent(todo);\n+    Assume(depgraph.IsConnected(comp));\n+    todo -= comp;\n+    while (todo.Any()) {\n+        auto nextcomp = depgraph.FindConnectedComponent(todo);\n+        Assume(depgraph.IsConnected(nextcomp));\n+        depgraph.AddDependency(comp.Last(), nextcomp.First());\n+        todo -= nextcomp;\n+        comp = nextcomp;\n+    }\n+}\n+\n+/** Given a dependency graph, and a todo set, read a topological subset of todo from reader. */\n+template<typename SetType>\n+SetType ReadTopologicalSet(const DepGraph<SetType>& depgraph, const SetType& todo, SpanReader& reader)\n+{\n+    uint64_t mask{0};\n+    try {\n+        reader >> VARINT(mask);\n+    } catch(const std::ios_base::failure&) {}\n+    SetType ret;\n+    for (auto i : todo) {\n+        if (!ret[i]) {\n+            if (mask & 1) ret |= depgraph.Ancestors(i);\n+            mask >>= 1;\n+        }\n+    }\n+    return ret & todo;\n+}\n+\n+/** Given a dependency graph, construct any valid linearization for it, reading from a SpanReader. */\n+template<typename BS>\n+std::vector<ClusterIndex> ReadLinearization(const DepGraph<BS>& depgraph, SpanReader& reader)\n+{\n+    std::vector<ClusterIndex> linearization;\n+    TestBitSet todo = TestBitSet::Fill(depgraph.TxCount());\n+    // In every iteration one topologically-valid transaction is appended to linearization.\n+    while (todo.Any()) {\n+        // Compute the set of transactions with no not-yet-included ancestors.\n+        TestBitSet potential_next;\n+        for (auto j : todo) {\n+            if ((depgraph.Ancestors(j) & todo) == TestBitSet::Singleton(j)) {\n+                potential_next.Set(j);\n+            }\n+        }\n+        // There must always be one (otherwise there is a cycle in the graph).\n+        assert(potential_next.Any());\n+        // Read a number from reader, and interpret it as index into potential_next.\n+        uint64_t idx{0};\n+        try {\n+            reader >> VARINT(idx);\n+        } catch (const std::ios_base::failure&) {}\n+        idx %= potential_next.Count();\n+        // Find out which transaction that corresponds to.\n+        for (auto j : potential_next) {\n+            if (idx-- == 0) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 223,
      "commit_id": "a00c1ca2405ca016cb3b807e1b5c4d7759efe420",
      "original_commit_id": "41e31ce727ebb80c083255f53e109fc413e2d39f",
      "in_reply_to_id": null,
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```\r\nRun clusterlin_chunking with args ['/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz', '-max_total_time=60']INFO: Running with entropic power schedule (0xFF, 100).\r\nINFO: Seed: 2800051321\r\nINFO: Loaded 1 modules   (625955 inline 8-bit counters): 625955 [0x556ead4c6938, 0x556ead55f65b), \r\nINFO: Loaded 1 PC tables (625955 PCs): 625955 [0x556ead55f660,0x556eadeec890), \r\nINFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes\r\nINFO: A corpus is not provided, starting from an empty corpus\r\n#2\tINITED cov: 101 ft: 102 corp: 1/1b exec/s: 0 rss: 112Mb\r\n\tNEW_FUNC[1/5]: 0x556eaa4369e0 in cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>>::AddTransaction(FeeFrac const&) src/./cluster_linearize.h:134\r\n\tNEW_FUNC[2/5]: 0x556eaa437100 in cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>>::Entry& std::vector<cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>>::Entry, std::allocator<cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>>::Entry>>::emplace_back<FeeFrac const&, bitset_detail::IntBitSet<unsigned int>, bitset_detail::IntBitSet<unsigned int>>(FeeFrac const&, bitset_detail::IntBitSet<unsigned int>&&, bitset_detail::IntBitSet<unsigned int>&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/vector.tcc:113\r\n#7\tNEW    cov: 130 ft: 137 corp: 2/3b lim: 4 exec/s: 0 rss: 112Mb L: 2/2 MS: 5 ChangeByte-CopyPart-ChangeBinInt-CrossOver-InsertByte-\r\n#8\tNEW    cov: 131 ft: 138 corp: 3/5b lim: 4 exec/s: 0 rss: 112Mb L: 2/2 MS: 1 InsertByte-\r\n#9\tNEW    cov: 132 ft: 139 corp: 4/7b lim: 4 exec/s: 0 rss: 112Mb L: 2/2 MS: 1 ChangeASCIIInt-\r\n#22\tNEW    cov: 132 ft: 143 corp: 5/10b lim: 4 exec/s: 0 rss: 112Mb L: 3/3 MS: 3 ChangeByte-ShuffleBytes-InsertByte-\r\n\tNEW_FUNC[1/3]: 0x556eaa1fb770 in void std::vector<unsigned int, std::allocator<unsigned int>>::_M_realloc_insert<unsigned int const&>(__gnu_cxx::__normal_iterator<unsigned int*, std::vector<unsigned int, std::allocator<unsigned int>>>, unsigned int const&) /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/vector.tcc:453\r\n\tNEW_FUNC[2/3]: 0x556eaa1fbed0 in std::vector<unsigned int, std::allocator<unsigned int>>::_M_check_len(unsigned long, char const*) const /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h:1897\r\n#27\tNEW    cov: 161 ft: 174 corp: 6/13b lim: 4 exec/s: 0 rss: 112Mb L: 3/3 MS: 5 ChangeBit-ChangeByte-CopyPart-CopyPart-ChangeByte-\r\n#36\tNEW    cov: 162 ft: 175 corp: 7/15b lim: 4 exec/s: 0 rss: 112Mb L: 2/3 MS: 4 ChangeBit-CrossOver-ChangeBit-ChangeBinInt-\r\n#44\tNEW    cov: 162 ft: 179 corp: 8/19b lim: 4 exec/s: 0 rss: 112Mb L: 4/4 MS: 3 ChangeBit-ChangeBit-CopyPart-\r\n#49\tNEW    cov: 162 ft: 180 corp: 9/23b lim: 4 exec/s: 0 rss: 112Mb L: 4/4 MS: 5 ShuffleBytes-CrossOver-ShuffleBytes-ChangeByte-ShuffleBytes-\r\n#52\tNEW    cov: 162 ft: 182 corp: 10/27b lim: 4 exec/s: 0 rss: 112Mb L: 4/4 MS: 3 InsertByte-CrossOver-CrossOver-\r\n#55\tNEW    cov: 173 ft: 196 corp: 11/31b lim: 4 exec/s: 0 rss: 112Mb L: 4/4 MS: 3 ChangeByte-CrossOver-CMP- DE: \"\\000\\000\\000\\000\"-\r\ntest/fuzz/cluster_linearize.cpp:223:20: runtime error: unsigned integer overflow: 0 - 1 cannot be represented in type 'uint64_t' (aka 'unsigned long')\r\n    #0 0x556eaa4203ed in std::vector<unsigned int, std::allocator<unsigned int>> (anonymous namespace)::ReadLinearization<bitset_detail::IntBitSet<unsigned int>>(cluster_linearize::DepGraph<bitset_detail::IntBitSet<unsigned int>> const&, SpanReader&) src/test/fuzz/cluster_linearize.cpp:223:20\r\n    #1 0x556eaa41e849 in clusterlin_chunking_fuzz_target(std::span<unsigned char const, 18446744073709551615ul>) src/test/fuzz/cluster_linearize.cpp:356:26\r\n    #2 0x556eaa96888d in std::function<void (std::span<unsigned char const, 18446744073709551615ul>)>::operator()(std::span<unsigned char const, 18446744073709551615ul>) const /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h:591:9\r\n    #3 0x556eaa96888d in LLVMFuzzerTestOneInput src/test/fuzz/fuzz.cpp:209:5\r\n    #4 0x556eaa033534 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c02534) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #5 0x556eaa032c29 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c01c29) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #6 0x556eaa034415 in fuzzer::Fuzzer::MutateAndTestOne() (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c03415) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #7 0x556eaa034f75 in fuzzer::Fuzzer::Loop(std::vector<fuzzer::SizedFile, std::allocator<fuzzer::SizedFile>>&) (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c03f75) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #8 0x556eaa02224f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1bf124f) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #9 0x556eaa04c8d6 in main (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1c1b8d6) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n    #10 0x7fae2899a1c9  (/lib/x86_64-linux-gnu/libc.so.6+0x2a1c9) (BuildId: 08134323d00289185684a4cd177d202f39c2a5f3)\r\n    #11 0x7fae2899a28a in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2a28a) (BuildId: 08134323d00289185684a4cd177d202f39c2a5f3)\r\n    #12 0x556eaa017234 in _start (/ci_container_base/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/test/fuzz/fuzz+0x1be6234) (BuildId: 4f2fa2987d9f90b866b2491be1f80d23e1cce505)\r\n\r\nSUMMARY: UndefinedBehaviorSanitizer: unsigned-integer-overflow test/fuzz/cluster_linearize.cpp:223:20 \r\nMS: 4 ChangeByte-EraseBytes-CMP-CopyPart- DE: \"\\003\\000\"-; base unit: e5dc0d414ce7dc334d19fc3ca66d8e4d4272b8cd\r\n0x1,0x3,0x0,0x0,\r\n\\001\\003\\000\\000\r\nartifact_prefix='./'; Test unit written to ./crash-275df7aaf0e8504be8fb5e3fbcd9b1be65e65326\r\nBase64: AQMAAA==",
      "created_at": "2024-07-10T18:12:30Z",
      "updated_at": "2024-07-10T18:12:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1672749601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1672749601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    }
  ]
}