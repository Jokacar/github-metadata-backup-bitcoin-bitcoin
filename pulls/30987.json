{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30987",
    "id": 2094697569,
    "node_id": "PR_kwDOABII58582oxh",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30987",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30987.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30987.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30987",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30987/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30987/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30987/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/d90eb00d8b33a3839b113acbbbb7d9e58cffb148",
    "number": 30987,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Don't zero-after-free `DataStream`: ~25% faster IBD",
    "user": {
      "login": "davidgumberg",
      "id": 2257631,
      "node_id": "MDQ6VXNlcjIyNTc2MzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidgumberg",
      "html_url": "https://github.com/davidgumberg",
      "followers_url": "https://api.github.com/users/davidgumberg/followers",
      "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
      "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
      "repos_url": "https://api.github.com/users/davidgumberg/repos",
      "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This PR modifies `DataStream`'s vector ` to use the default allocator `std::allocator` rather than `zero_after_free_allocator` which causes a major degradation to performance. The `zero_after_free_allocator` is identical to the default `std::allocator` except that it zeroes memory using `memory_cleanse()` before deallocating.\r\n\r\nThis PR also drops the `zero_after_free_allocator`, since this was only used by `DataStream` and `SerializeData`, \r\n\r\nIn my testing (n=2) on a Raspberry Pi 5 with 4GB of memory, syncing from a fast connection to a stable dedicated node, my branch takes **~74%** of the time taken by master[^1] to sync to height 815,000; average wall clock time was 35h 58m 40s on this branch and 48h 17m 15s on master, see the benchmarking appendix for more detail.\r\n\r\nI believe the speedup mainly comes from the use of `DataStream` for all `CDBWrapper` keys and values, and for all of the data we receive from peers. I suspect there are other use cases where performance is improved, but I have not done much testing outside of IBD.\r\n\r\nAny objects that contains secrets should *not* be allocated using `zero_after_free_allocator` since they are liable to get mapped to swap space and written to disk if the user is running low on memory, and I intuit this is a likelier path than scanning unzero'd memory for an attacker to find cryptographic secrets. Secrets should be allocated using `secure_allocator` which cleanses on deallocation and `mlock()`s the memory reserved for secrets to prevent it from being mapped to swap space.\r\n\r\n## Are any secrets stored in `DataStream` that will lose security?\r\n\r\nI have reviewed every appearance of `DataStream` and `SerializeData` as of [`39219fe`](https://github.com/bitcoin/bitcoin/commit/39219fe145e5e6e6f079b591e3f4b5fea8e718040) and have made notes in the appendix below with notes that provide context for each instance where either is used.\r\n\r\nThe only use case that I wasn't certain of is PSBT's, I believe these are never secrets, but I don't know enough about to know if there are use cases where PSBT's are worthy of being treated as secrets, and being vigilant about not writing them to disk is wise.\r\n\r\nAs I understand, most of the use of `DataStream` in the wallet code is for the reading and writing of \"crypted\" key and value data, and they get decrypted somewhere else in a `ScriptPubKeyMan` far away from any `DataStream` container, but I could also be wrong about this, or have misunderstood it's use elsewhere in the wallet.\r\n\r\n## Zero-after-free as a buffer overflow mitigation\r\n\r\nThe `zero_after_free` allocator was added as a buffer overflow mitigation, the idea being that `DataStream`'s store a lot of unsecured data that we don't control like the UTXO set and all P2P messages, and an attacker could fill memory in a predictable way to escalate a buffer overflow into an RCE. (See Historical Background in the Appendix).\r\n\r\nI agree completely with practicing security in depth, but I don't think this mitigation is worth the performance hit because: \r\n\r\n1. Aren't there still an abundance of other opportunities for an attacker to fill memory that never gets deallocated?\r\n2. Doesn't ASLR mostly mitigate this issue and don't most devices have some form of ASLR?\r\n\r\nI'm not a security expert and I had a hard time finding any writing anywhere that discusses this particular mitigation strategy of zeroing memory, so I hope someone with more knowledge of memory vulnerabilities can assist.\r\n\r\n----------\r\n\r\n#### Other notes\r\n\r\n- I opted to leave `SerializeData` as `std::vector<std::byte>` instead of deleting it and refactoring in the spots where it's used in the wallet to keep the PR small, if others think it would be better to delete it I would be happy to do it.\r\n- I have a feeling that it's not just that we're memsetting everything to 0 in `memory_cleanse` that is causing the performance issue, but the trick we do to prevent compilers from optimizing out the `memset` call is also preventing other optimizations on the `DataStream`'s, but I have yet to test this.\r\n-  I also make a small change to a unit test where boost mysteriously fails to find a left shift-operator for `SerializeData` once it loses its custom allocator.\r\n\r\n----------\r\n\r\n## Appendices\r\n\r\n<details>\r\n\r\n<summary>\r\n\r\n### Benchmarks\r\n\r\n</summary>\r\n\r\nCommand being timed:\r\n```bash\r\n./src/bitcoind -daemon=0 -connect=amd-ryzen-7900x-node:8333 -stopatheight=815000 -port=8444 -rpcport=8445 -dbcache=2048 -prune=550 -debug=bench -debug=blockstorage -debug=coindb -debug=mempool -debug=prune\"\r\n```\r\n\r\nI applied my branch on\r\n[6d546336e800](https://github.com/bitcoin/bitcoin/commit/6d546336e800), which is\r\n\"master\" in the data below.\r\n\r\nAverage master time (hh:mm:ss): 48:17:15 (173835s)\r\nAverage branch time (hh:mm:ss): 35:58:40 (129520s)\r\n\r\n~25% reduction in IBD time on a raspberry Pi 5 with a DB cache of 2GB.\r\n\r\n#### Master run 1\r\nWall clock time (hh:mm:ss): 49:38:31 (178711s)\r\n\r\n```console\r\nBitcoin Core version v27.99.0-6d546336e800 (release build)\r\n- Connect block: 158290.53s (620.94ms/blk)\r\n    - Sanity checks: 10.89s (0.01ms/blk)\r\n    - Fork checks: 151.82s (0.02ms/blk)\r\n    - Verify 7077 txins: 135057.68s (165.71ms/blk)\r\n      - Connect 1760 transactions: 134786.36s (165.38ms/blk)\r\n    - Write undo data: 2681.34s (7.38ms/blk)\r\n    - Index writing: 52.76s (0.03ms/blk)\r\n  - Connect total: 138100.75s (611.27ms/blk)\r\n  - Flush: 3933.29s (8.97ms/blk)\r\n  - Writing chainstate: 15814.36s (0.14ms/blk)\r\n  - Connect postprocess: 273.39s (0.52ms/blk)\r\n```\r\n\r\n#### Master run 2\r\nWall clock time (hh:mm:ss): 46:55:58 (168958s)\r\n\r\n```\r\nBitcoin Core version v27.99.0-6d546336e800 (release build)\r\n- Connect block: 145449.95s (940.78ms/blk)\r\n    - Sanity checks: 10.69s (0.01ms/blk)\r\n    - Fork checks: 155.81s (0.02ms/blk)\r\n    - Verify 7077 txins: 115935.55s (142.25ms/blk)\r\n      - Connect 1760 transactions: 115481.15s (141.69ms/blk)\r\n    - Write undo data: 2561.36s (9.05ms/blk)\r\n    - Index writing: 73.63s (0.04ms/blk)\r\n  - Connect total: 118877.56s (929.93ms/blk)\r\n  - Flush: 3864.34s (10.11ms/blk)\r\n  - Writing chainstate: 22294.82s (0.14ms/blk)\r\n  - Connect postprocess: 267.68s (0.56ms/blk)\r\n```\r\n\r\n#### Branch run 1\r\nWall clock time (hh:mm:ss): 34:28:56 (124136s)\r\n\r\n```\r\nBitcoin Core version v27.99.0-a0dddf8b4092 (release build)\r\n- Connect block: 107134.59s (1017.01ms/blk)\r\n    - Sanity checks: 11.01s (0.01ms/blk)\r\n    - Fork checks: 150.93s (0.03ms/blk)\r\n    - Verify 7077 txins: 87446.53s (107.30ms/blk)\r\n      - Connect 1760 transactions: 87329.99s (107.15ms/blk)\r\n    - Write undo data: 2495.47s (7.36ms/blk)\r\n    - Index writing: 37.95s (0.04ms/blk)\r\n  - Connect total: 90318.60s (1006.42ms/blk)\r\n  - Flush: 3917.28s (9.92ms/blk)\r\n  - Writing chainstate: 12560.43s (0.15ms/blk)\r\n  - Connect postprocess: 259.89s (0.47ms/blk)\r\n```\r\n\r\n#### Branch run 2\r\nWall clock time (hh:mm:ss): 37:28:24 (134904s)\r\n\r\n```\r\nBitcoin Core version v27.99.0-a0dddf8b4092 (release build)\r\n- Connect block: 117991.55s (144.77ms/blk)\r\n  - Connect total: 101298.20s (124.29ms/blk)\r\n    - Sanity checks: 11.17s (0.01ms/blk)\r\n    - Fork checks: 151.24s (0.19ms/blk)\r\n    - Verify 7077 txins: 98446.38s (120.79ms/blk)\r\n      - Connect 1760 transactions: 98339.79s (120.66ms/blk)\r\n    - Write undo data: 2484.75s (3.05ms/blk)\r\n    - Index writing: 36.62s (0.04ms/blk)\r\n  - Flush: 3892.28s (4.78ms/blk)\r\n  - Writing chainstate: 12446.33s (15.27ms/blk)\r\n  - Connect postprocess: 259.11s (0.32ms/blk)\r\n```\r\n</details>\r\n\r\n<details>\r\n\r\n<summary>\r\n\r\n### Historical background\r\n\r\n</summary>\r\n\r\nAt some point prior to the oldest git commit for the repo, an allocator `secure_allocator` was [added](https://github.com/bitcoin/bitcoin/blob/0a61b0df1224a5470bcddab302bc199ca5a9e356/serialize.h#L675-L702) that zeroes out memory on deallocation with `memset()`, and was [used](https://github.com/bitcoin/bitcoin/blob/0a61b0df1224a5470bcddab302bc199ca5a9e356/serialize.h#L711-L714) as the allocator for the vector `vch` in `CDataStream` (now `DataStream`).\r\n\r\nIn July 2011, PR [#352](https://github.com/bitcoin/bitcoin/pull/352) adding support for encrypted wallets `secure_allocator` was [modified](https://github.com/bitcoin/bitcoin/pull/352/commits/c1aacf0be347b10a6ab9bbce841e8127412bce41) to also `mlock()` data on allocation to prevent the wallet passphrase or other secrets from being paged to swap space (written to disk).\r\n\r\nIn January 2012, findings were shared (https://bitcointalk.org/index.php?topic=56491.0) that [#352](https://github.com/bitcoin/bitcoin/pull/352) modifying `CDataStream`'s allocator slowed down IBD substantially[^2], since `CDataStream` was used in many places that did not need the guarantees of `mlock()`, and since every call to `mlock()` results in a flush of the TLB (a cache that maps virtual memory to physical memory).\r\n\r\nPR [#740](https://github.com/bitcoin/bitcoin/pull/740) was opened to fix this, initially[^3] by removing the custom allocator `secure_allocator` from `CDataStream`'s `vector_type`:\r\n\r\n```diff\r\n class CDataStream\r\n {\r\n protected:\r\n-    typedef std::vector<char, secure_allocator<char> > vector_type;\r\n+    typedef std::vector<char> vector_type;\r\n     vector_type vch;\r\n```\r\n\r\nA reviewer of [#740](https://github.com/bitcoin/bitcoin/pull/740) [suggested](https://github.com/bitcoin/bitcoin/pull/740#issuecomment-3356239) that dropping `mlock()` was a good idea, but that the original behavior of zeroing-after-freeing (should it be zeroing-*before*-freeing?) `CDataStream` should be restored as a mitigation for buffer overflows:\r\n\r\n> I love the performance improvement, but I still don't like the elimination of zero-after-free. Security in depth is important.\r\n>\r\n> Here's the danger:\r\n>\r\n> Attacker finds a remotely-exploitable buffer overrun somewhere in the networking code that crashes the process.\r\n> They turn the crash into a full remote exploit by sending carefully constructed packets before the crash packet, to initialize used-but-then-freed memory to a known state.\r\n>\r\n> Unlikely? Sure.\r\n>\r\n> Is it ugly to define a zero_after_free_allocator for CDataStream? Sure. (simplest implementation: copy secure_allocator, remove the mlock/munlock calls).\r\n>\r\n> But given that CDataStream is the primary interface between bitcoin and the network, I think being extra paranoid here is a very good idea.\r\n\r\nAnother reviewer benchmarked `CDataStream` with an allocator that zeroed memory using `memset` without `mlock`ing it and found that performance was almost identical to the default allocator, while both were substantially faster than the `mlock`ing variant of `CDataStream`. (https://web.archive.org/web/20130622160044/https://people.xiph.org/~greg/bitcoin-sync.png).\r\n\r\nBased on the benchmark, and the potential security benefit, the `zero_after_free` allocator was created and used as `CDataStream`'s allocator.\r\n\r\nIn November 2012, PR [#1992](https://github.com/bitcoin/bitcoin/pull/1992) was opened to address the fact that in many cases `memset()` calls are optimized away by compilers as part of a family of compiler optimizations called [dead store elimination](https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/yang) by replacing the `memset` call with openssl's `OPENSSL_cleanse` which is meant to solve this problem. Given that all of the data being zero'ed out in the deallocator is also having it's only pointer destroyed, these memset calls were candidates for being optimized.\r\n\r\nI suspect that the reason no performance regression was found in the benchmarking of [#740](https://github.com/bitcoin/bitcoin/pull/740) which introduced the `zero_after_free` allocator is that the `memset` calls were being optimized out.\r\n\r\nI am not the first to suggest that this is a performance issue:\r\n\r\nhttps://bitcoin-irc.chaincode.com/bitcoin-core-dev/2015-11-06#1446837840-1446854100;\r\n\r\nhttps://bitcoin-irc.chaincode.com/bitcoin-core-dev/2016-11-23#1479883620-1479882900;\r\n\r\nOr to write a patch changing it:\r\n\r\nhttps://github.com/bitcoin/bitcoin/commit/671c724716abdd69b9d253a01f8fec67a37ab7d7\r\n\r\n</details>\r\n\r\n<details>\r\n\r\n<summary>\r\n\r\n### All uses of DataStream and SerializeData\r\n( ⚠️ when opening: very long)\r\n\r\n</summary>\r\n\r\nI performed this review on commit [39219fe145e5e6e6f079b591e3f4b5fea8e71804](https://github.com/bitcoin/bitcoin/commit/39219fe145e5e6e6f079b591e3f4b5fea8e71804)\r\n\r\nI look, briefly, at every single use of `DataStream` outside of test code, to see whether or not it contains secret information that should be zeroed out, or should be mlocked to prevent paging to swap.\r\n\r\nI've taken liberties to editorialize some of the codeblocks below for legibility, and all comments that have `[]` are my own.\r\n\r\n##### `DataStream`\r\n\r\nIn `src/addrdb.cpp`+`src/addrdb.h`:\r\n\r\n```cpp\r\n/** Only used by tests. */\r\nvoid ReadFromStream(AddrMan& addr, DataStream& ssPeers);\r\n```\r\n\r\nOnly used by tests.\r\n\r\n-----\r\n\r\nIn `src/addrman.cpp` `Addrman::Serialize(DataStream&)` & `Unserialize(DataStream&)`, are explicitly instantiated, these are used in `SerializeFileDB` and `DeserializeDB` which are used to serialize (`DumpPeerAddresses`) addrman to disk, and to deserialize addrman from disk (`LoadAddrman`).\r\n\r\nThe most valuable secret seems to be addrman's `nKey` used to determine the address buckets randomly.\r\n\r\n-------\r\n\r\nIn `src/blockencodings.cpp`:\r\n\r\n```cpp\r\nvoid CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\r\n    DataStream stream{};\r\n    stream << header << nonce;\r\n    CSHA256 hasher;\r\n    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\r\n    uint256 shorttxidhash;\r\n    hasher.Finalize(shorttxidhash.begin());\r\n    shorttxidk0 = shorttxidhash.GetUint64(0);\r\n    shorttxidk1 = shorttxidhash.GetUint64(1);\r\n}\r\n```\r\n\r\nHere we are just using the DataStream to be able to Serialize the block header and nonce into a string of bytes that get hashed to make short id k0 and k1 for [BIP 152](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki#short-transaction-ids).\r\n\r\nThis gets invoked when we construct a `CBlockHeaderandShortTxIDs` for an INV of type `MSG_CMPCT_BLOCK` in `PeerManagerImpl::SendMessage()`.\r\n\r\n-------\r\n\r\nIn `src/common/blooms.cpp`:\r\n\r\nDataStream is used to deserialize outpoints into our bloom filter, these are not secrets in any way:\r\n\r\n```cpp\r\nvoid CBloomFilter::insert(const COutPoint& outpoint)\r\n{\r\n    DataStream stream{};\r\n    stream << outpoint;\r\n    insert(MakeUCharSpan(stream));\r\n}\r\n```\r\n\r\n-------\r\n\r\nIn `src/core_read.cpp`:\r\n\r\nDataStream is used in `DecodeTx` for serialization/deserialization of the transaction data, used afaict only in RPC's for deserializing user arguments into `CMutableTransaction`'s.\r\n\r\nIt's used in `DecodeHexBlockHeader()`which deserializes a block header argument into a `CBlockHeader` for the `submitheader` rpc.\r\n\r\nSimilar for `DecodeHexBlk()` used by the `getblocktemplate` and `submitblock` rpc's.\r\n\r\n----\r\n\r\nIn `src/core_write.cpp`:\r\n\r\n```cpp\r\nvoid CBloomFilter::insert(const COutPoint& outpoint)\r\n{\r\n    DataStream stream{};\r\n    stream << outpoint;\r\n    insert(MakeUCharSpan(stream));\r\n}\r\n```\r\n\r\n`EncodeHexTx` is only used in RPC's, and transaction data does not contain secrets.\r\n\r\n------\r\n\r\nIn `dbwrapper.h` and `dbwrapper.cpp` it is used exclusively to serialize and deserialize coinsdb keys and values, none of which is secret.\r\n\r\n--------\r\n\r\nIn `src/external_signer`:\r\n\r\n```cpp\r\nbool ExternalSigner::SignTransaction(PartiallySignedTransaction& psbtx, std::string& error)\r\n{\r\n    // Serialize the PSBT\r\n    DataStream ssTx{};\r\n    ssTx << psbtx;\r\n```\r\n\r\nI don't think this is a secret, but I don't know enough about PSBT's to be sure.\r\n\r\n-------\r\n\r\nThere is some scaffolding for being able to transmit serializable stuff over the IPC wire in `src/capnp/common-types.h`, I assume this depends on how it's used, nothing essentially secret.\r\n\r\n--------\r\n\r\nIn `src/kernel/coinstats.cpp`:\r\n\r\n```cpp\r\nvoid ApplyCoinHash(MuHash3072& muhash, const COutPoint& outpoint, const Coin& coin)\r\n{\r\n    DataStream ss{};\r\n    TxOutSer(ss, outpoint, coin);\r\n    muhash.Insert(MakeUCharSpan(ss));\r\n}\r\n```\r\n\r\nHere it's used for serializing oupoints and coins for creating the AssumeUTXO assumed utxo set hash, nothing secret.\r\n\r\n-------\r\n\r\nIn `src/net.cpp`:\r\n\r\nIn `ConvertSeeds()` serialized seeds get converted into usable address objects, we initialize a DataStream with the input seeds that we are going to try connecting to during node bootstrapping.\r\n\r\n```cpp\r\n//! Convert the serialized seeds into usable address objects.\r\nstatic std::vector<CAddress> ConvertSeeds(const std::vector<uint8_t> &vSeedsIn)\r\n{\r\n    // It'll only connect to one or two seed nodes because once it connects,\r\n    // it'll get a pile of addresses with newer timestamps.\r\n    // Seed nodes are given a random 'last seen time' of between one and two\r\n    // weeks ago.\r\n    const auto one_week{7 * 24h};\r\n    std::vector<CAddress> vSeedsOut;\r\n    FastRandomContext rng;\r\n    ParamsStream s{DataStream{vSeedsIn}, CAddress::V2_NETWORK};\r\n    while (!s.eof()) {\r\n        CService endpoint;\r\n        s >> endpoint;\r\n        CAddress addr{endpoint, SeedsServiceFlags()};\r\n        addr.nTime = rng.rand_uniform_delay(Now<NodeSeconds>() - one_week, -one_week);\r\n        LogDebug(BCLog::NET, \"Added hardcoded seed: %s\\n\", addr.ToStringAddrPort());\r\n        vSeedsOut.push_back(addr);\r\n    }\r\n    return vSeedsOut;\r\n}\r\n```\r\n\r\nIt is also used for creating an empty `CNetMessage` which has a `DataStream` member in `CNetMessage V2Transport::GetReceivedMessage()`:\r\n\r\n```cpp\r\n//! Convert the serialized seeds into usable address objects.\r\nstatic std::vector<CAddress> ConvertSeeds(const std::vector<uint8_t> &vSeedsIn)\r\n{\r\n    // It'll only connect to one or two seed nodes because once it connects,\r\n    // it'll get a pile of addresses with newer timestamps.\r\n    // Seed nodes are given a random 'last seen time' of between one and two\r\n    // weeks ago.\r\n    const auto one_week{7 * 24h};\r\n    std::vector<CAddress> vSeedsOut;\r\n    FastRandomContext rng;\r\n    ParamsStream s{DataStream{vSeedsIn}, CAddress::V2_NETWORK};\r\n    while (!s.eof()) {\r\n        CService endpoint;\r\n        s >> endpoint;\r\n        CAddress addr{endpoint, SeedsServiceFlags()};\r\n        addr.nTime = rng.rand_uniform_delay(Now<NodeSeconds>() - one_week, -one_week);\r\n        LogDebug(BCLog::NET, \"Added hardcoded seed: %s\\n\", addr.ToStringAddrPort());\r\n        vSeedsOut.push_back(addr);\r\n    }\r\n    return vSeedsOut;\r\n}\r\n```\r\n\r\n--------\r\n\r\nIn `net.h`\r\n\r\n`CNetMessage` the universal p2p message container used a `DataStream` to store received message data.\r\n\r\n```cpp\r\n/** Transport protocol agnostic message container.\r\n * Ideally it should only contain receive time, payload,\r\n * type and size.\r\n */\r\nclass CNetMessage\r\n{\r\npublic:\r\n    DataStream m_recv;                   //!< received message data\r\n    std::chrono::microseconds m_time{0}; //!< time of message receipt\r\n    uint32_t m_message_size{0};          //!< size of the payload\r\n    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\r\n    std::string m_type;\r\n\r\n    explicit CNetMessage(DataStream&& recv_in) : m_recv(std::move(recv_in)) {}\r\n    // Only one CNetMessage object will exist for the same message on either\r\n    // the receive or processing queue. For performance reasons we therefore\r\n    // delete the copy constructor and assignment operator to avoid the\r\n    // possibility of copying CNetMessage objects.\r\n    CNetMessage(CNetMessage&&) = default;\r\n    CNetMessage(const CNetMessage&) = delete;\r\n    CNetMessage& operator=(CNetMessage&&) = default;\r\n    CNetMessage& operator=(const CNetMessage&) = delete;\r\n};\r\n```\r\n\r\nIt's also used for the lower level handling of messages, including partially received header buffers and received socket data in `V1Transport` as in v2 transport above in `net.cpp`.\r\n\r\n```cpp\r\n/** Transport protocol agnostic message container.\r\n * Ideally it should only contain receive time, payload,\r\n * type and size.\r\n */\r\nclass CNetMessage\r\n{\r\npublic:\r\n    DataStream m_recv;                   //!< received message data\r\n    std::chrono::microseconds m_time{0}; //!< time of message receipt\r\n    uint32_t m_message_size{0};          //!< size of the payload\r\n    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\r\n    std::string m_type;\r\n\r\n    explicit CNetMessage(DataStream&& recv_in) : m_recv(std::move(recv_in)) {}\r\n    // Only one CNetMessage object will exist for the same message on either\r\n    // the receive or processing queue. For performance reasons we therefore\r\n    // delete the copy constructor and assignment operator to avoid the\r\n    // possibility of copying CNetMessage objects.\r\n    CNetMessage(CNetMessage&&) = default;\r\n    CNetMessage(const CNetMessage&) = delete;\r\n    CNetMessage& operator=(CNetMessage&&) = default;\r\n    CNetMessage& operator=(const CNetMessage&) = delete;\r\n};\r\n```\r\n\r\n--------\r\n\r\nIn `src/net_processing.cpp` it used for representing the received data when\r\nprocessing messages in the great `PeerManagerImpl::ProcessMessage()`:\r\n\r\n```cpp\r\nvoid PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type, DataStream& vRecv,\r\n                                     const std::chrono::microseconds time_received,\r\n                                     const std::atomic<bool>& interruptMsgProc)\r\n{\r\n```\r\n\r\nAnd for Processing BIP 157 cfilters: \r\n\r\n```cpp\r\n/**\r\n * Handle a cfilters request.\r\n *\r\n * May disconnect from the peer in the case of a bad request.\r\n *\r\n * @param[in]   node            The node that we received the request from\r\n * @param[in]   peer            The peer that we received the request from\r\n * @param[in]   vRecv           The raw message received\r\n */\r\nvoid PeerManagerImpl::ProcessGetCFilters(CNode& node, Peer& peer, DataStream& vRecv)\r\n{\r\n    uint8_t filter_type_ser;\r\n    uint32_t start_height;\r\n    uint256 stop_hash;\r\n\r\n    vRecv >> filter_type_ser >> start_height >> stop_hash;\r\n\r\n    const BlockFilterType filter_type = static_cast<BlockFilterType>(filter_type_ser);\r\n\r\n    const CBlockIndex* stop_index;\r\n    BlockFilterIndex* filter_index;\r\n    if (!PrepareBlockFilterRequest(node, peer, filter_type, start_height, stop_hash,\r\n                                   MAX_GETCFILTERS_SIZE, stop_index, filter_index)) {\r\n        return;\r\n    }\r\n\r\n    std::vector<BlockFilter> filters;\r\n    if (!filter_index->LookupFilterRange(start_height, stop_index, filters)) {\r\n        LogDebug(BCLog::NET, \"Failed to find block filter in index: filter_type=%s, start_height=%d, stop_hash=%s\\n\",\r\n                     BlockFilterTypeName(filter_type), start_height, stop_hash.ToString());\r\n        return;\r\n    }\r\n\r\n    for (const auto& filter : filters) {\r\n        MakeAndPushMessage(node, NetMsgType::CFILTER, filter);\r\n    }\r\n```\r\n\r\nand bip 157 cfheaders:\r\n\r\n```cpp\r\n/**\r\n * Handle a cfheaders request.\r\n *\r\n * May disconnect from the peer in the case of a bad request.\r\n *\r\n * @param[in]   node            The node that we received the request from\r\n * @param[in]   peer            The peer that we received the request from\r\n * @param[in]   vRecv           The raw message received\r\n */\r\n void PeerManagerImpl::ProcessGetCFHeaders(CNode& node, Peer& peer, DataStream& vRecv)\r\n{\r\n    uint8_t filter_type_ser;\r\n    uint32_t start_height;\r\n    uint256 stop_hash;\r\n\r\n    vRecv >> filter_type_ser >> start_height >> stop_hash;\r\n\r\n    const BlockFilterType filter_type = static_cast<BlockFilterType>(filter_type_ser);\r\n\r\n    const CBlockIndex* stop_index;\r\n    BlockFilterIndex* filter_index;\r\n    if (!PrepareBlockFilterRequest(node, peer, filter_type, start_height, stop_hash,\r\n                                   MAX_GETCFHEADERS_SIZE, stop_index, filter_index)) {\r\n        return;\r\n    }\r\n\r\n    uint256 prev_header;\r\n    if (start_height > 0) {\r\n        const CBlockIndex* const prev_block =\r\n            stop_index->GetAncestor(static_cast<int>(start_height - 1));\r\n        if (!filter_index->LookupFilterHeader(prev_block, prev_header)) {\r\n            LogDebug(BCLog::NET, \"Failed to find block filter header in index: filter_type=%s, block_hash=%s\\n\",\r\n                         BlockFilterTypeName(filter_type), prev_block->GetBlockHash().ToString());\r\n            return;\r\n        }\r\n    }\r\n\r\n    std::vector<uint256> filter_hashes;\r\n    if (!filter_index->LookupFilterHashRange(start_height, stop_index, filter_hashes)) {\r\n        LogDebug(BCLog::NET, \"Failed to find block filter hashes in index: filter_type=%s, start_height=%d, stop_hash=%s\\n\",\r\n                     BlockFilterTypeName(filter_type), start_height, stop_hash.ToString());\r\n        return;\r\n    }\r\n\r\n    MakeAndPushMessage(node, NetMsgType::CFHEADERS,\r\n              filter_type_ser,\r\n              stop_index->GetBlockHash(),\r\n              prev_header,\r\n              filter_hashes);\r\n}\r\n```\r\n\r\n------\r\n\r\nIn `src/psbt.cpp`:\r\n\r\n```cpp\r\nbool DecodeRawPSBT(PartiallySignedTransaction& psbt, Span<const std::byte> tx_data, std::string& error)\r\n{\r\n    DataStream ss_data{tx_data};\r\n    try {\r\n        ss_data >> psbt;\r\n        if (!ss_data.empty()) {\r\n            error = \"extra data after PSBT\";\r\n            return false;\r\n        }\r\n    } catch (const std::exception& e) {\r\n        error = e.what();\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n```\r\n\r\nIt is used for deserializing hex data into a `PartiallySignedTransaction` object.\r\n\r\n--------\r\n\r\n\r\nIn `src/qt/psbtoperationsdialog.cpp`:\r\n\r\nBitcoin Qt interface for Copying psbt to clipboard:\r\n\r\n```cpp\r\nvoid PSBTOperationsDialog::copyToClipboard() {\r\n    DataStream ssTx{};\r\n    ssTx << m_transaction_data;\r\n    GUIUtil::setClipboard(EncodeBase64(ssTx.str()).c_str());\r\n    showStatus(tr(\"PSBT copied to clipboard.\"), StatusLevel::INFO);\r\n}\r\n```\r\n\r\nSaving PSBT to disk:\r\n```cpp\r\nvoid PSBTOperationsDialog::saveTransaction() {\r\n    DataStream ssTx{};\r\n    ssTx << m_transaction_data;\r\n\r\n    QString selected_filter;\r\n    QString filename_suggestion = \"\";\r\n    bool first = true;\r\n    for (const CTxOut& out : m_transaction_data.tx->vout) {\r\n        if (!first) {\r\n            filename_suggestion.append(\"-\");\r\n        }\r\n        CTxDestination address;\r\n        ExtractDestination(out.scriptPubKey, address);\r\n        QString amount = BitcoinUnits::format(m_client_model->getOptionsModel()->getDisplayUnit(), out.nValue);\r\n        QString address_str = QString::fromStdString(EncodeDestination(address));\r\n        filename_suggestion.append(address_str + \"-\" + amount);\r\n        first = false;\r\n    }\r\n    filename_suggestion.append(\".psbt\");\r\n    QString filename = GUIUtil::getSaveFileName(this,\r\n        tr(\"Save Transaction Data\"), filename_suggestion,\r\n        //: Expanded name of the binary PSBT file format. See: BIP 174.\r\n        tr(\"Partially Signed Transaction (Binary)\") + QLatin1String(\" (*.psbt)\"), &selected_filter);\r\n    if (filename.isEmpty()) {\r\n        return;\r\n    }\r\n    std::ofstream out{filename.toLocal8Bit().data(), std::ofstream::out | std::ofstream::binary};\r\n    out << ssTx.str();\r\n    out.close();\r\n    showStatus(tr(\"PSBT saved to disk.\"), StatusLevel::INFO);\r\n}\r\n```\r\n\r\n--------\r\n\r\nIn `src/qt/recentrequestsstablemodel.cpp`:\r\n\r\n```cpp\r\n// called when adding a request from the GUI\r\nvoid RecentRequestsTableModel::addNewRequest(const SendCoinsRecipient &recipient)\r\n{\r\n    RecentRequestEntry newEntry;\r\n    newEntry.id = ++nReceiveRequestsMaxId;\r\n    newEntry.date = QDateTime::currentDateTime();\r\n    newEntry.recipient = recipient;\r\n\r\n    DataStream ss{};\r\n    ss << newEntry;\r\n\r\n    if (!walletModel->wallet().setAddressReceiveRequest(DecodeDestination(recipient.address.toStdString()), ToString(newEntry.id), ss.str()))\r\n        return;\r\n\r\n    addNewRequest(newEntry);\r\n}\r\n```\r\n\r\nI am not very familiar with the GUI but as far as I can tell the `RecentRequestsTable` stores and displays receive addresses / payment requests that you've generated. Here the `SendCoinsRecipient` of payment request consists of an address, a label, an amount, and a memo/message. We serialize the recipient and other data about the request, an ID, and a date/time for the request, and then pass the string into a function which will store it in the `RecentRequestsTable`.\r\n\r\n--------\r\n\r\nIn `src/qt/sendcoinsdialog.cpp`:\r\n\r\n```cpp\r\nvoid SendCoinsDialog::presentPSBT(PartiallySignedTransaction& psbtx)\r\n{\r\n    // Serialize the PSBT\r\n    DataStream ssTx{};\r\n    ssTx << psbtx;\r\n    GUIUtil::setClipboard(EncodeBase64(ssTx.str()).c_str());\r\n    QMessageBox msgBox(this);\r\n    //: Caption of \"PSBT has been copied\" messagebox\r\n    msgBox.setText(tr(\"Unsigned Transaction\", \"PSBT copied\"));\r\n    msgBox.setInformativeText(tr(\"The PSBT has been copied to the clipboard. You can also save it.\"));\r\n    msgBox.setStandardButtons(QMessageBox::Save | QMessageBox::Discard);\r\n    msgBox.setDefaultButton(QMessageBox::Discard);\r\n    msgBox.setObjectName(\"psbt_copied_message\");\r\n    switch (msgBox.exec()) {\r\n    case QMessageBox::Save: {\r\n        QString selectedFilter;\r\n        QString fileNameSuggestion = \"\";\r\n        bool first = true;\r\n        for (const SendCoinsRecipient &rcp : m_current_transaction->getRecipients()) {\r\n            if (!first) {\r\n                fileNameSuggestion.append(\" - \");\r\n            }\r\n            QString labelOrAddress = rcp.label.isEmpty() ? rcp.address : rcp.label;\r\n            QString amount = BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp.amount);\r\n            fileNameSuggestion.append(labelOrAddress + \"-\" + amount);\r\n            first = false;\r\n        }\r\n        fileNameSuggestion.append(\".psbt\");\r\n        QString filename = GUIUtil::getSaveFileName(this,\r\n            tr(\"Save Transaction Data\"), fileNameSuggestion,\r\n            //: Expanded name of the binary PSBT file format. See: BIP 174.\r\n            tr(\"Partially Signed Transaction (Binary)\") + QLatin1String(\" (*.psbt)\"), &selectedFilter);\r\n        if (filename.isEmpty()) {\r\n            return;\r\n        }\r\n        std::ofstream out{filename.toLocal8Bit().data(), std::ofstream::out | std::ofstream::binary};\r\n        out << ssTx.str();\r\n        out.close();\r\n        //: Popup message when a PSBT has been saved to a file\r\n        Q_EMIT message(tr(\"PSBT saved\"), tr(\"PSBT saved to disk\"), CClientUIInterface::MSG_INFORMATION);\r\n        break;\r\n    }\r\n    case QMessageBox::Discard:\r\n        break;\r\n    default:\r\n        assert(false);\r\n    } // msgBox.exec()\r\n}\r\n```\r\n\r\nHere it's used to serialize the PSBT in order to display it to the user during the process of sending in the GUI.\r\n\r\n\r\n---------\r\n\r\nIn `src/qt/walletmodel.cpp`:\r\n\r\n`DataStream`'s are used to serialize PSBT's when fee bumping a stuck transaction\r\nin:\r\n\r\n```cpp\r\nbool WalletModel::bumpFee(uint256 hash, uint256& new_hash)\r\n```\r\n\r\nand to serialize the sent transaction in `WalletModel::sendCoins()`:\r\n\r\n```cpp\r\nvoid WalletModel::sendCoins(WalletModelTransaction& transaction)\r\n{\r\n    QByteArray transaction_array; /* store serialized transaction */\r\n\r\n    {\r\n        std::vector<std::pair<std::string, std::string>> vOrderForm;\r\n        for (const SendCoinsRecipient &rcp : transaction.getRecipients())\r\n        {\r\n            if (!rcp.message.isEmpty()) // Message from normal bitcoin:URI (bitcoin:123...?message=example)\r\n                vOrderForm.emplace_back(\"Message\", rcp.message.toStdString());\r\n        }\r\n\r\n        auto& newTx = transaction.getWtx();\r\n        wallet().commitTransaction(newTx, /*value_map=*/{}, std::move(vOrderForm));\r\n\r\n        DataStream ssTx;\r\n        ssTx << TX_WITH_WITNESS(*newTx);\r\n        transaction_array.append((const char*)ssTx.data(), ssTx.size());\r\n    }\r\n\r\n    // Add addresses / update labels that we've sent to the address book,\r\n    // and emit coinsSent signal for each recipient\r\n    for (const SendCoinsRecipient &rcp : transaction.getRecipients())\r\n    {\r\n        // [...]\r\n        Q_EMIT coinsSent(this, rcp, transaction_array);\r\n    }\r\n\r\n    checkBalanceChanged(m_wallet->getBalances()); // update balance immediately, otherwise there could be a short noticeable delay until pollBalanceChanged hits\r\n}\r\n```\r\n\r\n-----------------------------\r\n\r\nIn `src/rest.cpp`:\r\n\r\n`DataStream` is used by Bitcoin Core's REST interface to serialize responses to requests for headers in `rest_headers()`, blocks in `rest_block()`, blockfilterheaders in `rest_filter_header()` blockfilters in `rest_block_filter()`, tx's in `rest_tx()` utxo's in `rest_getutxos()` and blockhashes in `rest_blockhash_by_height()`.\r\n\r\n---------------------------\r\n\r\nIn `src/rpc/blockchain.cpp`:\r\n\r\n`DataStream` is used to serialize the block header in the `getblockheader` rpc\r\ncommand:\r\n\r\n```cpp\r\n    if (!fVerbose)\r\n    {\r\n        DataStream ssBlock{};\r\n        ssBlock << pblockindex->GetBlockHeader();\r\n        std::string strHex = HexStr(ssBlock);\r\n        return strHex;\r\n    }\r\n```\r\n\r\nand to deserialize the block data into a `CBlock` in the `getblock` rpc command:\r\n\r\n```cpp\r\n    const std::vector<uint8_t> block_data{GetRawBlockChecked(chainman.m_blockman, *pblockindex)};\r\n\r\n    DataStream block_stream{block_data};\r\n    CBlock block{};\r\n    block_stream >> TX_WITH_WITNESS(block);\r\n\r\n    return blockToJSON(chainman.m_blockman, block, *tip, *pblockindex, tx_verbosity);\r\n```\r\n\r\n------------------\r\n\r\nIn `src/rpc/mining.cpp`:\r\n\r\n`DataStream` is used by the `generateblock` rpc for serializing the output hex of a generated block when `generateblock` is called with `submit=false`:\r\n\r\n```cpp\r\n    UniValue obj(UniValue::VOBJ);\r\n    obj.pushKV(\"hash\", block_out->GetHash().GetHex());\r\n    if (!process_new_block) {\r\n        DataStream block_ser;\r\n        block_ser << TX_WITH_WITNESS(*block_out);\r\n        obj.pushKV(\"hex\", HexStr(block_ser));\r\n    }\r\n```\r\n\r\n----------------\r\n\r\nIn `src/rpc/rawtransaction.cpp`:\r\n\r\n`DataStream` is used to serialize the resulting PSBT's that get passed to `EncodeBase64()` and returned in `combinepsbt`:\r\n\r\n```cpp\r\nstatic RPCHelpMan combinepsbt()\r\n    // [ ..preparing merged_psbt.. ]\r\n\r\n    DataStream ssTx{};\r\n    ssTx << merged_psbt;\r\n    return EncodeBase64(ssTx);\r\n```\r\n\r\nand `finalizepsbt()` which also might serialize the final transaction hex using a `DataStream` of `TX_WITH_WITNESS(tx)` passed to `HexStr()`:\r\n\r\n```cpp\r\nstatic RPCHelpMan finalizepsbt()\r\n{\r\n    // Unserialize the transactions\r\n    PartiallySignedTransaction psbtx;\r\n    std::string error;\r\n    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\r\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\r\n    }\r\n\r\n    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\r\n\r\n    CMutableTransaction mtx;\r\n    bool complete = FinalizeAndExtractPSBT(psbtx, mtx);\r\n\r\n    UniValue result(UniValue::VOBJ);\r\n    DataStream ssTx{};\r\n    std::string result_str;\r\n\r\n    if (complete && extract) {\r\n        ssTx << TX_WITH_WITNESS(mtx);\r\n        result_str = HexStr(ssTx);\r\n        result.pushKV(\"hex\", result_str);\r\n    } else {\r\n        ssTx << psbtx;\r\n        result_str = EncodeBase64(ssTx.str());\r\n        result.pushKV(\"psbt\", result_str);\r\n    }\r\n    result.pushKV(\"complete\", complete);\r\n\r\n    return result;\r\n}\r\n```\r\n\r\nand in `createpsbt`:\r\n\r\n```cpp\r\nstatic RPCHelpMan createpsbt()\r\n{\r\n\r\n    std::optional<bool> rbf;\r\n    if (!request.params[3].isNull()) {\r\n        rbf = request.params[3].get_bool();\r\n    }\r\n    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], rbf);\r\n\r\n    // Make a blank psbt\r\n    PartiallySignedTransaction psbtx;\r\n    psbtx.tx = rawTx;\r\n    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\r\n        psbtx.inputs.emplace_back();\r\n    }\r\n    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\r\n        psbtx.outputs.emplace_back();\r\n    }\r\n\r\n    // Serialize the PSBT\r\n    DataStream ssTx{};\r\n    ssTx << psbtx;\r\n\r\n    return EncodeBase64(ssTx);\r\n}\r\n```\r\n\r\nand in `utxoupdatepsbt()`:\r\n\r\n```cpp\r\nstatic RPCHelpMan utxoupdatepsbt()\r\n{\r\n    // Parse descriptors, if any.\r\n    FlatSigningProvider provider;\r\n    if (!request.params[1].isNull()) {\r\n        auto descs = request.params[1].get_array();\r\n        for (size_t i = 0; i < descs.size(); ++i) {\r\n            EvalDescriptorStringOrObject(descs[i], provider);\r\n        }\r\n    }\r\n\r\n    // We don't actually need private keys further on; hide them as a precaution.\r\n    const PartiallySignedTransaction& psbtx = ProcessPSBT(\r\n        request.params[0].get_str(),\r\n        request.context,\r\n        HidingSigningProvider(&provider, /*hide_secret=*/true, /*hide_origin=*/false),\r\n        /*sighash_type=*/SIGHASH_ALL,\r\n        /*finalize=*/false);\r\n\r\n    DataStream ssTx{};\r\n    ssTx << psbtx;\r\n    return EncodeBase64(ssTx);\r\n}\r\n```\r\n\r\nand `joinpsbts`:\r\n\r\n```cpp\r\nstatic RPCHelpMan joinpsbts()\r\n    // [ ... prepare PartiallySignedTransaction shuffled psbt ... ]\r\n    DataStream ssTx{};\r\n    ssTx << shuffled_psbt;\r\n    return EncodeBase64(ssTx);\r\n}\r\n```\r\n\r\nand in `descriptorprocesspsbt`, which like `finalizepsbt` above might also use `DataStream` for serializing a final transaction hex that gets passed to `HexStr` and return if the psbt is complete:\r\n\r\n```cpp\r\nRPCHelpMan descriptorprocesspsbt()\r\n    // [ ...prepare PartiallySignedTransaction &psbtx... ]\r\n    DataStream ssTx{};\r\n    ssTx << psbtx;\r\n\r\n    UniValue result(UniValue::VOBJ);\r\n\r\n    result.pushKV(\"psbt\", EncodeBase64(ssTx));\r\n    result.pushKV(\"complete\", complete);\r\n    if (complete) {\r\n        CMutableTransaction mtx;\r\n        PartiallySignedTransaction psbtx_copy = psbtx;\r\n        CHECK_NONFATAL(FinalizeAndExtractPSBT(psbtx_copy, mtx));\r\n        DataStream ssTx_final;\r\n        ssTx_final << TX_WITH_WITNESS(mtx);\r\n        result.pushKV(\"hex\", HexStr(ssTx_final));\r\n    }\r\n    return result;\r\n}\r\n```\r\n\r\n------\r\n\r\nIn `src/rpc/txoutproof`:\r\n\r\nIt is used for serializing the merkle inclusion proof in `gettxoutproof()`:\r\n\r\n```cpp\r\nstatic RPCHelpMan gettxoutproof()\r\n{\r\n    // [...]\r\n\r\n    DataStream ssMB{};\r\n    CMerkleBlock mb(block, setTxids);\r\n    ssMB << mb;\r\n    std::string strHex = HexStr(ssMB);\r\n    return strHex;\r\n}\r\n```\r\n\r\nand for deserializing the inclusion proof in `verifytxoutproof`:\r\n\r\n```cpp\r\nstatic RPCHelpMan verifytxoutproof()\r\n{\r\n    DataStream ssMB{ParseHexV(request.params[0], \"proof\")};\r\n    CMerkleBlock merkleBlock;\r\n    ssMB >> merkleBlock;\r\n\r\n    // [ ... Validate merkleBlock ... ] \r\n}\r\n```\r\n\r\n-------\r\n\r\n#### Wallet\r\n\r\nIf wallet is unencrypted on disk, I feel there is no reason for us to be delicate about how it is handled in memory.\r\n\r\n##### How wallet disk encryption happens\r\n\r\nMy understanding of the way that wallet encryption on disk works is that keys and values are written and read by the wallet in crypted form, and they are decrypted/encrypted in memory by `ScriptPubKeyMan`, for example:\r\n\r\n```cpp\r\n// [ Getting the private key for `CKeyID` address and storing the result \r\n//   in `CKey& keyOut` ]\r\nbool LegacyDataSPKM::GetKey(const CKeyID &address, CKey& keyOut) const\r\n{\r\n    LOCK(cs_KeyStore);\r\n    if (!m_storage.HasEncryptionKeys()) {\r\n        return FillableSigningProvider::GetKey(address, keyOut);\r\n    }\r\n\r\n    // [ a map of crypted keys is created on legacy wallet load in\r\n    //   `LoadLegacyWalletRecords()` ]\r\n    CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\r\n    if (mi != mapCryptedKeys.end())\r\n    {\r\n        const CPubKey &vchPubKey = (*mi).second.first;\r\n        const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\r\n        // [ Use the encryption key to decrypt the crypted key from the map. ]\r\n        return m_storage.WithEncryptionKey([&](const CKeyingMaterial& encryption_key) {\r\n            return DecryptKey(encryption_key, vchCryptedSecret, vchPubKey, keyOut);\r\n        });\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\nBecause of this, we should not be vigilant about securing memory that contains crypted data from the disk.\r\n\r\n------\r\n\r\nIn `src/wallet/bdb.cpp`:\r\n\r\n`BerkeleyDatabase::Rewrite()` uses `DataStream` to serialize the keys and values from the existing db when rewriting the database. \r\n\r\n`BerkeleyDatabase::Rewrite()` is used when encrypting a wallet for the first time, since, according to comments \"BDB might keep bits of the unencrypted private key in slack space in the database file.\" or when we detect a wallet that was encrypted by version <0.5.0 and >0.4.0 of bitcoin, presumably because of some horrible bug in those versions. (PR [#635](https://github.com/bitcoin/bitcoin/pull/635)\r\n\r\nBut at this point, the wallet has already been encrypted, and we won't be loading anything from slack space when rewriting the db, so no problems.\r\n\r\n`BerkeleyCursor::Next()` is used when cursoring through the BDB, and stores the retrieved Key and Value in DataStream's, if the wallet is encrypted these will be crypted, if not, the keys are on disk in plaintext anyways.\r\n\r\n`BerkeleyBatch::ReadKey()` retrieves the value for a given key in the database:\r\n\r\n```cpp\r\nbool BerkeleyBatch::ReadKey(DataStream&& key, DataStream& value)\r\n{\r\n    if (!pdb)\r\n        return false;\r\n\r\n    SafeDbt datKey(key.data(), key.size());\r\n\r\n    SafeDbt datValue;\r\n    int ret = pdb->get(activeTxn, datKey, datValue, 0);\r\n    if (ret == 0 && datValue.get_data() != nullptr) {\r\n        value.clear();\r\n        value.write(SpanFromDbt(datValue));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\nThis is not a concern because like above, this data is either in plaintext on disk, or it is being retrieved in crypted form and will be decrypted elsewhere by SPKM.\r\n\r\nSimilar arguments to the above apply for `BerkeleyBatch::WriteKey()`, `BerkeleyBatch::EraseKey()`, and `BerkeleyBatch::HasKey()`\r\n\r\n-------\r\n\r\nIn `src/wallet/db.h`:\r\n\r\nThe same argument as above applies for keys and values used here in `DatabaseBatch` functions Read, Write, Erase, Exists:\r\n\r\n```cpp\r\n/** RAII class that provides access to a WalletDatabase */\r\nclass DatabaseBatch\r\n{\r\nprivate:\r\n    virtual bool ReadKey(DataStream&& key, DataStream& value) = 0;\r\n    virtual bool WriteKey(DataStream&& key, DataStream&& value, bool overwrite = true) = 0;\r\n    virtual bool EraseKey(DataStream&& key) = 0;\r\n    virtual bool HasKey(DataStream&& key) = 0;\r\n\r\npublic:\r\n    template <typename K, typename T>\r\n    bool Read(const K& key, T& value)\r\n    {\r\n        DataStream ssKey{};\r\n        ssKey.reserve(1000);\r\n        ssKey << key;\r\n\r\n        DataStream ssValue{};\r\n        if (!ReadKey(std::move(ssKey), ssValue)) return false;\r\n        try {\r\n            ssValue >> value;\r\n            return true;\r\n        } catch (const std::exception&) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    template <typename K, typename T>\r\n    bool Write(const K& key, const T& value, bool fOverwrite = true)\r\n    {\r\n        DataStream ssKey{};\r\n        ssKey.reserve(1000);\r\n        ssKey << key;\r\n\r\n        DataStream ssValue{};\r\n        ssValue.reserve(10000);\r\n        ssValue << value;\r\n\r\n        return WriteKey(std::move(ssKey), std::move(ssValue), fOverwrite);\r\n    }\r\n\r\n    template <typename K>\r\n    bool Erase(const K& key)\r\n    {\r\n        DataStream ssKey{};\r\n        ssKey.reserve(1000);\r\n        ssKey << key;\r\n\r\n        return EraseKey(std::move(ssKey));\r\n    }\r\n\r\n    template <typename K>\r\n    bool Exists(const K& key)\r\n    {\r\n        DataStream ssKey{};\r\n        ssKey.reserve(1000);\r\n        ssKey << key;\r\n\r\n        return HasKey(std::move(ssKey));\r\n    }\r\n};\r\n```\r\n\r\n-----\r\n\r\nIn `dump.cpp`:\r\n\r\n`DumpWallet()` invoked by doing `bitcoin-wallet dump` prints all keys and values in a wallet, but does not decrypt them:\r\n\r\n```cpp\r\n// [ I've editorialized this codeblock to focus on the part I'm interested in ]\r\nbool DumpWallet(const ArgsManager& args, WalletDatabase& db, bilingual_str& error)\r\n{\r\n    // [.. handle dump file stuff ..]\r\n    std::unique_ptr<DatabaseBatch> batch = db.MakeBatch();\r\n    std::unique_ptr<DatabaseCursor> cursor = batch->GetNewCursor();\r\n\r\n    // Read the records\r\n    while (true) {\r\n        DataStream ss_key{};\r\n        DataStream ss_value{};\r\n        DatabaseCursor::Status status = cursor->Next(ss_key, ss_value);\r\n        if (status == DatabaseCursor::Status::DONE) {\r\n            ret = true;\r\n            break;\r\n        } else if (status == DatabaseCursor::Status::FAIL) {\r\n            error = _(\"Error reading next record from wallet database\");\r\n            ret = false;\r\n            break;\r\n        }\r\n        std::string key_str = HexStr(ss_key);\r\n        std::string value_str = HexStr(ss_value);\r\n        line = strprintf(\"%s,%s\\n\", key_str, value_str);\r\n        dump_file.write(line.data(), line.size());\r\n        hasher << Span{line};\r\n    }\r\n\r\n    cursor.reset();\r\n    batch.reset();\r\n\r\n    // [.. handle dump file stuff ..]\r\n\r\n    return ret;\r\n}\r\n```\r\n\r\n----------------\r\n\r\nIn `src/wallet/migrate.cpp` & `src/wallet/migrate.h`:\r\n\r\n`BerkeleyRO*` exist so that we can read keys and values from a legacy bdb wallet when migrating so that we can drop the bdb wallet entirely in the future, the same as in `db.h` applies here, all the ekys and values read in `BerkeleyROBatch::ReadKey()`, `HasKey` and `BerkeleyROCursor::Next()` are crypted as in their non-RO counterparts found above.\r\n\r\n---------------------\r\n\r\nIn `src/wallet/rpc/backup.cpp`:\r\n\r\n`DataStream` is used to serialize the transaction inclusion proof argument to the `importprunedfunds()` rpc which lets pruned nodes import funds without rescanning if they have inclusion proofs similar to above in `src/rpc/txoutproof.cpp`.\r\n\r\n```cpp\r\nRPCHelpMan importprunedfunds()\r\n{\r\n    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\r\n    if (!pwallet) return UniValue::VNULL;\r\n\r\n    CMutableTransaction tx;\r\n    if (!DecodeHexTx(tx, request.params[0].get_str())) {\r\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed. Make sure the tx has at least one input.\");\r\n    }\r\n    uint256 hashTx = tx.GetHash();\r\n\r\n    DataStream ssMB{ParseHexV(request.params[1], \"proof\")};\r\n    CMerkleBlock merkleBlock;\r\n    ssMB >> merkleBlock;\r\n\r\n    // [.. validate merkle block ..]\r\n\r\n    // [.. add transactions to wallet.. ]\r\n}\r\n```\r\n\r\n------------------------\r\n\r\n\r\nIn `src/wallet/rpc/txoutproof.cpp`:\r\n\r\nIn `static Univalue FinishTransaction` used by the rpc's `send()` and `sendall()`, DataStream is used to serialize the completed psbt and print it if either was called with `psbt=true`.\r\n\r\nIn `bumpfee_helper` when invoked as the `psbtbumpfee` rpc, a DataStream is used to serialize the unsigned psbt of the new transaction that gets returned.\r\n\r\nIn `walletprocesspsbt()` `DataStream is used to serialize the PSBT, and if the transaction is complete to serialize the final transaction:\r\n\r\n```cpp\r\nRPCHelpMan walletprocesspsbt()\r\n{\r\n    // [...prepare psbtx...]\r\n\r\n    UniValue result(UniValue::VOBJ);\r\n    DataStream ssTx{};\r\n    ssTx << psbtx;\r\n    result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\r\n    result.pushKV(\"complete\", complete);\r\n    if (complete) {\r\n        CMutableTransaction mtx;\r\n        // Returns true if complete, which we already think it is.\r\n        CHECK_NONFATAL(FinalizeAndExtractPSBT(psbtx, mtx));\r\n        DataStream ssTx_final;\r\n        ssTx_final << TX_WITH_WITNESS(mtx);\r\n        result.pushKV(\"hex\", HexStr(ssTx_final));\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\nin the `walletcreatefundedpsbt` rpc, it contains the serialized psbt\r\n\r\n--------------------\r\n\r\nIn `src/wallet/salvage.cpp`:\r\n\r\n`DataStream` is used during `RecoverDatabaseFile()` when trying to recover key and value data from a db, nothing gets decrypted here:\r\n\r\n```cpp\r\n    for (KeyValPair& row : salvagedData)\r\n    {\r\n        /* Filter for only private key type KV pairs to be added to the salvaged wallet */\r\n        DataStream ssKey{row.first};\r\n        DataStream ssValue(row.second);\r\n        std::string strType, strErr;\r\n\r\n        // We only care about KEY, MASTER_KEY, CRYPTED_KEY, and HDCHAIN types\r\n        ssKey >> strType;\r\n        bool fReadOK = false;\r\n        // [ The below just load the crypted form of the key, no decryption. ]\r\n        if (strType == DBKeys::KEY) {\r\n            fReadOK = LoadKey(&dummyWallet, ssKey, ssValue, strErr);\r\n        } else if (strType == DBKeys::CRYPTED_KEY) {\r\n            fReadOK = LoadCryptedKey(&dummyWallet, ssKey, ssValue, strErr);\r\n        } else if (strType == DBKeys::MASTER_KEY) {\r\n            fReadOK = LoadEncryptionKey(&dummyWallet, ssKey, ssValue, strErr);\r\n        } else if (strType == DBKeys::HDCHAIN) {\r\n            fReadOK = LoadHDChain(&dummyWallet, ssValue, strErr);\r\n        } else {\r\n            continue;\r\n        }\r\n```\r\n\r\n--------\r\n\r\nIn `src/wallet/sqlite.cpp` & `src/wallet/sqlite.h`:\r\n\r\n`SQLiteBatch::ReadKey`, WriteKey, etc. and `SQLiteCursor::next` mirror berkeley and berkeley RO batches above, again: all reading crypted data from disk, data gets decrypted somewhere else, once it's far away from it's humble `DataStream` beginnings.\r\n\r\n---------\r\n\r\nIn `src/wallet/wallet.cpp`:\r\n\r\nUsed in `MigrateToSQLite()` when iterating through BDB with the bdb cursor:\r\n\r\n```cpp\r\nbool CWallet::MigrateToSQLite(bilingual_str& error)\r\n{\r\n    while (true) {\r\n        DataStream ss_key{};\r\n        DataStream ss_value{};\r\n        status = cursor->Next(ss_key, ss_value);\r\n        if (status != DatabaseCursor::Status::MORE) {\r\n            break;\r\n        }\r\n        SerializeData key(ss_key.begin(), ss_key.end());\r\n        SerializeData value(ss_value.begin(), ss_value.end());\r\n        records.emplace_back(key, value);\r\n    }\r\n    cursor.reset();\r\n    batch.reset();\r\n\r\n    // [....insert the records in to the new sqlite db...] \r\n}\r\n```\r\n\r\n---------------------\r\n\r\nIn `src/wallet/walletdb.cpp`:\r\n\r\nMost of the arguments above about encrypted data on disk hold true here...\r\n\r\n```cpp\r\nbool WalletBatch::IsEncrypted()\r\n{\r\n    DataStream prefix;\r\n    prefix << DBKeys::MASTER_KEY;\r\n    if (auto cursor = m_batch->GetNewPrefixCursor(prefix)) {\r\n        DataStream k, v;\r\n        if (cursor->Next(k, v) == DatabaseCursor::Status::MORE) return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\nmaster encryption keys are stored in the db (in crypted form!), this is just serializing the master key prefix and then searching for such an entry, no secrets in the prefix!\r\n\r\n`LoadKey` and `LoadCryptedKey` don't do any decryption of the keys. LoadKey just grabs all the keys that have the unencrypted key prefix as-is, and loadcryptedkey loads keys with the crypted key prefix as-is. The story is almost identical with `LoadHDChain` and `LoadEncryptionKey` and the same with the rest of the `LoadRecords()`, `LoadLegacyWalletRecoreds()`, and `LoadDescriptorWalletRecords()` circus.\r\n\r\nI definitely got tired and slacked a little while reviewing `walletdb.cpp` but I'm pretty confident about this.\r\n\r\n-------------------------\r\n\r\nIn `src/zmq/zmpqpublishnotifier.cpp`:\r\n\r\n```cpp\r\nbool CZMQPublishRawTransactionNotifier::NotifyTransaction(const CTransaction &transaction)\r\n{\r\n    uint256 hash = transaction.GetHash();\r\n    LogDebug(BCLog::ZMQ, \"Publish rawtx %s to %s\\n\", hash.GetHex(), this->address);\r\n    DataStream ss;\r\n    ss << TX_WITH_WITNESS(transaction);\r\n    return SendZmqMessage(MSG_RAWTX, &(*ss.begin()), ss.size());\r\n}`\r\n```\r\n\r\nUsed to serialize the raw transaction that we are sending a ZeroMQ notification about.\r\n\r\n#### Not done yet, `SerializeData`\r\n\r\nLet's also look at every instance of `SerializeData` being used, since this is a vector of bytes, with the `zero_after_free_allocator`:\r\n\r\n-----------\r\n\r\nIn `src/wallet/migrate.cpp`:\r\n\r\nUsed in the `BerkeleyROBatch::*` family of `ReadKey()`, `HasKey()` to represent the vector portion of the same `DataStream`'s I used and described above that have just crypted key data, or unencrypted data *if* the wallet itself is unencrypted, e.g.:\r\n\r\n```cpp\r\n\r\nbool BerkeleyROBatch::ReadKey(DataStream&& key, DataStream& value)\r\n{\r\n    SerializeData key_data{key.begin(), key.end()};\r\n    const auto it{m_database.m_records.find(key_data)};\r\n    if (it == m_database.m_records.end()) {\r\n        return false;\r\n    }\r\n    auto val = it->second;\r\n    value.clear();\r\n    value.write(Span(val));\r\n    return true;\r\n}\r\n```\r\n\r\n-----------\r\n\r\nIn `src/wallet/wallet.cpp`:\r\n\r\nUsed in `MigrateToSQLite()` as discussed above to store the `DataStream` data described above:\r\n\r\n```cpp\r\nwhile (true) {\r\n    DataStream ss_key{};\r\n    DataStream ss_value{};\r\n    status = cursor->Next(ss_key, ss_value);\r\n    if (status != DatabaseCursor::Status::MORE) {\r\n        break;\r\n    }\r\n    SerializeData key(ss_key.begin(), ss_key.end());\r\n    SerializeData value(ss_value.begin(), ss_value.end());\r\n    records.emplace_back(key, value);\r\n}\r\n```\r\n\r\n</details>\r\n\r\n[^1]: Master at the time of my testing was: [`6d546336e800`](https://github.com/bitcoin/bitcoin/commit/6d546336e800)\r\n[^2]: Maybe as much as 50x: https://github.com/bitcoin/bitcoin/pull/740#issuecomment-3337245\r\n[^3]: I am assuming this from the discussion, github seems to not have dead commits for old pr's\r\n",
    "labels": [],
    "created_at": "2024-09-26T22:40:32Z",
    "updated_at": "2024-09-26T22:40:36Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "c75f4827b5b78e55c6fed9f899dbc1bb488c837d",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "davidgumberg:zero_after_free_allocator_change",
      "ref": "zero_after_free_allocator_change",
      "sha": "d90eb00d8b33a3839b113acbbbb7d9e58cffb148",
      "user": {
        "login": "davidgumberg",
        "id": 2257631,
        "node_id": "MDQ6VXNlcjIyNTc2MzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/davidgumberg",
        "html_url": "https://github.com/davidgumberg",
        "followers_url": "https://api.github.com/users/davidgumberg/followers",
        "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
        "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
        "repos_url": "https://api.github.com/users/davidgumberg/repos",
        "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 529442895,
        "node_id": "R_kgDOH46oTw",
        "name": "bitcoin",
        "full_name": "davidgumberg/bitcoin",
        "owner": {
          "login": "davidgumberg",
          "id": 2257631,
          "node_id": "MDQ6VXNlcjIyNTc2MzE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/davidgumberg",
          "html_url": "https://github.com/davidgumberg",
          "followers_url": "https://api.github.com/users/davidgumberg/followers",
          "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
          "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
          "repos_url": "https://api.github.com/users/davidgumberg/repos",
          "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/davidgumberg/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/davidgumberg/bitcoin",
        "archive_url": "https://api.github.com/repos/davidgumberg/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/davidgumberg/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/davidgumberg/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/davidgumberg/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/davidgumberg/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/davidgumberg/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/davidgumberg/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/davidgumberg/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/davidgumberg/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/davidgumberg/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/davidgumberg/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/davidgumberg/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/davidgumberg/bitcoin/events",
        "forks_url": "https://api.github.com/repos/davidgumberg/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/davidgumberg/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/davidgumberg/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/davidgumberg/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/davidgumberg/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/davidgumberg/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/davidgumberg/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/davidgumberg/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/davidgumberg/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/davidgumberg/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/davidgumberg/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/davidgumberg/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/davidgumberg/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/davidgumberg/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/davidgumberg/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/davidgumberg/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:davidgumberg/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/davidgumberg/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/davidgumberg/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/davidgumberg/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/davidgumberg/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/davidgumberg/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/davidgumberg/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/davidgumberg/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/davidgumberg/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/davidgumberg/bitcoin/hooks",
        "svn_url": "https://github.com/davidgumberg/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 228067,
        "default_branch": "master",
        "open_issues_count": 8,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-09-26T22:24:36Z",
        "created_at": "2022-08-27T00:44:27Z",
        "updated_at": "2024-09-20T18:17:12Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "36ad9516dbd6c0ff533251a4c3252cc24b192e73",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36204,
        "stargazers_count": 78555,
        "watchers_count": 78555,
        "size": 269017,
        "default_branch": "master",
        "open_issues_count": 665,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-09-26T15:51:36Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-09-26T22:39:53Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30987"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 17,
    "deletions": 62,
    "changed_files": 4,
    "commits": 3,
    "review_comments": 0,
    "comments": 1
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA0NDlhMjJiYzBiY2Q2MTBhODk4ZWM5MjFhZjMwMTc1ZTJiMzQ3NTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0449a22bc0bcd610a898ec921af30175e2b34757",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0449a22bc0bcd610a898ec921af30175e2b34757",
      "tree": {
        "sha": "03fb0e70e490441389f4569021bb1904e252b540",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/03fb0e70e490441389f4569021bb1904e252b540"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/36ad9516dbd6c0ff533251a4c3252cc24b192e73",
          "sha": "36ad9516dbd6c0ff533251a4c3252cc24b192e73",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/36ad9516dbd6c0ff533251a4c3252cc24b192e73"
        }
      ],
      "message": "test: avoid BOOST_CHECK_EQUAL for complex types\n\nAvoid using BOOST_CHECK_EQUAL_COLLECTIONS for two\nstd::vector<std::pair<SerializeData, SerializeData>> since boost expects\nprinting methods that are very brittle. See:\n\n* https://www.boost.org/doc/libs/1_86_0/libs/test/doc/html/boost_test/test_output/test_tools_support_for_logging/testing_tool_output_disable.html\n* https://stackoverflow.com/questions/10976130/boost-check-equal-with-pairint-int-and-custom-operator\n* https://stackoverflow.com/questions/3999644/how-to-compare-vectors-with-boost-test\n* https://github.com/boostorg/type_traits/issues/196",
      "committer": {
        "name": "David Gumberg",
        "email": "davidzgumberg@gmail.com",
        "date": "2024-09-26T22:18:13Z"
      },
      "author": {
        "name": "David Gumberg",
        "email": "davidzgumberg@gmail.com",
        "date": "2024-08-17T01:03:14Z"
      },
      "sha": "0449a22bc0bcd610a898ec921af30175e2b34757"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdjN2YwMGQxMWU4MTM0NDk4OTZlYTQ4NmM4MzBmNGVhOTI2MmQ3Mjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7c7f00d11e813449896ea486c830f4ea9262d728",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7c7f00d11e813449896ea486c830f4ea9262d728",
      "tree": {
        "sha": "4dd2eddd22bcd52294cf3231401859a0b666e1f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4dd2eddd22bcd52294cf3231401859a0b666e1f8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0449a22bc0bcd610a898ec921af30175e2b34757",
          "sha": "0449a22bc0bcd610a898ec921af30175e2b34757",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0449a22bc0bcd610a898ec921af30175e2b34757"
        }
      ],
      "message": "Stop zero-before-freeing all serialized data",
      "committer": {
        "name": "David Gumberg",
        "email": "davidzgumberg@gmail.com",
        "date": "2024-09-26T22:18:13Z"
      },
      "author": {
        "name": "David Gumberg",
        "email": "davidzgumberg@gmail.com",
        "date": "2024-08-15T22:09:33Z"
      },
      "sha": "7c7f00d11e813449896ea486c830f4ea9262d728"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ5MGViMDBkOGIzM2EzODM5YjExM2FjYmJiYjdkOWU1OGNmZmIxNDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d90eb00d8b33a3839b113acbbbb7d9e58cffb148",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d90eb00d8b33a3839b113acbbbb7d9e58cffb148",
      "tree": {
        "sha": "1f72dd41f88d4a3a6bf417873b24d8a957b8b61f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1f72dd41f88d4a3a6bf417873b24d8a957b8b61f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7c7f00d11e813449896ea486c830f4ea9262d728",
          "sha": "7c7f00d11e813449896ea486c830f4ea9262d728",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7c7f00d11e813449896ea486c830f4ea9262d728"
        }
      ],
      "message": "Drop unused `zero_after_free_allocator`",
      "committer": {
        "name": "David Gumberg",
        "email": "davidzgumberg@gmail.com",
        "date": "2024-09-26T22:18:13Z"
      },
      "author": {
        "name": "David Gumberg",
        "email": "davidzgumberg@gmail.com",
        "date": "2024-08-15T22:12:35Z"
      },
      "sha": "d90eb00d8b33a3839b113acbbbb7d9e58cffb148"
    },
    {
      "event": "commented",
      "id": 2378063467,
      "node_id": "IC_kwDOABII586Nvl5r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2378063467",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-26T22:40:35Z",
      "updated_at": "2024-09-26T22:40:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30987).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30987#issuecomment-2378063467",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30987"
    }
  ],
  "comments": []
}