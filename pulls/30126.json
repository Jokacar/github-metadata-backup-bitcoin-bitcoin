{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126",
    "id": 1874254526,
    "node_id": "PR_kwDOABII585vttq-",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30126.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30126.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
    "number": 30126,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "cluster mempool: cluster linearization algorithm",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Part of cluster mempool: #30289 \r\r\n\r\nThis introduces low-level cluster linearization code, including tests and some benchmarks. It is currently not hooked up to anything.\r\n\r\nUltimately, what this PR adds is a function `Linearize` which operates on instances of `DepGraph` (instances of which represent pre-processed transaction clusters) to produce and/or improve linearizations for that cluster.\r\n\r\nTo provide assurance, the code heavily relies on fuzz tests. A novel approach is used here, where the fuzz input is parsed using the serialization.h framework rather than `FuzzedDataProvider`, with a custom serializer/deserializer for `DepGraph` objects. By including serialization, it's possible to ascertain that the format can represent every relevant cluster, as well as potentially permitting the construction of ad-hoc fuzz inputs from clusters (not included in this PR, but used during development).\r\n\r\n---\r\n\r\nThe `Linearize(depgraph, iteration_limit, rng_seed, old_linearization)` function is an implementation of the (single) [LIMO](https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825) algorithm, with the $S$ in every iteration found as the best out of (a) the best remaining ancestor set and (b) randomized computationally-bounded search. It incrementally builds up a linearization by finding good topologically-valid subsets to move to the front, in such a way that the resulting linearization has a diagram that is at least as good as the `old_linearization` passed in (if any).\r\n* Despite using both best ancestor set and search, this is not Double LIMO, as no intersections between these are involved; just the best of the two.\r\n* The `iteration_limit` and `rng_seed` only control the (b) randomized search. Even with 0 iterations, the result will be as good as the old linearization, and the included sets at every point will have a feerate at least as high as the best remaining ancestor set at that point.\r\n\r\nThe search algorithm used in the (b) step is very basic. See #30286 for optimizations to make it more efficient.",
    "labels": [
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      },
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2024-05-16T20:29:15Z",
    "updated_at": "2024-06-28T03:53:46Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "71c8336e328152d4c62bd4faf9390e3efa2695a5",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202405_clusterlin",
      "ref": "202405_clusterlin",
      "sha": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 22,
        "stargazers_count": 86,
        "watchers_count": 86,
        "size": 241552,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-06-28T03:53:44Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-06-02T01:19:44Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "2f6dca4d1c01ee47275a4292f128d714736837a1",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35581,
        "stargazers_count": 77033,
        "watchers_count": 77033,
        "size": 262278,
        "default_branch": "master",
        "open_issues_count": 685,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-06-28T03:53:48Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-06-28T02:58:34Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1716,
    "deletions": 0,
    "changed_files": 9,
    "commits": 10,
    "review_comments": 64,
    "comments": 17
  },
  "events": [
    {
      "event": "commented",
      "id": 2116123949,
      "node_id": "IC_kwDOABII585-IX0t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116123949",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T20:29:17Z",
      "updated_at": "2024-06-27T03:47:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30126).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30286](https://github.com/bitcoin/bitcoin/pull/30286) (cluster mempool: optimized candidate search by sipa)\n* [#30285](https://github.com/bitcoin/bitcoin/pull/30285) (cluster mempool: merging & postprocessing of linearizations by sipa)\n* [#28676](https://github.com/bitcoin/bitcoin/pull/28676) ([WIP] Cluster mempool implementation by sdaftuar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2116123949",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "labeled",
      "id": 12840661156,
      "node_id": "LE_lADOABII586JKtCPzwAAAAL9XPCk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12840661156",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T22:28:58Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2116307861,
      "node_id": "IC_kwDOABII585-JEuV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116307861",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T22:28:59Z",
      "updated_at": "2024-05-16T22:28:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25072594213</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2116307861",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12841939086,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9cHCO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12841939086",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T02:20:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12841977041,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9cQTR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12841977041",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T02:25:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12841998527,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9cVi_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12841998527",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T02:28:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12847794028,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL9ycds",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12847794028",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T12:38:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12848600848,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL91hcQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12848600848",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T13:38:24Z"
    },
    {
      "event": "unlabeled",
      "id": 12849722556,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAL95zS8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12849722556",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T14:53:37Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 12852777283,
      "node_id": "LE_lADOABII586JKtCPzwAAAAL-FdFD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12852777283",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T19:54:02Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12859897701,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL-gndl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12859897701",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T01:34:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12859902015,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL-gog_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12859902015",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T01:35:33Z"
    },
    {
      "event": "labeled",
      "id": 12860230371,
      "node_id": "LE_lADOABII586JKtCPzwAAAAL-h4rj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12860230371",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T02:43:26Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 12868212799,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAL_AVg_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12868212799",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T16:03:14Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12869818131,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL_GdcT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12869818131",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T18:49:29Z"
    },
    {
      "event": "commented",
      "id": 2121018386,
      "node_id": "IC_kwDOABII585-bCwS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2121018386",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T18:53:52Z",
      "updated_at": "2024-05-20T19:16:50Z",
      "author_association": "MEMBER",
      "body": "Benchmarks on my Ryzen 5950X system:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|            2,373.94 |          421,240.11 |    0.1% |      1.10 | `LinearizeNoIters16TxWorstCase`\r\n|            7,530.22 |          132,798.26 |    0.0% |      1.07 | `LinearizeNoIters32TxWorstCase`\r\n|           16,585.34 |           60,294.20 |    0.1% |      1.10 | `LinearizeNoIters48TxWorstCase`\r\n|           28,591.70 |           34,975.18 |    0.1% |      1.10 | `LinearizeNoIters64TxWorstCase`\r\n|           53,918.56 |           18,546.49 |    0.0% |      1.10 | `LinearizeNoIters75TxWorstCase`\r\n|           93,589.21 |           10,684.99 |    0.1% |      1.10 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               45.36 |       22,045,550.98 |    0.5% |      1.10 | `LinearizePerIter16TxWorstCase`\r\n|               35.57 |       28,111,376.58 |    0.1% |      1.10 | `LinearizePerIter32TxWorstCase`\r\n|               33.04 |       30,262,951.89 |    0.0% |      1.10 | `LinearizePerIter48TxWorstCase`\r\n|               33.21 |       30,107,745.17 |    0.1% |      1.10 | `LinearizePerIter64TxWorstCase`\r\n|               75.98 |       13,161,530.63 |    0.4% |      1.07 | `LinearizePerIter75TxWorstCase`\r\n|               76.62 |       13,051,066.77 |    0.5% |      1.08 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              332.97 |        3,003,274.74 |    0.0% |      1.10 | `PostLinearize16TxWorstCase`\r\n|            1,121.92 |          891,330.77 |    0.0% |      1.10 | `PostLinearize32TxWorstCase`\r\n|            3,358.33 |          297,767.01 |    0.3% |      1.13 | `PostLinearize48TxWorstCase`\r\n|            5,826.72 |          171,623.05 |    0.5% |      1.11 | `PostLinearize64TxWorstCase`\r\n|            7,453.31 |          134,168.55 |    0.1% |      1.07 | `PostLinearize75TxWorstCase`\r\n|           12,476.44 |           80,151.09 |    0.1% |      1.10 | `PostLinearize99TxWorstCase`\r\n\r\nThis means that for a 64-transaction cluster, it should be possible to linearize (28.59 µs) with 100 candidate search iterations (3.32 µs) plus postlinearize (5.83 µs), within a total of 37.74 µs, on my system.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2121018386",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12871304039,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAL_MINn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12871304039",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T21:33:55Z"
    },
    {
      "event": "labeled",
      "id": 12884960646,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMAAOWG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12884960646",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T20:09:26Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "reviewed",
      "id": 2074233399,
      "node_id": "PRR_kwDOABII5857oko3",
      "url": null,
      "actor": null,
      "commit_id": "316e2044aad16e1ed8d024d3325bfcee8c04cd1f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2074233399",
      "submitted_at": "2024-05-23T14:55:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12911183405,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMBkQYt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911183405",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:15:40Z"
    },
    {
      "event": "commented",
      "id": 2127404990,
      "node_id": "IC_kwDOABII585-zZ--",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127404990",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:18:30Z",
      "updated_at": "2024-05-23T15:19:11Z",
      "author_association": "MEMBER",
      "body": "I've dropped the dependency on #29625, and switched to using FastRandomContext instead; there is a measurable slowdown from using the (ChaCha20-based) FastRandomContext over the (xoroshiro128++-based) InsecureRandomContext introduced there, but it's no more than 1-2%. I can switch back to that approach if 29625 were to make it in.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2127404990",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12911356100,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMBk6jE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911356100",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:28:02Z"
    },
    {
      "event": "unlabeled",
      "id": 12911651125,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMBmCk1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911651125",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:48:19Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12913685226,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMBtzLq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913685226",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:23:24Z"
    },
    {
      "event": "commented",
      "id": 2127799066,
      "node_id": "IC_kwDOABII585-06Ma",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127799066",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:33:11Z",
      "updated_at": "2024-05-23T18:33:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--9cd9c72976c961c55c7acef8f6ba82cd-->\n### Guix builds (on x86_64) [untrusted test-only build, possibly unsafe, not for production use]\n\n| File | commit 83ae1bac9d3e01de994734b4bc7002deaf19bc67<br>(master) | commit e5cbc2372efc917784b6cae4175b8653a20517c4<br>(master and this pull) |\n|--|--|--|\n| SHA256SUMS.part | [`24fd016e03e8c7da...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/SHA256SUMS.part) | [`15fae3483445e33b...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/SHA256SUMS.part) |\n| *-aarch64-linux-gnu-debug.tar.gz | [`94942cf7dedf3604...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-aarch64-linux-gnu-debug.tar.gz) | [`23eeccf77ee5799d...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-aarch64-linux-gnu-debug.tar.gz) |\n| *-aarch64-linux-gnu.tar.gz | [`4b30ca93b6788f48...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-aarch64-linux-gnu.tar.gz) | [`ed8e5024d960f53e...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-aarch64-linux-gnu.tar.gz) |\n| *-arm-linux-gnueabihf-debug.tar.gz | [`a0f57c45e5f02bb1...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm-linux-gnueabihf-debug.tar.gz) | [`f22f89c1eba49dda...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm-linux-gnueabihf-debug.tar.gz) |\n| *-arm-linux-gnueabihf.tar.gz | [`9f0376baaf54b988...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm-linux-gnueabihf.tar.gz) | [`17da8a968635c492...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm-linux-gnueabihf.tar.gz) |\n| *-arm64-apple-darwin-unsigned.tar.gz | [`9b952b32db70d099...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm64-apple-darwin-unsigned.tar.gz) | [`16d805ab4bcf8d54...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm64-apple-darwin-unsigned.tar.gz) |\n| *-arm64-apple-darwin-unsigned.zip | [`d49361bbbc5529fc...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm64-apple-darwin-unsigned.zip) | [`e225d79a24b058a5...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm64-apple-darwin-unsigned.zip) |\n| *-arm64-apple-darwin.tar.gz | [`34e9cf4b79cbc190...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-arm64-apple-darwin.tar.gz) | [`29b28e6d57761201...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-arm64-apple-darwin.tar.gz) |\n| *-powerpc64-linux-gnu-debug.tar.gz | [`5f322a7b213e244e...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-powerpc64-linux-gnu-debug.tar.gz) | [`cb5f37b036b5c52c...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-powerpc64-linux-gnu-debug.tar.gz) |\n| *-powerpc64-linux-gnu.tar.gz | [`bb57b46482c5b1e6...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-powerpc64-linux-gnu.tar.gz) | [`57adf954458a27d5...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-powerpc64-linux-gnu.tar.gz) |\n| *-riscv64-linux-gnu-debug.tar.gz | [`d1a3a405c5b45fff...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-riscv64-linux-gnu-debug.tar.gz) | [`237eb467f8547d22...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-riscv64-linux-gnu-debug.tar.gz) |\n| *-riscv64-linux-gnu.tar.gz | [`68d7e6671e2dba30...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-riscv64-linux-gnu.tar.gz) | [`29d9f1e9052e96d3...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-riscv64-linux-gnu.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.tar.gz | [`6fb22000e8c14c40...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-apple-darwin-unsigned.tar.gz) | [`67e5bd5b86483c8a...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-apple-darwin-unsigned.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.zip | [`1c5f2a216e87cbf5...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-apple-darwin-unsigned.zip) | [`abdbca97fafc146f...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-apple-darwin-unsigned.zip) |\n| *-x86_64-apple-darwin.tar.gz | [`66f17a574163ecaf...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-apple-darwin.tar.gz) | [`f002830b4b8da330...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-apple-darwin.tar.gz) |\n| *-x86_64-linux-gnu-debug.tar.gz | [`a5044f956a824228...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-linux-gnu-debug.tar.gz) | [`0791685e39e80672...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-linux-gnu-debug.tar.gz) |\n| *-x86_64-linux-gnu.tar.gz | [`23af1dc6cb921b37...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e-x86_64-linux-gnu.tar.gz) | [`ff9625165c3f19c2...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc-x86_64-linux-gnu.tar.gz) |\n| *.tar.gz | [`caac4a182deb1e04...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/bitcoin-83ae1bac9d3e.tar.gz) | [`ba8abeef4165dafb...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/bitcoin-e5cbc2372efc.tar.gz) |\n| guix_build.log | [`c7cc0190f7085f04...`](https://drahtbot.space/guix/bitcoin/bitcoin/83ae1bac9d3e01de994734b4bc7002deaf19bc67/guix_build.log) | [`100da60c2f0e6686...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/guix_build.log) |\n| guix_build.log.diff |  | [`7c460aa3b1aafc32...`](https://drahtbot.space/guix/bitcoin/bitcoin/e5cbc2372efc917784b6cae4175b8653a20517c4/guix_build.log.diff) |\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2127799066",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12926701844,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCfdEU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12926701844",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T15:33:59Z"
    },
    {
      "event": "commented",
      "id": 2129982443,
      "node_id": "IC_kwDOABII585-9PPr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129982443",
      "actor": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T16:49:21Z",
      "updated_at": "2024-05-24T16:49:21Z",
      "author_association": "MEMBER",
      "body": "Some more benchmarks.\r\n\r\nMacBook M3 Max:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|            1,678.30 |          595,841.56 |    0.4% |      1.11 | `LinearizeNoIters16TxWorstCase`\r\n|            4,975.16 |          200,998.49 |    0.1% |      1.10 | `LinearizeNoIters32TxWorstCase`\r\n|           10,624.85 |           94,118.94 |    0.1% |      1.10 | `LinearizeNoIters48TxWorstCase`\r\n|           18,570.63 |           53,848.46 |    0.1% |      1.10 | `LinearizeNoIters64TxWorstCase`\r\n|           38,962.09 |           25,665.97 |    0.1% |      1.10 | `LinearizeNoIters75TxWorstCase`\r\n|           65,933.96 |           15,166.69 |    0.1% |      1.06 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               37.31 |       26,803,657.99 |    0.1% |      1.10 | `LinearizePerIter16TxWorstCase`\r\n|               26.62 |       37,561,209.12 |    0.2% |      1.10 | `LinearizePerIter32TxWorstCase`\r\n|               25.79 |       38,768,485.22 |    0.2% |      1.10 | `LinearizePerIter48TxWorstCase`\r\n|               26.05 |       38,392,847.23 |    0.1% |      1.10 | `LinearizePerIter64TxWorstCase`\r\n|               37.99 |       26,322,699.89 |    0.2% |      1.09 | `LinearizePerIter75TxWorstCase`\r\n|               38.21 |       26,169,082.76 |    0.1% |      1.10 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              375.76 |        2,661,273.20 |    0.3% |      1.11 | `PostLinearize16TxWorstCase`\r\n|            1,295.00 |          772,200.32 |    0.1% |      1.10 | `PostLinearize32TxWorstCase`\r\n|            2,850.98 |          350,756.38 |    0.0% |      1.10 | `PostLinearize48TxWorstCase`\r\n|            5,155.30 |          193,975.14 |    0.0% |      1.10 | `PostLinearize64TxWorstCase`\r\n|            6,804.84 |          146,954.16 |    0.1% |      1.06 | `PostLinearize75TxWorstCase`\r\n|           11,696.22 |           85,497.68 |    0.0% |      1.10 | `PostLinearize99TxWorstCase`\r\n\r\nRaspberry Pi 4 (arm32):\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|           24,979.12 |           40,033.43 |    0.1% |       62,303.01 |       37,432.31 |  1.664 |      1.10 | `LinearizeNoIters16TxWorstCase`\r\n|           79,796.77 |           12,531.84 |    0.0% |      199,042.69 |      119,579.10 |  1.665 |      1.08 | `LinearizeNoIters32TxWorstCase`\r\n|          206,049.75 |            4,853.20 |    0.0% |      514,152.74 |      308,732.11 |  1.665 |      1.10 | `LinearizeNoIters48TxWorstCase`\r\n|          339,314.40 |            2,947.12 |    0.0% |      866,686.12 |      508,414.12 |  1.705 |      1.10 | `LinearizeNoIters64TxWorstCase`\r\n|          574,288.94 |            1,741.28 |    0.0% |    1,309,819.21 |      860,366.98 |  1.522 |      1.10 | `LinearizeNoIters75TxWorstCase`\r\n|          983,808.56 |            1,016.46 |    0.0% |    2,278,204.68 |    1,474,149.12 |  1.545 |      1.10 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |       ins/iters |       cyc/iters |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|              362.94 |        2,755,255.49 |    0.1% |          862.03 |          543.89 |  1.585 |      1.10 | `LinearizePerIter16TxWorstCase`\r\n|              290.11 |        3,446,974.76 |    0.2% |          692.02 |          434.73 |  1.592 |      1.10 | `LinearizePerIter32TxWorstCase`\r\n|              529.35 |        1,889,094.80 |    0.1% |        1,319.02 |          793.26 |  1.663 |      1.11 | `LinearizePerIter48TxWorstCase`\r\n|              530.00 |        1,886,788.68 |    0.2% |        1,324.44 |          794.26 |  1.668 |      1.11 | `LinearizePerIter64TxWorstCase`\r\n|              782.35 |        1,278,197.39 |    0.5% |        2,079.81 |        1,172.37 |  1.774 |      1.06 | `LinearizePerIter75TxWorstCase`\r\n|              737.95 |        1,355,112.46 |    0.5% |        1,684.40 |        1,105.59 |  1.524 |      1.07 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|            5,010.36 |          199,586.29 |    0.8% |       10,606.00 |        7,506.09 |  1.413 |      1.10 | `PostLinearize16TxWorstCase`\r\n|           14,365.91 |           69,609.26 |    0.0% |       34,330.00 |       21,530.90 |  1.594 |      1.09 | `PostLinearize32TxWorstCase`\r\n|           32,751.91 |           30,532.57 |    0.0% |       76,671.01 |       49,085.98 |  1.562 |      1.10 | `PostLinearize48TxWorstCase`\r\n|           55,794.83 |           17,922.81 |    0.0% |      131,423.02 |       83,621.11 |  1.572 |      1.10 | `PostLinearize64TxWorstCase`\r\n|           81,534.00 |           12,264.82 |    1.6% |      210,784.02 |      120,341.56 |  1.752 |      1.09 | `PostLinearize75TxWorstCase`\r\n|          144,665.53 |            6,912.50 |    0.0% |      399,573.04 |      216,805.74 |  1.843 |      1.10 | `PostLinearize99TxWorstCase`\r\n\r\nRaspberry Pi 4 (aarch64):\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|           13,765.93 |           72,643.09 |    0.1% |       37,001.00 |       20,625.64 |  1.794 |     11.01 | `LinearizeNoIters16TxWorstCase`\r\n|           41,091.94 |           24,335.67 |    0.2% |      107,447.00 |       61,567.66 |  1.745 |     10.99 | `LinearizeNoIters32TxWorstCase`\r\n|           73,005.68 |           13,697.56 |    0.1% |      210,986.00 |      109,380.97 |  1.929 |     10.67 | `LinearizeNoIters48TxWorstCase`\r\n|          118,418.69 |            8,444.61 |    0.0% |      348,914.00 |      177,423.52 |  1.967 |     11.01 | `LinearizeNoIters64TxWorstCase`\r\n|          229,345.84 |            4,360.23 |    0.0% |      618,749.67 |      343,589.10 |  1.801 |     11.01 | `LinearizeNoIters75TxWorstCase`\r\n|          377,809.11 |            2,646.84 |    0.0% |    1,021,644.01 |      565,996.91 |  1.805 |     11.00 | `LinearizeNoIters99TxWorstCase`\r\n\r\n|            ns/iters |             iters/s |    err% |       ins/iters |       cyc/iters |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|              231.99 |        4,310,566.43 |    0.0% |          643.14 |          347.59 |  1.850 |     11.00 | `LinearizePerIter16TxWorstCase`\r\n|              190.47 |        5,250,207.80 |    0.1% |          525.81 |          285.35 |  1.843 |     11.03 | `LinearizePerIter32TxWorstCase`\r\n|              175.35 |        5,702,969.82 |    0.1% |          492.10 |          262.75 |  1.873 |     11.01 | `LinearizePerIter48TxWorstCase`\r\n|              175.70 |        5,691,481.30 |    0.1% |          494.56 |          263.25 |  1.879 |     11.00 | `LinearizePerIter64TxWorstCase`\r\n|              293.22 |        3,410,384.42 |    0.2% |          763.38 |          439.30 |  1.738 |     11.01 | `LinearizePerIter75TxWorstCase`\r\n|              293.55 |        3,406,519.94 |    0.1% |          766.88 |          439.77 |  1.744 |     11.01 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|            2,915.23 |          343,026.59 |    0.1% |        5,325.00 |        4,368.47 |  1.219 |     11.01 | `PostLinearize16TxWorstCase`\r\n|            9,830.26 |          101,726.71 |    0.0% |       17,247.00 |       14,729.95 |  1.171 |     11.00 | `PostLinearize32TxWorstCase`\r\n|           20,550.14 |           48,661.46 |    0.0% |       35,742.00 |       30,794.09 |  1.161 |     11.00 | `PostLinearize48TxWorstCase`\r\n|           35,211.73 |           28,399.62 |    0.0% |       61,199.00 |       52,763.93 |  1.160 |     11.00 | `PostLinearize64TxWorstCase`\r\n|           31,801.73 |           31,444.83 |    0.0% |       95,378.00 |       47,653.77 |  2.001 |     11.00 | `PostLinearize75TxWorstCase`\r\n|           52,955.80 |           18,883.67 |    0.0% |      162,443.00 |       79,349.66 |  2.047 |     11.00 | `PostLinearize99TxWorstCase`",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2129982443",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927624409,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCi-TZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927624409",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:03:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927882366,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCj9R-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927882366",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:30:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927934896,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMCkKGw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927934896",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:36:57Z"
    },
    {
      "event": "labeled",
      "id": 12927935505,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMCkKQR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927935505",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:37:01Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2130060489,
      "node_id": "IC_kwDOABII585-9iTJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130060489",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:37:02Z",
      "updated_at": "2024-05-24T17:37:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25390396918</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2130060489",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2130129883,
      "node_id": "IC_kwDOABII585-9zPb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130129883",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T18:26:06Z",
      "updated_at": "2024-05-24T18:26:06Z",
      "author_association": "MEMBER",
      "body": "> Ancestor-set based presplitting inside the search is replaced with using the best ancestor set as one of the LIMO set choices.\r\n\r\nCan this be elaborated a bit? I've taken a few minutes looking at the commits and it wasn't immediately clear how this all maps to existing public discussions and the comments:\r\n\r\n```\r\n        // This is an implementation of the (single) LIMO algorithm:\r\n        // https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\r\n        // where S is instantiated to be the result of a bounded search, which itself is seeded\r\n        // with the best prefix of what remains of the input linearization, or the best ancestor set.\r\n```\r\nthanks!",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2130129883",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "commented",
      "id": 2130187888,
      "node_id": "IC_kwDOABII585--BZw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130187888",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:05:02Z",
      "updated_at": "2024-05-24T19:16:08Z",
      "author_association": "MEMBER",
      "body": "@instagibbs I've expanded the explanation in the PR description. Happy to elaborate more if things are unclear.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2130187888",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "mentioned",
      "id": 12928689814,
      "node_id": "MEE_lADOABII586JKtCPzwAAAAMCnCaW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12928689814",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:05:04Z"
    },
    {
      "event": "subscribed",
      "id": 12928689822,
      "node_id": "SE_lADOABII586JKtCPzwAAAAMCnCae",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12928689822",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:05:04Z"
    },
    {
      "event": "unlabeled",
      "id": 12930191775,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMCsxGf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12930191775",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T22:47:36Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934054913,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMC7gQB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934054913",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T22:07:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934290395,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMC8Zvb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934290395",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T23:42:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934323825,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMC8h5x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934323825",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-26T00:00:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12936811909,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMDGBWF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12936811909",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-26T13:32:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12958045312,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMEXBSA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12958045312",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T13:50:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12975512592,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMFZpwQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12975512592",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T18:06:13Z"
    },
    {
      "event": "commented",
      "id": 2138188901,
      "node_id": "IC_kwDOABII585_cixl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2138188901",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T20:14:05Z",
      "updated_at": "2024-05-29T20:14:05Z",
      "author_association": "MEMBER",
      "body": "I've added support for merging linearizations to this PR (`MergeLinearizations()` function), plus benchmarks and tests.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2138188901",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "labeled",
      "id": 12980402065,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMFsTeR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12980402065",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T05:55:09Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2138735594,
      "node_id": "IC_kwDOABII585_eoPq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2138735594",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T05:55:10Z",
      "updated_at": "2024-05-30T05:55:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25568469819</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2138735594",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12985679275,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMGAb2r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12985679275",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T12:52:10Z"
    },
    {
      "event": "unlabeled",
      "id": 12991846022,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMGX9aG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12991846022",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T21:07:01Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2077166958,
      "node_id": "PRR_kwDOABII5857zw1u",
      "url": null,
      "actor": null,
      "commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "glanced in the context of checking what of VecDeque/BitSet actually required",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2077166958",
      "submitted_at": "2024-06-06T14:13:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13070771117,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMLFCOt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13070771117",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T18:33:20Z"
    },
    {
      "event": "referenced",
      "id": 13081030834,
      "node_id": "REFE_lADOABII586JKtCPzwAAAAMLsLCy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13081030834",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "feab35189bc00bc4cf15e9dcb5cf6b34ff3a1e91",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/feab35189bc00bc4cf15e9dcb5cf6b34ff3a1e91",
      "created_at": "2024-06-07T13:33:20Z"
    },
    {
      "event": "labeled",
      "id": 13082095784,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMLwPCo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13082095784",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T14:44:39Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13082513580,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMLx1Cs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13082513580",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T15:20:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13084466690,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAML5R4C",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13084466690",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T18:52:51Z"
    },
    {
      "event": "unlabeled",
      "id": 13084572312,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAML5rqY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13084572312",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T19:04:25Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13085738874,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAML-Id6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13085738874",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T21:37:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13093283115,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMMa6Ur",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13093283115",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-10T00:28:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13109045660,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMNXCmc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13109045660",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T00:58:52Z"
    },
    {
      "event": "labeled",
      "id": 13110771411,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMNdn7T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13110771411",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T05:11:18Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2159806599,
      "node_id": "IC_kwDOABII586AvAiH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2159806599",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T05:11:19Z",
      "updated_at": "2024-06-11T05:11:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26052313359</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2159806599",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13115580682,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMNv-EK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13115580682",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T11:23:21Z"
    },
    {
      "event": "unlabeled",
      "id": 13117085849,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMN1tiZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13117085849",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T13:15:11Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13122043976,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMOIoBI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122043976",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T19:51:04Z"
    },
    {
      "event": "referenced",
      "id": 13122953655,
      "node_id": "REFE_lADOABII586JKtCPzwAAAAMOMGG3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122953655",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "91e0beede2859dea987ba6db746e95dca0ceb024",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91e0beede2859dea987ba6db746e95dca0ceb024",
      "created_at": "2024-06-11T21:28:58Z"
    },
    {
      "event": "labeled",
      "id": 13123639969,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMOOtqh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13123639969",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T23:12:20Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13123652095,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMOOwn_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13123652095",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T23:14:29Z"
    },
    {
      "event": "unlabeled",
      "id": 13124366874,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMORfIa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13124366874",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T01:17:30Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13137473518,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPDe_u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13137473518",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T21:14:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13137755681,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPEj4h",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13137755681",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T21:47:11Z"
    },
    {
      "event": "labeled",
      "id": 13143080877,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMPY3-t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13143080877",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T08:57:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2165049648,
      "node_id": "IC_kwDOABII586BDAkw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2165049648",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T08:57:46Z",
      "updated_at": "2024-06-13T08:57:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26153096652</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2165049648",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13147233559,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPot0X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13147233559",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T13:49:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13148811159,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPuu-X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13148811159",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T15:26:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13150112020,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMPzskU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13150112020",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T17:01:33Z"
    },
    {
      "event": "unlabeled",
      "id": 13151725563,
      "node_id": "UNLE_lADOABII586JKtCPzwAAAAMP52f7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13151725563",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T19:14:32Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13151774954,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMP6Cjq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13151774954",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-13T19:19:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13154448696,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMQEPU4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13154448696",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T01:47:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13154557139,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMQEpzT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13154557139",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T02:05:33Z"
    },
    {
      "event": "renamed",
      "id": 13160829573,
      "node_id": "RTE_lADOABII586JKtCPzwAAAAMQclKF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13160829573",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T13:12:50Z",
      "rename": {
        "from": "Low-level cluster linearization code",
        "to": "cluster mempool: cluster linearization algorithm"
      }
    },
    {
      "event": "commented",
      "id": 2168024936,
      "node_id": "IC_kwDOABII586BOW9o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168024936",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T13:17:11Z",
      "updated_at": "2024-06-14T13:17:11Z",
      "author_association": "MEMBER",
      "body": "I have split off the optimizations for candidate search to PR #30286, and the merging & postprocessing algorithms to PR #30285, and renamed the PR. It is now focused on just adding the `Linearize()` function, with its eventual interface (including passing in an old linearization, and a randomization seed), but without optimizations beyond that.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2168024936",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13235415708,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMU5Gqc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13235415708",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-20T23:08:33Z"
    },
    {
      "event": "commented",
      "id": 2181689921,
      "node_id": "IC_kwDOABII586CCfJB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2181689921",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-20T23:09:06Z",
      "updated_at": "2024-06-20T23:09:06Z",
      "author_association": "MEMBER",
      "body": "Added a big description about the fuzzer serialization format for DepGraph objects.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2181689921",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "reviewed",
      "id": 2116172410,
      "node_id": "PRR_kwDOABII585-Ijp6",
      "url": null,
      "actor": null,
      "commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "couldn't find any logic issues in the parts I complete understood, I've run the fuzzer on each commit and reviewed through  https://github.com/bitcoin/bitcoin/pull/30126/commits/9633b40722fd9295b93baaf9914b31b9dec96f45\r\n\r\na couple general comments:\r\n\r\n1) The bespoke DepGraphFormatter is pretty artisanal and as a reviewer I'm relying heavily on the cluster->depgraph->check depgraph matches -> serialization round-trip for asserting correctness. Unit tests-as-documentation is one thing I'm kind of missing, especially with the more involved parts.\r\n2) Matching the actual LIMO commit with the LIMO literature/theory available is difficult for me(e.g., what's sufficient vs necessary). I know there's a new writeup coming, so I'll wait for that before investigating further.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#pullrequestreview-2116172410",
      "submitted_at": "2024-06-27T15:02:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13323909917,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMaKrsd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13323909917",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:57:19Z"
    },
    {
      "event": "commented",
      "id": 2195728404,
      "node_id": "IC_kwDOABII586C4CgU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2195728404",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:59:06Z",
      "updated_at": "2024-06-27T21:59:06Z",
      "author_association": "MEMBER",
      "body": "Addressed some of @instagibbs' comments, which involved moving some of the `src/test/fuzz/cluster_linearize.cpp` code to a common `src/test/util/cluster_linearize.h`, where it is also available to a newly-added (but pretty barebones) `src/test/cluster_linearize_tests.cpp`.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2195728404",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "mentioned",
      "id": 13323922870,
      "node_id": "MEE_lADOABII586JKtCPzwAAAAMaKu22",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13323922870",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:59:08Z"
    },
    {
      "event": "subscribed",
      "id": 13323922878,
      "node_id": "SE_lADOABII586JKtCPzwAAAAMaKu2-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13323922878",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T21:59:08Z"
    },
    {
      "event": "commented",
      "id": 2195825414,
      "node_id": "IC_kwDOABII586C4aMG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2195825414",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T23:27:50Z",
      "updated_at": "2024-06-27T23:27:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26783773668</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2195825414",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126"
    },
    {
      "event": "labeled",
      "id": 13324461892,
      "node_id": "LE_lADOABII586JKtCPzwAAAAMaMydE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13324461892",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-27T23:27:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJhYjM0NWU1MmM1NTU5MGM0ODlkY2RjMWExOTQ1ZjEyM2Q2OTJhNDQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2ab345e52c55590c489dcdc1a1945f123d692a44",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2ab345e52c55590c489dcdc1a1945f123d692a44",
      "tree": {
        "sha": "7e1659bfa8a25101de030c963d6b9c436636f0e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e1659bfa8a25101de030c963d6b9c436636f0e7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f6dca4d1c01ee47275a4292f128d714736837a1",
          "sha": "2f6dca4d1c01ee47275a4292f128d714736837a1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2f6dca4d1c01ee47275a4292f128d714736837a1"
        }
      ],
      "message": "clusterlin: introduce cluster_linearize.h with Cluster and DepGraph types\n\nThis primarily adds the DepGraph class, which encapsulated precomputed\nancestor/descendant information for a given transaction cluster, with a\nnumber of a utility features (inspectors for set feerates, computing\nreduced parents/children, adding transactions, adding dependencies), which\nwill become needed in future commits.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:49:10Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-01-30T03:05:53Z"
      },
      "sha": "2ab345e52c55590c489dcdc1a1945f123d692a44"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDlmNWEyM2M4NDk4YjI1NzE1ZjYzZDRiYzI5Y2JlNTQ5ZDIwY2I3NzQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f5a23c8498b25715f63d4bc29cbe549d20cb774",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9f5a23c8498b25715f63d4bc29cbe549d20cb774",
      "tree": {
        "sha": "664d8565b835565f81d9c6b32f2e63370461ec6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/664d8565b835565f81d9c6b32f2e63370461ec6a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2ab345e52c55590c489dcdc1a1945f123d692a44",
          "sha": "2ab345e52c55590c489dcdc1a1945f123d692a44",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2ab345e52c55590c489dcdc1a1945f123d692a44"
        }
      ],
      "message": "tests: framework for testing DepGraph class\n\nThis introduces a bespoke fuzzing-focused serialization format for DepGraphs,\nand then tests that this format can represent any graph, roundtrips, and then\nuses that to test the correctness of DepGraph itself.\n\nThis forms the basis for future fuzz tests that need to work with interesting\ngraph.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:53:10Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-09T00:52:56Z"
      },
      "sha": "9f5a23c8498b25715f63d4bc29cbe549d20cb774"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZkNzYxYzQ0YzFjNDNiYTM5NzgzOTFiNDczNjc2ODJjMzYzZDk0NTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d761c44c1c43ba3978391b47367682c363d9454",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6d761c44c1c43ba3978391b47367682c363d9454",
      "tree": {
        "sha": "b2c4209211b1e9fcd0b4023448e2b22f5d47e75d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b2c4209211b1e9fcd0b4023448e2b22f5d47e75d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f5a23c8498b25715f63d4bc29cbe549d20cb774",
          "sha": "9f5a23c8498b25715f63d4bc29cbe549d20cb774",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9f5a23c8498b25715f63d4bc29cbe549d20cb774"
        }
      ],
      "message": "clusterlin: add AncestorCandidateFinder class\n\nThis is a class that encapsulated precomputes ancestor set feerates, and\npresents an interface for getting the best remaining ancestor set.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:53:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-08T22:56:59Z"
      },
      "sha": "6d761c44c1c43ba3978391b47367682c363d9454"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDVhMjBlNGUwZDc2NmNkMzgyZDk2N2RjOWIzMTQ4MDQzYjNhODBmMjY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5a20e4e0d766cd382d967dc9b3148043b3a80f26",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5a20e4e0d766cd382d967dc9b3148043b3a80f26",
      "tree": {
        "sha": "bbbb269c7780f3768204086c4b75c6d0d48ad05b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bbbb269c7780f3768204086c4b75c6d0d48ad05b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d761c44c1c43ba3978391b47367682c363d9454",
          "sha": "6d761c44c1c43ba3978391b47367682c363d9454",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6d761c44c1c43ba3978391b47367682c363d9454"
        }
      ],
      "message": "clusterlin: add SearchCandidateFinder class\n\nSimilar to AncestorCandidateFinder, this encapsulates the state needed for\nfinding good candidate sets using a search algorithm.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:53:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-08T22:09:34Z"
      },
      "sha": "5a20e4e0d766cd382d967dc9b3148043b3a80f26"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDgwMWZhYzVhNDRjZTZiNDhkZWE4N2M5Y2YxY2E5ZGE4NWU2YTA5Zjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/801fac5a44ce6b48dea87c9cf1ca9da85e6a09f9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/801fac5a44ce6b48dea87c9cf1ca9da85e6a09f9",
      "tree": {
        "sha": "51e1be8b40787fb6499697333969b1312d346c8e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/51e1be8b40787fb6499697333969b1312d346c8e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5a20e4e0d766cd382d967dc9b3148043b3a80f26",
          "sha": "5a20e4e0d766cd382d967dc9b3148043b3a80f26",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5a20e4e0d766cd382d967dc9b3148043b3a80f26"
        }
      ],
      "message": "clusterlin: add Linearize function\n\nThis adds a first version of the overall linearization interface, which given\na DepGraph constructs a good linearization, by incrementally including good\ncandidate sets (found using AncestorCandidateFinder and SearchCandidateFinder).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:53:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-08T21:28:39Z"
      },
      "sha": "801fac5a44ce6b48dea87c9cf1ca9da85e6a09f9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY5NjNkYTgwYThiZjk2OWYwNzViOTc0ZWQ1MDlkMmE1N2FjY2I4MDY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6963da80a8bf969f075b974ed509d2a57accb806",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6963da80a8bf969f075b974ed509d2a57accb806",
      "tree": {
        "sha": "8a2815aa12ec545062ceb880267838ee47f9214b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8a2815aa12ec545062ceb880267838ee47f9214b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/801fac5a44ce6b48dea87c9cf1ca9da85e6a09f9",
          "sha": "801fac5a44ce6b48dea87c9cf1ca9da85e6a09f9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/801fac5a44ce6b48dea87c9cf1ca9da85e6a09f9"
        }
      ],
      "message": "bench: Candidate finding and linearization benchmarks\n\nAdd benchmarks for known bad graphs for the purpose of search (as\nan upper bound on work per search iterations) and ancestor sorting\n(as an upper bound on linearization work with no search iterations).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:53:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-16T01:09:31Z"
      },
      "sha": "6963da80a8bf969f075b974ed509d2a57accb806"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM0OGQ1ZjE4Yjc0NGUzMzQ5NmYxMWY1MTMxMWFiOWJlNTgyNmE4ZTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c48d5f18b744e33496f11f51311ab9be5826a8e3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c48d5f18b744e33496f11f51311ab9be5826a8e3",
      "tree": {
        "sha": "508308a39425aad6be592f46340330fee2edb041",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/508308a39425aad6be592f46340330fee2edb041"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6963da80a8bf969f075b974ed509d2a57accb806",
          "sha": "6963da80a8bf969f075b974ed509d2a57accb806",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6963da80a8bf969f075b974ed509d2a57accb806"
        }
      ],
      "message": "clusterlin: use bounded BFS exploration (optimization)\n\nSwitch to BFS exploration of the search tree in SearchCandidateFinder\ninstead of DFS exploration. This appears to behave better for real\nworld clusters.\n\nAs BFS has the downside of needing far larger search queues, switch\nback to DFS temporarily when the queue grows too large.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:53:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-09T15:53:02Z"
      },
      "sha": "c48d5f18b744e33496f11f51311ab9be5826a8e3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGEzNzBmMWNiNTY1ODMyMDBhZDNiZTA3MGU5OGU4ZDgxNzI3MDVhNmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a370f1cb56583200ad3be070e98e8d8172705a6b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a370f1cb56583200ad3be070e98e8d8172705a6b",
      "tree": {
        "sha": "3900cb662b2fe4af3492e56dfaa98fb0c61037bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3900cb662b2fe4af3492e56dfaa98fb0c61037bb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c48d5f18b744e33496f11f51311ab9be5826a8e3",
          "sha": "c48d5f18b744e33496f11f51311ab9be5826a8e3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c48d5f18b744e33496f11f51311ab9be5826a8e3"
        }
      ],
      "message": "clusterlin: randomize the SearchCandidateFinder search order\n\nTo make search non-deterministic, change the BFS logic from always picking\nthe first queue item, randomly picking the first or second queue item.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:53:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-10T01:41:52Z"
      },
      "sha": "a370f1cb56583200ad3be070e98e8d8172705a6b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZlMzNjNGJlZTk5ODRlYTFkN2ZiN2UxMGJjNTY1OWFkYjVlZDJmMjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6e33c4bee9984ea1d7fb7e10bc5659adb5ed2f23",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6e33c4bee9984ea1d7fb7e10bc5659adb5ed2f23",
      "tree": {
        "sha": "9bb73658e0270a773866e0d387ce950dd82c5ae5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9bb73658e0270a773866e0d387ce950dd82c5ae5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a370f1cb56583200ad3be070e98e8d8172705a6b",
          "sha": "a370f1cb56583200ad3be070e98e8d8172705a6b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a370f1cb56583200ad3be070e98e8d8172705a6b"
        }
      ],
      "message": "clusterlin: permit passing in existing linearization to Linearize\n\nThis implements the LIMO algorithm for linearizing by improving an existing\nlinearization. See\nhttps://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging\nfor details.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:53:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-09T13:02:18Z"
      },
      "sha": "6e33c4bee9984ea1d7fb7e10bc5659adb5ed2f23"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM3NWIyMmU1MWNiMGU1YmRhZjFlZGRkMWQ2NmQ1YTRiY2NhZjgwMTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "tree": {
        "sha": "4f7204f513b0a46a0309ed71e738a276970cee18",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4f7204f513b0a46a0309ed71e738a276970cee18"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6e33c4bee9984ea1d7fb7e10bc5659adb5ed2f23",
          "sha": "6e33c4bee9984ea1d7fb7e10bc5659adb5ed2f23",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6e33c4bee9984ea1d7fb7e10bc5659adb5ed2f23"
        }
      ],
      "message": "clusterlin: add algorithms for connectedness/connected components\n\nAdd utility functions to DepGraph for finding connected components.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-28T03:53:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-15T12:37:12Z"
      },
      "sha": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13326060235,
      "node_id": "HRFPE_lADOABII586JKtCPzwAAAAMaS4rL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13326060235",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-28T03:53:46Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611851597",
      "pull_request_review_id": 2074233399,
      "id": 1611851597,
      "node_id": "PRRC_kwDOABII585gEudN",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+#ifdef _MSC_VER\n+#  include <intrin.h>",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 15,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "316e2044aad16e1ed8d024d3325bfcee8c04cd1f",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why is this needed?",
      "created_at": "2024-05-23T14:55:40Z",
      "updated_at": "2024-05-23T14:55:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1611851597",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611851597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611885584",
      "pull_request_review_id": 2074291321,
      "id": 1611885584,
      "node_id": "PRRC_kwDOABII585gE2wQ",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+#ifdef _MSC_VER\n+#  include <intrin.h>",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 15,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "316e2044aad16e1ed8d024d3325bfcee8c04cd1f",
      "in_reply_to_id": 1611851597,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Remnant of a long-lost pre-C++20 past. Gone.",
      "created_at": "2024-05-23T15:16:07Z",
      "updated_at": "2024-05-23T15:16:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1611885584",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611885584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613617080",
      "pull_request_review_id": 2077166958,
      "id": 1613617080,
      "node_id": "PRRC_kwDOABII585gLde4",
      "diff_hunk": "@@ -469,6 +485,56 @@ class SearchCandidateFinder\n     }\n };\n \n+/** Improve a linearization of a cluster.\n+ *\n+ * @param[in]     depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in,out] iteration_limit    On input, an upper bound on the number of optimization steps\n+ *                                   that will be performed in order to find a good linearization.\n+ *                                   On output the number will be reduced by the number of actually\n+ *                                   performed optimization steps. If that number is nonzero, the\n+ *                                   linearization is optimal.\n+ */\n+template<typename S>\n+std::vector<ClusterIndex> Linearize(const DepGraph<S>& depgraph, uint64_t& iteration_limit) noexcept\n+{\n+    auto todo = S::Fill(depgraph.TxCount());\n+    std::vector<ClusterIndex> linearization;\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    SearchCandidateFinder src_finder(depgraph);\n+    linearization.reserve(depgraph.TxCount());\n+    bool perfect = true;\n+\n+    while (todo.Any()) {\n+        // Initialize best to be either the best ancestor set.\n+        auto best = anc_finder.FindCandidateSet();\n+\n+        // Invoke bounded search to update best, with up to half of our remaining iterations as\n+        // limit.\n+        uint64_t iterations = (iteration_limit + 1) / 2;\n+        iteration_limit -= iterations;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 54,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "f6deff9f4c5dbb379fd4f099f17e09387de27efc",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in/out args for iterations is kinda spooky and made these few lines really hard to read, could `FindCandidateSet` just return a `std::pair` or similar?",
      "created_at": "2024-05-24T14:59:17Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1613617080",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613617080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 825,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622515654",
      "pull_request_review_id": 2077166958,
      "id": 1622515654,
      "node_id": "PRRC_kwDOABII585gtZ_G",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For this operator are `S ancestors` and `S descendants` ordered? Is it just compared via `m_val` for `BitSets`? Is ordering by these elements meaningful?",
      "created_at": "2024-05-31T14:31:45Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622515654",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622515654"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622564714",
      "pull_request_review_id": 2077166958,
      "id": 1622564714,
      "node_id": "PRRC_kwDOABII585gtl9q",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);",
      "path": "src/cluster_linearize.h",
      "position": 77,
      "original_position": 75,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it crashes once it hits `S::Singleton` if violated but maybe an earlier crash is more immediately informative\r\n```suggestion\r\n        Assume(ntx <= S::Size());\r\n        entries.resize(ntx);\r\n```",
      "created_at": "2024-05-31T15:04:38Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622564714",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622564714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 77,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622574793",
      "pull_request_review_id": 2077166958,
      "id": 1622574793,
      "node_id": "PRRC_kwDOABII585gtobJ",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 123,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "to avoid an OOB access regression\r\n```suggestion\r\n        Assert(mapping.size() == depgraph.TxCount());\r\n        // Fill in fee, size, ancestors.\r\n```",
      "created_at": "2024-05-31T15:13:10Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622574793",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622574793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622667577",
      "pull_request_review_id": 2077166958,
      "id": 1622667577,
      "node_id": "PRRC_kwDOABII585gt_E5",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 34,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "not super important but can we use a more descriptive typename since our use-case is pretty narrow? I'm mentally substituting `S` everywhere with `bitset` which is a fair mental leap and it's relatively difficult to grep for being so short.\r\n\r\n`S_bitset`? I don't know why the conventions are the way they are :sweat_smile: ",
      "created_at": "2024-05-31T16:16:35Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1622667577",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1622667577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626377280",
      "pull_request_review_id": 2077166958,
      "id": 1626377280,
      "node_id": "PRRC_kwDOABII585g8IxA",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            const auto& input = depgraph.entries[i];\n+            auto& output = entries[mapping[i]];\n+            output.feerate = input.feerate;\n+            for (auto j : input.ancestors) output.ancestors.Set(mapping[j]);\n+        }\n+        // Fill in descendant information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the mutable feerate of a given transaction i. Complexity: O(1). */\n+    FeeFrac& FeeRate(ClusterIndex i) noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const S& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const S& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, S::Singleton(new_idx), S::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const S& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Find some connected component within the subset \"left\" of this graph.\n+     *\n+     * Complexity: O(ret.Count()).\n+     */\n+    S FindConnectedComponent(const S& left) const noexcept\n+    {\n+        if (left.None()) return left;\n+        auto first = left.First();\n+        S ret = Descendants(first) | Ancestors(first);\n+        ret &= left;\n+        S to_add = ret;\n+        to_add.Reset(first);\n+        do {\n+            S old = ret;\n+            for (auto add : to_add) {\n+                ret |= Descendants(add);\n+                ret |= Ancestors(add);\n+            }\n+            ret &= left;\n+            to_add = ret - old;\n+        } while (to_add.Any());\n+        return ret;\n+    }\n+\n+    /** Determine if a subset is connected.\n+     *\n+     * Complexity: O(subset.Count()).\n+     */\n+    bool IsConnected(const S& subset) const noexcept\n+    {\n+        return FindConnectedComponent(subset) == subset;\n+    }\n+\n+    /** Determine if this entire graph is connected.\n+     *\n+     * Complexity: O(TxCount()).\n+     */\n+    bool IsConnected() const noexcept { return IsConnected(S::Fill(TxCount())); }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const S& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename S>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<S>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    S m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<S>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{S::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            S anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(S select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename S>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** m_sorted_to_original[i] is the original position that sorted transaction position i had. */\n+    std::vector<ClusterIndex> m_sorted_to_original;\n+    /** m_original_to_sorted[i] is the sorted position original transaction position i has. */\n+    std::vector<ClusterIndex> m_original_to_sorted;\n+    /** Internal dependency graph for the cluster (with transactions in decreasing individual\n+     *  feerate order). */\n+    DepGraph<S> m_depgraph;\n+    /** Which transactions are left to do (indices in m_depgraph's sorted order). */\n+    S m_todo;\n+\n+    static uint256 GetRNGKey(uint64_t rng_seed) noexcept\n+    {\n+        uint256 rng_key;\n+        WriteLE64(rng_key.data(), rng_seed);\n+        return rng_key;\n+    }\n+\n+    /** Given a set of transactions with sorted indices, get their original indices. */\n+    S SortedToOriginal(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_sorted_to_original[pos]);\n+        return ret;\n+    }\n+\n+    /** Given a set of transactions with original indices, get their sorted indices. */\n+    S OriginalToSorted(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_original_to_sorted[pos]);\n+        return ret;\n+    }\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.Count().\n+     */\n+    SearchCandidateFinder(const DepGraph<S>& depgraph, uint64_t rng_seed) noexcept :\n+        m_rng(GetRNGKey(rng_seed)),\n+        m_sorted_to_original(depgraph.TxCount()),\n+        m_original_to_sorted(depgraph.TxCount())\n+    {\n+        // Determine reordering mapping, by sorting by decreasing feerate.\n+        std::iota(m_sorted_to_original.begin(), m_sorted_to_original.end(), ClusterIndex{0});\n+        std::sort(m_sorted_to_original.begin(), m_sorted_to_original.end(), [&](auto a, auto b) {\n+            auto feerate_cmp = depgraph.FeeRate(a) <=> depgraph.FeeRate(b);\n+            if (feerate_cmp == 0) return a < b;\n+            return feerate_cmp > 0;\n+        });\n+        // Compute reverse mapping.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            m_original_to_sorted[m_sorted_to_original[i]] = i;\n+        }\n+        // Compute reordered dependency graph.\n+        m_depgraph = DepGraph(depgraph, m_original_to_sorted);\n+        // Set todo to the entire graph.\n+        m_todo = S::Fill(depgraph.TxCount());\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in,out] iterations_left    On input, an upper bound on the number of optimization\n+     *                                   steps that can be performed. On output, that number is\n+     *                                   reduced by the number of actually performed optimization\n+     *                                   steps.\n+     * @param[in] best                   A set/feerate pair with an already-known good candidate.\n+     *                                   This can be empty.\n+     * @return                           The best (highest feerate, smallest size as tiebreaker)\n+     *                                   topologically-valid subset of what remains of the cluster\n+     *                                   that was encountered during search. If iterations_left is\n+     *                                   nonzero on output, it is the absolute best such subset. If\n+     *                                   not, the feerate of the returned set will be at least as\n+     *                                   good as the best passed in.\n+     *\n+     * Complexity: possibly O(N * min(iterations_left, sqrt(2^N))) where N=depgraph.TxCount().\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet(uint64_t& iterations_left, std::pair<S, FeeFrac> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        if (best.second.IsEmpty()) {\n+            // Set best to the entire remainder if not provided.\n+            best.first = m_todo;\n+            best.second = m_depgraph.FeeRate(m_todo);\n+        } else {\n+            // Otherwise convert to internal sorted indices.\n+            best.first = OriginalToSorted(best.first);\n+        }\n+        Assume(!best.second.IsEmpty());\n+        Assume(best.first.Any());\n+        Assume(best.first.IsSubsetOf(m_todo));\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included. This must be a subset of m_todo, and be\n+             *  topologically valid (includes all in-m_todo ancestors of itself). */\n+            S inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            S und;\n+            /** (Only when inc is not empty) The subset with the best feerate of any superset of\n+             *  inc that is also a subset of (inc | und), without requiring it to be topologically\n+             *  valid. If the real best such feerate does not exceed best.second, then this value\n+             *  is not guaranteed to be accurate. */\n+            S pot;\n+            /** Equal to m_depgraph.FeeRate(inc). */\n+            FeeFrac inc_feerate;\n+            /** Equal to m_depgraph.FeeRate(pot). It forms a conservative upper bound on how good\n+             *  a set this work item can give rise to, unless that's known to be below best.second.\n+             */\n+            FeeFrac pot_feerate;\n+            /** Construct a new work item. */\n+            WorkItem(S&& i, S&& u, S&& p, FeeFrac&& i_f, FeeFrac&& p_f) noexcept :\n+                inc(std::move(i)), und(std::move(u)), pot(std::move(p)),\n+                inc_feerate(std::move(i_f)), pot_feerate(std::move(p_f)) {}\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+                swap(pot, other.pot);\n+                swap(inc_feerate, other.inc_feerate);\n+                swap(pot_feerate, other.pot_feerate);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        /** The set of transactions in m_todo which have feerate > best_feerate. */\n+        S imp = m_todo;\n+        while (imp.Any()) {\n+            ClusterIndex check = imp.Last();\n+            if (m_depgraph.FeeRate(check) >> best.second) break;\n+            imp.Reset(check);\n+        }\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iteration_limit = iterations_left;\n+\n+        /** Internal function to add a work item, possibly improving it before doing so.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         * - pot: a subset of the \"pot\" value for the new work item (but a superset of inc).\n+         *        It does not need to be the full pot value; missing pot transactions will be added\n+         *        to it by add_fn.\n+         * - inc_feerate: equal to m_depgraph.FeeRate(inc)\n+         * - pot_feerate: equal to m_depgraph.FeeRate(pot)\n+         * - grow_inc: whether to attempt moving transactions from und to inc, if it can be proven\n+         *             that they must be a part of the best topologically valid superset of inc and\n+         *             subset of (inc | und). Transactions that are missing from pot are always\n+         *             considered, regardless of grow_inc. It only makes sense to enable this if\n+         *             transactions were added to inc.\n+         */\n+        auto add_fn = [&](S inc, S und, S pot, FeeFrac inc_feerate, FeeFrac pot_feerate, bool grow_inc) noexcept {\n+            Assume(inc.IsSubsetOf(m_todo));\n+            Assume(und.IsSubsetOf(m_todo));\n+            Assume(!inc.Overlaps(und));\n+            Assume(pot.IsSupersetOf(inc));\n+            Assume(pot.IsSubsetOf(inc | und));\n+            Assume(pot.None() == inc.None());\n+\n+            if (!inc_feerate.IsEmpty()) {\n+                /** Which transactions to consider adding to inc. */\n+                S consider_inc = grow_inc ? pot - inc : S{};\n+                // Add entries to pot (and pot_feerate). We iterate over all undecided transactions\n+                // whose feerate is higher than best_feerate, and aren't already part of pot. While\n+                // undecided transactions of lower feerate may improve pot still, if they do, the\n+                // resulting pot_feerate cannot possibly exceed best.second (resulting in the item\n+                // being skipped in split_fn).\n+                for (auto pos : (imp & und) - pot) {\n+                    // Determine if adding transaction pos to pot (ignoring topology) would improve it. If\n+                    // not, we're done updating pot. This relies on the fact that m_depgraph, and\n+                    // thus the set iterated over, is in decreasing individual feerate order.\n+                    if (!(m_depgraph.FeeRate(pos) >> pot_feerate)) break;\n+                    pot_feerate += m_depgraph.FeeRate(pos);\n+                    pot.Set(pos);\n+                    consider_inc.Set(pos);\n+                }\n+\n+                // The \"jump ahead\" optimization: whenever pot has a topologically-valid subset,\n+                // that subset can be added to inc. Any subset of (pot - inc) has the property that\n+                // its feerate exceeds that of any set compatible with this work item (superset of\n+                // inc, subset of (inc | und)). Thus, if T is a topological subset of pot, and B is\n+                // the best topologically-valid set compatible with this work item, and (T - B) is\n+                // non-empty, then (T | B) is better than B and also topological. This is in\n+                // contradiction with the assumption that B is best. Thus, (T - B) must be empty,\n+                // or T must be a subset of B.\n+                //\n+                // See https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303 section 2.4.\n+                const S init_inc = inc;\n+                for (auto pos : consider_inc) {\n+                    // If the transaction's ancestors are a subset of pot, we can add it together\n+                    // with its ancestors to inc.\n+                    auto anc_todo = m_depgraph.Ancestors(pos) & m_todo;\n+                    if (anc_todo.IsSubsetOf(pot)) inc |= anc_todo;\n+                }\n+                // Finally update und and inc_feerate to account for the added transactions.\n+                und -= inc;\n+                inc_feerate += m_depgraph.FeeRate(inc - init_inc);\n+\n+                // If inc_feerate is better than best_feerate, remember inc as our new best.\n+                if (inc_feerate > best.second) {\n+                    best = {inc, inc_feerate};\n+                    // See if we can remove any entries from imp now.\n+                    while (imp.Any()) {\n+                        ClusterIndex check = imp.Last();\n+                        if (m_depgraph.FeeRate(check) >> best.second) break;\n+                        imp.Reset(check);\n+                    }\n+                }\n+\n+                // If no potential transactions exist beyond the already included ones, no improvement\n+                // is possible anymore.\n+                if (pot == inc) return;\n+                // At this point und must be non-empty. If it were empty then pot would equal inc.\n+                Assume(und.Any());\n+            } else {\n+                // If inc is empty, we just make sure there are undecided transactions left to\n+                // split on.\n+                if (und.None()) return;\n+            }\n+\n+            // Actually construct new work item on the queue.\n+            Assume(queue.size() < queue.capacity());",
      "path": "src/cluster_linearize.h",
      "position": 455,
      "original_position": 558,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "is this for ensuring no allocations are going to take place? How do we know this?",
      "created_at": "2024-06-04T17:29:25Z",
      "updated_at": "2024-06-06T14:13:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1626377280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626377280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 455,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631584746",
      "pull_request_review_id": 2105193198,
      "id": 1631584746,
      "node_id": "PRRC_kwDOABII585hQAHq",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 34,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622667577,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've renamed it to `SetType` everywhere. While it's expected to be instantiated with `BitSet`, that's not a necessity, and I expect that for certain temporarily-very-large clusters in TxGraph we'll need some algorithms instantiated by another type (something using an `std::set` or a sorted vector, for example).",
      "created_at": "2024-06-07T18:54:41Z",
      "updated_at": "2024-06-07T18:54:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1631584746",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631584746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631724039",
      "pull_request_review_id": 2105418287,
      "id": 1631724039,
      "node_id": "PRRC_kwDOABII585hQiIH",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 48,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622515654,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think any attempt to invoke this comparison operator would just have failed, as `BitSet` doesn't have an `operator<=>` (it did at some point, but I had dropped it). I've just removed the operator here too.",
      "created_at": "2024-06-07T21:41:58Z",
      "updated_at": "2024-06-07T21:41:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1631724039",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631724039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102449",
      "pull_request_review_id": 2114235927,
      "id": 1637102449,
      "node_id": "PRRC_kwDOABII585hlDNx",
      "diff_hunk": "@@ -469,6 +485,56 @@ class SearchCandidateFinder\n     }\n };\n \n+/** Improve a linearization of a cluster.\n+ *\n+ * @param[in]     depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in,out] iteration_limit    On input, an upper bound on the number of optimization steps\n+ *                                   that will be performed in order to find a good linearization.\n+ *                                   On output the number will be reduced by the number of actually\n+ *                                   performed optimization steps. If that number is nonzero, the\n+ *                                   linearization is optimal.\n+ */\n+template<typename S>\n+std::vector<ClusterIndex> Linearize(const DepGraph<S>& depgraph, uint64_t& iteration_limit) noexcept\n+{\n+    auto todo = S::Fill(depgraph.TxCount());\n+    std::vector<ClusterIndex> linearization;\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    SearchCandidateFinder src_finder(depgraph);\n+    linearization.reserve(depgraph.TxCount());\n+    bool perfect = true;\n+\n+    while (todo.Any()) {\n+        // Initialize best to be either the best ancestor set.\n+        auto best = anc_finder.FindCandidateSet();\n+\n+        // Invoke bounded search to update best, with up to half of our remaining iterations as\n+        // limit.\n+        uint64_t iterations = (iteration_limit + 1) / 2;\n+        iteration_limit -= iterations;",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 54,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "f6deff9f4c5dbb379fd4f099f17e09387de27efc",
      "in_reply_to_id": 1613617080,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. I've encapsulated the `std::pair<SetType, FeeFrac>` for representing sets with their feerates into a new `SetInfo<SetType>` type, and changed the return type of candidate finders which count iterations to be `std::pair<SetInfo<SetType>, uint64_t>`, representing the found candidate and the number of performed iterations. I've also changed the Linearization functions to just return a `bool optimal`, rather than an iteration count (as it wasn't used anywhere anyway).",
      "created_at": "2024-06-12T21:16:57Z",
      "updated_at": "2024-06-12T21:16:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637102449",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102449"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 825,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102621",
      "pull_request_review_id": 2114236128,
      "id": 1637102621,
      "node_id": "PRRC_kwDOABII585hlDQd",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);",
      "path": "src/cluster_linearize.h",
      "position": 77,
      "original_position": 75,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622564714,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-12T21:17:06Z",
      "updated_at": "2024-06-12T21:17:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637102621",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102621"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 77,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102708",
      "pull_request_review_id": 2114236246,
      "id": 1637102708,
      "node_id": "PRRC_kwDOABII585hlDR0",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 123,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1622574793,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-12T21:17:11Z",
      "updated_at": "2024-06-12T21:17:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637102708",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637102708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637103088",
      "pull_request_review_id": 2114236678,
      "id": 1637103088,
      "node_id": "PRRC_kwDOABII585hlDXw",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            const auto& input = depgraph.entries[i];\n+            auto& output = entries[mapping[i]];\n+            output.feerate = input.feerate;\n+            for (auto j : input.ancestors) output.ancestors.Set(mapping[j]);\n+        }\n+        // Fill in descendant information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the mutable feerate of a given transaction i. Complexity: O(1). */\n+    FeeFrac& FeeRate(ClusterIndex i) noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const S& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const S& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, S::Singleton(new_idx), S::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const S& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Find some connected component within the subset \"left\" of this graph.\n+     *\n+     * Complexity: O(ret.Count()).\n+     */\n+    S FindConnectedComponent(const S& left) const noexcept\n+    {\n+        if (left.None()) return left;\n+        auto first = left.First();\n+        S ret = Descendants(first) | Ancestors(first);\n+        ret &= left;\n+        S to_add = ret;\n+        to_add.Reset(first);\n+        do {\n+            S old = ret;\n+            for (auto add : to_add) {\n+                ret |= Descendants(add);\n+                ret |= Ancestors(add);\n+            }\n+            ret &= left;\n+            to_add = ret - old;\n+        } while (to_add.Any());\n+        return ret;\n+    }\n+\n+    /** Determine if a subset is connected.\n+     *\n+     * Complexity: O(subset.Count()).\n+     */\n+    bool IsConnected(const S& subset) const noexcept\n+    {\n+        return FindConnectedComponent(subset) == subset;\n+    }\n+\n+    /** Determine if this entire graph is connected.\n+     *\n+     * Complexity: O(TxCount()).\n+     */\n+    bool IsConnected() const noexcept { return IsConnected(S::Fill(TxCount())); }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const S& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename S>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<S>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    S m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<S>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{S::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            S anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(S select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename S>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** m_sorted_to_original[i] is the original position that sorted transaction position i had. */\n+    std::vector<ClusterIndex> m_sorted_to_original;\n+    /** m_original_to_sorted[i] is the sorted position original transaction position i has. */\n+    std::vector<ClusterIndex> m_original_to_sorted;\n+    /** Internal dependency graph for the cluster (with transactions in decreasing individual\n+     *  feerate order). */\n+    DepGraph<S> m_depgraph;\n+    /** Which transactions are left to do (indices in m_depgraph's sorted order). */\n+    S m_todo;\n+\n+    static uint256 GetRNGKey(uint64_t rng_seed) noexcept\n+    {\n+        uint256 rng_key;\n+        WriteLE64(rng_key.data(), rng_seed);\n+        return rng_key;\n+    }\n+\n+    /** Given a set of transactions with sorted indices, get their original indices. */\n+    S SortedToOriginal(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_sorted_to_original[pos]);\n+        return ret;\n+    }\n+\n+    /** Given a set of transactions with original indices, get their sorted indices. */\n+    S OriginalToSorted(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_original_to_sorted[pos]);\n+        return ret;\n+    }\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.Count().\n+     */\n+    SearchCandidateFinder(const DepGraph<S>& depgraph, uint64_t rng_seed) noexcept :\n+        m_rng(GetRNGKey(rng_seed)),\n+        m_sorted_to_original(depgraph.TxCount()),\n+        m_original_to_sorted(depgraph.TxCount())\n+    {\n+        // Determine reordering mapping, by sorting by decreasing feerate.\n+        std::iota(m_sorted_to_original.begin(), m_sorted_to_original.end(), ClusterIndex{0});\n+        std::sort(m_sorted_to_original.begin(), m_sorted_to_original.end(), [&](auto a, auto b) {\n+            auto feerate_cmp = depgraph.FeeRate(a) <=> depgraph.FeeRate(b);\n+            if (feerate_cmp == 0) return a < b;\n+            return feerate_cmp > 0;\n+        });\n+        // Compute reverse mapping.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            m_original_to_sorted[m_sorted_to_original[i]] = i;\n+        }\n+        // Compute reordered dependency graph.\n+        m_depgraph = DepGraph(depgraph, m_original_to_sorted);\n+        // Set todo to the entire graph.\n+        m_todo = S::Fill(depgraph.TxCount());\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in,out] iterations_left    On input, an upper bound on the number of optimization\n+     *                                   steps that can be performed. On output, that number is\n+     *                                   reduced by the number of actually performed optimization\n+     *                                   steps.\n+     * @param[in] best                   A set/feerate pair with an already-known good candidate.\n+     *                                   This can be empty.\n+     * @return                           The best (highest feerate, smallest size as tiebreaker)\n+     *                                   topologically-valid subset of what remains of the cluster\n+     *                                   that was encountered during search. If iterations_left is\n+     *                                   nonzero on output, it is the absolute best such subset. If\n+     *                                   not, the feerate of the returned set will be at least as\n+     *                                   good as the best passed in.\n+     *\n+     * Complexity: possibly O(N * min(iterations_left, sqrt(2^N))) where N=depgraph.TxCount().\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet(uint64_t& iterations_left, std::pair<S, FeeFrac> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        if (best.second.IsEmpty()) {\n+            // Set best to the entire remainder if not provided.\n+            best.first = m_todo;\n+            best.second = m_depgraph.FeeRate(m_todo);\n+        } else {\n+            // Otherwise convert to internal sorted indices.\n+            best.first = OriginalToSorted(best.first);\n+        }\n+        Assume(!best.second.IsEmpty());\n+        Assume(best.first.Any());\n+        Assume(best.first.IsSubsetOf(m_todo));\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included. This must be a subset of m_todo, and be\n+             *  topologically valid (includes all in-m_todo ancestors of itself). */\n+            S inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            S und;\n+            /** (Only when inc is not empty) The subset with the best feerate of any superset of\n+             *  inc that is also a subset of (inc | und), without requiring it to be topologically\n+             *  valid. If the real best such feerate does not exceed best.second, then this value\n+             *  is not guaranteed to be accurate. */\n+            S pot;\n+            /** Equal to m_depgraph.FeeRate(inc). */\n+            FeeFrac inc_feerate;\n+            /** Equal to m_depgraph.FeeRate(pot). It forms a conservative upper bound on how good\n+             *  a set this work item can give rise to, unless that's known to be below best.second.\n+             */\n+            FeeFrac pot_feerate;\n+            /** Construct a new work item. */\n+            WorkItem(S&& i, S&& u, S&& p, FeeFrac&& i_f, FeeFrac&& p_f) noexcept :\n+                inc(std::move(i)), und(std::move(u)), pot(std::move(p)),\n+                inc_feerate(std::move(i_f)), pot_feerate(std::move(p_f)) {}\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+                swap(pot, other.pot);\n+                swap(inc_feerate, other.inc_feerate);\n+                swap(pot_feerate, other.pot_feerate);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        /** The set of transactions in m_todo which have feerate > best_feerate. */\n+        S imp = m_todo;\n+        while (imp.Any()) {\n+            ClusterIndex check = imp.Last();\n+            if (m_depgraph.FeeRate(check) >> best.second) break;\n+            imp.Reset(check);\n+        }\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iteration_limit = iterations_left;\n+\n+        /** Internal function to add a work item, possibly improving it before doing so.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         * - pot: a subset of the \"pot\" value for the new work item (but a superset of inc).\n+         *        It does not need to be the full pot value; missing pot transactions will be added\n+         *        to it by add_fn.\n+         * - inc_feerate: equal to m_depgraph.FeeRate(inc)\n+         * - pot_feerate: equal to m_depgraph.FeeRate(pot)\n+         * - grow_inc: whether to attempt moving transactions from und to inc, if it can be proven\n+         *             that they must be a part of the best topologically valid superset of inc and\n+         *             subset of (inc | und). Transactions that are missing from pot are always\n+         *             considered, regardless of grow_inc. It only makes sense to enable this if\n+         *             transactions were added to inc.\n+         */\n+        auto add_fn = [&](S inc, S und, S pot, FeeFrac inc_feerate, FeeFrac pot_feerate, bool grow_inc) noexcept {\n+            Assume(inc.IsSubsetOf(m_todo));\n+            Assume(und.IsSubsetOf(m_todo));\n+            Assume(!inc.Overlaps(und));\n+            Assume(pot.IsSupersetOf(inc));\n+            Assume(pot.IsSubsetOf(inc | und));\n+            Assume(pot.None() == inc.None());\n+\n+            if (!inc_feerate.IsEmpty()) {\n+                /** Which transactions to consider adding to inc. */\n+                S consider_inc = grow_inc ? pot - inc : S{};\n+                // Add entries to pot (and pot_feerate). We iterate over all undecided transactions\n+                // whose feerate is higher than best_feerate, and aren't already part of pot. While\n+                // undecided transactions of lower feerate may improve pot still, if they do, the\n+                // resulting pot_feerate cannot possibly exceed best.second (resulting in the item\n+                // being skipped in split_fn).\n+                for (auto pos : (imp & und) - pot) {\n+                    // Determine if adding transaction pos to pot (ignoring topology) would improve it. If\n+                    // not, we're done updating pot. This relies on the fact that m_depgraph, and\n+                    // thus the set iterated over, is in decreasing individual feerate order.\n+                    if (!(m_depgraph.FeeRate(pos) >> pot_feerate)) break;\n+                    pot_feerate += m_depgraph.FeeRate(pos);\n+                    pot.Set(pos);\n+                    consider_inc.Set(pos);\n+                }\n+\n+                // The \"jump ahead\" optimization: whenever pot has a topologically-valid subset,\n+                // that subset can be added to inc. Any subset of (pot - inc) has the property that\n+                // its feerate exceeds that of any set compatible with this work item (superset of\n+                // inc, subset of (inc | und)). Thus, if T is a topological subset of pot, and B is\n+                // the best topologically-valid set compatible with this work item, and (T - B) is\n+                // non-empty, then (T | B) is better than B and also topological. This is in\n+                // contradiction with the assumption that B is best. Thus, (T - B) must be empty,\n+                // or T must be a subset of B.\n+                //\n+                // See https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303 section 2.4.\n+                const S init_inc = inc;\n+                for (auto pos : consider_inc) {\n+                    // If the transaction's ancestors are a subset of pot, we can add it together\n+                    // with its ancestors to inc.\n+                    auto anc_todo = m_depgraph.Ancestors(pos) & m_todo;\n+                    if (anc_todo.IsSubsetOf(pot)) inc |= anc_todo;\n+                }\n+                // Finally update und and inc_feerate to account for the added transactions.\n+                und -= inc;\n+                inc_feerate += m_depgraph.FeeRate(inc - init_inc);\n+\n+                // If inc_feerate is better than best_feerate, remember inc as our new best.\n+                if (inc_feerate > best.second) {\n+                    best = {inc, inc_feerate};\n+                    // See if we can remove any entries from imp now.\n+                    while (imp.Any()) {\n+                        ClusterIndex check = imp.Last();\n+                        if (m_depgraph.FeeRate(check) >> best.second) break;\n+                        imp.Reset(check);\n+                    }\n+                }\n+\n+                // If no potential transactions exist beyond the already included ones, no improvement\n+                // is possible anymore.\n+                if (pot == inc) return;\n+                // At this point und must be non-empty. If it were empty then pot would equal inc.\n+                Assume(und.Any());\n+            } else {\n+                // If inc is empty, we just make sure there are undecided transactions left to\n+                // split on.\n+                if (und.None()) return;\n+            }\n+\n+            // Actually construct new work item on the queue.\n+            Assume(queue.size() < queue.capacity());",
      "path": "src/cluster_linearize.h",
      "position": 455,
      "original_position": 558,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1626377280,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed. I've added a comment. LMK whether it's clearer now.",
      "created_at": "2024-06-12T21:17:31Z",
      "updated_at": "2024-06-12T21:17:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1637103088",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1637103088"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 455,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638438741",
      "pull_request_review_id": 2116172410,
      "id": 1638438741,
      "node_id": "PRRC_kwDOABII585hqJdV",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 266,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`Cluster<TestBitSet> cluster(num_tx, std::make_pair(FeeFrac{0, 1}, TestBitSet()));` should work?",
      "created_at": "2024-06-13T15:43:33Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638438741",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638438741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638450101",
      "pull_request_review_id": 2116172410,
      "id": 1638450101,
      "node_id": "PRRC_kwDOABII585hqMO1",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 270,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    // Read (parent, child) pairs, and add them to the cluster and depgraph.\r\n```",
      "created_at": "2024-06-13T15:51:50Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638450101",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638450101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638465834",
      "pull_request_review_id": 2116172410,
      "id": 1638465834,
      "node_id": "PRRC_kwDOABII585hqQEq",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 146,
      "original_position": 141,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we `Assume()`/short-circuit if `parent == child`",
      "created_at": "2024-06-13T16:00:24Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638465834",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638465834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 146,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638472774",
      "pull_request_review_id": 2116172410,
      "id": 1638472774,
      "node_id": "PRRC_kwDOABII585hqRxG",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 126,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Where does the amortization come in?",
      "created_at": "2024-06-13T16:03:29Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638472774",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638472774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638488625",
      "pull_request_review_id": 2116172410,
      "id": 1638488625,
      "node_id": "PRRC_kwDOABII585hqVox",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 271,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    LIMITED_WHILE(provider.remaining_bytes() > 0, TestBitSet::Size() * TestBitSet::Size()) {\r\n```",
      "created_at": "2024-06-13T16:15:47Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1638488625",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1638488625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 530,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177227",
      "pull_request_review_id": 2116172410,
      "id": 1640177227,
      "node_id": "PRRC_kwDOABII585hwx5L",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could leave an assert to this effect right after this",
      "created_at": "2024-06-14T18:00:33Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1640177227",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177309",
      "pull_request_review_id": 2116172410,
      "id": 1640177309,
      "node_id": "PRRC_kwDOABII585hwx6d",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 159,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could leave an assert to this effect right after this",
      "created_at": "2024-06-14T18:00:38Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1640177309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1640177309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644863011",
      "pull_request_review_id": 2116172410,
      "id": 1644863011,
      "node_id": "PRRC_kwDOABII585iCp4j",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];",
      "path": "src/cluster_linearize.h",
      "position": 302,
      "original_position": 61,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n                Assume(!m_ancestor_set_feerates[first].IsEmpty());\r\n                anc_feerate = m_ancestor_set_feerates[first];\r\n```",
      "created_at": "2024-06-18T18:04:46Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644863011",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644863011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 302,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644905104",
      "pull_request_review_id": 2116172410,
      "id": 1644905104,
      "node_id": "PRRC_kwDOABII585iC0KQ",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(SetType select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {",
      "path": "src/cluster_linearize.h",
      "position": 338,
      "original_position": 96,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "belt and suspenders nit prior to a comparison\r\n```Suggestion\r\n            if (best.has_value()) {\r\n                Assume(!m_ancestor_set_feerates[i].IsEmpty());\r\n```",
      "created_at": "2024-06-18T18:46:31Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644905104",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644905104"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 338,
      "original_line": 338,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644945090",
      "pull_request_review_id": 2116172410,
      "id": 1644945090,
      "node_id": "PRRC_kwDOABII585iC97C",
      "diff_hunk": "@@ -346,3 +364,49 @@ FUZZ_TARGET(clusterlin_depgraph_serialization)\n     // Verify the graph is a DAG.\n     assert(IsAcyclic(depgraph));\n }\n+\n+FUZZ_TARGET(clusterlin_ancestor_finder)\n+{\n+    // Verify that AncestorCandidateFinder works as expected.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    AncestorCandidateFinder anc_finder(depgraph);\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // Call the ancestor finder's FindCandidateSet for what remains of the graph.\n+        auto best_anc = anc_finder.FindCandidateSet();\n+        // Sanity check the result.\n+        assert(best_anc.transactions.Any());\n+        assert(best_anc.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(best_anc.transactions) == best_anc.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : best_anc.transactions) {\n+            assert((depgraph.Ancestors(i) & todo).IsSubsetOf(best_anc.transactions));\n+        }\n+\n+        // Compute all remaining ancestor sets.\n+        std::optional<SetInfo<TestBitSet>> real_best_anc;\n+        for (auto i : todo) {\n+            SetInfo info(depgraph, todo & depgraph.Ancestors(i));\n+            if (!real_best_anc.has_value() || info.feerate > real_best_anc->feerate) {\n+                real_best_anc = info;\n+            }\n+        }\n+        // The set returned by anc_finder must equal the real best ancestor sets.\n+        assert(real_best_anc.has_value());\n+        assert(*real_best_anc == best_anc);\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use best_anc itself, because we should remove something.\n+        if (del_set.None()) del_set = best_anc.transactions;\n+        todo -= del_set;\n+        anc_finder.MarkDone(del_set);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 377,
      "original_position": 72,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it'd be worth it to have `del_set` be sometimes overcomplete, including random subsets of `~todo` which should be handled internally by being dropped. Alternatively it could be disallowed via `Assume()`?",
      "created_at": "2024-06-18T19:26:19Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644945090",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644945090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 377,
      "original_line": 377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644952136",
      "pull_request_review_id": 2116172410,
      "id": 1644952136,
      "node_id": "PRRC_kwDOABII585iC_pI",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 64,
      "original_position": 45,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A top-level description of what this is useful for would be appreciated.",
      "created_at": "2024-06-18T19:33:51Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644952136",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644952136"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 64,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644963760",
      "pull_request_review_id": 2116172410,
      "id": 1644963760,
      "node_id": "PRRC_kwDOABII585iDCew",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.\n+            if (todo.Count() <= 12) {\n+                auto exhaustive = exh_finder.FindCandidateSet();\n+                assert(exhaustive.feerate == found.feerate);\n+                // Also compare ExhaustiveCandidateFinder with SimpleCandidateFinder (this is more\n+                // a test for SimpleCandidateFinder's correctness).\n+                assert(exhaustive.feerate >= simple.feerate);\n+                if (simple_iters < 0x3ffff) assert(exhaustive.feerate == simple.feerate);\n+            }\n+        }\n+\n+        // Find a topologically valid subset of transactions to remove from the graph.\n+        auto del_set = ReadTopologicalSet(depgraph, todo, reader);\n+        // If we did not find anything, use found_set itself, because we should remove something.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 459,
      "original_position": 185,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`found_set` doesn't exist",
      "created_at": "2024-06-18T19:45:42Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644963760",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644963760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 459,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966180",
      "pull_request_review_id": 2116172410,
      "id": 1644966180,
      "node_id": "PRRC_kwDOABII585iDDEk",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 74,
      "original_position": 55,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "SimpleCandidateFinder",
      "created_at": "2024-06-18T19:48:05Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644966180",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966317",
      "pull_request_review_id": 2116172410,
      "id": 1644966317,
      "node_id": "PRRC_kwDOABII585iDDGt",
      "diff_hunk": "@@ -193,6 +193,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 33,
      "original_position": 14,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ExhaustiveCandidateFinder",
      "created_at": "2024-06-18T19:48:15Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644966317",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644966317"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644982295",
      "pull_request_review_id": 2116172410,
      "id": 1644982295,
      "node_id": "PRRC_kwDOABII585iDHAX",
      "diff_hunk": "@@ -410,3 +510,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 438,
      "original_position": 164,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "86b341f5499525bb2dcd67997a61a771118a5ded",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "please consti-fy `0x3ffff` since it's use 3x",
      "created_at": "2024-06-18T20:00:54Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1644982295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644982295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 438,
      "original_line": 438,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649155445",
      "pull_request_review_id": 2116172410,
      "id": 1649155445,
      "node_id": "PRRC_kwDOABII585iTB11",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "useful note in code would be this is the only critical check to ensure fuzzer doesn't generate a cyclical graph, and the other checks are optimizations? ",
      "created_at": "2024-06-21T15:59:58Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649155445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649155445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649205112",
      "pull_request_review_id": 2116172410,
      "id": 1649205112,
      "node_id": "PRRC_kwDOABII585iTN94",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I can't make an example that causes this clause to fail which hinders my understanding of what it's doing.\r\n\r\nThis is where having static unit test for this case firing would be helpful to step through.",
      "created_at": "2024-06-21T16:46:08Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649205112",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649205112"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649232974",
      "pull_request_review_id": 2116172410,
      "id": 1649232974,
      "node_id": "PRRC_kwDOABII585iTUxO",
      "diff_hunk": "@@ -452,3 +552,86 @@ FUZZ_TARGET(clusterlin_ancestor_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_search_finder)\n+{\n+    // Verify that SearchCandidateFinder works as expected by sanity checking the results\n+    // and comparing with the results from SimpleCandidateFinder, ExhaustiveCandidateFinder, and\n+    // AncestorCandidateFinder.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Instantiate ALL the candidate finders.\n+    SearchCandidateFinder src_finder(depgraph);\n+    SimpleCandidateFinder smp_finder(depgraph);\n+    ExhaustiveCandidateFinder exh_finder(depgraph);\n+    AncestorCandidateFinder anc_finder(depgraph);\n+\n+    auto todo = TestBitSet::Fill(depgraph.TxCount());\n+    while (todo.Any()) {\n+        // For each iteration, read an iteration count limit from the fuzz input.\n+        uint64_t max_iterations = 1;\n+        try {\n+            reader >> VARINT(max_iterations);\n+        } catch (const std::ios_base::failure&) {}\n+        max_iterations &= 0xfffff;\n+\n+        // Read an initial subset from the fuzz input.\n+        SetInfo init_best(depgraph, ReadTopologicalSet(depgraph, todo, reader));\n+\n+        // Call the search finder's FindCandidateSet for what remains of the graph.\n+        auto [found, iterations_done] = src_finder.FindCandidateSet(max_iterations, init_best);\n+\n+        // Sanity check the result.\n+        assert(iterations_done <= max_iterations);\n+        assert(found.transactions.Any());\n+        assert(found.transactions.IsSubsetOf(todo));\n+        assert(depgraph.FeeRate(found.transactions) == found.feerate);\n+        if (!init_best.feerate.IsEmpty()) assert(found.feerate >= init_best.feerate);\n+        // Check that it is topologically valid.\n+        for (auto i : found.transactions) {\n+            assert(found.transactions.IsSupersetOf(depgraph.Ancestors(i) & todo));\n+        }\n+\n+        // At most 2^N-1 iterations can be required: the number of non-empty subsets a graph with N\n+        // transactions has.\n+        assert(iterations_done <= ((uint64_t{1} << todo.Count()) - 1));\n+\n+        // Perform quality checks only if SearchCandidateFinder claims an optimal result.\n+        if (iterations_done < max_iterations) {\n+            // Compare with SimpleCandidateFinder.\n+            auto [simple, simple_iters] = smp_finder.FindCandidateSet(0x3ffff);\n+            assert(found.feerate >= simple.feerate);\n+            if (simple_iters < 0x3ffff) assert(found.feerate == simple.feerate);\n+\n+            // Compare with AncestorCandidateFinder;\n+            auto anc = anc_finder.FindCandidateSet();\n+            assert(found.feerate >= anc.feerate);\n+\n+            // If todo isn't too big, compare with ExhaustiveCandidateFinder.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 446,
      "original_position": 172,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If we're checking against exhaustive we can avoid using the other finders?",
      "created_at": "2024-06-21T17:10:41Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649232974",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649232974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 446,
      "original_line": 446,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649259334",
      "pull_request_review_id": 2116172410,
      "id": 1649259334,
      "node_id": "PRRC_kwDOABII585iTbNG",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions\n+                // that share ancestry with inc so far (which means only connected sets will be\n+                // considered).\n+                if (inc_none || inc.Overlaps(m_depgraph.Ancestors(pivot))) {\n+                    // Add a queue entry with pivot included.\n+                    SetInfo new_inc(m_depgraph, inc | (m_todo & m_depgraph.Ancestors(pivot)));\n+                    queue.emplace_back(new_inc.transactions, und - new_inc.transactions);\n+                    // Add a queue entry with pivot excluded.\n+                    queue.emplace_back(inc, und - m_depgraph.Descendants(pivot));\n+                    // Update statistics to account for the candidate new_inc.\n+                    if (new_inc.feerate > best.feerate) best = new_inc;\n+                    break;\n+                }\n+            }\n+        }\n+        return {std::move(best), max_iterations - iterations_left};",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 119,
      "original_position": 100,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "double-checking: In this and other candidate set finders it seems like `max_iterations - iterations_left` could be zero even if it was optimal on the very last step?",
      "created_at": "2024-06-21T17:36:53Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649259334",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649259334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 119,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649287854",
      "pull_request_review_id": 2116172410,
      "id": 1649287854,
      "node_id": "PRRC_kwDOABII585iTiKu",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};",
      "path": "src/cluster_linearize.h",
      "position": 398,
      "original_position": 84,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this needs coverage or should be disallowed entirely",
      "created_at": "2024-06-21T18:08:55Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649287854",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649287854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 398,
      "original_line": 398,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649300280",
      "pull_request_review_id": 2116172410,
      "id": 1649300280,
      "node_id": "PRRC_kwDOABII585iTlM4",
      "diff_hunk": "@@ -235,6 +235,106 @@ struct DepGraphFormatter\n     }\n };\n \n+/** A very simple finder class for optimal candidate sets, which tries every subset. */\n+template<typename SetType>\n+class ExhaustiveCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    ExhaustiveCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find the optimal remaining candidate set. */\n+    SetInfo<SetType> FindCandidateSet() const noexcept\n+    {\n+        // Best solution so far.\n+        SetInfo<SetType> best{m_todo, m_depgraph.FeeRate(m_todo)};\n+        // The number of combinations to try.\n+        uint64_t limit = (uint64_t{1} << m_todo.Count()) - 1;\n+        // Try the transitive closure of every non-empty subset of m_todo.\n+        for (uint64_t x = 1; x < limit; ++x) {\n+            // If bit number b is set in x, then the remaining ancestors of the b'th remaining\n+            // transaction in m_todo are included.\n+            SetType txn;\n+            auto x_shifted{x};\n+            for (auto i : m_todo) {\n+                if (x_shifted & 1) txn |= m_depgraph.Ancestors(i);\n+                x_shifted >>= 1;\n+            }\n+            SetInfo cur(m_depgraph, txn & m_todo);\n+            if (cur.feerate > best.feerate) best = cur;\n+        }\n+        return best;\n+    }\n+};\n+\n+/** A simple finder class for candidate sets. */\n+template<typename SetType>\n+class SimpleCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct an SimpleOptimalCandidateFinder for a given graph. */\n+    SimpleCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph), m_todo{SetType::Fill(depgraph.TxCount())} {}\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones. */\n+    void MarkDone(SetType select) noexcept { m_todo -= select; }\n+\n+    /** Find a candidate set using at most max_iterations iterations, and the number of iterations\n+     *  actually performed. If that number is less than max_iterations, then the result is optimal.\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations) const noexcept\n+    {\n+        uint64_t iterations_left = max_iterations;\n+        // Queue of work units. Each consists of:\n+        // - inc: set of transactions definitely included\n+        // - und: set of transactions that can be added to inc still\n+        std::vector<std::pair<SetType, SetType>> queue;\n+        // Initially we have just one queue element, with the entire graph in und.\n+        queue.emplace_back(SetType{}, m_todo);\n+        // Best solution so far.\n+        SetInfo best(m_depgraph, m_todo);\n+        // Process the queue.\n+        while (!queue.empty() && iterations_left) {\n+            --iterations_left;\n+            // Pop top element of the queue.\n+            auto [inc, und] = queue.back();\n+            queue.pop_back();\n+            // Look for a transaction to consider adding/removing.\n+            bool inc_none = inc.None();\n+            for (auto pivot : und) {\n+                // If inc is empty, consider any pivot. Otherwise only consider transactions",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 104,
      "original_position": 85,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can we call this split rather than pivot since it only occurs here in the codebase?",
      "created_at": "2024-06-21T18:22:57Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649300280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649300280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 104,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649308286",
      "pull_request_review_id": 2116172410,
      "id": 1649308286,
      "node_id": "PRRC_kwDOABII585iTnJ-",
      "diff_hunk": "@@ -257,6 +277,145 @@ class AncestorCandidateFinder\n     }\n };\n \n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename SetType>\n+class SearchCandidateFinder\n+{\n+    /** Internal dependency graph for the cluster. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transactions are left to do (sorted indices). */\n+    SetType m_todo;\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     *\n+     * Complexity: O(1).\n+     */\n+    SearchCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo(SetType::Fill(depgraph.TxCount())) {}\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in] max_iterations  The maximum number of optimization steps that will be performed.\n+     * @param[in] best            A set/feerate pair with an already-known good candidate. This may\n+     *                            be empty.\n+     * @return                    A pair of:\n+     *                            - The best (highest feerate, smallest size as tiebreaker)\n+     *                              topologically valid subset (and its feerate) that was\n+     *                              encountered during search. It will be at least as good as the\n+     *                              best passed in (if not empty).\n+     *                            - The number of optimization steps that were performed. This will\n+     *                              be <= max_iterations. If strictly < max_iterations, the\n+     *                              returned subset is optimal.\n+     *\n+     * Complexity: O(N * min(max_iterations, 2^N)) where N=depgraph.TxCount().\n+     */\n+    std::pair<SetInfo<SetType>, uint64_t> FindCandidateSet(uint64_t max_iterations, SetInfo<SetType> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included (and its feerate). This must be a subset\n+             *  of m_todo, and be topologically valid (includes all in-m_todo ancestors of\n+             *  itself). */\n+            SetInfo<SetType> inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            SetType und;\n+\n+            /** Construct a new work item. */\n+            WorkItem(SetInfo<SetType>&& i, SetType&& u) noexcept :\n+                inc(std::move(i)), und(std::move(u)) {}\n+        };\n+\n+        /** The queue of work items. */\n+        std::vector<WorkItem> queue;\n+\n+        // Create an initial entry with m_todo as undecided. Also use it as best if not provided,\n+        // so that during the work processing loop below, and during the add_fn/split_fn calls, we\n+        // do not need to deal with the best=empty case.\n+        if (best.feerate.IsEmpty()) best = SetInfo(m_depgraph, m_todo);\n+        queue.emplace_back(SetInfo<SetType>{}, SetType{m_todo});\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iterations_left = max_iterations;\n+\n+        /** Internal function to add a work item.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         */\n+        auto add_fn = [&](SetInfo<SetType> inc, SetType und) noexcept {\n+            if (!inc.feerate.IsEmpty()) {\n+                // If inc's feerate is better than best's, remember it as our new best.\n+                if (inc.feerate > best.feerate) {\n+                    best = inc;\n+                }\n+            }",
      "path": "src/cluster_linearize.h",
      "position": 447,
      "original_position": 125,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "68a6c5daa334387526223930ff7593126ed5b20a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n            } else {\r\n                Assume(inc.transactions.None())\r\n            }\r\n```",
      "created_at": "2024-06-21T18:32:10Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649308286",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649308286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 447,
      "original_line": 447,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649373379",
      "pull_request_review_id": 2116172410,
      "id": 1649373379,
      "node_id": "PRRC_kwDOABII585iT3DD",
      "diff_hunk": "@@ -635,3 +688,68 @@ FUZZ_TARGET(clusterlin_search_finder)\n         anc_finder.MarkDone(del_set);\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_linearize)\n+{\n+    // Verify the behavior of Linearize().\n+\n+    // Retrieve an iteration count, and a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    uint64_t iter_count{0};\n+    try {\n+        reader >> VARINT(iter_count) >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Invoke Linearize().\n+    iter_count &= 0x7ffff;\n+    auto [linearization, optimal] = Linearize(depgraph, iter_count);\n+    SanityCheck(depgraph, linearization);\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+\n+    // If the iteration count is sufficiently high, an optimal linearization must be found.\n+    // Each linearization step can use up to 2^k iterations, with steps k=1..n. That sum is\n+    // 2 * (2^n - 1)\n+    const uint64_t n = depgraph.TxCount();\n+    if (n <= 18 && iter_count > 2U * ((uint64_t{1} << n) - 1U)) {\n+        assert(optimal);\n+    }\n+\n+    // If Linearize claims optimal result, run quality tests.\n+    if (optimal) {\n+        // It must be as good as SimpleLinearize.\n+        auto [simple_linearization, simple_optimal] = SimpleLinearize(depgraph, 0x3ffff);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 520,
      "original_position": 115,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "a34467001c258adf6b6f6d5d626221e7f89d38df",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`0x3ffff` should be explained",
      "created_at": "2024-06-21T19:53:05Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649373379",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649373379"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 520,
      "original_line": 520,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649396138",
      "pull_request_review_id": 2116172410,
      "id": 1649396138,
      "node_id": "PRRC_kwDOABII585iT8mq",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.",
      "path": "src/bench/clusterlin.cpp",
      "position": 98,
      "original_position": 94,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "a little confused what this is trying to say",
      "created_at": "2024-06-21T20:22:14Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649396138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649396138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 98,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649399637",
      "pull_request_review_id": 2116172410,
      "id": 1649399637,
      "node_id": "PRRC_kwDOABII585iT9dV",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeLinearGraph<SetType>(ntx);\n+    bench.run([&] {\n+        // Do 10 iterations just to make sure some of that logic is executed, but this is\n+        // effectively negligible.\n+        uint64_t iters = 10;\n+        Linearize(depgraph, iters);\n+    });\n+}\n+\n+} // namespace\n+\n+static void LinearizePerIter16TxWorstCase(benchmark::Bench& bench) { BenchLinearizePerIterWorstCase<BitSet<16>>(16, bench); }",
      "path": "src/bench/clusterlin.cpp",
      "position": 106,
      "original_position": 102,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "if each benchmark matches the BitSet::Size(), no need for `ntx` args?",
      "created_at": "2024-06-21T20:25:27Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649399637",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649399637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 106,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649401042",
      "pull_request_review_id": 2116172410,
      "id": 1649401042,
      "node_id": "PRRC_kwDOABII585iT9zS",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best\n+// implemented algorithms.\n+template<typename SetType>\n+DepGraph<SetType> MakeHardGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        if (ntx & 1) {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 2});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({14, 2});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({6, 1});\n+                depgraph.AddDependency(2, 1);\n+            } else if (i == 3) {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(2, 3);\n+            } else if ((i & 1) == 0) {\n+                depgraph.AddTransaction({7, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({5, 1});\n+                depgraph.AddDependency(i, 4);\n+            }\n+        } else {\n+            if (i == 0) {\n+                depgraph.AddTransaction({1, 1});\n+            } else if (i == 1) {\n+                depgraph.AddTransaction({3, 1});\n+                depgraph.AddDependency(0, 1);\n+            } else if (i == 2) {\n+                depgraph.AddTransaction({1, 1});\n+                depgraph.AddDependency(0, 2);\n+            } else if (i & 1) {\n+                depgraph.AddTransaction({4, 1});\n+                depgraph.AddDependency(i - 1, i);\n+            } else {\n+                depgraph.AddTransaction({0, 1});\n+                depgraph.AddDependency(i, 3);\n+            }\n+        }\n+    }\n+    return depgraph;\n+}\n+\n+/** Benchmark that does search-based candidate finding with 10000 iterations. */\n+template<typename SetType>\n+void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n+{\n+    const auto depgraph = MakeHardGraph<SetType>(ntx);\n+    const auto iter_limit = std::min<uint64_t>(10000, uint64_t{1} << (ntx / 2 - 1));\n+    bench.batch(iter_limit).unit(\"iters\").run([&] {\n+        SearchCandidateFinder finder(depgraph);\n+        auto [candidate, iters_performed] = finder.FindCandidateSet(iter_limit, {});\n+        assert(iters_performed == iter_limit);\n+    });\n+}\n+\n+/** Benchmark for linearization of a trivial linear graph using just ancestor sort. */\n+template<typename SetType>\n+void BenchLinearizeNoItersWorstCase(ClusterIndex ntx, benchmark::Bench& bench)",
      "path": "src/bench/clusterlin.cpp",
      "position": 90,
      "original_position": 89,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "having trouble understanding what `PerIter` and `NoIter` mean",
      "created_at": "2024-06-21T20:27:22Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1649401042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649401042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651203077",
      "pull_request_review_id": 2116172410,
      "id": 1651203077,
      "node_id": "PRRC_kwDOABII585ia1wF",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+\n+#include <util/bitset.h>\n+#include <cluster_linearize.h>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Construct a linear graph. These are pessimal for AncestorCandidateFinder, as they maximize\n+ *  the number of ancestor set feerate updates. */\n+template<typename SetType>\n+DepGraph<SetType> MakeLinearGraph(ClusterIndex ntx)\n+{\n+    DepGraph<SetType> depgraph;\n+    for (ClusterIndex i = 0; i < ntx; ++i) {\n+        depgraph.AddTransaction({-int32_t(i), 1});\n+        if (i > 0) depgraph.AddDependency(i - 1, i);\n+    }\n+    return depgraph;\n+}\n+\n+// Construct a difficult graph. These need at least sqrt(2^(n-1)) iterations in the best",
      "path": "src/bench/clusterlin.cpp",
      "position": 27,
      "original_position": 27,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8733d2dbcda7b40a26387f625230148a9ff951f5",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you add a description of how it's inherently difficult and what these two types of topologies are achieving? \r\n",
      "created_at": "2024-06-24T15:09:14Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651203077",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651203077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 27,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651302872",
      "pull_request_review_id": 2116172410,
      "id": 1651302872,
      "node_id": "PRRC_kwDOABII585ibOHY",
      "diff_hunk": "@@ -351,7 +352,8 @@ class SearchCandidateFinder\n         };\n \n         /** The queue of work items. */\n-        std::vector<WorkItem> queue;\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));",
      "path": "src/cluster_linearize.h",
      "position": 425,
      "original_position": 14,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think 256 is ever exceeded in bench(99)/fuzz(32) cases?\r\n\r\nIIUC If the other value were ever exercised, it has to at least be `m_todo.Count() + 1`",
      "created_at": "2024-06-24T16:18:03Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651302872",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651302872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 425,
      "original_line": 425,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651468145",
      "pull_request_review_id": 2116172410,
      "id": 1651468145,
      "node_id": "PRRC_kwDOABII585ib2dx",
      "diff_hunk": "@@ -411,10 +416,36 @@ class SearchCandidateFinder\n         };\n \n         // Work processing loop.\n+        //\n+        // New work items are always added at the back of the queue, but items to process use a\n+        // hybrid approach where they can be taken from the front or the back.\n+        //\n+        // Depth-first search (DFS) corresponds to always taking from the back of the queue. This\n+        // is very memory-efficient (linear in the number of transactions). Breadth-first search\n+        // (BFS) corresponds to always taking from the front, which potentially uses more memory\n+        // (up to exponential in the transaction count), but seems to work better in practice.\n+        //\n+        // The approach here combines the two: use BFS until the queue grows too large, at which\n+        // point we temporarily switch to DFS until the size shrinks again.\n         while (!queue.empty()) {\n+            // See if processing the first queue item (BFS) is possible without exceeding the queue\n+            // capacity(), assuming we process the last queue items (DFS) after that.\n+            const auto queuesize_for_front = queue.capacity() - queue.front().und.Count();",
      "path": "src/cluster_linearize.h",
      "position": 505,
      "original_position": 48,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "aacb67d9142f7cfe286590021b60b3945fd1620c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe this is all correct and understand reasoning for flow, but I don't really understand what `queuesize_for_front` name is meant to convey. It took me a while to convince myself this section was correct fwiw\r\n\r\n",
      "created_at": "2024-06-24T18:40:00Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651468145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651468145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 505,
      "original_line": 505,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651471330",
      "pull_request_review_id": 2116172410,
      "id": 1651471330,
      "node_id": "PRRC_kwDOABII585ib3Pi",
      "diff_hunk": "@@ -0,0 +1,1133 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <optional>\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <random.h>\n+#include <util/feefrac.h>\n+#include <util/vecdeque.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename S>\n+using Cluster = std::vector<std::pair<FeeFrac, S>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename S>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        S ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        S descendants;\n+\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+        friend auto operator<=>(const Entry&, const Entry&) noexcept = default;\n+\n+        Entry() noexcept = default;\n+        Entry(const FeeFrac& f, const S& a, const S& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    // Comparison operators.\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+    friend auto operator<=>(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = S::Singleton(i);\n+            entries[i].descendants = S::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<S>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            S to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given another DepGraph and a mapping from old to new.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    DepGraph(const DepGraph<S>& depgraph, Span<const ClusterIndex> mapping) noexcept : entries(depgraph.TxCount())\n+    {\n+        // Fill in fee, size, ancestors.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            const auto& input = depgraph.entries[i];\n+            auto& output = entries[mapping[i]];\n+            output.feerate = input.feerate;\n+            for (auto j : input.ancestors) output.ancestors.Set(mapping[j]);\n+        }\n+        // Fill in descendant information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the mutable feerate of a given transaction i. Complexity: O(1). */\n+    FeeFrac& FeeRate(ClusterIndex i) noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const S& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const S& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, S::Singleton(new_idx), S::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.\n+        const auto& chl_des = entries[child].descendants;\n+        for (auto anc_of_par : Ancestors(parent)) {\n+            entries[anc_of_par].descendants |= chl_des;\n+        }\n+        // To each descendant of the child, add as ancestors the ancestors of the parent.\n+        const auto& par_anc = entries[parent].ancestors;\n+        for (auto dec_of_chl : Descendants(child)) {\n+            entries[dec_of_chl].ancestors |= par_anc;\n+        }\n+    }\n+\n+    /** Compute the aggregate feerate of a set of nodes in this graph.\n+     *\n+     * Complexity: O(N) where N=elems.Count().\n+     **/\n+    FeeFrac FeeRate(const S& elems) const noexcept\n+    {\n+        FeeFrac ret;\n+        for (auto pos : elems) ret += entries[pos].feerate;\n+        return ret;\n+    }\n+\n+    /** Find some connected component within the subset \"left\" of this graph.\n+     *\n+     * Complexity: O(ret.Count()).\n+     */\n+    S FindConnectedComponent(const S& left) const noexcept\n+    {\n+        if (left.None()) return left;\n+        auto first = left.First();\n+        S ret = Descendants(first) | Ancestors(first);\n+        ret &= left;\n+        S to_add = ret;\n+        to_add.Reset(first);\n+        do {\n+            S old = ret;\n+            for (auto add : to_add) {\n+                ret |= Descendants(add);\n+                ret |= Ancestors(add);\n+            }\n+            ret &= left;\n+            to_add = ret - old;\n+        } while (to_add.Any());\n+        return ret;\n+    }\n+\n+    /** Determine if a subset is connected.\n+     *\n+     * Complexity: O(subset.Count()).\n+     */\n+    bool IsConnected(const S& subset) const noexcept\n+    {\n+        return FindConnectedComponent(subset) == subset;\n+    }\n+\n+    /** Determine if this entire graph is connected.\n+     *\n+     * Complexity: O(TxCount()).\n+     */\n+    bool IsConnected() const noexcept { return IsConnected(S::Fill(TxCount())); }\n+\n+    /** Append the entries of select to list in a topologically valid order.\n+     *\n+     * Complexity: O(select.Count() * log(select.Count())).\n+     */\n+    void AppendTopo(std::vector<ClusterIndex>& list, const S& select) const noexcept\n+    {\n+        ClusterIndex old_len = list.size();\n+        for (auto i : select) list.push_back(i);\n+        std::sort(list.begin() + old_len, list.end(), [&](ClusterIndex a, ClusterIndex b) noexcept {\n+            const auto a_anc_count = entries[a].ancestors.Count();\n+            const auto b_anc_count = entries[b].ancestors.Count();\n+            if (a_anc_count != b_anc_count) return a_anc_count < b_anc_count;\n+            return a < b;\n+        });\n+    }\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename S>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<S>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    S m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<S>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{S::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            S anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];\n+                anc_to_add -= m_depgraph.Ancestors(first);\n+            }\n+            // Add in other ancestors (which necessarily include i itself).\n+            Assume(anc_to_add[i]);\n+            for (ClusterIndex idx : anc_to_add) anc_feerate += m_depgraph.FeeRate(idx);\n+            // Store the result.\n+            m_ancestor_set_feerates[i] = anc_feerate;\n+        }\n+    }\n+\n+    /** Remove a set of transactions from the set of to-be-linearized ones.\n+     *\n+     * Complexity: O(N*M) where N=depgraph.TxCount(), M=select.Count().\n+     */\n+    void MarkDone(S select) noexcept\n+    {\n+        select &= m_todo;\n+        m_todo -= select;\n+        for (auto i : select) {\n+            auto feerate = m_depgraph.FeeRate(i);\n+            for (auto j : m_depgraph.Descendants(i) & m_todo) {\n+                m_ancestor_set_feerates[j] -= feerate;\n+            }\n+        }\n+    }\n+\n+    /** Find the best remaining ancestor set. Unlinearized transactions must remain.\n+     *\n+     * Complexity: O(N) where N=depgraph.TxCount();\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet() const noexcept\n+    {\n+        std::optional<ClusterIndex> best;\n+        for (auto i : m_todo) {\n+            if (best.has_value()) {\n+                if (!(m_ancestor_set_feerates[i] > m_ancestor_set_feerates[*best])) continue;\n+            }\n+            best = i;\n+        }\n+        Assume(best.has_value());\n+        return {m_depgraph.Ancestors(*best) & m_todo, m_ancestor_set_feerates[*best]};\n+    }\n+};\n+\n+/** Class encapsulating the state needed to perform search for good candidate sets. */\n+template<typename S>\n+class SearchCandidateFinder\n+{\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** m_sorted_to_original[i] is the original position that sorted transaction position i had. */\n+    std::vector<ClusterIndex> m_sorted_to_original;\n+    /** m_original_to_sorted[i] is the sorted position original transaction position i has. */\n+    std::vector<ClusterIndex> m_original_to_sorted;\n+    /** Internal dependency graph for the cluster (with transactions in decreasing individual\n+     *  feerate order). */\n+    DepGraph<S> m_depgraph;\n+    /** Which transactions are left to do (indices in m_depgraph's sorted order). */\n+    S m_todo;\n+\n+    static uint256 GetRNGKey(uint64_t rng_seed) noexcept\n+    {\n+        uint256 rng_key;\n+        WriteLE64(rng_key.data(), rng_seed);\n+        return rng_key;\n+    }\n+\n+    /** Given a set of transactions with sorted indices, get their original indices. */\n+    S SortedToOriginal(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_sorted_to_original[pos]);\n+        return ret;\n+    }\n+\n+    /** Given a set of transactions with original indices, get their sorted indices. */\n+    S OriginalToSorted(const S& arg) const noexcept\n+    {\n+        S ret;\n+        for (auto pos : arg) ret.Set(m_original_to_sorted[pos]);\n+        return ret;\n+    }\n+\n+public:\n+    /** Construct a candidate finder for a graph.\n+     *\n+     * @param[in] depgraph   Dependency graph for the to-be-linearized cluster.\n+     * @param[in] rng_seed   A random seed to control the search order.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.Count().\n+     */\n+    SearchCandidateFinder(const DepGraph<S>& depgraph, uint64_t rng_seed) noexcept :\n+        m_rng(GetRNGKey(rng_seed)),\n+        m_sorted_to_original(depgraph.TxCount()),\n+        m_original_to_sorted(depgraph.TxCount())\n+    {\n+        // Determine reordering mapping, by sorting by decreasing feerate.\n+        std::iota(m_sorted_to_original.begin(), m_sorted_to_original.end(), ClusterIndex{0});\n+        std::sort(m_sorted_to_original.begin(), m_sorted_to_original.end(), [&](auto a, auto b) {\n+            auto feerate_cmp = depgraph.FeeRate(a) <=> depgraph.FeeRate(b);\n+            if (feerate_cmp == 0) return a < b;\n+            return feerate_cmp > 0;\n+        });\n+        // Compute reverse mapping.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            m_original_to_sorted[m_sorted_to_original[i]] = i;\n+        }\n+        // Compute reordered dependency graph.\n+        m_depgraph = DepGraph(depgraph, m_original_to_sorted);\n+        // Set todo to the entire graph.\n+        m_todo = S::Fill(depgraph.TxCount());\n+    }\n+\n+    /** Find a high-feerate topologically-valid subset of what remains of the cluster.\n+     *\n+     * @param[in,out] iterations_left    On input, an upper bound on the number of optimization\n+     *                                   steps that can be performed. On output, that number is\n+     *                                   reduced by the number of actually performed optimization\n+     *                                   steps.\n+     * @param[in] best                   A set/feerate pair with an already-known good candidate.\n+     *                                   This can be empty.\n+     * @return                           The best (highest feerate, smallest size as tiebreaker)\n+     *                                   topologically-valid subset of what remains of the cluster\n+     *                                   that was encountered during search. If iterations_left is\n+     *                                   nonzero on output, it is the absolute best such subset. If\n+     *                                   not, the feerate of the returned set will be at least as\n+     *                                   good as the best passed in.\n+     *\n+     * Complexity: possibly O(N * min(iterations_left, sqrt(2^N))) where N=depgraph.TxCount().\n+     */\n+    std::pair<S, FeeFrac> FindCandidateSet(uint64_t& iterations_left, std::pair<S, FeeFrac> best) noexcept\n+    {\n+        // Bail out quickly if we're given a (remaining) cluster that is empty.\n+        if (m_todo.None()) return {};\n+\n+        if (best.second.IsEmpty()) {\n+            // Set best to the entire remainder if not provided.\n+            best.first = m_todo;\n+            best.second = m_depgraph.FeeRate(m_todo);\n+        } else {\n+            // Otherwise convert to internal sorted indices.\n+            best.first = OriginalToSorted(best.first);\n+        }\n+        Assume(!best.second.IsEmpty());\n+        Assume(best.first.Any());\n+        Assume(best.first.IsSubsetOf(m_todo));\n+\n+        /** Type for work queue items. */\n+        struct WorkItem\n+        {\n+            /** Set of transactions definitely included. This must be a subset of m_todo, and be\n+             *  topologically valid (includes all in-m_todo ancestors of itself). */\n+            S inc;\n+            /** Set of undecided transactions. This must be a subset of m_todo, and have no overlap\n+             *  with inc. The set (inc | und) must be topologically valid. */\n+            S und;\n+            /** (Only when inc is not empty) The subset with the best feerate of any superset of\n+             *  inc that is also a subset of (inc | und), without requiring it to be topologically\n+             *  valid. If the real best such feerate does not exceed best.second, then this value\n+             *  is not guaranteed to be accurate. */\n+            S pot;\n+            /** Equal to m_depgraph.FeeRate(inc). */\n+            FeeFrac inc_feerate;\n+            /** Equal to m_depgraph.FeeRate(pot). It forms a conservative upper bound on how good\n+             *  a set this work item can give rise to, unless that's known to be below best.second.\n+             */\n+            FeeFrac pot_feerate;\n+            /** Construct a new work item. */\n+            WorkItem(S&& i, S&& u, S&& p, FeeFrac&& i_f, FeeFrac&& p_f) noexcept :\n+                inc(std::move(i)), und(std::move(u)), pot(std::move(p)),\n+                inc_feerate(std::move(i_f)), pot_feerate(std::move(p_f)) {}\n+            /** Swap two WorkItems. */\n+            void Swap(WorkItem& other) noexcept\n+            {\n+                swap(inc, other.inc);\n+                swap(und, other.und);\n+                swap(pot, other.pot);\n+                swap(inc_feerate, other.inc_feerate);\n+                swap(pot_feerate, other.pot_feerate);\n+            }\n+        };\n+\n+        /** The queue of work items. */\n+        VecDeque<WorkItem> queue;\n+        queue.reserve(std::max<size_t>(256, 2 * m_todo.Count()));\n+\n+        /** The set of transactions in m_todo which have feerate > best_feerate. */\n+        S imp = m_todo;\n+        while (imp.Any()) {\n+            ClusterIndex check = imp.Last();\n+            if (m_depgraph.FeeRate(check) >> best.second) break;\n+            imp.Reset(check);\n+        }\n+\n+        /** Local copy of the iteration limit. */\n+        uint64_t iteration_limit = iterations_left;\n+\n+        /** Internal function to add a work item, possibly improving it before doing so.\n+         *\n+         * - inc: the \"inc\" value for the new work item\n+         * - und: the \"und\" value for the new work item\n+         * - pot: a subset of the \"pot\" value for the new work item (but a superset of inc).\n+         *        It does not need to be the full pot value; missing pot transactions will be added\n+         *        to it by add_fn.\n+         * - inc_feerate: equal to m_depgraph.FeeRate(inc)\n+         * - pot_feerate: equal to m_depgraph.FeeRate(pot)\n+         * - grow_inc: whether to attempt moving transactions from und to inc, if it can be proven\n+         *             that they must be a part of the best topologically valid superset of inc and\n+         *             subset of (inc | und). Transactions that are missing from pot are always\n+         *             considered, regardless of grow_inc. It only makes sense to enable this if\n+         *             transactions were added to inc.\n+         */\n+        auto add_fn = [&](S inc, S und, S pot, FeeFrac inc_feerate, FeeFrac pot_feerate, bool grow_inc) noexcept {\n+            Assume(inc.IsSubsetOf(m_todo));\n+            Assume(und.IsSubsetOf(m_todo));\n+            Assume(!inc.Overlaps(und));\n+            Assume(pot.IsSupersetOf(inc));\n+            Assume(pot.IsSubsetOf(inc | und));\n+            Assume(pot.None() == inc.None());\n+\n+            if (!inc_feerate.IsEmpty()) {\n+                /** Which transactions to consider adding to inc. */\n+                S consider_inc = grow_inc ? pot - inc : S{};\n+                // Add entries to pot (and pot_feerate). We iterate over all undecided transactions\n+                // whose feerate is higher than best_feerate, and aren't already part of pot. While\n+                // undecided transactions of lower feerate may improve pot still, if they do, the\n+                // resulting pot_feerate cannot possibly exceed best.second (resulting in the item\n+                // being skipped in split_fn).\n+                for (auto pos : (imp & und) - pot) {\n+                    // Determine if adding transaction pos to pot (ignoring topology) would improve it. If\n+                    // not, we're done updating pot. This relies on the fact that m_depgraph, and\n+                    // thus the set iterated over, is in decreasing individual feerate order.\n+                    if (!(m_depgraph.FeeRate(pos) >> pot_feerate)) break;\n+                    pot_feerate += m_depgraph.FeeRate(pos);\n+                    pot.Set(pos);\n+                    consider_inc.Set(pos);\n+                }\n+\n+                // The \"jump ahead\" optimization: whenever pot has a topologically-valid subset,\n+                // that subset can be added to inc. Any subset of (pot - inc) has the property that\n+                // its feerate exceeds that of any set compatible with this work item (superset of\n+                // inc, subset of (inc | und)). Thus, if T is a topological subset of pot, and B is\n+                // the best topologically-valid set compatible with this work item, and (T - B) is\n+                // non-empty, then (T | B) is better than B and also topological. This is in\n+                // contradiction with the assumption that B is best. Thus, (T - B) must be empty,\n+                // or T must be a subset of B.\n+                //\n+                // See https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303 section 2.4.\n+                const S init_inc = inc;\n+                for (auto pos : consider_inc) {\n+                    // If the transaction's ancestors are a subset of pot, we can add it together\n+                    // with its ancestors to inc.\n+                    auto anc_todo = m_depgraph.Ancestors(pos) & m_todo;\n+                    if (anc_todo.IsSubsetOf(pot)) inc |= anc_todo;\n+                }\n+                // Finally update und and inc_feerate to account for the added transactions.\n+                und -= inc;\n+                inc_feerate += m_depgraph.FeeRate(inc - init_inc);\n+\n+                // If inc_feerate is better than best_feerate, remember inc as our new best.\n+                if (inc_feerate > best.second) {\n+                    best = {inc, inc_feerate};\n+                    // See if we can remove any entries from imp now.\n+                    while (imp.Any()) {\n+                        ClusterIndex check = imp.Last();\n+                        if (m_depgraph.FeeRate(check) >> best.second) break;\n+                        imp.Reset(check);\n+                    }\n+                }\n+\n+                // If no potential transactions exist beyond the already included ones, no improvement\n+                // is possible anymore.\n+                if (pot == inc) return;\n+                // At this point und must be non-empty. If it were empty then pot would equal inc.\n+                Assume(und.Any());\n+            } else {\n+                // If inc is empty, we just make sure there are undecided transactions left to\n+                // split on.\n+                if (und.None()) return;\n+            }\n+\n+            // Actually construct new work item on the queue.\n+            Assume(queue.size() < queue.capacity());",
      "path": "src/cluster_linearize.h",
      "position": 455,
      "original_position": 558,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "8170a81e71249ba61a343ae83a0a5e7e368a38a0",
      "in_reply_to_id": 1626377280,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes, took me a while to convince myself, but the claim is clear",
      "created_at": "2024-06-24T18:43:01Z",
      "updated_at": "2024-06-27T15:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651471330",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651471330"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 455,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651482096",
      "pull_request_review_id": 2116172410,
      "id": 1651482096,
      "node_id": "PRRC_kwDOABII585ib53w",
      "diff_hunk": "@@ -77,8 +77,9 @@ void BenchLinearizePerIterWorstCase(ClusterIndex ntx, benchmark::Bench& bench)\n {",
      "path": "src/bench/clusterlin.cpp",
      "position": 77,
      "original_position": 1,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "2228113dbbdd356aaaad385fd3e46a71308392aa commit message nit:\r\n\r\ns/item,/item to/",
      "created_at": "2024-06-24T18:53:07Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651482096",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651482096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 77,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651484882",
      "pull_request_review_id": 2116172410,
      "id": 1651484882,
      "node_id": "PRRC_kwDOABII585ib6jS",
      "diff_hunk": "@@ -467,6 +495,7 @@ class SearchCandidateFinder\n  *\n  * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n  * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed        A random number seed to control search order.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 86,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "2228113dbbdd356aaaad385fd3e46a71308392aa",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I presume the non-determinism is helpful to reduce the influence other nodes have on your linearization? Or maybe the idea that you could run linearizatio algo intermittently and make improvements? Other motivations?",
      "created_at": "2024-06-24T18:55:22Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1651484882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651484882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 498,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652892335",
      "pull_request_review_id": 2116172410,
      "id": 1652892335,
      "node_id": "PRRC_kwDOABII585ihSKv",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n ",
      "path": "src/cluster_linearize.h",
      "position": 558,
      "original_position": 44,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n\r\n    Assume(old_linearization.empty() || old_linearization.size() == depgraph.TxCount());\r\n```",
      "created_at": "2024-06-25T14:08:01Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1652892335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652892335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 558,
      "original_line": 558,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652946934",
      "pull_request_review_id": 2116172410,
      "id": 1652946934,
      "node_id": "PRRC_kwDOABII585ihff2",
      "diff_hunk": "@@ -491,33 +495,65 @@ class SearchCandidateFinder\n     }\n };\n \n-/** Find a linearization for a cluster.\n+/** Find or improve a linearization for a cluster.\n  *\n- * @param[in] depgraph        Dependency graph of the the cluster to be linearized.\n- * @param[in] max_iterations  Upper bound on the number of optimization steps that will be done.\n- * @param[in] rng_seed        A random number seed to control search order.\n- * @return                    A pair of:\n- *                            - The resulting linearization.\n- *                            - A boolean indicating whether the result is guaranteed to be\n- *                              optimal.\n+ * @param[in] depgraph           Dependency graph of the the cluster to be linearized.\n+ * @param[in] max_iterations     Upper bound on the number of optimization steps that will be done.\n+ * @param[in] rng_seed           A random number seed to control search order.\n+ * @param[in] old_linearization  An existing linearization for the cluster, or empty.\n+ * @return                       A pair of:\n+ *                               - The resulting linearization. It is guaranteed to be at least as\n+ *                                 good (in the feerate diagram sense) as old_linearization.\n+ *                               - A boolean indicating whether the result is guaranteed to be\n+ *                                 optimal.\n  *\n  * Complexity: O(N * min(max_iterations + N, 2^N)) where N=depgraph.TxCount().\n  */\n template<typename SetType>\n-std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed) noexcept\n+std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>& depgraph, uint64_t max_iterations, uint64_t rng_seed, Span<const ClusterIndex> old_linearization = {}) noexcept\n {\n     uint64_t iterations_left = max_iterations;\n     auto todo = SetType::Fill(depgraph.TxCount());\n     std::vector<ClusterIndex> linearization;\n \n+    // Precompute chunking of the existing linearization.\n+    std::vector<SetInfo<SetType>> chunks;\n+    for (auto i : old_linearization) {\n+        SetInfo new_chunk(depgraph, i);\n+        while (!chunks.empty() && new_chunk.feerate >> chunks.back().feerate) {\n+            new_chunk |= chunks.back();\n+            chunks.pop_back();\n+        }\n+        chunks.push_back(std::move(new_chunk));\n+    }\n+\n     AncestorCandidateFinder anc_finder(depgraph);\n     SearchCandidateFinder src_finder(depgraph, rng_seed);\n     linearization.reserve(depgraph.TxCount());\n     bool optimal = true;\n \n     while (todo.Any()) {\n-        // Initialize best as the best remaining ancestor set.\n-        auto best = anc_finder.FindCandidateSet();\n+        // This is an implementation of the (single) LIMO algorithm:\n+        // https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825\n+        // where S is instantiated to be the result of a bounded search, which itself is seeded\n+        // with the best prefix of what remains of the input linearization, or the best ancestor set.\n+\n+        // Find the highest-feerate prefix of remainder of original chunks.\n+        SetInfo<SetType> best_prefix, best_prefix_acc;\n+        for (const auto& chunk : chunks) {\n+            SetType intersect = chunk.transactions & todo;\n+            if (intersect.Any()) {\n+                best_prefix_acc |= SetInfo(depgraph, intersect);\n+                if (best_prefix.feerate.IsEmpty() || best_prefix_acc.feerate > best_prefix.feerate) {\n+                    best_prefix = best_prefix_acc;\n+                }\n+            }\n+        }\n+\n+        // Then initialize best to be either the best remaining ancestor set, or the first chunk.\n+        auto best_anc = anc_finder.FindCandidateSet();",
      "path": "src/cluster_linearize.h",
      "position": 594,
      "original_position": 82,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`best_anc` seems unneeded since it's only read once next line?",
      "created_at": "2024-06-25T14:28:52Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1652946934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652946934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 594,
      "original_line": 594,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652960236",
      "pull_request_review_id": 2116172410,
      "id": 1652960236,
      "node_id": "PRRC_kwDOABII585ihivs",
      "diff_hunk": "@@ -527,6 +563,24 @@ std::pair<std::vector<ClusterIndex>, uint64_t> Linearize(const DepGraph<SetType>\n \n         if (iterations_done_now == max_iterations_now) {\n             optimal = false;\n+            // If the search result is not (guaranteed to be) optimal, run intersections to make\n+            // sure we don't pick something that makes us unable to reach further diagram points\n+            // of the old linearization.\n+            if (best.transactions != best_prefix.transactions) {",
      "path": "src/cluster_linearize.h",
      "position": 609,
      "original_position": 95,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this section bears further elaboration, or direct citation to a good explanation of what this is necessary for correctness.",
      "created_at": "2024-06-25T14:36:53Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1652960236",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1652960236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 609,
      "original_line": 609,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653136174",
      "pull_request_review_id": 2116172410,
      "id": 1653136174,
      "node_id": "PRRC_kwDOABII585iiNsu",
      "diff_hunk": "@@ -464,6 +464,37 @@ std::vector<FeeFrac> ChunkLinearization(const DepGraph<SetType>& depgraph, Span<\n     return ret;\n }\n \n+/** Given a dependency graph, construct any valid linearization for it, reading from a SpanReader. */\n+template<typename BS>\n+std::vector<ClusterIndex> ReadLinearization(const DepGraph<BS>& depgraph, SpanReader& reader)\n+{\n+    std::vector<ClusterIndex> linearization;\n+    TestBitSet todo = TestBitSet::Fill(depgraph.TxCount());\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 200,
      "original_position": 10,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "be82e8693161e3b7bc948408337d92bf3dee175c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`i` is never used, which was confusing for me, perhaps this?\r\n```Suggestion\r\n    while (todo.Any()) {\r\n```\r\n\r\nalong with asserting that `todo.Count()` is going down for each iteration of the loop to avoid infinite loops ala `assert(todo.Count() < todo_count);`?",
      "created_at": "2024-06-25T16:17:12Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1653136174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653136174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 200,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653168294",
      "pull_request_review_id": 2116172410,
      "id": 1653168294,
      "node_id": "PRRC_kwDOABII585iiVim",
      "diff_hunk": "@@ -166,6 +166,45 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"left\" of this graph.",
      "path": "src/cluster_linearize.h",
      "position": 169,
      "original_position": 4,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I kept reading \"Left\" and is left vs right, since it was taking the `First` bit. \"todo\" probably matches better.",
      "created_at": "2024-06-25T16:39:59Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1653168294",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653168294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 169,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653204539",
      "pull_request_review_id": 2116172410,
      "id": 1653204539,
      "node_id": "PRRC_kwDOABII585iieY7",
      "diff_hunk": "@@ -427,6 +427,21 @@ void SanityCheck(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin\n     }\n }\n \n+/** Stitch connected components together in a DepGraph, guaranteeing its corresponding cluster is connected. */\n+template<typename BS>\n+void MakeConnected(DepGraph<BS>& depgraph)\n+{\n+    auto todo = BS::Fill(depgraph.TxCount());\n+    auto comp = depgraph.FindConnectedComponent(todo);\n+    todo -= comp;\n+    while (todo.Any()) {\n+        auto nextcomp = depgraph.FindConnectedComponent(todo);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 150,
      "original_position": 12,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "9633b40722fd9295b93baaf9914b31b9dec96f45",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n        Assume(!depgraph.IsConnected());\r\n        auto nextcomp = depgraph.FindConnectedComponent(todo);\r\n```",
      "created_at": "2024-06-25T16:57:19Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1653204539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1653204539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 150,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657303810",
      "pull_request_review_id": 2116172410,
      "id": 1657303810,
      "node_id": "PRRC_kwDOABII585iyHMC",
      "diff_hunk": "@@ -0,0 +1,390 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for acyclic DepGraph objects.\n+ *\n+ * The serialization format consists of:\n+ * - For each transaction t in the DepGraph:\n+ *   - The size: VARINT(tx[t].size), which cannot be 0.\n+ *   - The fee: VARINT(SignedToUnsigned(tx[t].fee)), see below for SignedToUnsigned.\n+ *   - The dependencies: for each minimized parent and minimized child of t among tx[0..t-1]:\n+ *     - VARINT(delta), which cannot be 0.\n+ *       To determine these values, consider the list of all potential parents and children tx t\n+ *       has among tx[0..t-1]. First the parents, in order from t-1 back to 0, and then the\n+ *       children in the same order. For these, we only consider ones that satisyfy\n+ *       CanAddDependency, based on all (actual) dependencies emitted before it, so it excludes\n+ *       parents/children that would be redundant, ones which would imply a cyclic dependency, or\n+ *       ones which would make an earlier dependency redundant.\n+ *       Now find in this list the positions that correspond to actual parents/children. The delta\n+ *       value for the first is 1 + its position in the list. The delta value for all further ones\n+ *       is the distance between its position and the previous ones' position.\n+ *   - The end of the dependencies: VARINT(0)\n+ * - The end of the graph: VARINT(0)\n+ *\n+ * On deserialization, if a read delta value results in a position outside the list of potential\n+ * parents/children, it is treated as 0 (i.e., the end of the encodings of dependences of t).\n+ *\n+ * Rationale:\n+ * - Why VARINTs? They are flexible enough to represent large numbers where needed, but more\n+ *   compact for smaller numbers. The serialization format is designed so that simple structures\n+ *   involve smaller numbers, so smaller size maps to simpler graphs.\n+ * - Why use SignedToUnsigned? It results in small unsigned values for signed values with small\n+ *   absolute value. This way we can encode negative fees in graphs, but still let small negative\n+ *   numbers have small encodings.\n+ * - Why are the parents/children emitted in order from t-1 back to 0? This means that if E is the\n+ *   encoding of a subgraph with no outside dependencies, copies of E in the serialization (in the\n+ *   right places) will result in copies of that subgraph.\n+ * - Why use CanAddDependency in the serialization definition? This makes sure that every variation\n+ *   (as produced by a fuzzer) of a graph will result in another, meaningful, and very likely\n+ *   distinct graph.\n+ * - Why use delta encoding and not a bitmask to convey the list positions? It turns out that\n+ *   the most complex graphs (in terms of linearization complexity) are ones with ~1 dependency per\n+ *   transaction. Delta encoding means just 2 bytes per transaction in this case (1 delta, 1 zero),\n+ *   while a bitmask would require 1 bit per potential transaction (= linear in the graph size).\n+ */\n+\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        /** The graph corresponding to what the deserializer already knows. */\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 read children.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {\n+        auto parent = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 1);\n+        auto child = provider.ConsumeIntegralInRange<ClusterIndex>(0, num_tx - 2);\n+        child += (child >= parent);\n+        cluster[child].second.Set(parent);\n+        depgraph.AddDependency(parent, child);\n+        assert(depgraph.Ancestors(child)[parent]);\n+        assert(depgraph.Descendants(parent)[child]);\n+    }\n+    // Sanity check the result.\n+    SanityCheck(depgraph);\n+    // Verify that the resulting DepGraph matches one recomputed from the cluster.\n+    assert(DepGraph(cluster) == depgraph);\n+}\n+\n+FUZZ_TARGET(clusterlin_cluster_serialization)\n+{\n+    // Verify that any graph of transaction has its ancestry correctly computed by DepGraph, and if\n+    // it is a DAG, it can be serialized as a DepGraph in a way that roundtrips. This guarantees\n+    // that any acyclic cluster has a corresponding DepGraph serialization.\n+\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    // Construct a cluster in a naive way (using a FuzzedDataProvider-based serialization).\n+    Cluster<TestBitSet> cluster;\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(1, 32);\n+    cluster.resize(num_tx);\n+    for (ClusterIndex i = 0; i < num_tx; ++i) {\n+        cluster[i].first.size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+        cluster[i].first.fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+        for (ClusterIndex j = 0; j < num_tx; ++j) {\n+            if (i == j) continue;\n+            if (provider.ConsumeBool()) cluster[i].second.Set(j);\n+        }\n+    }\n+\n+    // Construct dependency graph. The sanity check here includes a round-trip check.\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+\n+    // Verify that ancestry is computed correctly.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 280,
      "original_position": 353,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "4fbc4687d9c42d6782a6768537f2a3ac9687e28c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "for assurance shouldn't we also be checking the descendants are being computed as expected? Or is that covered somewhere else?",
      "created_at": "2024-06-27T15:01:17Z",
      "updated_at": "2024-06-27T15:02:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657303810",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657303810"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 280,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657850742",
      "pull_request_review_id": 2146569823,
      "id": 1657850742,
      "node_id": "PRRC_kwDOABII585i0Mt2",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).\n+     */\n+    ClusterIndex AddTransaction(const FeeFrac& feefrac) noexcept\n+    {\n+        ClusterIndex new_idx = TxCount();\n+        entries.emplace_back(feefrac, SetType::Singleton(new_idx), SetType::Singleton(new_idx));\n+        return new_idx;\n+    }\n+\n+    /** Modify this transaction graph, adding a dependency between a specified parent and child.\n+     *\n+     * Complexity: O(N) where N=TxCount().\n+     **/\n+    void AddDependency(ClusterIndex parent, ClusterIndex child) noexcept\n+    {\n+        // To each ancestor of the parent, add as descendants the descendants of the child.",
      "path": "src/cluster_linearize.h",
      "position": 146,
      "original_position": 141,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": 1638465834,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think there is a need for that. If `parent == child` then this is a no-op (every transaction is already an ancestor and descendant of itself).",
      "created_at": "2024-06-27T21:48:39Z",
      "updated_at": "2024-06-27T21:48:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657850742",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657850742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 146,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857264",
      "pull_request_review_id": 2146580224,
      "id": 1657857264,
      "node_id": "PRRC_kwDOABII585i0OTw",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 266,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": 1638438741,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:25Z",
      "updated_at": "2024-06-27T21:57:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857264",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857307",
      "pull_request_review_id": 2146580297,
      "id": 1657857307,
      "node_id": "PRRC_kwDOABII585i0OUb",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 270,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": 1638450101,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:30Z",
      "updated_at": "2024-06-27T21:57:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857307",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857391",
      "pull_request_review_id": 2146580422,
      "id": 1657857391,
      "node_id": "PRRC_kwDOABII585i0OVv",
      "diff_hunk": "@@ -0,0 +1,167 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CLUSTER_LINEARIZE_H\n+#define BITCOIN_CLUSTER_LINEARIZE_H\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+#include <util/feefrac.h>\n+\n+namespace cluster_linearize {\n+\n+/** Data type to represent cluster input.\n+ *\n+ * cluster[i].first is tx_i's fee and size.\n+ * cluster[i].second[j] is true iff tx_i spends one or more of tx_j's outputs.\n+ */\n+template<typename SetType>\n+using Cluster = std::vector<std::pair<FeeFrac, SetType>>;\n+\n+/** Data type to represent transaction indices in clusters. */\n+using ClusterIndex = uint32_t;\n+\n+/** Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors,\n+ *  descendants). */\n+template<typename SetType>\n+class DepGraph\n+{\n+    /** Information about a single transaction. */\n+    struct Entry\n+    {\n+        /** Fee and size of transaction itself. */\n+        FeeFrac feerate;\n+        /** All ancestors of the transaction (including itself). */\n+        SetType ancestors;\n+        /** All descendants of the transaction (including itself). */\n+        SetType descendants;\n+\n+        /** Equality operator. */\n+        friend bool operator==(const Entry&, const Entry&) noexcept = default;\n+\n+        /** Construct an empty entry. */\n+        Entry() noexcept = default;\n+        /** Construct an entry with a given feerate, ancestor set, descendant set. */\n+        Entry(const FeeFrac& f, const SetType& a, const SetType& d) noexcept : feerate(f), ancestors(a), descendants(d) {}\n+    };\n+\n+    /** Data for each transaction, in order. */\n+    std::vector<Entry> entries;\n+\n+public:\n+    /** Equality operator. */\n+    friend bool operator==(const DepGraph&, const DepGraph&) noexcept = default;\n+\n+    // Default constructors.\n+    DepGraph() noexcept = default;\n+    DepGraph(const DepGraph&) noexcept = default;\n+    DepGraph(DepGraph&&) noexcept = default;\n+    DepGraph& operator=(const DepGraph&) noexcept = default;\n+    DepGraph& operator=(DepGraph&&) noexcept = default;\n+\n+    /** Construct a DepGraph object for ntx transactions, with no dependencies.\n+     *\n+     * Complexity: O(N) where N=ntx.\n+     **/\n+    explicit DepGraph(ClusterIndex ntx) noexcept\n+    {\n+        Assume(ntx <= SetType::Size());\n+        entries.resize(ntx);\n+        for (ClusterIndex i = 0; i < ntx; ++i) {\n+            entries[i].ancestors = SetType::Singleton(i);\n+            entries[i].descendants = SetType::Singleton(i);\n+        }\n+    }\n+\n+    /** Construct a DepGraph object given a cluster.\n+     *\n+     * Complexity: O(N^2) where N=cluster.size().\n+     */\n+    explicit DepGraph(const Cluster<SetType>& cluster) noexcept : entries(cluster.size())\n+    {\n+        // Fill in fee, size, parent information.\n+        for (ClusterIndex i = 0; i < cluster.size(); ++i) {\n+            entries[i].feerate = cluster[i].first;\n+            entries[i].ancestors = cluster[i].second;\n+            // Make sure transactions are ancestors of themselves.\n+            entries[i].ancestors.Set(i);\n+        }\n+\n+        // Propagate ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            // At this point, entries[a].ancestors[b] is true iff b is an ancestor of a and there\n+            // is a path from a to b through the subgraph consisting of {a, b} union\n+            // {0, 1, ..., (i-1)}.\n+            SetType to_merge = entries[i].ancestors;\n+            for (ClusterIndex j = 0; j < entries.size(); ++j) {\n+                if (entries[j].ancestors[i]) {\n+                    entries[j].ancestors |= to_merge;\n+                }\n+            }\n+        }\n+\n+        // Fill in descendant information by transposing the ancestor information.\n+        for (ClusterIndex i = 0; i < entries.size(); ++i) {\n+            for (auto j : entries[i].ancestors) {\n+                entries[j].descendants.Set(i);\n+            }\n+        }\n+    }\n+\n+    /** Get the number of transactions in the graph. Complexity: O(1). */\n+    auto TxCount() const noexcept { return entries.size(); }\n+    /** Get the feerate of a given transaction i. Complexity: O(1). */\n+    const FeeFrac& FeeRate(ClusterIndex i) const noexcept { return entries[i].feerate; }\n+    /** Get the ancestors of a given transaction i. Complexity: O(1). */\n+    const SetType& Ancestors(ClusterIndex i) const noexcept { return entries[i].ancestors; }\n+    /** Get the descendants of a given transaction i. Complexity: O(1). */\n+    const SetType& Descendants(ClusterIndex i) const noexcept { return entries[i].descendants; }\n+\n+    /** Add a new unconnected transaction to this transaction graph (at the end), and return its\n+     *  ClusterIndex.\n+     *\n+     * Complexity: Amortized O(1).",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 126,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "06c600099abe129a5bb5c6a5a533018f03e51304",
      "in_reply_to_id": 1638472774,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment.",
      "created_at": "2024-06-27T21:57:38Z",
      "updated_at": "2024-06-27T21:57:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857455",
      "pull_request_review_id": 2146580502,
      "id": 1657857455,
      "node_id": "PRRC_kwDOABII585i0OWv",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.\n+            auto fee = UnsignedToSigned(coded_fee);\n+            // Extend resulting graph with new transaction.\n+            auto idx = depgraph.AddTransaction({fee, size});\n+            // Read dependency information.\n+            uint64_t offset = 0; //!< The next encoded value.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 read parents among tx 0..idx-1; in loop 1 store children among those.\n+                bool done = false;\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(depgraph, parent, child)) {\n+                        ++counter;\n+                        // If counter passes offset, read & decode the next differentially encoded\n+                        // value. If a 0 is read, this signifies the end of this transaction's\n+                        // dependency information.\n+                        if (offset < counter) {\n+                            uint64_t diff;\n+                            s >> VARINT(diff);\n+                            offset += diff;\n+                            if (diff == 0 || offset < diff) {\n+                                done = true;\n+                                break;\n+                            }\n+                        }\n+                        // On a match, actually add the relation.\n+                        if (offset == counter) depgraph.AddDependency(parent, child);\n+                    }\n+                }\n+                if (done) break;\n+            }\n+        }\n+    }\n+};\n+\n+/** Perform a sanity/consistency check on a DepGraph. */\n+template<typename SetType>\n+void SanityCheck(const DepGraph<SetType>& depgraph)\n+{\n+    // Consistency check between ancestors internally.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        // Transactions include themselves as ancestors.\n+        assert(depgraph.Ancestors(i)[i]);\n+        // If a is an ancestor of b, then b's ancestors must include all of a's ancestors.\n+        for (auto a : depgraph.Ancestors(i)) {\n+            assert(depgraph.Ancestors(i).IsSupersetOf(depgraph.Ancestors(a)));\n+        }\n+    }\n+    // Consistency check between ancestors and descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        for (ClusterIndex j = 0; j < depgraph.TxCount(); ++j) {\n+            assert(depgraph.Ancestors(i)[j] == depgraph.Descendants(j)[i]);\n+        }\n+    }\n+    // Consistency check between reduced parents/children and ancestors/descendants.\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        SetType parents = GetReducedParents(depgraph, i);\n+        SetType combined_anc = SetType::Singleton(i);\n+        for (auto j : parents) {\n+            // Transactions cannot be a parent of themselves.\n+            assert(j != i);\n+            // Parents cannot have other parents as ancestors.\n+            assert((depgraph.Ancestors(j) & parents) == SetType::Singleton(j));\n+            combined_anc |= depgraph.Ancestors(j);\n+        }\n+        // The ancestors of all parents combined must equal the ancestors.\n+        assert(combined_anc == depgraph.Ancestors(i));\n+\n+        SetType children = GetReducedChildren(depgraph, i);\n+        SetType combined_desc = SetType::Singleton(i);\n+        for (auto j : children) {\n+            // Transactions cannot be a child of themselves.\n+            assert(j != i);\n+            // Children cannot have other children as descendants.\n+            assert((depgraph.Descendants(j) & children) == SetType::Singleton(j));\n+            combined_desc |= depgraph.Descendants(j);\n+        }\n+        // The descendants of all children combined must equal the descendants.\n+        assert(combined_desc == depgraph.Descendants(i));\n+    }\n+    // If DepGraph is acyclic, serialize + deserialize must roundtrip.\n+    if (IsAcyclic(depgraph)) {\n+        std::vector<unsigned char> ser;\n+        VectorWriter writer(ser, 0);\n+        writer << Using<DepGraphFormatter>(depgraph);\n+        SpanReader reader(ser);\n+        DepGraph<TestBitSet> decoded_depgraph;\n+        reader >> Using<DepGraphFormatter>(decoded_depgraph);\n+        assert(depgraph == decoded_depgraph);\n+        assert(reader.empty());\n+    }\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(clusterlin_add_dependency)\n+{\n+    // Verify that computing a DepGraph from a cluster, or building it step by step using AddDependency\n+    // have the same effect.\n+\n+    // Construct a cluster of a certain length, with no dependencies.\n+    Cluster<TestBitSet> cluster;\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    auto num_tx = provider.ConsumeIntegralInRange<ClusterIndex>(2, 32);\n+    cluster.resize(num_tx);\n+    for (auto& item : cluster) item.first.size = 1;\n+    // Construct the corresponding DepGraph object (also no dependencies).\n+    DepGraph depgraph(cluster);\n+    SanityCheck(depgraph);\n+    // Read (parent, child) pairs, and add them to the cluster and txgraph.\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 1024) {",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 271,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "7dfe49ea5dfc500a56f74ae5f87f0c0068bb8d51",
      "in_reply_to_id": 1638488625,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:42Z",
      "updated_at": "2024-06-27T21:57:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 530,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857579",
      "pull_request_review_id": 2146580710,
      "id": 1657857579,
      "node_id": "PRRC_kwDOABII585i0OYr",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.\n+            if (size == 0 || depgraph.TxCount() == SetType::Size()) break;\n+            // Read fee, encoded as a signed varint (odd means negative, even means non-negative).\n+            uint64_t coded_fee;\n+            s >> VARINT(coded_fee);\n+            coded_fee &= 0xFFFFFFFFFFFFF; // Enough for fee between -21M...21M BTC.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 159,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": 1640177309,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done with a `static_assert`.",
      "created_at": "2024-06-27T21:57:53Z",
      "updated_at": "2024-06-27T21:57:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857631",
      "pull_request_review_id": 2146580809,
      "id": 1657857631,
      "node_id": "PRRC_kwDOABII585i0OZf",
      "diff_hunk": "@@ -162,6 +163,100 @@ class DepGraph\n     }\n };\n \n+/** A set of transactions together with their aggregate feerate. */\n+template<typename SetType>\n+struct SetInfo\n+{\n+    /** The transactions in the set. */\n+    SetType transactions;\n+    /** Their combined fee and size. */\n+    FeeFrac feerate;\n+\n+    /** Construct a SetInfo for a specified set and feerate. */\n+    SetInfo(const SetType& txn, const FeeFrac& fr) noexcept : transactions(txn), feerate(fr) {}\n+\n+    /** Construct a SetInfo for a set of transactions in a depgraph. */\n+    explicit SetInfo(const DepGraph<SetType>& depgraph, const SetType& txn) noexcept :\n+        transactions(txn), feerate(depgraph.FeeRate(txn)) {}\n+\n+    /** Permit equality testing. */\n+    friend bool operator==(const SetInfo&, const SetInfo&) noexcept = default;\n+};\n+\n+/** Class encapsulating the state needed to find the best remaining ancestor set. */\n+template<typename SetType>\n+class AncestorCandidateFinder\n+{\n+    /** Internal dependency graph. */\n+    const DepGraph<SetType>& m_depgraph;\n+    /** Which transaction are left to include. */\n+    SetType m_todo;\n+    /** Precomputed ancestor-set feerates (only kept up-to-date for indices in m_todo). */\n+    std::vector<FeeFrac> m_ancestor_set_feerates;\n+\n+public:\n+    /** Construct an AncestorCandidateFinder for a given cluster.\n+     *\n+     * Complexity: O(N^2) where N=depgraph.TxCount().\n+     */\n+    AncestorCandidateFinder(const DepGraph<SetType>& depgraph LIFETIMEBOUND) noexcept :\n+        m_depgraph(depgraph),\n+        m_todo{SetType::Fill(depgraph.TxCount())},\n+        m_ancestor_set_feerates(depgraph.TxCount())\n+    {\n+        // Precompute ancestor-set feerates.\n+        for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+            SetType anc_to_add = m_depgraph.Ancestors(i); //!< Remaining ancestors for transaction i.\n+            FeeFrac anc_feerate;\n+            // Reuse accumulated feerate from first ancestor, if usable.\n+            Assume(anc_to_add.Any());\n+            ClusterIndex first = anc_to_add.First();\n+            if (first < i) {\n+                anc_feerate = m_ancestor_set_feerates[first];",
      "path": "src/cluster_linearize.h",
      "position": 302,
      "original_position": 61,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "626b247e218a08b51ca24305351693099f429dd3",
      "in_reply_to_id": 1644863011,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-06-27T21:57:58Z",
      "updated_at": "2024-06-27T21:57:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857631",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 302,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857760",
      "pull_request_review_id": 2146581040,
      "id": 1657857760,
      "node_id": "PRRC_kwDOABII585i0Obg",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cluster_linearize.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+using TestBitSet = BitSet<32>;\n+\n+/** Check if a graph is acyclic. */\n+template<typename SetType>\n+bool IsAcyclic(const DepGraph<SetType>& depgraph) noexcept\n+{\n+    for (ClusterIndex i = 0; i < depgraph.TxCount(); ++i) {\n+        if ((depgraph.Ancestors(i) & depgraph.Descendants(i)) != SetType::Singleton(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** Get the minimal set of parents a transaction has (parents which are not parents\n+ *  of ancestors). */\n+template<typename SetType>\n+SetType GetReducedParents(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Ancestors(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Ancestors(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Get the minimal set of children a transaction has (children which are not children\n+ *  of descendants). */\n+template<typename SetType>\n+SetType GetReducedChildren(const DepGraph<SetType>& depgraph, ClusterIndex i) noexcept\n+{\n+    SetType ret = depgraph.Descendants(i);\n+    ret.Reset(i);\n+    for (auto a : ret) {\n+        if (ret[a]) {\n+            ret -= depgraph.Descendants(a);\n+            ret.Set(a);\n+        }\n+    }\n+    return ret;\n+}\n+\n+/** Test whether adding a dependency between parent and child is valid and meaningful. */\n+template<typename SetType>\n+bool CanAddDependency(const DepGraph<SetType>& depgraph, ClusterIndex parent, ClusterIndex child) noexcept\n+{\n+    // If child is already a descendant of parent, the dependency would be redundant.\n+    if (depgraph.Descendants(parent)[child]) return false;\n+    // If child is already an ancestor of parent, the dependency would cause a cycle.\n+    if (depgraph.Ancestors(parent)[child]) return false;\n+    // If there is an ancestor of parent which is a direct parent of a descendant of child,\n+    // that dependency will have been redundant if a dependency between parent and child is\n+    // added.\n+    const auto& descendants = depgraph.Descendants(child);\n+    for (auto i : depgraph.Ancestors(parent)) {\n+        if (descendants.Overlaps(depgraph.Descendants(i))) {\n+            if (descendants.Overlaps(GetReducedChildren(depgraph, i))) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+/** A formatter for a bespoke serialization for *acyclic* DepGraph objects. */\n+struct DepGraphFormatter\n+{\n+    /** Convert x>=0 to 2x (even), x<0 to -2x-1 (odd). */\n+    static uint64_t SignedToUnsigned(int64_t x) noexcept\n+    {\n+        if (x < 0) {\n+            return 2 * uint64_t(-(x + 1)) + 1;\n+        } else {\n+            return 2 * uint64_t(x);\n+        }\n+    }\n+\n+    /** Convert even x to x/2 (>=0), odd x to -(x/2)-1 (<0). */\n+    static int64_t UnsignedToSigned(uint64_t x) noexcept\n+    {\n+        if (x & 1) {\n+            return -int64_t(x / 2) - 1;\n+        } else {\n+            return int64_t(x / 2);\n+        }\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    static void Ser(Stream& s, const DepGraph<SetType>& depgraph)\n+    {\n+        DepGraph<SetType> rebuild(depgraph.TxCount());\n+        for (ClusterIndex idx = 0; idx < depgraph.TxCount(); ++idx) {\n+            // Write size.\n+            s << VARINT_MODE(depgraph.FeeRate(idx).size, VarIntMode::NONNEGATIVE_SIGNED);\n+            // Write fee.\n+            s << VARINT(SignedToUnsigned(depgraph.FeeRate(idx).fee));\n+            // Write dependency information.\n+            uint64_t counter = 0; //!< How many potential parent/child relations we've iterated over.\n+            uint64_t offset = 0; //!< The counter value at the last actually written relation.\n+            for (unsigned loop = 0; loop < 2; ++loop) {\n+                // In loop 0 store parents among tx 0..idx-1; in loop 1 store children among those.\n+                SetType towrite = loop ? GetReducedChildren(depgraph, idx) : GetReducedParents(depgraph, idx);\n+                for (ClusterIndex i = 0; i < idx; ++i) {\n+                    ClusterIndex parent = loop ? idx : idx - 1 - i;\n+                    ClusterIndex child = loop ? idx - 1 - i : idx;\n+                    if (CanAddDependency(rebuild, parent, child)) {\n+                        ++counter;\n+                        if (towrite[idx - 1 - i]) {\n+                            rebuild.AddDependency(parent, child);\n+                            // The actually emitted values are differentially encoded (one value\n+                            // per parent/child relation).\n+                            s << VARINT(counter - offset);\n+                            offset = counter;\n+                        }\n+                    }\n+                }\n+            }\n+            if (counter > offset) s << uint8_t{0};\n+        }\n+        // Output a final 0 to denote the end of the graph.\n+        s << uint8_t{0};\n+    }\n+\n+    template <typename Stream, typename SetType>\n+    void Unser(Stream& s, DepGraph<SetType>& depgraph)\n+    {\n+        depgraph = {};\n+        while (true) {\n+            // Read size. Size 0 signifies the end of the DepGraph.\n+            int32_t size;\n+            s >> VARINT_MODE(size, VarIntMode::NONNEGATIVE_SIGNED);\n+            size &= 0x3FFFFF; // Enough for size up to 4M.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "c75b22e51cb0e5bdaf1eddd1d66d5a4bccaf8017",
      "original_commit_id": "e5ba6ece9b2ae3f46625825cfabcf348c229f935",
      "in_reply_to_id": 1640177227,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done with a `static_assert`.",
      "created_at": "2024-06-27T21:58:11Z",
      "updated_at": "2024-06-27T21:58:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30126#discussion_r1657857760",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657857760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    }
  ]
}