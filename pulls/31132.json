{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132",
    "id": 2138649533,
    "node_id": "PR_kwDOABII585_eTO9",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/31132",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/31132.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/31132.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/e9e23b59f8eedb8dfae75aa660328299fba92b50",
    "number": 31132,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "validation: fetch block inputs on parallel threads ~17% faster IBD",
    "user": {
      "login": "andrewtoth",
      "id": 237213,
      "node_id": "MDQ6VXNlcjIzNzIxMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/andrewtoth",
      "html_url": "https://github.com/andrewtoth",
      "followers_url": "https://api.github.com/users/andrewtoth/followers",
      "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
      "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
      "repos_url": "https://api.github.com/users/andrewtoth/repos",
      "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "When fetching inputs in ConnectBlock, each input is fetched from the cache in series. A cache miss means a round trip to the disk db to fetch the outpoint and insert it into the cache. Since the db is locked from being written during ConnectTip, we can fetch all block inputs missing from the cache on parallel threads before entering ConnectBlock. Using this strategy resulted in a ~17% faster IBD (or master was ~21% slower).\r\n\r\nDoing IBD with 16 vcores from a local peer with default settings, stopping at height 850k:\r\n\r\n|  | Mean [s] | Min [s] | Max [s] | Relative |\r\n|:---|---:|---:|---:|---:|\r\n| branch | 22187.488 ± 50.159 | 22152.021 | 22222.956 | 1.00 |\r\n| master | 26865.884 ± 33.498 | 26842.197 | 26889.570 | 1.21 |\r\n\r\n\r\nThis approach is heavily inspired by `CCheckQueue`, but we could not easily reuse it since it only checks for validity and doesn't allow us to store results in a queue. So, this PR creates a new `InputFetcher` that loops through all inputs of a block on the main thread and adds their outpoints to a queue to be fetched in parallel. Worker threads pull outpoints from the queue and fetch them from the db, and then push the results back onto another queue. Once the main thread has finished looping through the block inputs, it pulls results from the result queue and inserts them into the cache.\r\n\r\nThis PR uses number of cores to create the worker threads, but since the work on the threads is IO bound, it might benefit from using a multiple of the number of cores. However, that would result in more memory usage and lock contention, so the optimal number is still unknown.",
    "labels": [
      {
        "id": 118379652,
        "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
        "name": "Validation",
        "color": "6060aa",
        "default": false
      }
    ],
    "created_at": "2024-10-22T14:40:28Z",
    "updated_at": "2024-10-23T13:58:56Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "8a8e9a4e35520210750419a4005e343e2be683dc",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "andrewtoth:threaded-inputs",
      "ref": "threaded-inputs",
      "sha": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 156145027,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNTYxNDUwMjc=",
        "name": "bitcoin",
        "full_name": "andrewtoth/bitcoin",
        "owner": {
          "login": "andrewtoth",
          "id": 237213,
          "node_id": "MDQ6VXNlcjIzNzIxMw==",
          "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/andrewtoth",
          "html_url": "https://github.com/andrewtoth",
          "followers_url": "https://api.github.com/users/andrewtoth/followers",
          "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
          "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
          "repos_url": "https://api.github.com/users/andrewtoth/repos",
          "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/andrewtoth/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/andrewtoth/bitcoin",
        "archive_url": "https://api.github.com/repos/andrewtoth/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/andrewtoth/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/andrewtoth/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/andrewtoth/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/andrewtoth/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/andrewtoth/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/andrewtoth/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/andrewtoth/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/andrewtoth/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/andrewtoth/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/andrewtoth/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/andrewtoth/bitcoin/events",
        "forks_url": "https://api.github.com/repos/andrewtoth/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/andrewtoth/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/andrewtoth/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/andrewtoth/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/andrewtoth/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/andrewtoth/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/andrewtoth/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/andrewtoth/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/andrewtoth/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/andrewtoth/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/andrewtoth/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/andrewtoth/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/andrewtoth/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:andrewtoth/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/andrewtoth/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/andrewtoth/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/andrewtoth/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/andrewtoth/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/andrewtoth/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/andrewtoth/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/andrewtoth/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/andrewtoth/bitcoin/hooks",
        "svn_url": "https://github.com/andrewtoth/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 264173,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-10-22T18:46:50Z",
        "created_at": "2018-11-05T01:43:59Z",
        "updated_at": "2022-12-23T04:16:30Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "ffe4261cb0669b1e1a926638e0498ae5b63f3599",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36266,
        "stargazers_count": 78991,
        "watchers_count": 78991,
        "size": 270025,
        "default_branch": "master",
        "open_issues_count": 651,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-10-22T14:52:58Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-10-23T13:43:29Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 249,
    "deletions": 3,
    "changed_files": 5,
    "commits": 2,
    "review_comments": 19,
    "comments": 3
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGYyNzhjYTRlYzNmMGE5MGMyODVlNjQwZjFhMjcwODY5Y2E1OTRkMjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f278ca4ec3f0a90c285e640f1a270869ca594d20",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f278ca4ec3f0a90c285e640f1a270869ca594d20",
      "tree": {
        "sha": "efe21634da0ababaf6c0a0f6ed4991a4b840de20",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/efe21634da0ababaf6c0a0f6ed4991a4b840de20"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree efe21634da0ababaf6c0a0f6ed4991a4b840de20\nparent e8f72aefd20049eac81b150e7f0d33709acd18ed\nauthor Andrew Toth <andrewstoth@gmail.com> 1729599354 -0400\ncommitter Andrew Toth <andrewstoth@gmail.com> 1729599354 -0400\n\ncoins: allow emplacing non-dirty coins internally\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEISytpz6vNK/yCogaYAB6/Ik4sBgFAmcXl5QACgkQYAB6/Ik4\nsBin2Q/+OFTpD2Kn2jmOhstntXHw/I1QyjqlHm5+IqfmsqXy1CUD/DKneiadYxE4\naGaitG8ijFkz56Mk1iL2cUX5nQKV56MvKaXhJ0GcjBn9pv/xbsGUjkYr7komcbTD\nIkxvEIqjFrvRle7Aym4q1E1obJwkjafZuSW6vJI9LqFujcnwwpZqh9SEUJs6AUH4\nGQaDiQx8NHnovXHMgFIroYUfzgbNtlzSum/ymsJWkMdikH+ABGX0OZmGLyn1lJYF\n5dYEXk9f5YbtpdDku4XRomup2cHpA5F0rTAu/OGzZbHFSY4FFJ02gOZSRwWwTILO\nOTFfAPoy05r54zkKdIHCFh6Kz12giLjyaocM8PK0nwp7H8sTF5RDPCbrLEDsKzVG\n5hyN2hZp89btl66fFTOYVrWFGZfmqXpNjytqPA9ttSzZnLG8KlnKOw+K56x3LVY9\naZhgFzFcVIAigMY56W5J9L5CWRR0XnVsw8BCqThABsBK7MZBouO2jgXhyTy7dww3\ngPbmjXh2S2+YyiISU5a9UJA+KgITEcQME5OeD90tIHfp2SPFuRrMQFY6c1U9ju5/\noXKPJahw1VKlOYjD7TRZQzH5WXeJj0bf8/IVSyB/9gv/cVn2I3xCj0BU1U1oR594\nc+004iGBAASZcn6DxHihZLKNDQ4yhOMhTlch2OBbDh9/W3QLWhA=\n=Zxad\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e8f72aefd20049eac81b150e7f0d33709acd18ed",
          "sha": "e8f72aefd20049eac81b150e7f0d33709acd18ed",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e8f72aefd20049eac81b150e7f0d33709acd18ed"
        }
      ],
      "message": "coins: allow emplacing non-dirty coins internally",
      "committer": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2024-10-22T12:15:54Z"
      },
      "author": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2024-10-22T12:15:54Z"
      },
      "sha": "f278ca4ec3f0a90c285e640f1a270869ca594d20"
    },
    {
      "event": "commented",
      "id": 2429478185,
      "node_id": "IC_kwDOABII586QzuUp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2429478185",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:40:31Z",
      "updated_at": "2024-10-23T12:44:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/31132).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [l0rinc](https://github.com/bitcoin/bitcoin/pull/31132#pullrequestreview-2388117544) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30906](https://github.com/bitcoin/bitcoin/pull/30906) (refactor: prohibit direct flags access in CCoinsCacheEntry and remove invalid tests by l0rinc)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#issuecomment-2429478185",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132"
    },
    {
      "event": "labeled",
      "id": 14786916578,
      "node_id": "LE_lADOABII586bT0I_zwAAAANxXnDi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14786916578",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:40:34Z",
      "label": {
        "name": "Validation",
        "color": "6060aa"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14787017217,
      "node_id": "HRFPE_lADOABII586bT0I_zwAAAANxX_oB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14787017217",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:45:41Z"
    },
    {
      "event": "commented",
      "id": 2429491813,
      "node_id": "IC_kwDOABII586Qzxpl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2429491813",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:45:47Z",
      "updated_at": "2024-10-22T14:45:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/31894441286</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#issuecomment-2429491813",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132"
    },
    {
      "event": "labeled",
      "id": 14787019013,
      "node_id": "LE_lADOABII586bT0I_zwAAAANxYAEF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14787019013",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:45:47Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "renamed",
      "id": 14787094471,
      "node_id": "RTE_lADOABII586bT0I_zwAAAANxYSfH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14787094471",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:49:35Z",
      "rename": {
        "from": "validation: fetch block inputs parallel threads ~17% faster IBD",
        "to": "validation: fetch block inputs on parallel threads ~17% faster IBD"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14787303983,
      "node_id": "HRFPE_lADOABII586bT0I_zwAAAANxZFov",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14787303983",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:59:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14788613835,
      "node_id": "HRFPE_lADOABII586bT0I_zwAAAANxeFbL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14788613835",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T16:12:52Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU5ZTIzYjU5ZjhlZWRiOGRmYWU3NWFhNjYwMzI4Mjk5ZmJhOTJiNTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "tree": {
        "sha": "9c0e5f877d540608e5f947b3b4417c693602aff8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9c0e5f877d540608e5f947b3b4417c693602aff8"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 9c0e5f877d540608e5f947b3b4417c693602aff8\nparent f278ca4ec3f0a90c285e640f1a270869ca594d20\nauthor Andrew Toth <andrewstoth@gmail.com> 1729603682 -0400\ncommitter Andrew Toth <andrewstoth@gmail.com> 1729622804 -0400\n\nvalidation: fetch block inputs in parallel\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEISytpz6vNK/yCogaYAB6/Ik4sBgFAmcX8xcACgkQYAB6/Ik4\nsBjEpw//fq48pS0TF2DakVPoGVmO1rCXwxpDSvu1GcotKm66QaYEt/TrfXausF+f\npIjEpN2LH33xBYPnNjzLmbXdmN7HBQaGE+t2JdtQ+RyFsOtiibx89/TsQbUwKI6S\neOE8VoAIhygLLsE1WxIY6xAs+MQQ4i+IU6LWcGOaxhQFaRaTKmLpMOrGZxTiajAB\nqroFVAxQE1P7d+5PmZSceIuNWrqxcJkYzHeoAb+jDD2sb3iH2Ua0ibpMyklx08Z8\nBQeNgz0UhPJQlR+K9+SE7wUo7/aeU2EhHiErDp2EWI7X0bBngjr8sIn6K+MrL2R6\n1qcH6rjSYRfTswZxLXbdh6df7S0lCV95Nr6Vxs/+Wgncrs/JjR0NgcbQvOIJJOJG\nH24c7nV9MeHRn8KeaM10HLxw7joPAW/LLOvLrsBTEU8arc5waCBJFl+3m6olaWkR\nmHyCgyOQxIiy/1syeipBtCVSuM9yC5eOyaRTXRT/n358MRBFXxhSiRRBKbGZX/Ut\n3Bp5qSvguCww0eNR5W4m3HBEvc3GBwlW3WTrPHQtnVbO5fdbpPzavrxgJTvCp3ua\nXhAj14p1pdtrNDPTYHvanP+vmi/EIuY3e6D5QiykdG98NhFI6Wcdc2Pr9HSdOWyd\nrlbXVb9jWKzs29kiG3ZypZo6mK8uFc3IOmW62WEJNfFhza887Qw=\n=+IUJ\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f278ca4ec3f0a90c285e640f1a270869ca594d20",
          "sha": "f278ca4ec3f0a90c285e640f1a270869ca594d20",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f278ca4ec3f0a90c285e640f1a270869ca594d20"
        }
      ],
      "message": "validation: fetch block inputs in parallel",
      "committer": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2024-10-22T18:46:44Z"
      },
      "author": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2024-10-22T13:28:02Z"
      },
      "sha": "e9e23b59f8eedb8dfae75aa660328299fba92b50"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14790893735,
      "node_id": "HRFPE_lADOABII586bT0I_zwAAAANxmyCn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14790893735",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T18:46:51Z"
    },
    {
      "event": "unlabeled",
      "id": 14792905981,
      "node_id": "UNLE_lADOABII586bT0I_zwAAAANxudT9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14792905981",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T21:09:47Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2431934694,
      "node_id": "IC_kwDOABII586Q9GDm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2431934694",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-23T12:16:54Z",
      "updated_at": "2024-10-23T12:16:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "I will wait for some conceptual support before writing tests for `InputFetcher`.",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#issuecomment-2431934694",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132"
    },
    {
      "event": "reviewed",
      "id": 2388117544,
      "node_id": "PRR_kwDOABII586OV8go",
      "url": null,
      "actor": null,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nI'm still missing tests and benchmarks here and I think we need to find better default values for SSD and HDD parallelism, and I'd be interested in how coroutines would perform here instead of trying to find the best batching size manually.",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#pullrequestreview-2388117544",
      "submitted_at": "2024-10-23T12:44:26Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812440117",
      "pull_request_review_id": 2388117544,
      "id": 1812440117,
      "node_id": "PRRC_kwDOABII585sB6Q1",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));",
      "path": "src/inputfetcher.h",
      "position": 151,
      "original_position": 151,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Q: Is this a leftover a hack for non-owning LevelDB threads, or is this really the best way to name threads in a cross-platform way?",
      "created_at": "2024-10-23T10:26:47Z",
      "updated_at": "2024-10-23T13:27:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812440117",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812440117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812531761",
      "pull_request_review_id": 2388117544,
      "id": 1812531761,
      "node_id": "PRRC_kwDOABII585sCQox",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 189,
      "original_position": 189,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We're mostly creating the buckets randomly here, so each thread will need access to basically all of the keys.\r\nSince we have an idea of how LevelDB works here (i.e. Sorted String Table), we could likely improve cache locality (would likely be most beneficial on HDDs) and minimize lock contention by splitting the reads by sorted transactions instead.",
      "created_at": "2024-10-23T11:29:06Z",
      "updated_at": "2024-10-23T12:44:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812531761",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812531761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 189,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812534028",
      "pull_request_review_id": 2388117544,
      "id": 1812534028,
      "node_id": "PRRC_kwDOABII585sCRMM",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);",
      "path": "src/inputfetcher.h",
      "position": 73,
      "original_position": 73,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm wondering if we really need to (b)lock here or whether we could we create a [read-only snapshot](https://github.com/google/leveldb/blob/main/doc/index.md#snapshots) instead and avoid stalling?",
      "created_at": "2024-10-23T11:30:32Z",
      "updated_at": "2024-10-23T12:44:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812534028",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812534028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 73,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812548418",
      "pull_request_review_id": 2388117544,
      "id": 1812548418,
      "node_id": "PRRC_kwDOABII585sCUtC",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher",
      "path": "src/inputfetcher.h",
      "position": 29,
      "original_position": 29,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I know it's not trivial request, but can we add a test for this class which fetches everything in parallel and sequentially and assert that the result is equivalent?\r\nAnd preferably also a benchmark, like we have it for https://github.com/bitcoin/bitcoin/blob/master/src/bench/checkqueue.cpp.\r\nI would gladly help here, if needed.",
      "created_at": "2024-10-23T11:39:06Z",
      "updated_at": "2024-10-23T12:44:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812548418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812548418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 29,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812560601",
      "pull_request_review_id": 2388117544,
      "id": 1812560601,
      "node_id": "PRRC_kwDOABII585sCXrZ",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept",
      "path": "src/inputfetcher.h",
      "position": 145,
      "original_position": 145,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For consistency (see: `explicit CCheckQueue(unsigned int batch_size, int worker_threads_num)`) and simplicity (`m_input_fetcher{/*batch_size=*/128, static_cast<size_t>(options.worker_threads_num)}`, and to follow modern C++ directions where sizes seem to be preferred as signed values, see: https://github.com/bitcoin/bitcoin/pull/30927#discussion_r1766881296), please consider making these int(s) instead.",
      "created_at": "2024-10-23T11:46:37Z",
      "updated_at": "2024-10-23T12:47:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812560601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812560601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812599960",
      "pull_request_review_id": 2388117544,
      "id": 1812599960,
      "node_id": "PRRC_kwDOABII585sChSY",
      "diff_hunk": "@@ -6243,6 +6248,7 @@ static ChainstateManager::Options&& Flatten(ChainstateManager::Options&& opts)\n \n ChainstateManager::ChainstateManager(const util::SignalInterrupt& interrupt, Options options, node::BlockManager::Options blockman_options)\n     : m_script_check_queue{/*batch_size=*/128, options.worker_threads_num},\n+      m_input_fetcher{/*batch_size=*/128, static_cast<size_t>(options.worker_threads_num)},",
      "path": "src/validation.cpp",
      "position": 16,
      "original_position": 16,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Unlike the script checks, these fetches aren't CPU bound, there is no reason to provide the number of CPUs as the number of parallels threads.\r\nI don't know if we care about HDD performance here or not, but we can likely find a multiplier that makes this better for both SSD and HDD.\r\n\r\nQuoting from https://pkolaczk.github.io/disk-parallelism:\r\n> It was surprising to me that even 64 threads, which are far more than the number of CPU cores (4 physical, 8 virtual), still improved the performance. I guess that with requests of such a small size to such a fast storage, you need to submit really many of them to keep the SSD busy.\r\n\r\nIf we can provide a benchmark for this usecase we can likely find an optimal multiplier here - I won't nack but this part is very important for me.",
      "created_at": "2024-10-23T12:07:45Z",
      "updated_at": "2024-10-23T12:44:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812599960",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812599960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 6251,
      "original_line": 6251,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812604307",
      "pull_request_review_id": 2388117544,
      "id": 1812604307,
      "node_id": "PRRC_kwDOABII585sCiWT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {",
      "path": "src/inputfetcher.h",
      "position": 188,
      "original_position": 188,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would it be possible to create the batch sizes dynamically?\r\nSince the number of missing values differs for every block (and every dbcache size), it may not make more sense to calculate the optimal split instead of using the random value of 128.\r\nCoroutines might alleviate this problem.",
      "created_at": "2024-10-23T12:10:35Z",
      "updated_at": "2024-10-23T13:37:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812604307",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812604307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 188,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812606720",
      "pull_request_review_id": 2388117544,
      "id": 1812606720,
      "node_id": "PRRC_kwDOABII585sCi8A",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));\n+                    buffer.clear();\n+                    buffer.reserve(m_batch_size);\n+                }\n+            }\n+            txids.insert(tx->GetHash());\n+        }\n+\n+        Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 197,
      "original_position": 197,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we always have leftovers or will this process the last batch twice (or process an empty one) if the batch happens to be divisible by batch_size?",
      "created_at": "2024-10-23T12:11:58Z",
      "updated_at": "2024-10-23T13:37:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812606720",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812606720"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 197,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812659221",
      "pull_request_review_id": 2388117544,
      "id": 1812659221,
      "node_id": "PRRC_kwDOABII585sCvwV",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We're basically mimicking RocksDB's `MultiGet` here - but prewarming the cache instead in separate get requests, since we can't really access LevelDB's internals.\r\n\r\nSince splitting into buckets isn't trivial and since `MultiGet` seems to rely on C++20 [coroutines](https://en.cppreference.com/w/cpp/language/coroutines) (which wasn't available in 2012 when `CCheckQueue` was written), I'm wondering how much simpler this fetching would be if we had lightweight suspendible threads instead: https://rocksdb.org/blog/2022/10/07/asynchronous-io-in-rocksdb.html#multiget",
      "created_at": "2024-10-23T12:35:29Z",
      "updated_at": "2024-10-23T13:37:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812659221",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812659221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812779405",
      "pull_request_review_id": 2388734949,
      "id": 1812779405,
      "node_id": "PRRC_kwDOABII585sDNGN",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);",
      "path": "src/inputfetcher.h",
      "position": 73,
      "original_position": 73,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812534028,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is blocking so we can access the queue of shared outpoints that we need to fetch from. It is not blocking for LevelDB, we access the db once we are out of the critical section.",
      "created_at": "2024-10-23T13:34:07Z",
      "updated_at": "2024-10-23T13:34:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812779405",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812779405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 73,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812781136",
      "pull_request_review_id": 2388740849,
      "id": 1812781136,
      "node_id": "PRRC_kwDOABII585sDNhQ",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher",
      "path": "src/inputfetcher.h",
      "position": 29,
      "original_position": 29,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812548418,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, I can add these but I am waiting for some more conceptual support.",
      "created_at": "2024-10-23T13:35:04Z",
      "updated_at": "2024-10-23T13:35:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812781136",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812781136"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 29,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812785573",
      "pull_request_review_id": 2388754731,
      "id": 1812785573,
      "node_id": "PRRC_kwDOABII585sDOml",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));\n+                    buffer.clear();\n+                    buffer.reserve(m_batch_size);\n+                }\n+            }\n+            txids.insert(tx->GetHash());\n+        }\n+\n+        Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 197,
      "original_position": 197,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812606720,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It won't process twice, but it could pass in an empty vector, which is ignored if you look at `Add` implementation.",
      "created_at": "2024-10-23T13:37:19Z",
      "updated_at": "2024-10-23T13:37:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812785573",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812785573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 197,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812794214",
      "pull_request_review_id": 2388768186,
      "id": 1812794214,
      "node_id": "PRRC_kwDOABII585sDQtm",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812659221,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it would be similar in complexity, we would still need all the locking mechanisms to prevent multithreaded access.\r\n\r\nWhat would really be great is if we had a similar construction to Rust's `std::sync::mpsc`.",
      "created_at": "2024-10-23T13:40:49Z",
      "updated_at": "2024-10-23T13:40:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812794214",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812794214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812797796",
      "pull_request_review_id": 2388773991,
      "id": 1812797796,
      "node_id": "PRRC_kwDOABII585sDRlk",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {",
      "path": "src/inputfetcher.h",
      "position": 188,
      "original_position": 188,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812604307,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure it would warrant the complexity I think this batch size is \"good enough\" for now. In a follow up we could maybe add ways to set this with configs to experiment if there really is more optimal settings.",
      "created_at": "2024-10-23T13:42:02Z",
      "updated_at": "2024-10-23T13:42:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812797796",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812797796"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 188,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812800076",
      "pull_request_review_id": 2388778745,
      "id": 1812800076,
      "node_id": "PRRC_kwDOABII585sDSJM",
      "diff_hunk": "@@ -6243,6 +6248,7 @@ static ChainstateManager::Options&& Flatten(ChainstateManager::Options&& opts)\n \n ChainstateManager::ChainstateManager(const util::SignalInterrupt& interrupt, Options options, node::BlockManager::Options blockman_options)\n     : m_script_check_queue{/*batch_size=*/128, options.worker_threads_num},\n+      m_input_fetcher{/*batch_size=*/128, static_cast<size_t>(options.worker_threads_num)},",
      "path": "src/validation.cpp",
      "position": 16,
      "original_position": 16,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812599960,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Adding more threads will require more memory, which is one reason to not use many more.\r\n\r\nI did a benchmark using 64 threads on the same 16 vcore machine, and it was slightly slower :/",
      "created_at": "2024-10-23T13:43:08Z",
      "updated_at": "2024-10-23T13:43:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812800076",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812800076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 6251,
      "original_line": 6251,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812807883",
      "pull_request_review_id": 2388792724,
      "id": 1812807883,
      "node_id": "PRRC_kwDOABII585sDUDL",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 189,
      "original_position": 189,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812531761,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think there is any lock contention here if we are doing multithreaded reading?\r\n\r\nI also think what you're suggesting would add a lot more complexity to this PR, when this is \"good enough\".",
      "created_at": "2024-10-23T13:46:50Z",
      "updated_at": "2024-10-23T13:46:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812807883",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812807883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 189,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812815888",
      "pull_request_review_id": 2388804635,
      "id": 1812815888,
      "node_id": "PRRC_kwDOABII585sDWAQ",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));",
      "path": "src/inputfetcher.h",
      "position": 151,
      "original_position": 151,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812440117,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Unsure, copied from `CScriptCheck`. If the state of the art of thread naming has advanced since that was written, please let me know!",
      "created_at": "2024-10-23T13:49:23Z",
      "updated_at": "2024-10-23T13:49:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812815888",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812815888"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812826580",
      "pull_request_review_id": 2388824311,
      "id": 1812826580,
      "node_id": "PRRC_kwDOABII585sDYnU",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));",
      "path": "src/inputfetcher.h",
      "position": 151,
      "original_position": 151,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812440117,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The C++ standard library does as far as I know have no way of renaming threads at all. `src/util/threadnames.{h,cpp}` is our wrapper around the various platform-dependent ways of doing so on supported systems.",
      "created_at": "2024-10-23T13:54:03Z",
      "updated_at": "2024-10-23T13:54:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812826580",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812826580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812838378",
      "pull_request_review_id": 2388842458,
      "id": 1812838378,
      "node_id": "PRRC_kwDOABII585sDbfq",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812659221,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you tell me why we need to prevent multithreaded access exactly? We could collect the values to different vectors, each one accessed only by a single thread and merge them into the cache at the end on a single thread, right?\r\n \r\n How would `mpsc` solve this better? Do you think we need work stealing to make it perfectly parallel? Wouldn't coroutines already achieve the same?",
      "created_at": "2024-10-23T13:58:56Z",
      "updated_at": "2024-10-23T13:58:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812838378",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812838378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    }
  ]
}