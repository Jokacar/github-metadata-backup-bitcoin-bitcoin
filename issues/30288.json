{
  "type": "issue",
  "issue": {
    "id": 2353360477,
    "node_id": "I_kwDOABII586MRW5d",
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288",
    "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
    "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288/labels%7B/name%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288/comments",
    "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288/events",
    "html_url": "https://github.com/bitcoin/bitcoin/issues/30288",
    "number": 30288,
    "state": "open",
    "state_reason": null,
    "title": "RFC: Assumeutxo and large forks and reorgs",
    "body": "(tl;dr This is mainly a question about when an assumeutxo snapshot is loaded, if it makes more sense for the original chainstate to continue downloading and attaching blocks in the normal way, or if it should only download and attach blocks leading up to the snapshot block.)\r\n\r\n---\r\n\r\nIt seems unclear how validation code should behave when an assumeutxo snapshot is loaded, and then new headers are received pointing to a forked chain with more proof of work than any known chain including the snapshot block. This question come up in https://github.com/bitcoin/bitcoin/pull/29519#discussion_r1628436308.\r\n\r\nThis is not an urgent question, because if this situation arose on the network there would be bigger issues to confront than assumeutxo behavior, but it's worth raising because there seem to be different ways of dealing with it that impact that design of validation code, and maybe also have implications in other cases like eclipse attacks.\r\n\r\n### Background\r\n\r\nWhen an assumeutxo snapshot is loaded, a new chainstate object is created. A chainstate is just a UTXO database and a pointer to the last block added to the database.\r\n\r\nSo immediately after the assumeutxo snapshot is loaded there are two chainstates:\r\n\r\n- The original chainstate pointing at the most-work block which has been locally validated. (This block should normally be an ancestor of the snapshot block, but doesn't have to be.)\r\n\r\n- A new snapshot chainstate pointing at the snapshot block, which has been not been locally validated and probably not downloaded, but is assumed-valid.\r\n\r\nAfter this point, because of missing block and undo data before the snapshot, the snapshot chainstate is constrained to only sync to chains including the snapshot block. If headers for chains with more work not including the snapshot block are found, the snapshot chainstate needs to ignore them, because even if it downloaded blocks on those chains, it would lack the undo data needed to reorg and actually validate them.\r\n\r\nIt is less clear whether the original chainstate should also ignore chains not including the snapshot block.\r\n\r\n### Possible behavior: Original chainstate targets the most-work chain\r\n\r\nThis is not what currently happens, but simplest approach might be for the original chainstate to be unaffected by the snapshot chainstate, and to continue to download and attach the same blocks it otherwise would have if no snapshot were loaded. It would just do it more slowly due to a reduced cache size and lower priority for block requests compared to the snapshot chainstate.\r\n\r\n### Current behavior: Original chainstate targets the snapshot block\r\n\r\nCurrently, instead of the original chainstate being unaffected by the snapshot chainstate, it's constrained to only download and blocks that are ancestors of the snapshot block, and ignore other chains.\r\n\r\n### Tradeoffs\r\n\r\nPossible advantages of original chainstate targeting the most work chain:\r\n\r\n- Probably simpler implemenation. If original chainstate behaves the same way whether or not a snapshot is loaded, fewer special cases need to exist when a snapshot is loaded.\r\n- Would sync to most-work chain faster if most-work chain did not include the snapshot block and turned out to be valid (i.e. not a hard fork)\r\n- Maybe more philosophically neutral, because the node continues normal behavior of syncing to the most-work chain, instead of ignoring any chain not including the snapshot block.\r\n\r\nPossible advantages of original chainstate targeting the snapshot block:\r\n\r\n- This what code currently does so would not require further changes.\r\n- Maybe could provide resilience against hard forks that contain more work? If loading a snapshot makes a node temporarily ignore any chain not containing a snapshot block, maybe that is a useful feature if the chain with more work turns out to be invalid.\r\n- Could help in an eclipse attack? If headers or blocks after the snapshot block were withheld, this could temporarily stop the node from syncing to a undesirable fork excluding the snapshot block that seemed to have more work.\r\n- [Maybe other reasons? Personally I'm more inclined towards the first approach, and have a weak understanding of things like forks and eclipse attacks, so I'm struggling to think of advantages to this approach.]\r\n  \r\n### Questions\r\n\r\nAs long as the most-work header chain includes the snapshot block, there should be no real differences in behavior between the two approaches described above. But if the most-work header chain doesn't include the snapshot block, it raises questions about which approach might be preferable. It also raises questions about what other behaviors we should consider implementing if this state is detected, like warning the user, shutting down, changing sync behavior, maybe adjusting relative priorities of the two chainstates. The main question is if we should be doing anything different than we are doing now.",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [],
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "locked": false,
    "comments": 1,
    "created_at": "2024-06-14T13:14:57Z",
    "updated_at": "2024-06-14T17:10:26Z"
  },
  "events": [
    {
      "event": "commented",
      "id": 2168444052,
      "node_id": "IC_kwDOABII586BP9SU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2168444052",
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T17:10:25Z",
      "updated_at": "2024-06-14T17:10:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "> This is not what currently happens, but simplest approach might be for the original chainstate to be unaffected by the snapshot chainstate, and to continue to download and attach the same blocks it otherwise would have if no snapshot were loaded. It would just do it more slowly due to a reduced cache size and lower priority for block requests compared to the snapshot chainstate.\r\n\r\nI think that the concept of the Active Chainstate / Active Tip is important for this this discussion. Currently, it is tied to the snapshot chainstate until the background sync has finished.\r\nIf we keep that logic, having the background chainstate target the most-work block doesn't really achieve anything - if that chain turns out to be valid, we would still never use it for anything meaningful because the snapshot chainstate will remain the active one.\r\nSo in order for targeting the most-work chain to make any sense, we'd also need to introduce the possibility of switching the active chainstate to it without the requirement that the background sync has to finish. Which would lead to other questions: I we don't prioritize syncing the background chainstate towards it anymore, should we keep the now-unused snapshot chainstate around indefinitely and just ignore it exists? Should we be able to switch the active chainstate back to the snapshot chain in case we receive more blocks building on top of it, so that it becomes the most-work chain again?\r\n\r\nConsidering that AssumeUtxo sync is meant to be an optional and temporary optimization, and that large reorgs should be very infrequent, it could also make sense to abandon the AssumeUtxo sync, delete the snapshot chainstate and revert to normal sync as soon as we accept a header on a different chain that has more work than the best header of the snapshot chain.\r\n\r\nI think that pragmatically we shouldn't accept a snapshot in the first place if it's not an ancestor of the most-work header `m_best_header` (I plan on opening a PR for that soon), but that doesn't solve the problem completely because we might only learn about another chain after having loaded the snapshot successfully.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/issues/30288#issuecomment-2168444052",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30288"
    }
  ]
}