{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864",
    "id": 550110185,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTUwMTEwMTg1",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/20864",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/20864.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/20864.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/fa210689e27b0d78b2fe894e51e364179db7a3ce",
    "number": 20864,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "net: Move SocketSendData lock annotation to header",
    "user": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Lock annotations must be in the header, otherwise the will have limited or no effect",
    "labels": [
      {
        "id": 135961,
        "node_id": "MDU6TGFiZWwxMzU5NjE=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
        "name": "Refactoring",
        "color": "E6F6D6",
        "default": false
      },
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      }
    ],
    "active_lock_reason": "resolved",
    "created_at": "2021-01-06T07:44:50Z",
    "updated_at": "2022-08-16T17:02:12Z",
    "closed_at": "2021-01-07T13:58:52Z",
    "mergeable_state": "unknown",
    "merged_at": "2021-01-07T13:58:52Z",
    "merge_commit_sha": "42675e783337bf56dfc51df6c14931df5e72f185",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "MarcoFalke:2101-netLock",
      "ref": "2101-netLock",
      "sha": "fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 40046254,
        "node_id": "MDEwOlJlcG9zaXRvcnk0MDA0NjI1NA==",
        "name": "b-c",
        "full_name": "MarcoFalke/b-c",
        "owner": {
          "login": "MarcoFalke",
          "id": 6399679,
          "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
          "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/MarcoFalke",
          "html_url": "https://github.com/MarcoFalke",
          "followers_url": "https://api.github.com/users/MarcoFalke/followers",
          "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
          "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
          "repos_url": "https://api.github.com/users/MarcoFalke/repos",
          "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/MarcoFalke/b-c",
        "fork": true,
        "url": "https://api.github.com/repos/MarcoFalke/b-c",
        "archive_url": "https://api.github.com/repos/MarcoFalke/b-c/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/MarcoFalke/b-c/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/MarcoFalke/b-c/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/MarcoFalke/b-c/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/MarcoFalke/b-c/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/MarcoFalke/b-c/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/MarcoFalke/b-c/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/MarcoFalke/b-c/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/MarcoFalke/b-c/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/MarcoFalke/b-c/contributors",
        "deployments_url": "https://api.github.com/repos/MarcoFalke/b-c/deployments",
        "downloads_url": "https://api.github.com/repos/MarcoFalke/b-c/downloads",
        "events_url": "https://api.github.com/repos/MarcoFalke/b-c/events",
        "forks_url": "https://api.github.com/repos/MarcoFalke/b-c/forks",
        "git_commits_url": "https://api.github.com/repos/MarcoFalke/b-c/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/MarcoFalke/b-c/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/MarcoFalke/b-c/git/tags%7B/sha%7D",
        "git_url": "git://github.com/MarcoFalke/b-c.git",
        "issue_comment_url": "https://api.github.com/repos/MarcoFalke/b-c/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/MarcoFalke/b-c/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/MarcoFalke/b-c/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/MarcoFalke/b-c/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/MarcoFalke/b-c/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/MarcoFalke/b-c/languages",
        "merges_url": "https://api.github.com/repos/MarcoFalke/b-c/merges",
        "milestones_url": "https://api.github.com/repos/MarcoFalke/b-c/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/MarcoFalke/b-c/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/MarcoFalke/b-c/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/MarcoFalke/b-c/releases%7B/id%7D",
        "ssh_url": "git@github.com:MarcoFalke/b-c.git",
        "stargazers_url": "https://api.github.com/repos/MarcoFalke/b-c/stargazers",
        "statuses_url": "https://api.github.com/repos/MarcoFalke/b-c/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/MarcoFalke/b-c/subscribers",
        "subscription_url": "https://api.github.com/repos/MarcoFalke/b-c/subscription",
        "tags_url": "https://api.github.com/repos/MarcoFalke/b-c/tags",
        "teams_url": "https://api.github.com/repos/MarcoFalke/b-c/teams",
        "trees_url": "https://api.github.com/repos/MarcoFalke/b-c/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/MarcoFalke/b-c.git",
        "hooks_url": "https://api.github.com/repos/MarcoFalke/b-c/hooks",
        "svn_url": "https://github.com/MarcoFalke/b-c",
        "homepage": "",
        "language": "C++",
        "forks_count": 12,
        "stargazers_count": 25,
        "watchers_count": 25,
        "size": 207848,
        "default_branch": "master",
        "open_issues_count": 25,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-02T15:31:58Z",
        "created_at": "2015-08-01T12:42:47Z",
        "updated_at": "2023-05-28T20:12:34Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "8a720ced5ff2fdd23b6ec7688998ad29e54fac98",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35476,
        "stargazers_count": 70608,
        "watchers_count": 70608,
        "size": 236222,
        "default_branch": "master",
        "open_issues_count": 672,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-02T20:20:41Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-08-02T18:21:18Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 892,
    "deletions": 893,
    "changed_files": 2,
    "commits": 2,
    "review_comments": 2,
    "comments": 6
  },
  "events": [
    {
      "event": "labeled",
      "id": 4173923956,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQxNzM5MjM5NTY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4173923956",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T07:44:56Z",
      "label": {
        "name": "Refactoring",
        "color": "E6F6D6"
      }
    },
    {
      "event": "labeled",
      "id": 4173924397,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQxNzM5MjQzOTc=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4173924397",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T07:45:05Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "commented",
      "id": 755162168,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTE2MjE2OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755162168",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T08:33:46Z",
      "updated_at": "2021-01-06T08:33:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK.\r\n\r\nIf you're moving things around in net.h to add lock annotations, might be worth moving `NetEventsInterface` to after the `CNode` definition, and making it `virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;`.\r\n\r\nMoving `IsPeerAddrLocalGood` and `AdvertiseLocal` later as well would allow removing the `class CNode;` forward declaration entirely.\r\n\r\nIt would be nice if there were some easy way to review pointer-becomes-reference changes.",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755162168",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4174142110,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE3NDE0MjExMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4174142110",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T08:44:28Z"
    },
    {
      "event": "commented",
      "id": 755167546,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTE2NzU0Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755167546",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T08:46:07Z",
      "updated_at": "2021-01-06T08:46:07Z",
      "author_association": "MEMBER",
      "body": "> It would be nice if there were some easy way to review pointer-becomes-reference changes.\r\n\r\nApart from `--word-diff-regex=.`?\r\n\r\n> SendMessages ...\r\n\r\nThanks, done",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755167546",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "commented",
      "id": 755260797,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTI2MDc5Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755260797",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T12:03:19Z",
      "updated_at": "2021-01-07T08:57:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #20811 (refactor: move net_processing implementation details out of header by ajtowns)\n* #20786 (net: [refactor] Prefer integral types in CNodeStats by MarcoFalke)\n* #20729 (p2p: standardize on outbound-{full, block}-relay connection type naming by jonatack)\n* #20724 (Cleanup of -debug=net log messages by ajtowns)\n* #20646 (doc: refer to BIPs 339/155 in feature negotiation by jonatack)\n* #20364 (Follow-ups to 19107 by troygiorshev)\n* #20234 (net: don't extra bind for Tor if binds are restricted by vasild)\n* #20228 (addrman: Make addrman a top-level component by jnewbery)\n* #20196 (net: fix GetListenPort() to derive the proper port by vasild)\n* #19843 (Refactoring and minor improvement for self-advertisements by naumenkogs)\n* #19460 (multiprocess: Add bitcoin-wallet -ipcconnect option by ryanofsky)\n* #19315 ([tests] Allow outbound & block-relay-only connections in functional tests. by amitiuttarwar)\n* #18819 (net: Replace cs_feeFilter with simple std::atomic by MarcoFalke)\n* #18077 (net: Add NAT-PMP port forwarding support by hebasto)\n* #10102 ([experimental] Multiprocess bitcoin by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755260797",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T12:23:57Z",
      "updated_at": "2021-01-06T12:23:57Z",
      "source": {
        "issue": {
          "id": 775448249,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTQ2MTMwNTY5",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20786",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20786/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20786/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20786/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20786",
          "number": 20786,
          "state": "closed",
          "state_reason": null,
          "title": "net: [refactor] Prefer integral types in CNodeStats",
          "body": "Currently, strings are stored for what are actually integral (strong) enum types. This is fine, because the strings are only used as-is for the debug log and RPC. However, it complicates using them in the GUI. User facing strings in the GUI should be translated and only string literals can be picked up for translation, not runtime `std::string`s.\r\n\r\nFix that by removing the `std::string` members and replace them by strong enum integral types.",
          "user": {
            "login": "MarcoFalke",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/MarcoFalke",
            "html_url": "https://github.com/MarcoFalke",
            "followers_url": "https://api.github.com/users/MarcoFalke/followers",
            "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
            "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
            "repos_url": "https://api.github.com/users/MarcoFalke/repos",
            "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 6,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20786",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20786",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20786.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20786.patch"
          },
          "closed_at": "2021-01-08T14:15:56Z",
          "created_at": "2020-12-28T15:15:22Z",
          "updated_at": "2022-08-16T17:02:25Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T12:37:12Z",
      "updated_at": "2021-01-06T12:37:12Z",
      "source": {
        "issue": {
          "id": 771580606,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTQzMDYzMTgy",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20729",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20729/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20729/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20729/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20729",
          "number": 20729,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: standardize outbound full/block relay connection type naming",
          "body": "We've accumulated many different ways of referring to outbound full relay and outbound block relay connection types in the codebase. In places, it is becoming less clear which type of connection is referred to. This PR proposes standardizing the naming to `outbound-{full, block}-relay` with a scripted diff as follows:\r\n\r\n```\r\n-BEGIN VERIFY SCRIPT-\r\ns() { git grep -l \"$1\" src test/functional doc/files.md doc/reduce-*.md | xargs sed -i \"s/$1/$2/g\"; }\r\n\r\ns 'ConnectionType::OUTBOUND '            'ConnectionType::OUTBOUND_FULL_RELAY '\r\ns 'IsFullOutboundConn'                   'IsOutboundFullRelayConn'\r\ns 'GetExtraFullOutboundCount'            'GetExtraOutboundFullRelayCount'\r\ns 'full_outbound_peers'                  'outbound_full_relay_peers'\r\ns 'GetTryNewOutboundPeer'                'GetTryNewOutboundFullRelayPeer'\r\ns 'SetTryNewOutboundPeer'                'SetTryNewOutboundFullRelayPeer'\r\ns 'm_try_another_outbound_peer'          'm_try_another_outbound_full_relay_peer'\r\ns 'outbound (full-relay)'                'outbound-full-relay'\r\ns 'outbound full-relay'                  'outbound-full-relay'\r\ns 'outbound, full-relay'                 'outbound-full-relay'\r\ns 'outbounds'                            'outbound-full-relay connections'\r\ns 'f\"outbound: '                         'f\"outbound-full-relay: '\r\ns ' full-relay'                          ' outbound-full-relay'\r\ns 'to an extra outbound peer'            'to an extra outbound-full-relay peer'\r\ns 'try another outbound peer'            'try another outbound-full-relay peer'\r\ns '(tx, block, addr) outbound'           '(tx, block, addr)'\r\ns 'we deal with extra outbound peers'    'we deal with extra outbound-full-relay peers'\r\ns 'outbound peers we have in excess'     'outbound-full-relay peers we have in excess'\r\ns 'some outbound connections are not'    'some outbound-full-relay connections are not'\r\ns 'or this is a'                         'or if this is an'\r\n\r\ns 'ConnectionType::BLOCK_RELAY'          'ConnectionType::OUTBOUND_BLOCK_RELAY'\r\ns ' BLOCK_RELAY'                         ' OUTBOUND_BLOCK_RELAY'\r\ns 'IsBlockOnlyConn'                      'IsOutboundBlockRelayConn'\r\ns 'GetExtraBlockRelayCount'              'GetExtraOutboundBlockRelayCount'\r\ns 'block_relay_peers'                    'outbound_block_relay_peers'\r\ns 'MAX_BLOCK_RELAY_ONLY_ANCHORS'         'MAX_OUTBOUND_BLOCK_RELAY_ANCHORS'\r\ns 'MAX_BLOCK_RELAY_ONLY_CONNECTIONS'     'MAX_OUTBOUND_BLOCK_RELAY_CONNECTIONS'\r\ns 'EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL' 'EXTRA_OUTBOUND_BLOCK_RELAY_PEER_INTERVAL'\r\ns 'm_start_extra_block_relay_peers'      'm_start_extra_outbound_block_relay_peers'\r\ns 'outgoing block-relay-only'            'outbound-block-relay'\r\ns 'outbound block-relay-only'            'outbound-block-relay'\r\ns 'outbound block-relay'                 'outbound-block-relay'\r\ns 'block-relay only outbound'            'outbound-block-relay'\r\ns 'block-relay-only outgoing'            'outbound-block-relay'\r\ns 'block-relay only peers'               'outbound-block-relay peers'\r\ns 'block-relay-only'                     'outbound-block-relay'\r\n\r\ns ' a outbound'                          ' an outbound'\r\n-END VERIFY SCRIPT-\r\n```\r\n",
          "user": {
            "login": "jonatack",
            "id": 2415484,
            "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonatack",
            "html_url": "https://github.com/jonatack",
            "followers_url": "https://api.github.com/users/jonatack/followers",
            "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
            "organizations_url": "https://api.github.com/users/jonatack/orgs",
            "repos_url": "https://api.github.com/users/jonatack/repos",
            "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonatack/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 749416508,
              "node_id": "MDU6TGFiZWw3NDk0MTY1MDg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Up%20for%20grabs",
              "name": "Up for grabs",
              "color": "99a810",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 15,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20729",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20729",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20729.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20729.patch"
          },
          "closed_at": "2021-05-11T10:12:08Z",
          "created_at": "2020-12-20T12:46:11Z",
          "updated_at": "2022-08-18T18:30:56Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T12:40:37Z",
      "updated_at": "2021-01-06T12:40:37Z",
      "source": {
        "issue": {
          "id": 771433762,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTQyOTYzOTYy",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20724",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20724/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20724/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20724/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20724",
          "number": 20724,
          "state": "closed",
          "state_reason": null,
          "title": "Cleanup of -debug=net log messages",
          "body": "A few changes to -debug=net logging:\r\n\r\n * always log when disconnecting a peer\r\n * only log various connection errors when -debug=net is enabled, since errors from random untrusted peers is completely expected\r\n * log when ignoring a message due to violating protocol (primarily to make it easier to debug other implementations)\r\n * use \"peer=123\" rather than \"from 123\" to make grepping logs a bit easier\r\n * log the value of the bip-37 `fRelay` field in version messages both when sending and receiving a version message",
          "user": {
            "login": "ajtowns",
            "id": 127186,
            "node_id": "MDQ6VXNlcjEyNzE4Ng==",
            "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ajtowns",
            "html_url": "https://github.com/ajtowns",
            "followers_url": "https://api.github.com/users/ajtowns/followers",
            "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
            "organizations_url": "https://api.github.com/users/ajtowns/orgs",
            "repos_url": "https://api.github.com/users/ajtowns/repos",
            "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ajtowns/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 23,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20724",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20724",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20724.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20724.patch"
          },
          "closed_at": "2021-01-29T06:45:02Z",
          "created_at": "2020-12-19T18:49:51Z",
          "updated_at": "2022-08-16T17:12:01Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T12:51:23Z",
      "updated_at": "2021-01-06T12:51:23Z",
      "source": {
        "issue": {
          "id": 765684230,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTM5MDM0Mzkz",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20646",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20646/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20646/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20646/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20646",
          "number": 20646,
          "state": "closed",
          "state_reason": null,
          "title": "doc: refer to BIPs 339/155 in feature negotiation",
          "body": "of `wtxidrelay` and `addrv2`/`sendaddrv2`, and add `fSuccessfullyConnected` doxygen documentation to clarify that it is set to true on VERACK.",
          "user": {
            "login": "jonatack",
            "id": 2415484,
            "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonatack",
            "html_url": "https://github.com/jonatack",
            "followers_url": "https://api.github.com/users/jonatack/followers",
            "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
            "organizations_url": "https://api.github.com/users/jonatack/orgs",
            "repos_url": "https://api.github.com/users/jonatack/repos",
            "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonatack/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 36,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20646",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20646",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20646.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20646.patch"
          },
          "closed_at": "2021-02-05T10:16:05Z",
          "created_at": "2020-12-13T22:37:18Z",
          "updated_at": "2022-08-16T17:03:52Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T13:02:11Z",
      "updated_at": "2021-01-06T13:02:11Z",
      "source": {
        "issue": {
          "id": 758000574,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTMzMjUwOTI4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20584",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20584/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20584/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20584/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20584",
          "number": 20584,
          "state": "closed",
          "state_reason": null,
          "title": "Declare de facto const reference variables/member functions as const",
          "body": "_Meta: This is the second and final part of the `const` refactoring series (part one: #20581). **I promise: no more refactoring PRs from me in a while! :)** I'll now go back to focusing on fuzzing/hardening!_\r\n\r\nChanges in this PR:\r\n* Don't declare de facto const member functions as non-const\r\n* Don't declare de facto const reference variables as non-const\r\n\r\nAwards for finding candidates for the above changes go to:\r\n* `clang-tidy`'s [`readability-make-member-function-const`](https://clang.llvm.org/extra/clang-tidy/checks/readability-make-member-function-const.html)  check ([list of `clang-tidy` checks](https://clang.llvm.org/extra/clang-tidy/checks/list.html))\r\n* `cppcheck`'s `constVariable` check ([list of `cppcheck` checks](https://sourceforge.net/p/cppcheck/wiki/ListOfChecks/))\r\n\r\nSee #18920 for instructions on how to analyse Bitcoin Core using Clang Static Analysis, `clang-tidy` and `cppcheck`.\r\n",
          "user": {
            "login": "practicalswift",
            "id": 7826565,
            "node_id": "MDQ6VXNlcjc4MjY1NjU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/practicalswift",
            "html_url": "https://github.com/practicalswift",
            "followers_url": "https://api.github.com/users/practicalswift/followers",
            "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
            "organizations_url": "https://api.github.com/users/practicalswift/orgs",
            "repos_url": "https://api.github.com/users/practicalswift/repos",
            "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/practicalswift/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 3,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20584",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20584",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20584.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20584.patch"
          },
          "closed_at": "2021-01-07T08:07:28Z",
          "created_at": "2020-12-06T19:18:26Z",
          "updated_at": "2022-08-16T17:19:53Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T13:31:23Z",
      "updated_at": "2021-01-06T13:31:23Z",
      "source": {
        "issue": {
          "id": 740265227,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTE4NzgyODEy",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20364",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20364/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20364/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20364/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20364",
          "number": 20364,
          "state": "closed",
          "state_reason": null,
          "title": "Follow-ups to 19107",
          "body": "This PR contains a few follow-ups to #19107.\r\n\r\nMost notable is a change to GetMessage, where it no longer returns an optional.  Ultimately this was done in a heavy-handed way that didn't improve readability and would probably cause more problems than it would save.",
          "user": {
            "login": "troygiorshev",
            "id": 5553787,
            "node_id": "MDQ6VXNlcjU1NTM3ODc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/5553787?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/troygiorshev",
            "html_url": "https://github.com/troygiorshev",
            "followers_url": "https://api.github.com/users/troygiorshev/followers",
            "following_url": "https://api.github.com/users/troygiorshev/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/troygiorshev/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/troygiorshev/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/troygiorshev/subscriptions",
            "organizations_url": "https://api.github.com/users/troygiorshev/orgs",
            "repos_url": "https://api.github.com/users/troygiorshev/repos",
            "events_url": "https://api.github.com/users/troygiorshev/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/troygiorshev/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 10,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20364",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20364",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20364.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20364.patch"
          },
          "closed_at": "2021-08-18T12:09:12Z",
          "created_at": "2020-11-10T21:46:00Z",
          "updated_at": "2022-08-18T18:33:13Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 562714005,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyNzE0MDA1",
      "url": null,
      "actor": null,
      "commit_id": "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK fad2e1f267d60afe9799e431233f54f02d14e8e0\r\n\r\nNice tidy-up.",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#pullrequestreview-562714005",
      "submitted_at": "2021-01-06T13:43:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T13:43:20Z",
      "updated_at": "2021-01-06T13:43:20Z",
      "source": {
        "issue": {
          "id": 728858805,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTA5NDgyMDYy",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20234",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20234/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20234/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20234/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20234",
          "number": 20234,
          "state": "closed",
          "state_reason": null,
          "title": "net: don't bind on 0.0.0.0 if binds are restricted to Tor",
          "body": "The semantic of `-bind` is to restrict the binding only to some address.\r\nIf not specified, then the user does not care and we bind to `0.0.0.0`.\r\nIf specified then we should honor the restriction and bind only to the \r\nspecified address.\r\n\r\nBefore this change, if no `-bind` is given then we would bind to\r\n`0.0.0.0:8333` and to `127.0.0.1:8334` (incoming Tor) which is ok -\r\nthe user does not care to restrict the binding.\r\n\r\nHowever, if only `-bind=addr:port=onion` is given (without ordinary\r\n`-bind=`) then we would bind to `addr:port` _and_ to `0.0.0.0:8333` in\r\naddition.\r\n\r\nChange the above to not do the additional bind: if only\r\n`-bind=addr:port=onion` is given (without ordinary `-bind=`) then bind\r\nto `addr:port` (only) and consider incoming connections to that as Tor \r\nand do not advertise it. I.e. a Tor-only node.\r\n",
          "user": {
            "login": "vasild",
            "id": 266751,
            "node_id": "MDQ6VXNlcjI2Njc1MQ==",
            "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vasild",
            "html_url": "https://github.com/vasild",
            "followers_url": "https://api.github.com/users/vasild/followers",
            "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
            "organizations_url": "https://api.github.com/users/vasild/orgs",
            "repos_url": "https://api.github.com/users/vasild/repos",
            "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/vasild/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/47",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47/labels",
            "id": 5347322,
            "node_id": "MDk6TWlsZXN0b25lNTM0NzMyMg==",
            "number": 47,
            "state": "closed",
            "title": "22.0",
            "description": "",
            "creator": {
              "login": "MarcoFalke",
              "id": 6399679,
              "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
              "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/MarcoFalke",
              "html_url": "https://github.com/MarcoFalke",
              "followers_url": "https://api.github.com/users/MarcoFalke/followers",
              "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
              "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
              "repos_url": "https://api.github.com/users/MarcoFalke/repos",
              "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 124,
            "created_at": "2020-04-25T00:14:49Z",
            "updated_at": "2021-09-14T07:16:53Z",
            "closed_at": "2021-09-09T12:47:52Z"
          },
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 37,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20234",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20234",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20234.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20234.patch"
          },
          "closed_at": "2021-07-12T08:08:38Z",
          "created_at": "2020-10-24T19:25:46Z",
          "updated_at": "2022-08-16T17:25:17Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T13:44:26Z",
      "updated_at": "2021-01-06T13:44:26Z",
      "source": {
        "issue": {
          "id": 728073037,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTA4ODQ3MjQ1",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20228",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20228/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20228/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20228/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20228",
          "number": 20228,
          "state": "closed",
          "state_reason": null,
          "title": "addrman: Make addrman a top-level component",
          "body": "Addrman is currently a member variable of connman. Make it a top-level component with lifetime owned by node.context, and add a reference to addrman in peerman. This allows us to eliminate some functions in connman that are simply forwarding requests to addrman, and simplifies the connman-peerman interface.\r\n\r\nBy constructing the addrman in init, we can also add parameters to the ctor, which allows us to test it better. See #20233, where we enable consistency checking for addrman in our functional tests.",
          "user": {
            "login": "jnewbery",
            "id": 1063656,
            "node_id": "MDQ6VXNlcjEwNjM2NTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jnewbery",
            "html_url": "https://github.com/jnewbery",
            "followers_url": "https://api.github.com/users/jnewbery/followers",
            "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
            "organizations_url": "https://api.github.com/users/jnewbery/orgs",
            "repos_url": "https://api.github.com/users/jnewbery/repos",
            "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jnewbery/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 33,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20228",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20228",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20228.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20228.patch"
          },
          "closed_at": "2021-03-30T10:30:22Z",
          "created_at": "2020-10-23T09:43:07Z",
          "updated_at": "2022-08-16T17:07:06Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T13:50:56Z",
      "updated_at": "2021-01-06T13:50:56Z",
      "source": {
        "issue": {
          "id": 725419229,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTA2NjU0NTY1",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20196",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20196/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20196/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20196/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20196",
          "number": 20196,
          "state": "closed",
          "state_reason": null,
          "title": "net: fix GetListenPort() to derive the proper port",
          "body": "`GetListenPort()` uses a simple logic: \"if `-port=P` is given, then we\r\nmust be listening on `P`, otherwise we must be listening on `8333`\".\r\nThis is however not true if `-bind=` has been provided with `:port` part\r\nor if `-whitebind=` has been provided. Thus, extend `GetListenPort()` to\r\nreturn the port from `-bind=` or `-whitebind=`, if any.\r\n\r\nAlso, if `-bind=` is provided then we would bind only to a particular address\r\nand should not add all the other addresses of the machine to the list of\r\nlocal addresses.\r\n\r\nFixes https://github.com/bitcoin/bitcoin/issues/20184\r\n",
          "user": {
            "login": "vasild",
            "id": 266751,
            "node_id": "MDQ6VXNlcjI2Njc1MQ==",
            "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vasild",
            "html_url": "https://github.com/vasild",
            "followers_url": "https://api.github.com/users/vasild/followers",
            "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
            "organizations_url": "https://api.github.com/users/vasild/orgs",
            "repos_url": "https://api.github.com/users/vasild/repos",
            "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/vasild/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/52",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/52",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/52/labels",
            "id": 6179837,
            "node_id": "MDk6TWlsZXN0b25lNjE3OTgzNw==",
            "number": 52,
            "state": "closed",
            "title": "23.0",
            "description": "",
            "creator": {
              "login": "MarcoFalke",
              "id": 6399679,
              "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
              "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/MarcoFalke",
              "html_url": "https://github.com/MarcoFalke",
              "followers_url": "https://api.github.com/users/MarcoFalke/followers",
              "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
              "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
              "repos_url": "https://api.github.com/users/MarcoFalke/repos",
              "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 123,
            "created_at": "2020-12-04T08:54:20Z",
            "updated_at": "2022-04-25T20:51:00Z",
            "closed_at": "2022-04-22T18:08:30Z"
          },
          "locked": true,
          "comments": 51,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20196",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20196",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20196.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20196.patch"
          },
          "closed_at": "2022-03-03T12:49:26Z",
          "created_at": "2020-10-20T10:01:49Z",
          "updated_at": "2023-03-03T10:15:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T14:13:00Z",
      "updated_at": "2021-01-06T14:13:00Z",
      "source": {
        "issue": {
          "id": 689128761,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NDc2MjMzMTY0",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19843",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19843/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19843/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19843/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/19843",
          "number": 19843,
          "state": "closed",
          "state_reason": null,
          "title": "Refactoring and minor improvement for self-advertisements",
          "body": "We have (almost) the same code chunk used twice. Improve that by slight refactoring.\r\n\r\nThe only behavior change is that the following will be also applied to the first (pre-VERACK) self-announcement:\r\n```   \r\n// If discovery is enabled, sometimes give our peer the address it\r\n// tells us that it sees us as in case it has a better idea of our\r\n// address than we do.\r\n```\r\nAnd I think it's a good change anyway.\r\n\r\nThe last commit is just to consider the first self-announcement as regular and reset the timer, so that we don't send the second self-announcement too soon.\r\nNote that since the first self-announcement is made at the end of processing VERSION, at that point addrLocal would be already filled with what the peers tells us we are, so this self-announcement would be no worse than any further one.",
          "user": {
            "login": "naumenkogs",
            "id": 7975071,
            "node_id": "MDQ6VXNlcjc5NzUwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/naumenkogs",
            "html_url": "https://github.com/naumenkogs",
            "followers_url": "https://api.github.com/users/naumenkogs/followers",
            "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
            "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
            "repos_url": "https://api.github.com/users/naumenkogs/repos",
            "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 19,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/19843",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/19843",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/19843.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/19843.patch"
          },
          "closed_at": "2021-04-16T09:28:08Z",
          "created_at": "2020-08-31T11:20:53Z",
          "updated_at": "2022-09-29T04:12:08Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T14:39:21Z",
      "updated_at": "2021-01-06T14:39:21Z",
      "source": {
        "issue": {
          "id": 652543635,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NDQ1NTkyMDUz",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19460",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19460/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19460/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19460/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/19460",
          "number": 19460,
          "state": "open",
          "state_reason": null,
          "title": "multiprocess: Add bitcoin-wallet -ipcconnect option",
          "body": "This PR is part of the [process separation project](https://github.com/bitcoin/bitcoin/projects/10).\r\n\r\n---\r\n\r\n**This is based on #10102.** The non-base commits are:\r\n\r\n- [`bbefbd3c199b` multiprocess: Add -ipcconnect and -ipcbind options](https://github.com/bitcoin/bitcoin/pull/19460/commits/bbefbd3c199b189188d6427b4564b17477c6d50e)\r\n\r\n---\r\n\r\nBuilding on #10102, this adds an `-ipcconnect` option to `bitcoin-wallet` and an `-ipcbind` option to `bitcoin-node` (both enabled by default in multiprocess builds) so bitcoin node will listen on a `<datadir>/sockets/node.sock` unix socket, and `bitcoin-wallet` will connect to it.\r\n\r\nThe idea is that `bitcoin-wallet` can be extended in the future to have some online functionality. For example, there could be a `bitcoin-wallet sync` command that will update balances and sync latest transactions to an unloaded wallet, or a `bitcoin-wallet serve` subcommand that loads a wallet and serves RPC requests, or a `bitcoin-wallet shell` subcommand that allows running RPC methods interactively like the GUI console, or just general support for `bitcoin-wallet <rpc method> <rpc params>` invocations suggested https://github.com/bitcoin/bitcoin/pull/13926#issuecomment-455187379.\r\n\r\nThis PR is small and doesn't do much. The only visible change is that `bitcoin-wallet` now checks whether a node socket exists on startup and prints \"Connected to IPC address\" if it can connect it it.\r\n\r\nThe default `bitcoin-wallet` connect option is `-ipcconnect=auto`, which connects if possible as described above, and proceeds offline if not possible. Other supported options are `-noipcconnect` to disable ipc, `-ipcconnect` to require a connection and fail if it can't be established, and `-ipcconnect=unix:<socket>` to require a connection and use a custom socket path.\r\n\r\nThese changes require multiprocess support and this PR has no effect unless bitcoin is configured with `--enable-multiprocess` as described in [doc/multiprocess.md](https://github.com/bitcoin/bitcoin/blob/master/doc/multiprocess.md)\r\n",
          "user": {
            "login": "ryanofsky",
            "id": 7133040,
            "node_id": "MDQ6VXNlcjcxMzMwNDA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ryanofsky",
            "html_url": "https://github.com/ryanofsky",
            "followers_url": "https://api.github.com/users/ryanofsky/followers",
            "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
            "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
            "repos_url": "https://api.github.com/users/ryanofsky/repos",
            "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 149424,
              "node_id": "MDU6TGFiZWwxNDk0MjQ=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Wallet",
              "name": "Wallet",
              "color": "08a781",
              "default": false
            },
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 5,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/19460",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/19460",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/19460.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/19460.patch"
          },
          "created_at": "2020-07-07T18:53:19Z",
          "updated_at": "2023-05-30T16:04:55Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T14:53:55Z",
      "updated_at": "2021-01-06T14:53:55Z",
      "source": {
        "issue": {
          "id": 640752006,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NDM2MTA0MjAz",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19315",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19315/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19315/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/19315/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/19315",
          "number": 19315,
          "state": "closed",
          "state_reason": null,
          "title": "[tests] Allow outbound & block-relay-only connections in functional tests. ",
          "body": "The existing functional test framework uses the `addnode` RPC to spin up manual connections between bitcoind nodes. This limits our ability to add integration tests for our networking code, which often executes different code paths for different connection types. \r\n\r\n**This PR enables creating `outbound` & `block-relay-only` P2P connections in the functional tests.** This allows us to increase our p2p test coverage, since we can now verify expectations around these connection types.\r\n\r\nThis builds out the [prototype](https://github.com/bitcoin/bitcoin/issues/14210#issuecomment-527421978) proposed by ajtowns in #14210. 🙌🏽\r\n\r\nAn overview of this branch:\r\n- introduces a new test-only RPC function `addconnection` which initiates opening an `outbound` or `block-relay-only` connection. (conceptually similar to `addnode` but for different connection types & restricted to regtest)\r\n- adds `test_framework` support so a mininode can open an `outbound`/`block-relay-only` connection to a `P2PInterface`/`P2PConnection`.\r\n- updates `p2p_blocksonly` tests to create a `block-relay-only` connection & verify expectations around transaction relay. \r\n- introduces `p2p_add_connections` test that checks the behaviors of the newly introduced `add_outbound_p2p_connection` test framework function. \r\n\r\nWith these changes, there are many more behaviors that we can add integration tests for. The blocksonly updates is just one example. \r\n\r\nHuge props to ajtowns for conceiving the approach & providing me feedback as I've built out this branch. Also thank you to jnewbery for lots of thoughtful input along the way. ",
          "user": {
            "login": "amitiuttarwar",
            "id": 1500952,
            "node_id": "MDQ6VXNlcjE1MDA5NTI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/amitiuttarwar",
            "html_url": "https://github.com/amitiuttarwar",
            "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
            "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
            "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
            "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
            "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 1648013533,
              "node_id": "MDU6TGFiZWwxNjQ4MDEzNTMz",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Review%20club",
              "name": "Review club",
              "description": "",
              "color": "0052cc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 34,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/19315",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/19315",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/19315.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/19315.patch"
          },
          "closed_at": "2021-01-11T20:08:15Z",
          "created_at": "2020-06-17T21:25:12Z",
          "updated_at": "2022-08-16T17:11:32Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T15:19:33Z",
      "updated_at": "2021-01-06T15:19:33Z",
      "source": {
        "issue": {
          "id": 609294978,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NDEwOTAyMTIx",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18819",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18819/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18819/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18819/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/18819",
          "number": 18819,
          "state": "closed",
          "state_reason": null,
          "title": "net: Replace cs_feeFilter with simple std::atomic",
          "body": "A `RecursiveMutex` is overkill for setting or reading a plain integer. Even a `Mutex` is overkill, when a plain `std::atomic` can be used.\r\n\r\nThis removes 11 lines of code. Also, it is cutting down on the number of locks put on the stack at the same time, which complicates review looking out for potential lock contention.",
          "user": {
            "login": "MarcoFalke",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/MarcoFalke",
            "html_url": "https://github.com/MarcoFalke",
            "followers_url": "https://api.github.com/users/MarcoFalke/followers",
            "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
            "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
            "repos_url": "https://api.github.com/users/MarcoFalke/repos",
            "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 14,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/18819",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/18819",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/18819.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/18819.patch"
          },
          "closed_at": "2021-01-11T02:14:43Z",
          "created_at": "2020-04-29T19:16:02Z",
          "updated_at": "2022-08-16T17:11:35Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T15:41:45Z",
      "updated_at": "2021-01-06T15:41:45Z",
      "source": {
        "issue": {
          "id": 560626660,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MzcxNTgzMzk4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18077/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18077/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18077/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/18077",
          "number": 18077,
          "state": "closed",
          "state_reason": null,
          "title": "net: Add NAT-PMP port forwarding support",
          "body": "Close #11902\r\nThis PR is an alternative to:\r\n- #12288\r\n- #15717\r\n\r\nTo compile with NAT-PMP support on Ubuntu [`libnatpmp-dev`](https://packages.ubuntu.com/source/bionic/libnatpmp) should be available.\r\n\r\nLog excerpt:\r\n```\r\n2020-02-05T20:12:28Z [mapport] NAT-PMP: public address = 95.164.65.194\r\n2020-02-05T20:12:28Z [mapport] AddLocal(95.164.65.194:18333,3)\r\n2020-02-05T20:12:28Z [mapport] NAT-PMP: port mapping successful.\r\n```\r\n\r\nSee: [`libnatpmp`](https://miniupnp.tuxfamily.org/libnatpmp.html)\r\n\r\n---\r\n\r\nSome follow-ups are out of this PR's scope:\r\n- mention NAT-PMP library in the version message\r\n- ~integrate NAT-PMP into the GUI~ (already [added](https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-589405068))",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignee": {
            "login": "dongcarl",
            "id": 3445290,
            "node_id": "MDQ6VXNlcjM0NDUyOTA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dongcarl",
            "html_url": "https://github.com/dongcarl",
            "followers_url": "https://api.github.com/users/dongcarl/followers",
            "following_url": "https://api.github.com/users/dongcarl/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dongcarl/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dongcarl/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
            "organizations_url": "https://api.github.com/users/dongcarl/orgs",
            "repos_url": "https://api.github.com/users/dongcarl/repos",
            "events_url": "https://api.github.com/users/dongcarl/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dongcarl/received_events",
            "type": "User",
            "site_admin": false
          },
          "assignees": [
            {
              "login": "dongcarl",
              "id": 3445290,
              "node_id": "MDQ6VXNlcjM0NDUyOTA=",
              "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/dongcarl",
              "html_url": "https://github.com/dongcarl",
              "followers_url": "https://api.github.com/users/dongcarl/followers",
              "following_url": "https://api.github.com/users/dongcarl/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/dongcarl/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/dongcarl/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
              "organizations_url": "https://api.github.com/users/dongcarl/orgs",
              "repos_url": "https://api.github.com/users/dongcarl/repos",
              "events_url": "https://api.github.com/users/dongcarl/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/dongcarl/received_events",
              "type": "User",
              "site_admin": false
            }
          ],
          "author_association": "MEMBER",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/47",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47/labels",
            "id": 5347322,
            "node_id": "MDk6TWlsZXN0b25lNTM0NzMyMg==",
            "number": 47,
            "state": "closed",
            "title": "22.0",
            "description": "",
            "creator": {
              "login": "MarcoFalke",
              "id": 6399679,
              "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
              "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/MarcoFalke",
              "html_url": "https://github.com/MarcoFalke",
              "followers_url": "https://api.github.com/users/MarcoFalke/followers",
              "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
              "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
              "repos_url": "https://api.github.com/users/MarcoFalke/repos",
              "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 124,
            "created_at": "2020-04-25T00:14:49Z",
            "updated_at": "2021-09-14T07:16:53Z",
            "closed_at": "2021-09-09T12:47:52Z"
          },
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 79,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/18077",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/18077.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/18077.patch"
          },
          "closed_at": "2021-01-07T18:42:38Z",
          "created_at": "2020-02-05T21:02:12Z",
          "updated_at": "2022-08-16T17:11:57Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T16:40:46Z",
      "updated_at": "2021-01-06T16:40:46Z",
      "source": {
        "issue": {
          "id": 217385623,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MTEyODQ2NDMx",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/10102/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/10102/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/10102/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/10102",
          "number": 10102,
          "state": "open",
          "state_reason": null,
          "title": "Multiprocess bitcoin",
          "body": "This PR is part of the [process separation project](https://github.com/bitcoin/bitcoin/projects/10).\r\n\r\n---\r\n\r\nThis PR adds an `--enable-multiprocess` configure option which builds new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables with relevant functionality isolated into different processes. See [doc/design/multiprocess.md](https://github.com/ryanofsky/bitcoin/tree/pr/ipc/doc/design/multiprocess.md) for usage details and future plans.\r\n\r\nThe change is implemented by adding a new [`Init`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/interfaces/init.h) interface that spawns new wallet and node subprocesses that can be controlled over a [socketpair](http://man7.org/linux/man-pages/man2/socketpair.2.html) by calling [`Node`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/interfaces/node.h), [`Wallet`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/interfaces/wallet.h), and [`ChainClient`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/interfaces/chain.h) methods. When running with split processes, you can see the IPC messages going back and forth in `-debug=1` output. Followup PR's #19460 and #19461 add `-ipcbind` and `-ipcconnect` options that allow more flexibility in how processes are connected.\r\n\r\nThe IPC protocol used is Cap'n Proto, but this could be swapped out for another protocol. Cap'n Proto types and libraries are only accessed in the [src/ipc/capnp/](https://github.com/ryanofsky/bitcoin/tree/pr/ipc/src/ipc/capnp) directory, and not in any public headers or other parts of bitcoin code.\r\n\r\n---\r\n\r\nSlides from a presentation describing this change are available on [google drive](https://docs.google.com/presentation/d/1AeJ-7gD-dItUgs5yH-HoEzLvXaEWe_2ZiGUUxYIXcws/edit). Demo code used in the presentation was from an older version this PR (tag [ipc.21](https://github.com/ryanofsky/bitcoin/releases/tag/pr%2Fipc.21), [commits](https://github.com/ryanofsky/bitcoin/compare/master...pr/ipc.21)).\r\n",
          "user": {
            "login": "ryanofsky",
            "id": 7133040,
            "node_id": "MDQ6VXNlcjcxMzMwNDA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ryanofsky",
            "html_url": "https://github.com/ryanofsky",
            "followers_url": "https://api.github.com/users/ryanofsky/followers",
            "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
            "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
            "repos_url": "https://api.github.com/users/ryanofsky/repos",
            "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135946,
              "node_id": "MDU6TGFiZWwxMzU5NDY=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/GUI",
              "name": "GUI",
              "color": "02d7e1",
              "default": false
            },
            {
              "id": 98279177,
              "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
              "name": "RPC/REST/ZMQ",
              "color": "0052cc",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 78,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/10102",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/10102.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/10102.patch"
          },
          "created_at": "2017-03-27T21:48:26Z",
          "updated_at": "2023-06-21T07:40:44Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 562948649,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyOTQ4NjQ5",
      "url": null,
      "actor": null,
      "commit_id": "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK fad2e1f267d60afe9799e431233f54f02d14e8e0\r\nWith the suggestions in the commit messages on how to best show the diffs, the review was quite straight-forward and painless. 👌 ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#pullrequestreview-562948649",
      "submitted_at": "2021-01-06T18:34:56Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
    },
    {
      "event": "commented",
      "id": 755818506,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTgxODUwNg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755818506",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T01:07:15Z",
      "updated_at": "2021-01-07T01:07:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755818506",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T02:54:18Z",
      "updated_at": "2021-01-07T02:54:18Z",
      "source": {
        "issue": {
          "id": 776822754,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTQ3MjQ3MzIy",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20811",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20811/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20811/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20811/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20811",
          "number": 20811,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: move net_processing implementation details out of header",
          "body": "Moves the implementation details of `PeerManager` and all of `struct Peer` into net_processing.cpp.",
          "user": {
            "login": "ajtowns",
            "id": 127186,
            "node_id": "MDQ6VXNlcjEyNzE4Ng==",
            "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ajtowns",
            "html_url": "https://github.com/ajtowns",
            "followers_url": "https://api.github.com/users/ajtowns/followers",
            "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
            "organizations_url": "https://api.github.com/users/ajtowns/orgs",
            "repos_url": "https://api.github.com/users/ajtowns/repos",
            "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ajtowns/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 15,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20811",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20811",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20811.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20811.patch"
          },
          "closed_at": "2021-01-13T08:48:34Z",
          "created_at": "2020-12-31T06:50:36Z",
          "updated_at": "2022-08-16T17:02:52Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 4178783002,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQxNzg3ODMwMDI=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4178783002",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:36:31Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4178789404,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE3ODc4OTQwNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4178789404",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:38:20Z"
    },
    {
      "event": "commented",
      "id": 755971118,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTk3MTExOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755971118",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:39:31Z",
      "updated_at": "2021-01-07T08:39:31Z",
      "author_association": "MEMBER",
      "body": "Rebased, should be trivial to re-ACK with git range-diff or from scratch",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755971118",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTBhNzE3ODFhOTY0ZDk0NGRiOWVjYzAwMjY3NWVmMzIyNDlmNjJl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa0a71781a964d944db9ecc002675ef32249f62e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0a71781a964d944db9ecc002675ef32249f62e",
      "tree": {
        "sha": "b001c0b58787d6ccbbd4673e2daf8a27733afa15",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b001c0b58787d6ccbbd4673e2daf8a27733afa15"
      },
      "verification": {
        "verified": false,
        "reason": "no_user",
        "payload": "tree b001c0b58787d6ccbbd4673e2daf8a27733afa15\nparent f13e03cda272fb7c9b667b4f7afb4b00fd44c461\nauthor MarcoFalke <falke.marco@gmail.com> 1609915144 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1610008849 +0100\n\nnet: Move CConnman/NetEventsInterface after CNode in header file\n\nCan be reviewed with --color-moved=dimmed-zebra --patience\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUhemgv+KqcMdyBrexUwlO2EBQZuNFnMnbPVOb6f+9ZYjz070Ut/SlA6kF/0GRQs\n4wmxwz+ZWJ2uiOwuxfJ8aBHGKwSwxKXz7I3O6Woe8AEVmoZjBFu38JfqewWSvCy9\nWtbIEKnhp+q3mW+T0sa2dV0R/XunoCuPwi2lnTkLSRix/o/OccWRVWRk1iOKE8Ww\n/MsdCL3CpwOSgUJvWMnmo81N6yafMiDC3VTXqbHt33np5hSJx0nkOOee+FBUPHDn\nhntPt6zBKNbMWtkx4DDtHmYDRCECITs/NK3WL+8axcdHsY3ujs8Ljj/zShDqAuKD\nqppb7B01XbCHTmn17JcXGUDFNWlg1ZHBY97V6fCTtSSOYoyrKzzmIpdfrEmxzcsz\nU9BERWoD7jp4qZazQpZaKOoCWnQDQ+MMZeWfa0ob+geOiPf542G6l0VoOBFz3SP7\nP9hwlESrY5El12l9Hq5202YOdHBoJrc9PdFgbt4ofOon7W4/4zjYNDCLNSFWX1fi\nrprkKGLK\n=mqin\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f13e03cda272fb7c9b667b4f7afb4b00fd44c461",
          "sha": "f13e03cda272fb7c9b667b4f7afb4b00fd44c461",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f13e03cda272fb7c9b667b4f7afb4b00fd44c461"
        }
      ],
      "message": "net: Move CConnman/NetEventsInterface after CNode in header file\n\nCan be reviewed with --color-moved=dimmed-zebra --patience",
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-07T08:40:49Z"
      },
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-06T06:39:04Z"
      },
      "sha": "fa0a71781a964d944db9ecc002675ef32249f62e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTIxMDY4OWUyN2IwZDc4YjJmZTg5NGU1MWUzNjQxNzlkYjdhM2Nl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "tree": {
        "sha": "e16fa7470067c2a56adcc5cd44f9f14dcc73f5a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e16fa7470067c2a56adcc5cd44f9f14dcc73f5a4"
      },
      "verification": {
        "verified": false,
        "reason": "no_user",
        "payload": "tree e16fa7470067c2a56adcc5cd44f9f14dcc73f5a4\nparent fa0a71781a964d944db9ecc002675ef32249f62e\nauthor MarcoFalke <falke.marco@gmail.com> 1609917148 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1610008894 +0100\n\nnet: Move SocketSendData lock annotation to header\n\nAlso, add lock annotation to SendMessages\n\nCan be reviewed with \"--word-diff-regex=.\"\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUhFiQwAlXbGugaShIxf2+T3H81KqIiMNsvfe3laGd6dRSuzqbHWeEQPbyu6mRK8\nMnOkekWxCrkRd0oI7aSl8KrYLPfyogI9ywN90kuBChfi2kmh9d4AChwe6fReFsYU\nwxkJj21c2jrePiHc6whTctAxaXXxrU3r4zajPOh2ZgUqYgwpJVb4SWBYkODKWy16\nylOpry/XmDhgFKyf/gcFfpZ2K0WgN9d6k2Elqu1IB/BT68aLkWg65X+XvEGtAjhS\nrP307B7ataCnN5SJ8Nj2Yo9jE4LzBII/bcspKQZW/Tm7UZzI0xZhhBgDEZ1LfCNi\nVVp6JvtWoGxLz0X11GK79F4gxXN30U/+WC7D2pfbUYEQ34gLfAFKDZO8rSl1mOcl\nWgY0FY8rDmd8I4BMbtw2L2FU2ImgWAtx+csu8yhYrvrkPU/fBYNYb1M0GJd8FrW+\ncoDLdBHiiBnN44l/DEN5dZAdWCOiUqB+8TNm0Kdy1PQsu0UOiR7DVMNiZyr9bKRN\n+raDxF0g\n=dVch\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa0a71781a964d944db9ecc002675ef32249f62e",
          "sha": "fa0a71781a964d944db9ecc002675ef32249f62e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0a71781a964d944db9ecc002675ef32249f62e"
        }
      ],
      "message": "net: Move SocketSendData lock annotation to header\n\nAlso, add lock annotation to SendMessages\n\nCan be reviewed with \"--word-diff-regex=.\"",
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-07T08:41:34Z"
      },
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-06T07:12:28Z"
      },
      "sha": "fa210689e27b0d78b2fe894e51e364179db7a3ce"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4178803320,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE3ODgwMzMyMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4178803320",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:42:02Z"
    },
    {
      "event": "unlabeled",
      "id": 4178826631,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50NDE3ODgyNjYzMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4178826631",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:48:41Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 755991945,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTk5MTk0NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755991945",
      "actor": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T09:20:16Z",
      "updated_at": "2021-01-07T09:20:16Z",
      "author_association": "MEMBER",
      "body": "utACK fa210689e2",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755991945",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "merged",
      "id": 4179996355,
      "node_id": "MDExOk1lcmdlZEV2ZW50NDE3OTk5NjM1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4179996355",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "42675e783337bf56dfc51df6c14931df5e72f185",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42675e783337bf56dfc51df6c14931df5e72f185",
      "created_at": "2021-01-07T13:58:52Z"
    },
    {
      "event": "closed",
      "id": 4179996375,
      "node_id": "MDExOkNsb3NlZEV2ZW50NDE3OTk5NjM3NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4179996375",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T13:58:52Z"
    },
    {
      "event": "head_ref_deleted",
      "id": 4180001973,
      "node_id": "MDE5OkhlYWRSZWZEZWxldGVkRXZlbnQ0MTgwMDAxOTcz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4180001973",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T14:00:15Z"
    },
    {
      "event": "referenced",
      "id": 4180466481,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQxODA0NjY0ODE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4180466481",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "52a356407c6873989a36e2c808873a46a91916fc",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/52a356407c6873989a36e2c808873a46a91916fc",
      "created_at": "2021-01-07T15:45:10Z"
    },
    {
      "event": "referenced",
      "id": 5949634877,
      "node_id": "REFE_lADOABII584ugOAdzwAAAAFioDk9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5949634877",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "018d4cef0cd3b15dee5adb0fb9421e09eded6d8a",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/018d4cef0cd3b15dee5adb0fb9421e09eded6d8a",
      "created_at": "2022-01-25T12:53:50Z"
    },
    {
      "event": "referenced",
      "id": 5949634885,
      "node_id": "REFE_lADOABII584ugOAdzwAAAAFioDlF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5949634885",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "13db67570818298731b738712fd2bbaa4fa57235",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/13db67570818298731b738712fd2bbaa4fa57235",
      "created_at": "2022-01-25T12:53:50Z"
    },
    {
      "event": "locked",
      "id": 7199003442,
      "node_id": "LOE_lADOABII584ugOAdzwAAAAGtGBMy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7199003442",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-08-16T17:02:12Z",
      "lock_reason": "resolved"
    },
    {
      "event": "subscribed",
      "id": 7547080021,
      "node_id": "SE_lADOABII584ugOAdzwAAAAHB101V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7547080021",
      "actor": {
        "login": "Leylimahmud",
        "id": 99537361,
        "node_id": "U_kgDOBe7R0Q",
        "avatar_url": "https://avatars.githubusercontent.com/u/99537361?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Leylimahmud",
        "html_url": "https://github.com/Leylimahmud",
        "followers_url": "https://api.github.com/users/Leylimahmud/followers",
        "following_url": "https://api.github.com/users/Leylimahmud/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Leylimahmud/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Leylimahmud/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Leylimahmud/subscriptions",
        "organizations_url": "https://api.github.com/users/Leylimahmud/orgs",
        "repos_url": "https://api.github.com/users/Leylimahmud/repos",
        "events_url": "https://api.github.com/users/Leylimahmud/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Leylimahmud/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-07T23:45:43Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/552621025",
      "pull_request_review_id": 562714005,
      "id": 552621025,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjYyMTAyNQ==",
      "diff_hunk": "@@ -180,1041 +180,1040 @@ enum class ConnectionType {\n     ADDR_FETCH,\n };\n \n-class NetEventsInterface;\n-class CConnman\n-{\n-public:\n-\n-    enum NumConnections {\n-        CONNECTIONS_NONE = 0,\n-        CONNECTIONS_IN = (1U << 0),\n-        CONNECTIONS_OUT = (1U << 1),\n-        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n-    };\n-\n-    struct Options\n-    {\n-        ServiceFlags nLocalServices = NODE_NONE;\n-        int nMaxConnections = 0;\n-        int m_max_outbound_full_relay = 0;\n-        int m_max_outbound_block_relay = 0;\n-        int nMaxAddnode = 0;\n-        int nMaxFeeler = 0;\n-        CClientUIInterface* uiInterface = nullptr;\n-        NetEventsInterface* m_msgproc = nullptr;\n-        BanMan* m_banman = nullptr;\n-        unsigned int nSendBufferMaxSize = 0;\n-        unsigned int nReceiveFloodSize = 0;\n-        uint64_t nMaxOutboundLimit = 0;\n-        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n-        std::vector<std::string> vSeedNodes;\n-        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n-        std::vector<NetWhitebindPermissions> vWhiteBinds;\n-        std::vector<CService> vBinds;\n-        std::vector<CService> onion_binds;\n-        bool m_use_addrman_outgoing = true;\n-        std::vector<std::string> m_specified_outgoing;\n-        std::vector<std::string> m_added_nodes;\n-        std::vector<bool> m_asmap;\n-    };\n-\n-    void Init(const Options& connOptions) {\n-        nLocalServices = connOptions.nLocalServices;\n-        nMaxConnections = connOptions.nMaxConnections;\n-        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n-        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n-        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n-        nMaxAddnode = connOptions.nMaxAddnode;\n-        nMaxFeeler = connOptions.nMaxFeeler;\n-        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n-        clientInterface = connOptions.uiInterface;\n-        m_banman = connOptions.m_banman;\n-        m_msgproc = connOptions.m_msgproc;\n-        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n-        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n-        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n-        {\n-            LOCK(cs_totalBytesSent);\n-            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n-        }\n-        vWhitelistedRange = connOptions.vWhitelistedRange;\n-        {\n-            LOCK(cs_vAddedNodes);\n-            vAddedNodes = connOptions.m_added_nodes;\n-        }\n-        m_onion_binds = connOptions.onion_binds;\n-    }\n-\n-    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n-    ~CConnman();\n-    bool Start(CScheduler& scheduler, const Options& options);\n-\n-    void StopThreads();\n-    void StopNodes();\n-    void Stop()\n-    {\n-        StopThreads();\n-        StopNodes();\n-    };\n-\n-    void Interrupt();\n-    bool GetNetworkActive() const { return fNetworkActive; };\n-    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n-    void SetNetworkActive(bool active);\n-    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n-    bool CheckIncomingNonce(uint64_t nonce);\n-\n-    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n-\n-    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n-\n-    using NodeFn = std::function<void(CNode*)>;\n-    void ForEachNode(const NodeFn& func)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    void ForEachNode(const NodeFn& func) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+void Discover();\n+void StartMapPort();\n+void InterruptMapPort();\n+void StopMapPort();\n+uint16_t GetListenPort();\n \n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+enum\n+{\n+    LOCAL_NONE,   // unknown\n+    LOCAL_IF,     // address a local interface listens on\n+    LOCAL_BIND,   // address explicit bound to\n+    LOCAL_UPNP,   // address reported by UPnP\n+    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n \n-    // Addrman functions\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n-    void MarkAddressGood(const CAddress& addr);\n-    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n-    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n-    /**\n-     * Cache is used to minimize topology leaks, so it should\n-     * be used for all non-trusted calls, for example, p2p.\n-     * A non-malicious call (from RPC or a peer with addr permission) should\n-     * call the function without a parameter to avoid using the cache.\n-     */\n-    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n+    LOCAL_MAX\n+};\n \n-    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n-    // a peer that is better than all our current peers.\n-    void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+bool IsPeerAddrLocalGood(CNode *pnode);\n+void AdvertiseLocal(CNode *pnode);\n \n-    void StartExtraBlockRelayPeers() {\n-        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n-        m_start_extra_block_relay_peers = true;\n-    }\n+/**\n+ * Mark a network as reachable or unreachable (no automatic connects to it)\n+ * @note Networks are reachable by default\n+ */\n+void SetReachable(enum Network net, bool reachable);\n+/** @returns true if the network is reachable, false otherwise */\n+bool IsReachable(enum Network net);\n+/** @returns true if the address is in a reachable network, false otherwise */\n+bool IsReachable(const CNetAddr& addr);\n \n-    // Return the number of outbound peers we have in excess of our target (eg,\n-    // if we previously called SetTryNewOutboundPeer(true), and have since set\n-    // to false, we may have extra peers that we wish to disconnect). This may\n-    // return a value less than (num_outbound_connections - num_outbound_slots)\n-    // in cases where some outbound connections are not yet fully connected, or\n-    // not yet fully disconnected.\n-    int GetExtraFullOutboundCount();\n-    // Count the number of block-relay-only peers we have over our limit.\n-    int GetExtraBlockRelayCount();\n+bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n+bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n+void RemoveLocal(const CService& addr);\n+bool SeenLocal(const CService& addr);\n+bool IsLocal(const CService& addr);\n+bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n+CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n \n-    bool AddNode(const std::string& node);\n-    bool RemoveAddedNode(const std::string& node);\n-    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    size_t GetNodeCount(NumConnections num);\n-    void GetNodeStats(std::vector<CNodeStats>& vstats);\n-    bool DisconnectNode(const std::string& node);\n-    bool DisconnectNode(const CSubNet& subnet);\n-    bool DisconnectNode(const CNetAddr& addr);\n-    bool DisconnectNode(NodeId id);\n+extern bool fDiscover;\n+extern bool fListen;\n \n-    //! Used to convey which local services we are offering peers during node\n-    //! connection.\n-    //!\n-    //! The data returned by this is used in CNode construction,\n-    //! which is used to advertise which services we are offering\n-    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n-    ServiceFlags GetLocalServices() const;\n+/** Subversion as sent to the P2P network in `version` messages */\n+extern std::string strSubVersion;\n \n-    uint64_t GetMaxOutboundTarget();\n-    std::chrono::seconds GetMaxOutboundTimeframe();\n+struct LocalServiceInfo {\n+    int nScore;\n+    int nPort;\n+};\n \n-    //! check if the outbound target is reached\n-    //! if param historicalBlockServingLimit is set true, the function will\n-    //! response true if the limit for serving historical blocks has been reached\n-    bool OutboundTargetReached(bool historicalBlockServingLimit);\n+extern RecursiveMutex cs_mapLocalHost;\n+extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n \n-    //! response the bytes left in the current max outbound cycle\n-    //! in case of no limit, it will always response 0\n-    uint64_t GetOutboundTargetBytesLeft();\n+extern const std::string NET_MESSAGE_COMMAND_OTHER;\n+typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n \n-    //! returns the time left in the current max outbound cycle\n-    //! in case of no limit, it will always return 0\n-    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n+class CNodeStats\n+{\n+public:\n+    NodeId nodeid;\n+    ServiceFlags nServices;\n+    bool fRelayTxes;\n+    int64_t nLastSend;\n+    int64_t nLastRecv;\n+    int64_t nLastTXTime;\n+    int64_t nLastBlockTime;\n+    int64_t nTimeConnected;\n+    int64_t nTimeOffset;\n+    std::string addrName;\n+    int nVersion;\n+    std::string cleanSubVer;\n+    bool fInbound;\n+    bool m_bip152_highbandwidth_to;\n+    bool m_bip152_highbandwidth_from;\n+    int m_starting_height;\n+    uint64_t nSendBytes;\n+    mapMsgCmdSize mapSendBytesPerMsgCmd;\n+    uint64_t nRecvBytes;\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n+    NetPermissionFlags m_permissionFlags;\n+    int64_t m_ping_usec;\n+    int64_t m_ping_wait_usec;\n+    int64_t m_min_ping_usec;\n+    CAmount minFeeFilter;\n+    // Our address, as reported by the peer\n+    std::string addrLocal;\n+    // Address of this peer\n+    CAddress addr;\n+    // Bind address of our side of the connection\n+    CAddress addrBind;\n+    // Network the peer connected through\n+    Network m_network;\n+    uint32_t m_mapped_as;\n+    std::string m_conn_type_string;\n+};\n \n-    uint64_t GetTotalBytesRecv();\n-    uint64_t GetTotalBytesSent();\n \n-    /** Get a unique deterministic randomizer. */\n-    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-    unsigned int GetReceiveFloodSize() const;\n+/** Transport protocol agnostic message container.\n+ * Ideally it should only contain receive time, payload,\n+ * command and size.\n+ */\n+class CNetMessage {\n+public:\n+    CDataStream m_recv;                  //!< received message data\n+    std::chrono::microseconds m_time{0}; //!< time of message receipt\n+    uint32_t m_message_size{0};          //!< size of the payload\n+    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n+    std::string m_command;\n \n-    void WakeMessageHandler();\n+    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n \n-    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n-        Works assuming that a single interval is used.\n-        Variable intervals will result in privacy decrease.\n-    */\n-    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n+    void SetVersion(int nVersionIn)\n+    {\n+        m_recv.SetVersion(nVersionIn);\n+    }\n+};\n \n-    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n+/** The TransportDeserializer takes care of holding and deserializing the\n+ * network receive buffer. It can deserialize the network buffer into a\n+ * transport protocol agnostic CNetMessage (command & payload)\n+ */\n+class TransportDeserializer {\n+public:\n+    // returns true if the current deserialization is complete\n+    virtual bool Complete() const = 0;\n+    // set the serialization context version\n+    virtual void SetVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer */\n+    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    // decomposes a message from the context\n+    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n+    virtual ~TransportDeserializer() {}\n+};\n \n+class V1TransportDeserializer final : public TransportDeserializer\n+{\n private:\n-    struct ListenSocket {\n-    public:\n-        SOCKET socket;\n-        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n-        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n-    private:\n-        NetPermissionFlags m_permissions;\n-    };\n-\n-    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n-    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n-    bool InitBinds(\n-        const std::vector<CService>& binds,\n-        const std::vector<NetWhitebindPermissions>& whiteBinds,\n-        const std::vector<CService>& onion_binds);\n-\n-    void ThreadOpenAddedConnections();\n-    void AddAddrFetch(const std::string& strDest);\n-    void ProcessAddrFetch();\n-    void ThreadOpenConnections(std::vector<std::string> connect);\n-    void ThreadMessageHandler();\n-    void AcceptConnection(const ListenSocket& hListenSocket);\n-    void DisconnectNodes();\n-    void NotifyNumConnectionsChanged();\n-    void InactivityCheck(CNode *pnode);\n-    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketHandler();\n-    void ThreadSocketHandler();\n-    void ThreadDNSAddressSeed();\n-\n-    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n-\n-    CNode* FindNode(const CNetAddr& ip);\n-    CNode* FindNode(const CSubNet& subNet);\n-    CNode* FindNode(const std::string& addrName);\n-    CNode* FindNode(const CService& addr);\n-\n-    /**\n-     * Determine whether we're already connected to a given address, in order to\n-     * avoid initiating duplicate connections.\n-     */\n-    bool AlreadyConnectedToAddress(const CAddress& addr);\n-\n-    bool AttemptToEvictConnection();\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n-    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n-\n-    void DeleteNode(CNode* pnode);\n+    const CChainParams& m_chain_params;\n+    const NodeId m_node_id; // Only for logging\n+    mutable CHash256 hasher;\n+    mutable uint256 data_hash;\n+    bool in_data;                   // parsing header (false) or data (true)\n+    CDataStream hdrbuf;             // partially received header\n+    CMessageHeader hdr;             // complete header\n+    CDataStream vRecv;              // received message data\n+    unsigned int nHdrPos;\n+    unsigned int nDataPos;\n \n-    NodeId GetNewNodeId();\n+    const uint256& GetMessageHash() const;\n+    int readHeader(Span<const uint8_t> msg_bytes);\n+    int readData(Span<const uint8_t> msg_bytes);\n \n-    size_t SocketSendData(CNode *pnode) const;\n-    void DumpAddresses();\n+    void Reset() {\n+        vRecv.clear();\n+        hdrbuf.clear();\n+        hdrbuf.resize(24);\n+        in_data = false;\n+        nHdrPos = 0;\n+        nDataPos = 0;\n+        data_hash.SetNull();\n+        hasher.Reset();\n+    }\n \n-    // Network stats\n-    void RecordBytesRecv(uint64_t bytes);\n-    void RecordBytesSent(uint64_t bytes);\n+public:\n+    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n+        : m_chain_params(chain_params),\n+          m_node_id(node_id),\n+          hdrbuf(nTypeIn, nVersionIn),\n+          vRecv(nTypeIn, nVersionIn)\n+    {\n+        Reset();\n+    }\n \n-    /**\n-     * Return vector of current BLOCK_RELAY peers.\n-     */\n-    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n+    bool Complete() const override\n+    {\n+        if (!in_data)\n+            return false;\n+        return (hdr.nMessageSize == nDataPos);\n+    }\n+    void SetVersion(int nVersionIn) override\n+    {\n+        hdrbuf.SetVersion(nVersionIn);\n+        vRecv.SetVersion(nVersionIn);\n+    }\n+    int Read(Span<const uint8_t>& msg_bytes) override\n+    {\n+        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n+        if (ret < 0) {\n+            Reset();\n+        } else {\n+            msg_bytes = msg_bytes.subspan(ret);\n+        }\n+        return ret;\n+    }\n+    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+};\n \n-    // Whether the node should be passed out in ForEach* callbacks\n-    static bool NodeFullyConnected(const CNode* pnode);\n+/** The TransportSerializer prepares messages for the network transport\n+ */\n+class TransportSerializer {\n+public:\n+    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n+    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n+    virtual ~TransportSerializer() {}\n+};\n \n-    // Network usage totals\n-    RecursiveMutex cs_totalBytesRecv;\n-    RecursiveMutex cs_totalBytesSent;\n-    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n-    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n+class V1TransportSerializer  : public TransportSerializer {\n+public:\n+    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+};\n \n-    // outbound limit & stats\n-    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n-    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n-    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n+/** Information about a peer */\n+class CNode\n+{\n+    friend class CConnman;\n+    friend struct ConnmanTestMsg;\n \n-    // P2P timeout in seconds\n-    int64_t m_peer_connect_timeout;\n+public:\n+    std::unique_ptr<TransportDeserializer> m_deserializer;\n+    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // Whitelisted ranges. Any node connecting from these is automatically\n-    // whitelisted (as well as those connecting to whitelisted binds).\n-    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+    // socket\n+    std::atomic<ServiceFlags> nServices{NODE_NONE};\n+    SOCKET hSocket GUARDED_BY(cs_hSocket);\n+    /** Total size of all vSendMsg entries */\n+    size_t nSendSize GUARDED_BY(cs_vSend){0};\n+    /** Offset inside the first vSendMsg already sent */\n+    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n+    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n+    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n+    Mutex cs_vSend;\n+    Mutex cs_hSocket;\n+    Mutex cs_vRecv;\n \n-    unsigned int nSendBufferMaxSize{0};\n-    unsigned int nReceiveFloodSize{0};\n+    RecursiveMutex cs_vProcessMsg;\n+    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n+    size_t nProcessQueueSize{0};\n \n-    std::vector<ListenSocket> vhListenSocket;\n-    std::atomic<bool> fNetworkActive{true};\n-    bool fAddressesInitialized{false};\n-    CAddrMan addrman;\n-    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n-    RecursiveMutex m_addr_fetches_mutex;\n-    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    RecursiveMutex cs_vAddedNodes;\n-    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n-    std::list<CNode*> vNodesDisconnected;\n-    mutable RecursiveMutex cs_vNodes;\n-    std::atomic<NodeId> nLastNodeId{0};\n-    unsigned int nPrevNodeCount{0};\n+    RecursiveMutex cs_sendProcessing;\n \n-    /**\n-     * Cache responses to addr requests to minimize privacy leak.\n-     * Attack example: scraping addrs in real-time may allow an attacker\n-     * to infer new connections of the victim by detecting new records\n-     * with fresh timestamps (per self-announcement).\n-     */\n-    struct CachedAddrResponse {\n-        std::vector<CAddress> m_addrs_response_cache;\n-        std::chrono::microseconds m_cache_entry_expiration{0};\n-    };\n+    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n \n+    std::atomic<int64_t> nLastSend{0};\n+    std::atomic<int64_t> nLastRecv{0};\n+    const int64_t nTimeConnected;\n+    std::atomic<int64_t> nTimeOffset{0};\n+    // Address of this peer\n+    const CAddress addr;\n+    // Bind address of our side of the connection\n+    const CAddress addrBind;\n+    std::atomic<int> nVersion{0};\n+    RecursiveMutex cs_SubVer;\n     /**\n-     * Addr responses stored in different caches\n-     * per (network, local socket) prevent cross-network node identification.\n-     * If a node for example is multi-homed under Tor and IPv6,\n-     * a single cache (or no cache at all) would let an attacker\n-     * to easily detect that it is the same node by comparing responses.\n-     * Indexing by local socket prevents leakage when a node has multiple\n-     * listening addresses on the same network.\n-     *\n-     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n-     * distinct Network (up to 5) we have/had an inbound peer from,\n-     * resulting in at most ~196 KB. Every separate local socket may\n-     * add up to ~196 KB extra.\n+     * cleanSubVer is a sanitized string of the user agent byte array we read\n+     * from the wire. This cleaned string can safely be logged or displayed.\n      */\n-    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n-\n+    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n+    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n+    bool HasPermission(NetPermissionFlags permission) const {\n+        return NetPermissions::HasFlag(m_permissionFlags, permission);\n+    }\n+    bool fClient{false}; // set by version message\n+    bool m_limited_node{false}; //after BIP159, set by version message\n     /**\n-     * Services this instance offers.\n-     *\n-     * This data is replicated in each CNode instance we create during peer\n-     * connection (in ConnectNode()) under a member also called\n-     * nLocalServices.\n-     *\n-     * This data is not marked const, but after being set it should not\n-     * change. See the note in CNode::nLocalServices documentation.\n-     *\n-     * \\sa CNode::nLocalServices\n+     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n+     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n      */\n-    ServiceFlags nLocalServices;\n-\n-    std::unique_ptr<CSemaphore> semOutbound;\n-    std::unique_ptr<CSemaphore> semAddnode;\n-    int nMaxConnections;\n+    std::atomic_bool m_wants_addrv2{false};\n+    std::atomic_bool fSuccessfullyConnected{false};\n+    // Setting fDisconnect to true will cause the node to be disconnected the\n+    // next time DisconnectNodes() runs\n+    std::atomic_bool fDisconnect{false};\n+    bool fSentAddr{false};\n+    CSemaphoreGrant grantOutbound;\n+    std::atomic<int> nRefCount{0};\n \n-    // How many full-relay (tx, block, addr) outbound peers we want\n-    int m_max_outbound_full_relay;\n+    const uint64_t nKeyedNetGroup;\n+    std::atomic_bool fPauseRecv{false};\n+    std::atomic_bool fPauseSend{false};\n \n-    // How many block-relay only outbound peers we want\n-    // We do not relay tx or addr messages with these peers\n-    int m_max_outbound_block_relay;\n+    bool IsOutboundOrBlockRelayConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+                return true;\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::ADDR_FETCH:\n+            case ConnectionType::FEELER:\n+                return false;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    int nMaxAddnode;\n-    int nMaxFeeler;\n-    int m_max_outbound;\n-    bool m_use_addrman_outgoing;\n-    CClientUIInterface* clientInterface;\n-    NetEventsInterface* m_msgproc;\n-    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n-    BanMan* m_banman;\n+        assert(false);\n+    }\n \n-    /**\n-     * Addresses that were saved during the previous clean shutdown. We'll\n-     * attempt to make block-relay-only connections to them.\n-     */\n-    std::vector<CAddress> m_anchors;\n+    bool IsFullOutboundConn() const {\n+        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    }\n \n-    /** SipHasher seeds for deterministic randomness */\n-    const uint64_t nSeed0, nSeed1;\n+    bool IsManualConn() const {\n+        return m_conn_type == ConnectionType::MANUAL;\n+    }\n \n-    /** flag for waking the message processor. */\n-    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n+    bool IsBlockOnlyConn() const {\n+        return m_conn_type == ConnectionType::BLOCK_RELAY;\n+    }\n \n-    std::condition_variable condMsgProc;\n-    Mutex mutexMsgProc;\n-    std::atomic<bool> flagInterruptMsgProc{false};\n+    bool IsFeelerConn() const {\n+        return m_conn_type == ConnectionType::FEELER;\n+    }\n \n-    CThreadInterrupt interruptNet;\n+    bool IsAddrFetchConn() const {\n+        return m_conn_type == ConnectionType::ADDR_FETCH;\n+    }\n \n-    std::thread threadDNSAddressSeed;\n-    std::thread threadSocketHandler;\n-    std::thread threadOpenAddedConnections;\n-    std::thread threadOpenConnections;\n-    std::thread threadMessageHandler;\n+    bool IsInboundConn() const {\n+        return m_conn_type == ConnectionType::INBOUND;\n+    }\n \n-    /** flag for deciding to connect to an extra outbound peer,\n-     *  in excess of m_max_outbound_full_relay\n-     *  This takes the place of a feeler connection */\n-    std::atomic_bool m_try_another_outbound_peer;\n+    /* Whether we send addr messages over this connection */\n+    bool RelayAddrsWithConn() const\n+    {\n+        // Don't relay addr messages to peers that we connect to as block-relay-only\n+        // peers (to prevent adversaries from inferring these links from addr\n+        // traffic).\n+        return m_conn_type != ConnectionType::BLOCK_RELAY;\n+    }\n \n-    /** flag for initiating extra block-relay-only peer connections.\n-     *  this should only be enabled after initial chain sync has occurred,\n-     *  as these connections are intended to be short-lived and low-bandwidth.\n-     */\n-    std::atomic_bool m_start_extra_block_relay_peers{false};\n+    bool ExpectServicesFromConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::FEELER:\n+                return false;\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+            case ConnectionType::ADDR_FETCH:\n+                return true;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n+        assert(false);\n+    }\n \n     /**\n-     * A vector of -bind=<address>:<port>=onion arguments each of which is\n-     * an address and port that are designated for incoming Tor connections.\n+     * Get network the peer connected through.\n+     *\n+     * Returns Network::NET_ONION for *inbound* onion connections,\n+     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n+     * because it doesn't detect the former, and it's not the responsibility of\n+     * the CNetAddr class to know the actual network a peer is connected through.\n+     *\n+     * @return network the peer connected through.\n      */\n-    std::vector<CService> m_onion_binds;\n+    Network ConnectedThroughNetwork() const;\n \n-    friend struct CConnmanTest;\n-    friend struct ConnmanTestMsg;\n-};\n-void Discover();\n-void StartMapPort();\n-void InterruptMapPort();\n-void StopMapPort();\n-uint16_t GetListenPort();\n+protected:\n+    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n \n-/**\n- * Interface for message handling\n- */\n-class NetEventsInterface\n-{\n public:\n-    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode) = 0;\n-    virtual void InitializeNode(CNode* pnode) = 0;\n-    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n+    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_to{false};\n+    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+\n+    // flood relay\n+    std::vector<CAddress> vAddrToSend;\n+    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n+    bool fGetAddr{false};\n+    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+\n+    struct TxRelay {\n+        mutable RecursiveMutex cs_filter;\n+        // We use fRelayTxes for two purposes -\n+        // a) it allows us to not relay tx invs before receiving the peer's version message\n+        // b) the peer may tell us in its version message that we should not relay tx invs\n+        //    unless it loads a bloom filter.\n+        bool fRelayTxes GUARDED_BY(cs_filter){false};\n+        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+\n+        mutable RecursiveMutex cs_tx_inventory;\n+        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n+        // Set of transaction ids we still have to announce.\n+        // They are sorted by the mempool before relay, so the order is not important.\n+        std::set<uint256> setInventoryTxToSend;\n+        // Used for BIP35 mempool sending\n+        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n+        // Last time a \"MEMPOOL\" request was serviced.\n+        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n+        std::chrono::microseconds nNextInvSend{0};\n \n-protected:\n-    /**\n-     * Protected destructor so that instances can only be deleted by derived classes.\n-     * If that restriction is no longer desired, this should be made public and virtual.\n-     */\n-    ~NetEventsInterface() = default;\n-};\n+        RecursiveMutex cs_feeFilter;\n+        // Minimum fee rate with which to filter inv's to this node\n+        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n+        CAmount lastSentFeeFilter{0};\n+        int64_t nextSendTimeFeeFilter{0};\n+    };\n \n-enum\n-{\n-    LOCAL_NONE,   // unknown\n-    LOCAL_IF,     // address a local interface listens on\n-    LOCAL_BIND,   // address explicit bound to\n-    LOCAL_UPNP,   // address reported by UPnP\n-    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n+    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n+    std::unique_ptr<TxRelay> m_tx_relay;\n \n-    LOCAL_MAX\n-};\n+    /** UNIX epoch time of the last block received from this peer that we had\n+     * not yet seen (e.g. not already received from another peer), that passed\n+     * preliminary validity checks and was saved to disk, even if we don't\n+     * connect the block or it eventually fails connection. Used as an inbound\n+     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastBlockTime{0};\n \n-bool IsPeerAddrLocalGood(CNode *pnode);\n-void AdvertiseLocal(CNode *pnode);\n+    /** UNIX epoch time of the last transaction received from this peer that we\n+     * had not yet seen (e.g. not already received from another peer) and that\n+     * was accepted into our mempool. Used as an inbound peer eviction criterium\n+     * in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastTXTime{0};\n \n-/**\n- * Mark a network as reachable or unreachable (no automatic connects to it)\n- * @note Networks are reachable by default\n- */\n-void SetReachable(enum Network net, bool reachable);\n-/** @returns true if the network is reachable, false otherwise */\n-bool IsReachable(enum Network net);\n-/** @returns true if the address is in a reachable network, false otherwise */\n-bool IsReachable(const CNetAddr& addr);\n+    // Ping time measurement:\n+    // The pong reply we're expecting, or 0 if no pong expected.\n+    std::atomic<uint64_t> nPingNonceSent{0};\n+    /** When the last ping was sent, or 0 if no ping was ever sent */\n+    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n+    // Last measured round-trip time.\n+    std::atomic<int64_t> nPingUsecTime{0};\n+    // Best measured round-trip time.\n+    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n+    // Whether a ping is requested.\n+    std::atomic<bool> fPingQueued{false};\n \n-bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n-bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n-void RemoveLocal(const CService& addr);\n-bool SeenLocal(const CService& addr);\n-bool IsLocal(const CService& addr);\n-bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n+    ~CNode();\n+    CNode(const CNode&) = delete;\n+    CNode& operator=(const CNode&) = delete;\n \n+private:\n+    const NodeId id;\n+    const uint64_t nLocalHostNonce;\n+    const ConnectionType m_conn_type;\n+    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n \n-extern bool fDiscover;\n-extern bool fListen;\n+    //! Services offered to this peer.\n+    //!\n+    //! This is supplied by the parent CConnman during peer connection\n+    //! (CConnman::ConnectNode()) from its attribute of the same name.\n+    //!\n+    //! This is const because there is no protocol defined for renegotiating\n+    //! services initially offered to a peer. The set of local services we\n+    //! offer should not change after initialization.\n+    //!\n+    //! An interesting example of this is NODE_NETWORK and initial block\n+    //! download: a node which starts up from scratch doesn't have any blocks\n+    //! to serve, but still advertises NODE_NETWORK because it will eventually\n+    //! fulfill this role after IBD completes. P2P code is written in such a\n+    //! way that it can gracefully handle peers who don't make good on their\n+    //! service advertisements.\n+    const ServiceFlags nLocalServices;\n \n-/** Subversion as sent to the P2P network in `version` messages */\n-extern std::string strSubVersion;\n+    NetPermissionFlags m_permissionFlags{ PF_NONE };\n+    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n \n-struct LocalServiceInfo {\n-    int nScore;\n-    int nPort;\n-};\n+    mutable RecursiveMutex cs_addrName;\n+    std::string addrName GUARDED_BY(cs_addrName);\n \n-extern RecursiveMutex cs_mapLocalHost;\n-extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n+    // Our address, as reported by the peer\n+    CService addrLocal GUARDED_BY(cs_addrLocal);\n+    mutable RecursiveMutex cs_addrLocal;\n \n-extern const std::string NET_MESSAGE_COMMAND_OTHER;\n-typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n+    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n+    const bool m_inbound_onion{false};\n \n-class CNodeStats\n-{\n public:\n-    NodeId nodeid;\n-    ServiceFlags nServices;\n-    bool fRelayTxes;\n-    int64_t nLastSend;\n-    int64_t nLastRecv;\n-    int64_t nLastTXTime;\n-    int64_t nLastBlockTime;\n-    int64_t nTimeConnected;\n-    int64_t nTimeOffset;\n-    std::string addrName;\n-    int nVersion;\n-    std::string cleanSubVer;\n-    bool fInbound;\n-    bool m_bip152_highbandwidth_to;\n-    bool m_bip152_highbandwidth_from;\n-    int m_starting_height;\n-    uint64_t nSendBytes;\n-    mapMsgCmdSize mapSendBytesPerMsgCmd;\n-    uint64_t nRecvBytes;\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n-    NetPermissionFlags m_permissionFlags;\n-    int64_t m_ping_usec;\n-    int64_t m_ping_wait_usec;\n-    int64_t m_min_ping_usec;\n-    CAmount minFeeFilter;\n-    // Our address, as reported by the peer\n-    std::string addrLocal;\n-    // Address of this peer\n-    CAddress addr;\n-    // Bind address of our side of the connection\n-    CAddress addrBind;\n-    // Network the peer connected through\n-    Network m_network;\n-    uint32_t m_mapped_as;\n-    std::string m_conn_type_string;\n-};\n \n+    NodeId GetId() const {\n+        return id;\n+    }\n \n+    uint64_t GetLocalNonce() const {\n+        return nLocalHostNonce;\n+    }\n \n-/** Transport protocol agnostic message container.\n- * Ideally it should only contain receive time, payload,\n- * command and size.\n- */\n-class CNetMessage {\n-public:\n-    CDataStream m_recv;                  //!< received message data\n-    std::chrono::microseconds m_time{0}; //!< time of message receipt\n-    uint32_t m_message_size{0};          //!< size of the payload\n-    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n-    std::string m_command;\n+    int GetRefCount() const\n+    {\n+        assert(nRefCount >= 0);\n+        return nRefCount;\n+    }\n \n-    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n+    /**\n+     * Receive bytes from the buffer and deserialize them into messages.\n+     *\n+     * @param[in]   msg_bytes   The raw data\n+     * @param[out]  complete    Set True if at least one message has been\n+     *                          deserialized and is ready to be processed\n+     * @return  True if the peer should stay connected,\n+     *          False if the peer should be disconnected from.\n+     */\n+    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n \n-    void SetVersion(int nVersionIn)\n+    void SetCommonVersion(int greatest_common_version)\n     {\n-        m_recv.SetVersion(nVersionIn);\n+        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n+        m_greatest_common_version = greatest_common_version;\n+    }\n+    int GetCommonVersion() const\n+    {\n+        return m_greatest_common_version;\n     }\n-};\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (command & payload)\n- */\n-class TransportDeserializer {\n-public:\n-    // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n-    // decomposes a message from the context\n-    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n-    virtual ~TransportDeserializer() {}\n-};\n+    CService GetAddrLocal() const;\n+    //! May not be called more than once\n+    void SetAddrLocal(const CService& addrLocalIn);\n \n-class V1TransportDeserializer final : public TransportDeserializer\n-{\n-private:\n-    const CChainParams& m_chain_params;\n-    const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n+    CNode* AddRef()\n+    {\n+        nRefCount++;\n+        return this;\n+    }\n \n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n+    void Release()\n+    {\n+        nRefCount--;\n+    }\n \n-    void Reset() {\n-        vRecv.clear();\n-        hdrbuf.clear();\n-        hdrbuf.resize(24);\n-        in_data = false;\n-        nHdrPos = 0;\n-        nDataPos = 0;\n-        data_hash.SetNull();\n-        hasher.Reset();\n+\n+\n+    void AddAddressKnown(const CAddress& _addr)\n+    {\n+        assert(m_addr_known);\n+        m_addr_known->insert(_addr.GetKey());\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    /**\n+     * Whether the peer supports the address. For example, a peer that does not\n+     * implement BIP155 cannot receive Tor v3 addresses because it requires\n+     * ADDRv2 (BIP155) encoding.\n+     */\n+    bool IsAddrCompatible(const CAddress& addr) const\n     {\n-        Reset();\n+        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n     }\n \n-    bool Complete() const override\n+    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        // Known checking here is only to save space from duplicates.\n+        // SendMessages will filter it again for knowns that were added\n+        // after addresses were pushed.\n+        assert(m_addr_known);\n+        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n+            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n+            } else {\n+                vAddrToSend.push_back(_addr);\n+            }\n+        }\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+\n+    void AddKnownTx(const uint256& hash)\n     {\n-        hdrbuf.SetVersion(nVersionIn);\n-        vRecv.SetVersion(nVersionIn);\n+        if (m_tx_relay != nullptr) {\n+            LOCK(m_tx_relay->cs_tx_inventory);\n+            m_tx_relay->filterInventoryKnown.insert(hash);\n+        }\n     }\n-    int Read(Span<const uint8_t>& msg_bytes) override\n+\n+    void PushTxInventory(const uint256& hash)\n     {\n-        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n-        if (ret < 0) {\n-            Reset();\n-        } else {\n-            msg_bytes = msg_bytes.subspan(ret);\n+        if (m_tx_relay == nullptr) return;\n+        LOCK(m_tx_relay->cs_tx_inventory);\n+        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n+            m_tx_relay->setInventoryTxToSend.insert(hash);\n         }\n-        return ret;\n     }\n-    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+\n+    void CloseSocketDisconnect();\n+\n+    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+\n+    ServiceFlags GetLocalServices() const\n+    {\n+        return nLocalServices;\n+    }\n+\n+    std::string GetAddrName() const;\n+    //! Sets the addrName only if it was not previously set\n+    void MaybeSetAddrName(const std::string& addrNameIn);\n+\n+    std::string ConnectionTypeAsString() const;\n+\n+    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n+    bool IsInboundOnion() const { return m_inbound_onion; }\n };\n \n-/** The TransportSerializer prepares messages for the network transport\n+/**\n+ * Interface for message handling\n  */\n-class TransportSerializer {\n+class NetEventsInterface\n+{\n public:\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n-    virtual ~TransportSerializer() {}\n-};\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;\n+    virtual void InitializeNode(CNode* pnode) = 0;\n+    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n \n-class V1TransportSerializer  : public TransportSerializer {\n-public:\n-    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+protected:\n+    /**\n+     * Protected destructor so that instances can only be deleted by derived classes.\n+     * If that restriction is no longer desired, this should be made public and virtual.\n+     */\n+    ~NetEventsInterface() = default;\n };\n \n-/** Information about a peer */\n-class CNode\n+class CConnman\n {\n-    friend class CConnman;\n-    friend struct ConnmanTestMsg;\n-\n public:\n-    std::unique_ptr<TransportDeserializer> m_deserializer;\n-    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // socket\n-    std::atomic<ServiceFlags> nServices{NODE_NONE};\n-    SOCKET hSocket GUARDED_BY(cs_hSocket);\n-    /** Total size of all vSendMsg entries */\n-    size_t nSendSize GUARDED_BY(cs_vSend){0};\n-    /** Offset inside the first vSendMsg already sent */\n-    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n-    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n-    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n-    Mutex cs_vSend;\n-    Mutex cs_hSocket;\n-    Mutex cs_vRecv;\n+    enum NumConnections {\n+        CONNECTIONS_NONE = 0,\n+        CONNECTIONS_IN = (1U << 0),\n+        CONNECTIONS_OUT = (1U << 1),\n+        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n+    };\n \n-    RecursiveMutex cs_vProcessMsg;\n-    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n-    size_t nProcessQueueSize{0};\n+    struct Options\n+    {\n+        ServiceFlags nLocalServices = NODE_NONE;\n+        int nMaxConnections = 0;\n+        int m_max_outbound_full_relay = 0;\n+        int m_max_outbound_block_relay = 0;\n+        int nMaxAddnode = 0;\n+        int nMaxFeeler = 0;\n+        CClientUIInterface* uiInterface = nullptr;\n+        NetEventsInterface* m_msgproc = nullptr;\n+        BanMan* m_banman = nullptr;\n+        unsigned int nSendBufferMaxSize = 0;\n+        unsigned int nReceiveFloodSize = 0;\n+        uint64_t nMaxOutboundLimit = 0;\n+        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n+        std::vector<std::string> vSeedNodes;\n+        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+        std::vector<NetWhitebindPermissions> vWhiteBinds;\n+        std::vector<CService> vBinds;\n+        std::vector<CService> onion_binds;\n+        bool m_use_addrman_outgoing = true;\n+        std::vector<std::string> m_specified_outgoing;\n+        std::vector<std::string> m_added_nodes;\n+        std::vector<bool> m_asmap;\n+    };\n \n-    RecursiveMutex cs_sendProcessing;\n+    void Init(const Options& connOptions) {\n+        nLocalServices = connOptions.nLocalServices;\n+        nMaxConnections = connOptions.nMaxConnections;\n+        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n+        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n+        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n+        nMaxAddnode = connOptions.nMaxAddnode;\n+        nMaxFeeler = connOptions.nMaxFeeler;\n+        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n+        clientInterface = connOptions.uiInterface;\n+        m_banman = connOptions.m_banman;\n+        m_msgproc = connOptions.m_msgproc;\n+        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n+        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n+        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n+        {\n+            LOCK(cs_totalBytesSent);\n+            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n+        }\n+        vWhitelistedRange = connOptions.vWhitelistedRange;\n+        {\n+            LOCK(cs_vAddedNodes);\n+            vAddedNodes = connOptions.m_added_nodes;\n+        }\n+        m_onion_binds = connOptions.onion_binds;\n+    }\n \n-    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n+    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n+    ~CConnman();\n+    bool Start(CScheduler& scheduler, const Options& options);\n \n-    std::atomic<int64_t> nLastSend{0};\n-    std::atomic<int64_t> nLastRecv{0};\n-    const int64_t nTimeConnected;\n-    std::atomic<int64_t> nTimeOffset{0};\n-    // Address of this peer\n-    const CAddress addr;\n-    // Bind address of our side of the connection\n-    const CAddress addrBind;\n-    std::atomic<int> nVersion{0};\n-    RecursiveMutex cs_SubVer;\n-    /**\n-     * cleanSubVer is a sanitized string of the user agent byte array we read\n-     * from the wire. This cleaned string can safely be logged or displayed.\n-     */\n-    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n-    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n-    bool HasPermission(NetPermissionFlags permission) const {\n-        return NetPermissions::HasFlag(m_permissionFlags, permission);\n-    }\n-    bool fClient{false}; // set by version message\n-    bool m_limited_node{false}; //after BIP159, set by version message\n-    /**\n-     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n-     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n-     */\n-    std::atomic_bool m_wants_addrv2{false};\n-    std::atomic_bool fSuccessfullyConnected{false};\n-    // Setting fDisconnect to true will cause the node to be disconnected the\n-    // next time DisconnectNodes() runs\n-    std::atomic_bool fDisconnect{false};\n-    bool fSentAddr{false};\n-    CSemaphoreGrant grantOutbound;\n-    std::atomic<int> nRefCount{0};\n+    void StopThreads();\n+    void StopNodes();\n+    void Stop()\n+    {\n+        StopThreads();\n+        StopNodes();\n+    };\n+\n+    void Interrupt();\n+    bool GetNetworkActive() const { return fNetworkActive; };\n+    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n+    void SetNetworkActive(bool active);\n+    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n+    bool CheckIncomingNonce(uint64_t nonce);\n+\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n+\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n+\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    void ForEachNode(const NodeFn& func) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    const uint64_t nKeyedNetGroup;\n-    std::atomic_bool fPauseRecv{false};\n-    std::atomic_bool fPauseSend{false};\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    bool IsOutboundOrBlockRelayConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-                return true;\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::ADDR_FETCH:\n-            case ConnectionType::FEELER:\n-                return false;\n-        } // no default case, so the compiler can warn about missing cases\n+    // Addrman functions\n+    void SetServices(const CService &addr, ServiceFlags nServices);\n+    void MarkAddressGood(const CAddress& addr);\n+    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n+    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n+    /**\n+     * Cache is used to minimize topology leaks, so it should\n+     * be used for all non-trusted calls, for example, p2p.\n+     * A non-malicious call (from RPC or a peer with addr permission) should\n+     * call the function without a parameter to avoid using the cache.\n+     */\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n \n-        assert(false);\n-    }\n+    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n+    // a peer that is better than all our current peers.\n+    void SetTryNewOutboundPeer(bool flag);\n+    bool GetTryNewOutboundPeer();\n \n-    bool IsFullOutboundConn() const {\n-        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    void StartExtraBlockRelayPeers() {\n+        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n+        m_start_extra_block_relay_peers = true;\n     }\n \n-    bool IsManualConn() const {\n-        return m_conn_type == ConnectionType::MANUAL;\n-    }\n+    // Return the number of outbound peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // to false, we may have extra peers that we wish to disconnect). This may\n+    // return a value less than (num_outbound_connections - num_outbound_slots)\n+    // in cases where some outbound connections are not yet fully connected, or\n+    // not yet fully disconnected.\n+    int GetExtraFullOutboundCount();\n+    // Count the number of block-relay-only peers we have over our limit.\n+    int GetExtraBlockRelayCount();\n \n-    bool IsBlockOnlyConn() const {\n-        return m_conn_type == ConnectionType::BLOCK_RELAY;\n-    }\n+    bool AddNode(const std::string& node);\n+    bool RemoveAddedNode(const std::string& node);\n+    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    bool IsFeelerConn() const {\n-        return m_conn_type == ConnectionType::FEELER;\n-    }\n+    size_t GetNodeCount(NumConnections num);\n+    void GetNodeStats(std::vector<CNodeStats>& vstats);\n+    bool DisconnectNode(const std::string& node);\n+    bool DisconnectNode(const CSubNet& subnet);\n+    bool DisconnectNode(const CNetAddr& addr);\n+    bool DisconnectNode(NodeId id);\n \n-    bool IsAddrFetchConn() const {\n-        return m_conn_type == ConnectionType::ADDR_FETCH;\n-    }\n+    //! Used to convey which local services we are offering peers during node\n+    //! connection.\n+    //!\n+    //! The data returned by this is used in CNode construction,\n+    //! which is used to advertise which services we are offering\n+    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n+    ServiceFlags GetLocalServices() const;\n \n-    bool IsInboundConn() const {\n-        return m_conn_type == ConnectionType::INBOUND;\n-    }\n+    uint64_t GetMaxOutboundTarget();\n+    std::chrono::seconds GetMaxOutboundTimeframe();\n \n-    /* Whether we send addr messages over this connection */\n-    bool RelayAddrsWithConn() const\n-    {\n-        // Don't relay addr messages to peers that we connect to as block-relay-only\n-        // peers (to prevent adversaries from inferring these links from addr\n-        // traffic).\n-        return m_conn_type != ConnectionType::BLOCK_RELAY;\n-    }\n+    //! check if the outbound target is reached\n+    //! if param historicalBlockServingLimit is set true, the function will\n+    //! response true if the limit for serving historical blocks has been reached\n+    bool OutboundTargetReached(bool historicalBlockServingLimit);\n \n-    bool ExpectServicesFromConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::FEELER:\n-                return false;\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-            case ConnectionType::ADDR_FETCH:\n-                return true;\n-        } // no default case, so the compiler can warn about missing cases\n+    //! response the bytes left in the current max outbound cycle\n+    //! in case of no limit, it will always response 0\n+    uint64_t GetOutboundTargetBytesLeft();\n \n-        assert(false);\n-    }\n+    //! returns the time left in the current max outbound cycle\n+    //! in case of no limit, it will always return 0\n+    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n \n-    /**\n-     * Get network the peer connected through.\n-     *\n-     * Returns Network::NET_ONION for *inbound* onion connections,\n-     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n-     * because it doesn't detect the former, and it's not the responsibility of\n-     * the CNetAddr class to know the actual network a peer is connected through.\n-     *\n-     * @return network the peer connected through.\n-     */\n-    Network ConnectedThroughNetwork() const;\n+    uint64_t GetTotalBytesRecv();\n+    uint64_t GetTotalBytesSent();\n \n-protected:\n-    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n+    /** Get a unique deterministic randomizer. */\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-public:\n-    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_to{false};\n-    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+    unsigned int GetReceiveFloodSize() const;\n \n-    // flood relay\n-    std::vector<CAddress> vAddrToSend;\n-    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n-    bool fGetAddr{false};\n-    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n-    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    void WakeMessageHandler();\n \n-    struct TxRelay {\n-        mutable RecursiveMutex cs_filter;\n-        // We use fRelayTxes for two purposes -\n-        // a) it allows us to not relay tx invs before receiving the peer's version message\n-        // b) the peer may tell us in its version message that we should not relay tx invs\n-        //    unless it loads a bloom filter.\n-        bool fRelayTxes GUARDED_BY(cs_filter){false};\n-        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n+        Works assuming that a single interval is used.\n+        Variable intervals will result in privacy decrease.\n+    */\n+    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n \n-        mutable RecursiveMutex cs_tx_inventory;\n-        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n-        // Set of transaction ids we still have to announce.\n-        // They are sorted by the mempool before relay, so the order is not important.\n-        std::set<uint256> setInventoryTxToSend;\n-        // Used for BIP35 mempool sending\n-        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n-        // Last time a \"MEMPOOL\" request was serviced.\n-        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n-        std::chrono::microseconds nNextInvSend{0};\n+    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n \n-        RecursiveMutex cs_feeFilter;\n-        // Minimum fee rate with which to filter inv's to this node\n-        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n-        CAmount lastSentFeeFilter{0};\n-        int64_t nextSendTimeFeeFilter{0};\n+private:\n+    struct ListenSocket {\n+    public:\n+        SOCKET socket;\n+        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n+        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n+    private:\n+        NetPermissionFlags m_permissions;\n     };\n \n-    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n-    std::unique_ptr<TxRelay> m_tx_relay;\n+    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n+    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n+    bool InitBinds(\n+        const std::vector<CService>& binds,\n+        const std::vector<NetWhitebindPermissions>& whiteBinds,\n+        const std::vector<CService>& onion_binds);\n \n-    /** UNIX epoch time of the last block received from this peer that we had\n-     * not yet seen (e.g. not already received from another peer), that passed\n-     * preliminary validity checks and was saved to disk, even if we don't\n-     * connect the block or it eventually fails connection. Used as an inbound\n-     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastBlockTime{0};\n+    void ThreadOpenAddedConnections();\n+    void AddAddrFetch(const std::string& strDest);\n+    void ProcessAddrFetch();\n+    void ThreadOpenConnections(std::vector<std::string> connect);\n+    void ThreadMessageHandler();\n+    void AcceptConnection(const ListenSocket& hListenSocket);\n+    void DisconnectNodes();\n+    void NotifyNumConnectionsChanged();\n+    void InactivityCheck(CNode *pnode);\n+    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketHandler();\n+    void ThreadSocketHandler();\n+    void ThreadDNSAddressSeed();\n \n-    /** UNIX epoch time of the last transaction received from this peer that we\n-     * had not yet seen (e.g. not already received from another peer) and that\n-     * was accepted into our mempool. Used as an inbound peer eviction criterium\n-     * in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastTXTime{0};\n+    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n \n-    // Ping time measurement:\n-    // The pong reply we're expecting, or 0 if no pong expected.\n-    std::atomic<uint64_t> nPingNonceSent{0};\n-    /** When the last ping was sent, or 0 if no ping was ever sent */\n-    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n-    // Last measured round-trip time.\n-    std::atomic<int64_t> nPingUsecTime{0};\n-    // Best measured round-trip time.\n-    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n-    // Whether a ping is requested.\n-    std::atomic<bool> fPingQueued{false};\n+    CNode* FindNode(const CNetAddr& ip);\n+    CNode* FindNode(const CSubNet& subNet);\n+    CNode* FindNode(const std::string& addrName);\n+    CNode* FindNode(const CService& addr);\n+\n+    /**\n+     * Determine whether we're already connected to a given address, in order to\n+     * avoid initiating duplicate connections.\n+     */\n+    bool AlreadyConnectedToAddress(const CAddress& addr);\n+\n+    bool AttemptToEvictConnection();\n+    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n+    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n+\n+    void DeleteNode(CNode* pnode);\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n-    ~CNode();\n-    CNode(const CNode&) = delete;\n-    CNode& operator=(const CNode&) = delete;\n+    NodeId GetNewNodeId();\n \n-private:\n-    const NodeId id;\n-    const uint64_t nLocalHostNonce;\n-    const ConnectionType m_conn_type;\n-    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n+    size_t SocketSendData(CNode& node) const EXCLUSIVE_LOCKS_REQUIRED(node.cs_vSend);\n+    void DumpAddresses();\n \n-    //! Services offered to this peer.\n-    //!\n-    //! This is supplied by the parent CConnman during peer connection\n-    //! (CConnman::ConnectNode()) from its attribute of the same name.\n-    //!\n-    //! This is const because there is no protocol defined for renegotiating\n-    //! services initially offered to a peer. The set of local services we\n-    //! offer should not change after initialization.\n-    //!\n-    //! An interesting example of this is NODE_NETWORK and initial block\n-    //! download: a node which starts up from scratch doesn't have any blocks\n-    //! to serve, but still advertises NODE_NETWORK because it will eventually\n-    //! fulfill this role after IBD completes. P2P code is written in such a\n-    //! way that it can gracefully handle peers who don't make good on their\n-    //! service advertisements.\n-    const ServiceFlags nLocalServices;\n+    // Network stats\n+    void RecordBytesRecv(uint64_t bytes);\n+    void RecordBytesSent(uint64_t bytes);\n \n-    NetPermissionFlags m_permissionFlags{ PF_NONE };\n-    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n+    /**\n+     * Return vector of current BLOCK_RELAY peers.\n+     */\n+    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n \n-    mutable RecursiveMutex cs_addrName;\n-    std::string addrName GUARDED_BY(cs_addrName);\n+    // Whether the node should be passed out in ForEach* callbacks\n+    static bool NodeFullyConnected(const CNode* pnode);\n \n-    // Our address, as reported by the peer\n-    CService addrLocal GUARDED_BY(cs_addrLocal);\n-    mutable RecursiveMutex cs_addrLocal;\n+    // Network usage totals\n+    RecursiveMutex cs_totalBytesRecv;\n+    RecursiveMutex cs_totalBytesSent;\n+    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n+    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n \n-    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n-    const bool m_inbound_onion{false};\n+    // outbound limit & stats\n+    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n+    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n+    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n \n-public:\n+    // P2P timeout in seconds\n+    int64_t m_peer_connect_timeout;\n \n-    NodeId GetId() const {\n-        return id;\n-    }\n+    // Whitelisted ranges. Any node connecting from these is automatically\n+    // whitelisted (as well as those connecting to whitelisted binds).\n+    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n \n-    uint64_t GetLocalNonce() const {\n-        return nLocalHostNonce;\n-    }\n+    unsigned int nSendBufferMaxSize{0};\n+    unsigned int nReceiveFloodSize{0};\n \n-    int GetRefCount() const\n-    {\n-        assert(nRefCount >= 0);\n-        return nRefCount;\n-    }\n+    std::vector<ListenSocket> vhListenSocket;\n+    std::atomic<bool> fNetworkActive{true};\n+    bool fAddressesInitialized{false};\n+    CAddrMan addrman;\n+    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n+    RecursiveMutex m_addr_fetches_mutex;\n+    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n+    RecursiveMutex cs_vAddedNodes;\n+    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n+    std::list<CNode*> vNodesDisconnected;\n+    mutable RecursiveMutex cs_vNodes;\n+    std::atomic<NodeId> nLastNodeId{0};\n+    unsigned int nPrevNodeCount{0};\n \n     /**\n-     * Receive bytes from the buffer and deserialize them into messages.\n-     *\n-     * @param[in]   msg_bytes   The raw data\n-     * @param[out]  complete    Set True if at least one message has been\n-     *                          deserialized and is ready to be processed\n-     * @return  True if the peer should stay connected,\n-     *          False if the peer should be disconnected from.\n+     * Cache responses to addr requests to minimize privacy leak.\n+     * Attack example: scraping addrs in real-time may allow an attacker\n+     * to infer new connections of the victim by detecting new records\n+     * with fresh timestamps (per self-announcement).\n      */\n-    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n-\n-    void SetCommonVersion(int greatest_common_version)\n-    {\n-        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n-        m_greatest_common_version = greatest_common_version;\n-    }\n-    int GetCommonVersion() const\n-    {\n-        return m_greatest_common_version;\n-    }\n+    struct CachedAddrResponse {\n+        std::vector<CAddress> m_addrs_response_cache;\n+        std::chrono::microseconds m_cache_entry_expiration{0};\n+    };\n \n-    CService GetAddrLocal() const;\n-    //! May not be called more than once\n-    void SetAddrLocal(const CService& addrLocalIn);\n+    /**\n+     * Addr responses stored in different caches\n+     * per (network, local socket) prevent cross-network node identification.\n+     * If a node for example is multi-homed under Tor and IPv6,\n+     * a single cache (or no cache at all) would let an attacker\n+     * to easily detect that it is the same node by comparing responses.\n+     * Indexing by local socket prevents leakage when a node has multiple\n+     * listening addresses on the same network.\n+     *\n+     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n+     * distinct Network (up to 5) we have/had an inbound peer from,\n+     * resulting in at most ~196 KB. Every separate local socket may\n+     * add up to ~196 KB extra.\n+     */\n+    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n \n-    CNode* AddRef()\n-    {\n-        nRefCount++;\n-        return this;\n-    }\n+    /**\n+     * Services this instance offers.\n+     *\n+     * This data is replicated in each CNode instance we create during peer\n+     * connection (in ConnectNode()) under a member also called\n+     * nLocalServices.\n+     *\n+     * This data is not marked const, but after being set it should not\n+     * change. See the note in CNode::nLocalServices documentation.\n+     *\n+     * \\sa CNode::nLocalServices\n+     */\n+    ServiceFlags nLocalServices;\n \n-    void Release()\n-    {\n-        nRefCount--;\n-    }\n+    std::unique_ptr<CSemaphore> semOutbound;\n+    std::unique_ptr<CSemaphore> semAddnode;\n+    int nMaxConnections;\n \n+    // How many full-relay (tx, block, addr) outbound peers we want\n+    int m_max_outbound_full_relay;\n \n+    // How many block-relay only outbound peers we want\n+    // We do not relay tx or addr messages with these peers\n+    int m_max_outbound_block_relay;\n \n-    void AddAddressKnown(const CAddress& _addr)\n-    {\n-        assert(m_addr_known);\n-        m_addr_known->insert(_addr.GetKey());\n-    }\n+    int nMaxAddnode;\n+    int nMaxFeeler;\n+    int m_max_outbound;\n+    bool m_use_addrman_outgoing;\n+    CClientUIInterface* clientInterface;\n+    NetEventsInterface* m_msgproc;\n+    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n+    BanMan* m_banman;\n \n     /**\n-     * Whether the peer supports the address. For example, a peer that does not\n-     * implement BIP155 cannot receive Tor v3 addresses because it requires\n-     * ADDRv2 (BIP155) encoding.\n+     * Addresses that were saved during the previous clean shutdown. We'll\n+     * attempt to make block-relay-only connections to them.\n      */\n-    bool IsAddrCompatible(const CAddress& addr) const\n-    {\n-        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n-    }\n+    std::vector<CAddress> m_anchors;\n \n-    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n-    {\n-        // Known checking here is only to save space from duplicates.\n-        // SendMessages will filter it again for knowns that were added\n-        // after addresses were pushed.\n-        assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n-            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n-            } else {\n-                vAddrToSend.push_back(_addr);\n-            }\n-        }\n-    }\n+    /** SipHasher seeds for deterministic randomness */\n+    const uint64_t nSeed0, nSeed1;\n \n+    /** flag for waking the message processor. */\n+    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n \n-    void AddKnownTx(const uint256& hash)\n-    {\n-        if (m_tx_relay != nullptr) {\n-            LOCK(m_tx_relay->cs_tx_inventory);\n-            m_tx_relay->filterInventoryKnown.insert(hash);\n-        }\n-    }\n+    std::condition_variable condMsgProc;\n+    Mutex mutexMsgProc;\n+    std::atomic<bool> flagInterruptMsgProc{false};\n \n-    void PushTxInventory(const uint256& hash)\n-    {\n-        if (m_tx_relay == nullptr) return;\n-        LOCK(m_tx_relay->cs_tx_inventory);\n-        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            m_tx_relay->setInventoryTxToSend.insert(hash);\n-        }\n-    }\n+    CThreadInterrupt interruptNet;\n \n-    void CloseSocketDisconnect();\n+    std::thread threadDNSAddressSeed;\n+    std::thread threadSocketHandler;\n+    std::thread threadOpenAddedConnections;\n+    std::thread threadOpenConnections;\n+    std::thread threadMessageHandler;\n \n-    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+    /** flag for deciding to connect to an extra outbound peer,\n+     *  in excess of m_max_outbound_full_relay\n+     *  This takes the place of a feeler connection */\n+    std::atomic_bool m_try_another_outbound_peer;\n \n-    ServiceFlags GetLocalServices() const\n-    {\n-        return nLocalServices;\n-    }\n+    /** flag for initiating extra block-relay-only peer connections.\n+     *  this should only be enabled after initial chain sync has occurred,\n+     *  as these connections are intended to be short-lived and low-bandwidth.\n+     */\n+    std::atomic_bool m_start_extra_block_relay_peers{false};\n \n-    std::string GetAddrName() const;\n-    //! Sets the addrName only if it was not previously set\n-    void MaybeSetAddrName(const std::string& addrNameIn);\n+    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n \n-    std::string ConnectionTypeAsString() const;\n+    /**\n+     * A vector of -bind=<address>:<port>=onion arguments each of which is\n+     * an address and port that are designated for incoming Tor connections.\n+     */\n+    std::vector<CService> m_onion_binds;\n \n-    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n-    bool IsInboundOnion() const { return m_inbound_onion; }\n+    friend struct CConnmanTest;\n+    friend struct ConnmanTestMsg;\n };",
      "path": "src/net.h",
      "position": 1906,
      "original_position": 1906,
      "commit_id": "fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "original_commit_id": "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you touch this again, add a blank line after the class declaration.",
      "created_at": "2021-01-06T13:40:13Z",
      "updated_at": "2021-01-07T08:42:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#discussion_r552621025",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/552621025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1216,
      "original_line": 1216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/553182212",
      "pull_request_review_id": 563299405,
      "id": 553182212,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE4MjIxMg==",
      "diff_hunk": "@@ -180,1041 +180,1040 @@ enum class ConnectionType {\n     ADDR_FETCH,\n };\n \n-class NetEventsInterface;\n-class CConnman\n-{\n-public:\n-\n-    enum NumConnections {\n-        CONNECTIONS_NONE = 0,\n-        CONNECTIONS_IN = (1U << 0),\n-        CONNECTIONS_OUT = (1U << 1),\n-        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n-    };\n-\n-    struct Options\n-    {\n-        ServiceFlags nLocalServices = NODE_NONE;\n-        int nMaxConnections = 0;\n-        int m_max_outbound_full_relay = 0;\n-        int m_max_outbound_block_relay = 0;\n-        int nMaxAddnode = 0;\n-        int nMaxFeeler = 0;\n-        CClientUIInterface* uiInterface = nullptr;\n-        NetEventsInterface* m_msgproc = nullptr;\n-        BanMan* m_banman = nullptr;\n-        unsigned int nSendBufferMaxSize = 0;\n-        unsigned int nReceiveFloodSize = 0;\n-        uint64_t nMaxOutboundLimit = 0;\n-        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n-        std::vector<std::string> vSeedNodes;\n-        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n-        std::vector<NetWhitebindPermissions> vWhiteBinds;\n-        std::vector<CService> vBinds;\n-        std::vector<CService> onion_binds;\n-        bool m_use_addrman_outgoing = true;\n-        std::vector<std::string> m_specified_outgoing;\n-        std::vector<std::string> m_added_nodes;\n-        std::vector<bool> m_asmap;\n-    };\n-\n-    void Init(const Options& connOptions) {\n-        nLocalServices = connOptions.nLocalServices;\n-        nMaxConnections = connOptions.nMaxConnections;\n-        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n-        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n-        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n-        nMaxAddnode = connOptions.nMaxAddnode;\n-        nMaxFeeler = connOptions.nMaxFeeler;\n-        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n-        clientInterface = connOptions.uiInterface;\n-        m_banman = connOptions.m_banman;\n-        m_msgproc = connOptions.m_msgproc;\n-        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n-        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n-        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n-        {\n-            LOCK(cs_totalBytesSent);\n-            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n-        }\n-        vWhitelistedRange = connOptions.vWhitelistedRange;\n-        {\n-            LOCK(cs_vAddedNodes);\n-            vAddedNodes = connOptions.m_added_nodes;\n-        }\n-        m_onion_binds = connOptions.onion_binds;\n-    }\n-\n-    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n-    ~CConnman();\n-    bool Start(CScheduler& scheduler, const Options& options);\n-\n-    void StopThreads();\n-    void StopNodes();\n-    void Stop()\n-    {\n-        StopThreads();\n-        StopNodes();\n-    };\n-\n-    void Interrupt();\n-    bool GetNetworkActive() const { return fNetworkActive; };\n-    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n-    void SetNetworkActive(bool active);\n-    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n-    bool CheckIncomingNonce(uint64_t nonce);\n-\n-    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n-\n-    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n-\n-    using NodeFn = std::function<void(CNode*)>;\n-    void ForEachNode(const NodeFn& func)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    void ForEachNode(const NodeFn& func) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+void Discover();\n+void StartMapPort();\n+void InterruptMapPort();\n+void StopMapPort();\n+uint16_t GetListenPort();\n \n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+enum\n+{\n+    LOCAL_NONE,   // unknown\n+    LOCAL_IF,     // address a local interface listens on\n+    LOCAL_BIND,   // address explicit bound to\n+    LOCAL_UPNP,   // address reported by UPnP\n+    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n \n-    // Addrman functions\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n-    void MarkAddressGood(const CAddress& addr);\n-    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n-    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n-    /**\n-     * Cache is used to minimize topology leaks, so it should\n-     * be used for all non-trusted calls, for example, p2p.\n-     * A non-malicious call (from RPC or a peer with addr permission) should\n-     * call the function without a parameter to avoid using the cache.\n-     */\n-    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n+    LOCAL_MAX\n+};\n \n-    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n-    // a peer that is better than all our current peers.\n-    void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+bool IsPeerAddrLocalGood(CNode *pnode);\n+void AdvertiseLocal(CNode *pnode);\n \n-    void StartExtraBlockRelayPeers() {\n-        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n-        m_start_extra_block_relay_peers = true;\n-    }\n+/**\n+ * Mark a network as reachable or unreachable (no automatic connects to it)\n+ * @note Networks are reachable by default\n+ */\n+void SetReachable(enum Network net, bool reachable);\n+/** @returns true if the network is reachable, false otherwise */\n+bool IsReachable(enum Network net);\n+/** @returns true if the address is in a reachable network, false otherwise */\n+bool IsReachable(const CNetAddr& addr);\n \n-    // Return the number of outbound peers we have in excess of our target (eg,\n-    // if we previously called SetTryNewOutboundPeer(true), and have since set\n-    // to false, we may have extra peers that we wish to disconnect). This may\n-    // return a value less than (num_outbound_connections - num_outbound_slots)\n-    // in cases where some outbound connections are not yet fully connected, or\n-    // not yet fully disconnected.\n-    int GetExtraFullOutboundCount();\n-    // Count the number of block-relay-only peers we have over our limit.\n-    int GetExtraBlockRelayCount();\n+bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n+bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n+void RemoveLocal(const CService& addr);\n+bool SeenLocal(const CService& addr);\n+bool IsLocal(const CService& addr);\n+bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n+CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n \n-    bool AddNode(const std::string& node);\n-    bool RemoveAddedNode(const std::string& node);\n-    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    size_t GetNodeCount(NumConnections num);\n-    void GetNodeStats(std::vector<CNodeStats>& vstats);\n-    bool DisconnectNode(const std::string& node);\n-    bool DisconnectNode(const CSubNet& subnet);\n-    bool DisconnectNode(const CNetAddr& addr);\n-    bool DisconnectNode(NodeId id);\n+extern bool fDiscover;\n+extern bool fListen;\n \n-    //! Used to convey which local services we are offering peers during node\n-    //! connection.\n-    //!\n-    //! The data returned by this is used in CNode construction,\n-    //! which is used to advertise which services we are offering\n-    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n-    ServiceFlags GetLocalServices() const;\n+/** Subversion as sent to the P2P network in `version` messages */\n+extern std::string strSubVersion;\n \n-    uint64_t GetMaxOutboundTarget();\n-    std::chrono::seconds GetMaxOutboundTimeframe();\n+struct LocalServiceInfo {\n+    int nScore;\n+    int nPort;\n+};\n \n-    //! check if the outbound target is reached\n-    //! if param historicalBlockServingLimit is set true, the function will\n-    //! response true if the limit for serving historical blocks has been reached\n-    bool OutboundTargetReached(bool historicalBlockServingLimit);\n+extern RecursiveMutex cs_mapLocalHost;\n+extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n \n-    //! response the bytes left in the current max outbound cycle\n-    //! in case of no limit, it will always response 0\n-    uint64_t GetOutboundTargetBytesLeft();\n+extern const std::string NET_MESSAGE_COMMAND_OTHER;\n+typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n \n-    //! returns the time left in the current max outbound cycle\n-    //! in case of no limit, it will always return 0\n-    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n+class CNodeStats\n+{\n+public:\n+    NodeId nodeid;\n+    ServiceFlags nServices;\n+    bool fRelayTxes;\n+    int64_t nLastSend;\n+    int64_t nLastRecv;\n+    int64_t nLastTXTime;\n+    int64_t nLastBlockTime;\n+    int64_t nTimeConnected;\n+    int64_t nTimeOffset;\n+    std::string addrName;\n+    int nVersion;\n+    std::string cleanSubVer;\n+    bool fInbound;\n+    bool m_bip152_highbandwidth_to;\n+    bool m_bip152_highbandwidth_from;\n+    int m_starting_height;\n+    uint64_t nSendBytes;\n+    mapMsgCmdSize mapSendBytesPerMsgCmd;\n+    uint64_t nRecvBytes;\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n+    NetPermissionFlags m_permissionFlags;\n+    int64_t m_ping_usec;\n+    int64_t m_ping_wait_usec;\n+    int64_t m_min_ping_usec;\n+    CAmount minFeeFilter;\n+    // Our address, as reported by the peer\n+    std::string addrLocal;\n+    // Address of this peer\n+    CAddress addr;\n+    // Bind address of our side of the connection\n+    CAddress addrBind;\n+    // Network the peer connected through\n+    Network m_network;\n+    uint32_t m_mapped_as;\n+    std::string m_conn_type_string;\n+};\n \n-    uint64_t GetTotalBytesRecv();\n-    uint64_t GetTotalBytesSent();\n \n-    /** Get a unique deterministic randomizer. */\n-    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-    unsigned int GetReceiveFloodSize() const;\n+/** Transport protocol agnostic message container.\n+ * Ideally it should only contain receive time, payload,\n+ * command and size.\n+ */\n+class CNetMessage {\n+public:\n+    CDataStream m_recv;                  //!< received message data\n+    std::chrono::microseconds m_time{0}; //!< time of message receipt\n+    uint32_t m_message_size{0};          //!< size of the payload\n+    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n+    std::string m_command;\n \n-    void WakeMessageHandler();\n+    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n \n-    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n-        Works assuming that a single interval is used.\n-        Variable intervals will result in privacy decrease.\n-    */\n-    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n+    void SetVersion(int nVersionIn)\n+    {\n+        m_recv.SetVersion(nVersionIn);\n+    }\n+};\n \n-    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n+/** The TransportDeserializer takes care of holding and deserializing the\n+ * network receive buffer. It can deserialize the network buffer into a\n+ * transport protocol agnostic CNetMessage (command & payload)\n+ */\n+class TransportDeserializer {\n+public:\n+    // returns true if the current deserialization is complete\n+    virtual bool Complete() const = 0;\n+    // set the serialization context version\n+    virtual void SetVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer */\n+    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    // decomposes a message from the context\n+    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n+    virtual ~TransportDeserializer() {}\n+};\n \n+class V1TransportDeserializer final : public TransportDeserializer\n+{\n private:\n-    struct ListenSocket {\n-    public:\n-        SOCKET socket;\n-        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n-        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n-    private:\n-        NetPermissionFlags m_permissions;\n-    };\n-\n-    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n-    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n-    bool InitBinds(\n-        const std::vector<CService>& binds,\n-        const std::vector<NetWhitebindPermissions>& whiteBinds,\n-        const std::vector<CService>& onion_binds);\n-\n-    void ThreadOpenAddedConnections();\n-    void AddAddrFetch(const std::string& strDest);\n-    void ProcessAddrFetch();\n-    void ThreadOpenConnections(std::vector<std::string> connect);\n-    void ThreadMessageHandler();\n-    void AcceptConnection(const ListenSocket& hListenSocket);\n-    void DisconnectNodes();\n-    void NotifyNumConnectionsChanged();\n-    void InactivityCheck(CNode *pnode);\n-    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketHandler();\n-    void ThreadSocketHandler();\n-    void ThreadDNSAddressSeed();\n-\n-    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n-\n-    CNode* FindNode(const CNetAddr& ip);\n-    CNode* FindNode(const CSubNet& subNet);\n-    CNode* FindNode(const std::string& addrName);\n-    CNode* FindNode(const CService& addr);\n-\n-    /**\n-     * Determine whether we're already connected to a given address, in order to\n-     * avoid initiating duplicate connections.\n-     */\n-    bool AlreadyConnectedToAddress(const CAddress& addr);\n-\n-    bool AttemptToEvictConnection();\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n-    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n-\n-    void DeleteNode(CNode* pnode);\n+    const CChainParams& m_chain_params;\n+    const NodeId m_node_id; // Only for logging\n+    mutable CHash256 hasher;\n+    mutable uint256 data_hash;\n+    bool in_data;                   // parsing header (false) or data (true)\n+    CDataStream hdrbuf;             // partially received header\n+    CMessageHeader hdr;             // complete header\n+    CDataStream vRecv;              // received message data\n+    unsigned int nHdrPos;\n+    unsigned int nDataPos;\n \n-    NodeId GetNewNodeId();\n+    const uint256& GetMessageHash() const;\n+    int readHeader(Span<const uint8_t> msg_bytes);\n+    int readData(Span<const uint8_t> msg_bytes);\n \n-    size_t SocketSendData(CNode *pnode) const;\n-    void DumpAddresses();\n+    void Reset() {\n+        vRecv.clear();\n+        hdrbuf.clear();\n+        hdrbuf.resize(24);\n+        in_data = false;\n+        nHdrPos = 0;\n+        nDataPos = 0;\n+        data_hash.SetNull();\n+        hasher.Reset();\n+    }\n \n-    // Network stats\n-    void RecordBytesRecv(uint64_t bytes);\n-    void RecordBytesSent(uint64_t bytes);\n+public:\n+    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n+        : m_chain_params(chain_params),\n+          m_node_id(node_id),\n+          hdrbuf(nTypeIn, nVersionIn),\n+          vRecv(nTypeIn, nVersionIn)\n+    {\n+        Reset();\n+    }\n \n-    /**\n-     * Return vector of current BLOCK_RELAY peers.\n-     */\n-    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n+    bool Complete() const override\n+    {\n+        if (!in_data)\n+            return false;\n+        return (hdr.nMessageSize == nDataPos);\n+    }\n+    void SetVersion(int nVersionIn) override\n+    {\n+        hdrbuf.SetVersion(nVersionIn);\n+        vRecv.SetVersion(nVersionIn);\n+    }\n+    int Read(Span<const uint8_t>& msg_bytes) override\n+    {\n+        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n+        if (ret < 0) {\n+            Reset();\n+        } else {\n+            msg_bytes = msg_bytes.subspan(ret);\n+        }\n+        return ret;\n+    }\n+    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+};\n \n-    // Whether the node should be passed out in ForEach* callbacks\n-    static bool NodeFullyConnected(const CNode* pnode);\n+/** The TransportSerializer prepares messages for the network transport\n+ */\n+class TransportSerializer {\n+public:\n+    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n+    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n+    virtual ~TransportSerializer() {}\n+};\n \n-    // Network usage totals\n-    RecursiveMutex cs_totalBytesRecv;\n-    RecursiveMutex cs_totalBytesSent;\n-    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n-    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n+class V1TransportSerializer  : public TransportSerializer {\n+public:\n+    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+};\n \n-    // outbound limit & stats\n-    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n-    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n-    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n+/** Information about a peer */\n+class CNode\n+{\n+    friend class CConnman;\n+    friend struct ConnmanTestMsg;\n \n-    // P2P timeout in seconds\n-    int64_t m_peer_connect_timeout;\n+public:\n+    std::unique_ptr<TransportDeserializer> m_deserializer;\n+    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // Whitelisted ranges. Any node connecting from these is automatically\n-    // whitelisted (as well as those connecting to whitelisted binds).\n-    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+    // socket\n+    std::atomic<ServiceFlags> nServices{NODE_NONE};\n+    SOCKET hSocket GUARDED_BY(cs_hSocket);\n+    /** Total size of all vSendMsg entries */\n+    size_t nSendSize GUARDED_BY(cs_vSend){0};\n+    /** Offset inside the first vSendMsg already sent */\n+    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n+    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n+    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n+    Mutex cs_vSend;\n+    Mutex cs_hSocket;\n+    Mutex cs_vRecv;\n \n-    unsigned int nSendBufferMaxSize{0};\n-    unsigned int nReceiveFloodSize{0};\n+    RecursiveMutex cs_vProcessMsg;\n+    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n+    size_t nProcessQueueSize{0};\n \n-    std::vector<ListenSocket> vhListenSocket;\n-    std::atomic<bool> fNetworkActive{true};\n-    bool fAddressesInitialized{false};\n-    CAddrMan addrman;\n-    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n-    RecursiveMutex m_addr_fetches_mutex;\n-    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    RecursiveMutex cs_vAddedNodes;\n-    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n-    std::list<CNode*> vNodesDisconnected;\n-    mutable RecursiveMutex cs_vNodes;\n-    std::atomic<NodeId> nLastNodeId{0};\n-    unsigned int nPrevNodeCount{0};\n+    RecursiveMutex cs_sendProcessing;\n \n-    /**\n-     * Cache responses to addr requests to minimize privacy leak.\n-     * Attack example: scraping addrs in real-time may allow an attacker\n-     * to infer new connections of the victim by detecting new records\n-     * with fresh timestamps (per self-announcement).\n-     */\n-    struct CachedAddrResponse {\n-        std::vector<CAddress> m_addrs_response_cache;\n-        std::chrono::microseconds m_cache_entry_expiration{0};\n-    };\n+    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n \n+    std::atomic<int64_t> nLastSend{0};\n+    std::atomic<int64_t> nLastRecv{0};\n+    const int64_t nTimeConnected;\n+    std::atomic<int64_t> nTimeOffset{0};\n+    // Address of this peer\n+    const CAddress addr;\n+    // Bind address of our side of the connection\n+    const CAddress addrBind;\n+    std::atomic<int> nVersion{0};\n+    RecursiveMutex cs_SubVer;\n     /**\n-     * Addr responses stored in different caches\n-     * per (network, local socket) prevent cross-network node identification.\n-     * If a node for example is multi-homed under Tor and IPv6,\n-     * a single cache (or no cache at all) would let an attacker\n-     * to easily detect that it is the same node by comparing responses.\n-     * Indexing by local socket prevents leakage when a node has multiple\n-     * listening addresses on the same network.\n-     *\n-     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n-     * distinct Network (up to 5) we have/had an inbound peer from,\n-     * resulting in at most ~196 KB. Every separate local socket may\n-     * add up to ~196 KB extra.\n+     * cleanSubVer is a sanitized string of the user agent byte array we read\n+     * from the wire. This cleaned string can safely be logged or displayed.\n      */\n-    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n-\n+    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n+    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n+    bool HasPermission(NetPermissionFlags permission) const {\n+        return NetPermissions::HasFlag(m_permissionFlags, permission);\n+    }\n+    bool fClient{false}; // set by version message\n+    bool m_limited_node{false}; //after BIP159, set by version message\n     /**\n-     * Services this instance offers.\n-     *\n-     * This data is replicated in each CNode instance we create during peer\n-     * connection (in ConnectNode()) under a member also called\n-     * nLocalServices.\n-     *\n-     * This data is not marked const, but after being set it should not\n-     * change. See the note in CNode::nLocalServices documentation.\n-     *\n-     * \\sa CNode::nLocalServices\n+     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n+     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n      */\n-    ServiceFlags nLocalServices;\n-\n-    std::unique_ptr<CSemaphore> semOutbound;\n-    std::unique_ptr<CSemaphore> semAddnode;\n-    int nMaxConnections;\n+    std::atomic_bool m_wants_addrv2{false};\n+    std::atomic_bool fSuccessfullyConnected{false};\n+    // Setting fDisconnect to true will cause the node to be disconnected the\n+    // next time DisconnectNodes() runs\n+    std::atomic_bool fDisconnect{false};\n+    bool fSentAddr{false};\n+    CSemaphoreGrant grantOutbound;\n+    std::atomic<int> nRefCount{0};\n \n-    // How many full-relay (tx, block, addr) outbound peers we want\n-    int m_max_outbound_full_relay;\n+    const uint64_t nKeyedNetGroup;\n+    std::atomic_bool fPauseRecv{false};\n+    std::atomic_bool fPauseSend{false};\n \n-    // How many block-relay only outbound peers we want\n-    // We do not relay tx or addr messages with these peers\n-    int m_max_outbound_block_relay;\n+    bool IsOutboundOrBlockRelayConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+                return true;\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::ADDR_FETCH:\n+            case ConnectionType::FEELER:\n+                return false;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    int nMaxAddnode;\n-    int nMaxFeeler;\n-    int m_max_outbound;\n-    bool m_use_addrman_outgoing;\n-    CClientUIInterface* clientInterface;\n-    NetEventsInterface* m_msgproc;\n-    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n-    BanMan* m_banman;\n+        assert(false);\n+    }\n \n-    /**\n-     * Addresses that were saved during the previous clean shutdown. We'll\n-     * attempt to make block-relay-only connections to them.\n-     */\n-    std::vector<CAddress> m_anchors;\n+    bool IsFullOutboundConn() const {\n+        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    }\n \n-    /** SipHasher seeds for deterministic randomness */\n-    const uint64_t nSeed0, nSeed1;\n+    bool IsManualConn() const {\n+        return m_conn_type == ConnectionType::MANUAL;\n+    }\n \n-    /** flag for waking the message processor. */\n-    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n+    bool IsBlockOnlyConn() const {\n+        return m_conn_type == ConnectionType::BLOCK_RELAY;\n+    }\n \n-    std::condition_variable condMsgProc;\n-    Mutex mutexMsgProc;\n-    std::atomic<bool> flagInterruptMsgProc{false};\n+    bool IsFeelerConn() const {\n+        return m_conn_type == ConnectionType::FEELER;\n+    }\n \n-    CThreadInterrupt interruptNet;\n+    bool IsAddrFetchConn() const {\n+        return m_conn_type == ConnectionType::ADDR_FETCH;\n+    }\n \n-    std::thread threadDNSAddressSeed;\n-    std::thread threadSocketHandler;\n-    std::thread threadOpenAddedConnections;\n-    std::thread threadOpenConnections;\n-    std::thread threadMessageHandler;\n+    bool IsInboundConn() const {\n+        return m_conn_type == ConnectionType::INBOUND;\n+    }\n \n-    /** flag for deciding to connect to an extra outbound peer,\n-     *  in excess of m_max_outbound_full_relay\n-     *  This takes the place of a feeler connection */\n-    std::atomic_bool m_try_another_outbound_peer;\n+    /* Whether we send addr messages over this connection */\n+    bool RelayAddrsWithConn() const\n+    {\n+        // Don't relay addr messages to peers that we connect to as block-relay-only\n+        // peers (to prevent adversaries from inferring these links from addr\n+        // traffic).\n+        return m_conn_type != ConnectionType::BLOCK_RELAY;\n+    }\n \n-    /** flag for initiating extra block-relay-only peer connections.\n-     *  this should only be enabled after initial chain sync has occurred,\n-     *  as these connections are intended to be short-lived and low-bandwidth.\n-     */\n-    std::atomic_bool m_start_extra_block_relay_peers{false};\n+    bool ExpectServicesFromConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::FEELER:\n+                return false;\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+            case ConnectionType::ADDR_FETCH:\n+                return true;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n+        assert(false);\n+    }\n \n     /**\n-     * A vector of -bind=<address>:<port>=onion arguments each of which is\n-     * an address and port that are designated for incoming Tor connections.\n+     * Get network the peer connected through.\n+     *\n+     * Returns Network::NET_ONION for *inbound* onion connections,\n+     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n+     * because it doesn't detect the former, and it's not the responsibility of\n+     * the CNetAddr class to know the actual network a peer is connected through.\n+     *\n+     * @return network the peer connected through.\n      */\n-    std::vector<CService> m_onion_binds;\n+    Network ConnectedThroughNetwork() const;\n \n-    friend struct CConnmanTest;\n-    friend struct ConnmanTestMsg;\n-};\n-void Discover();\n-void StartMapPort();\n-void InterruptMapPort();\n-void StopMapPort();\n-uint16_t GetListenPort();\n+protected:\n+    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n \n-/**\n- * Interface for message handling\n- */\n-class NetEventsInterface\n-{\n public:\n-    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode) = 0;\n-    virtual void InitializeNode(CNode* pnode) = 0;\n-    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n+    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_to{false};\n+    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+\n+    // flood relay\n+    std::vector<CAddress> vAddrToSend;\n+    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n+    bool fGetAddr{false};\n+    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+\n+    struct TxRelay {\n+        mutable RecursiveMutex cs_filter;\n+        // We use fRelayTxes for two purposes -\n+        // a) it allows us to not relay tx invs before receiving the peer's version message\n+        // b) the peer may tell us in its version message that we should not relay tx invs\n+        //    unless it loads a bloom filter.\n+        bool fRelayTxes GUARDED_BY(cs_filter){false};\n+        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+\n+        mutable RecursiveMutex cs_tx_inventory;\n+        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n+        // Set of transaction ids we still have to announce.\n+        // They are sorted by the mempool before relay, so the order is not important.\n+        std::set<uint256> setInventoryTxToSend;\n+        // Used for BIP35 mempool sending\n+        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n+        // Last time a \"MEMPOOL\" request was serviced.\n+        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n+        std::chrono::microseconds nNextInvSend{0};\n \n-protected:\n-    /**\n-     * Protected destructor so that instances can only be deleted by derived classes.\n-     * If that restriction is no longer desired, this should be made public and virtual.\n-     */\n-    ~NetEventsInterface() = default;\n-};\n+        RecursiveMutex cs_feeFilter;\n+        // Minimum fee rate with which to filter inv's to this node\n+        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n+        CAmount lastSentFeeFilter{0};\n+        int64_t nextSendTimeFeeFilter{0};\n+    };\n \n-enum\n-{\n-    LOCAL_NONE,   // unknown\n-    LOCAL_IF,     // address a local interface listens on\n-    LOCAL_BIND,   // address explicit bound to\n-    LOCAL_UPNP,   // address reported by UPnP\n-    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n+    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n+    std::unique_ptr<TxRelay> m_tx_relay;\n \n-    LOCAL_MAX\n-};\n+    /** UNIX epoch time of the last block received from this peer that we had\n+     * not yet seen (e.g. not already received from another peer), that passed\n+     * preliminary validity checks and was saved to disk, even if we don't\n+     * connect the block or it eventually fails connection. Used as an inbound\n+     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastBlockTime{0};\n \n-bool IsPeerAddrLocalGood(CNode *pnode);\n-void AdvertiseLocal(CNode *pnode);\n+    /** UNIX epoch time of the last transaction received from this peer that we\n+     * had not yet seen (e.g. not already received from another peer) and that\n+     * was accepted into our mempool. Used as an inbound peer eviction criterium\n+     * in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastTXTime{0};\n \n-/**\n- * Mark a network as reachable or unreachable (no automatic connects to it)\n- * @note Networks are reachable by default\n- */\n-void SetReachable(enum Network net, bool reachable);\n-/** @returns true if the network is reachable, false otherwise */\n-bool IsReachable(enum Network net);\n-/** @returns true if the address is in a reachable network, false otherwise */\n-bool IsReachable(const CNetAddr& addr);\n+    // Ping time measurement:\n+    // The pong reply we're expecting, or 0 if no pong expected.\n+    std::atomic<uint64_t> nPingNonceSent{0};\n+    /** When the last ping was sent, or 0 if no ping was ever sent */\n+    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n+    // Last measured round-trip time.\n+    std::atomic<int64_t> nPingUsecTime{0};\n+    // Best measured round-trip time.\n+    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n+    // Whether a ping is requested.\n+    std::atomic<bool> fPingQueued{false};\n \n-bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n-bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n-void RemoveLocal(const CService& addr);\n-bool SeenLocal(const CService& addr);\n-bool IsLocal(const CService& addr);\n-bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n+    ~CNode();\n+    CNode(const CNode&) = delete;\n+    CNode& operator=(const CNode&) = delete;\n \n+private:\n+    const NodeId id;\n+    const uint64_t nLocalHostNonce;\n+    const ConnectionType m_conn_type;\n+    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n \n-extern bool fDiscover;\n-extern bool fListen;\n+    //! Services offered to this peer.\n+    //!\n+    //! This is supplied by the parent CConnman during peer connection\n+    //! (CConnman::ConnectNode()) from its attribute of the same name.\n+    //!\n+    //! This is const because there is no protocol defined for renegotiating\n+    //! services initially offered to a peer. The set of local services we\n+    //! offer should not change after initialization.\n+    //!\n+    //! An interesting example of this is NODE_NETWORK and initial block\n+    //! download: a node which starts up from scratch doesn't have any blocks\n+    //! to serve, but still advertises NODE_NETWORK because it will eventually\n+    //! fulfill this role after IBD completes. P2P code is written in such a\n+    //! way that it can gracefully handle peers who don't make good on their\n+    //! service advertisements.\n+    const ServiceFlags nLocalServices;\n \n-/** Subversion as sent to the P2P network in `version` messages */\n-extern std::string strSubVersion;\n+    NetPermissionFlags m_permissionFlags{ PF_NONE };\n+    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n \n-struct LocalServiceInfo {\n-    int nScore;\n-    int nPort;\n-};\n+    mutable RecursiveMutex cs_addrName;\n+    std::string addrName GUARDED_BY(cs_addrName);\n \n-extern RecursiveMutex cs_mapLocalHost;\n-extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n+    // Our address, as reported by the peer\n+    CService addrLocal GUARDED_BY(cs_addrLocal);\n+    mutable RecursiveMutex cs_addrLocal;\n \n-extern const std::string NET_MESSAGE_COMMAND_OTHER;\n-typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n+    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n+    const bool m_inbound_onion{false};\n \n-class CNodeStats\n-{\n public:\n-    NodeId nodeid;\n-    ServiceFlags nServices;\n-    bool fRelayTxes;\n-    int64_t nLastSend;\n-    int64_t nLastRecv;\n-    int64_t nLastTXTime;\n-    int64_t nLastBlockTime;\n-    int64_t nTimeConnected;\n-    int64_t nTimeOffset;\n-    std::string addrName;\n-    int nVersion;\n-    std::string cleanSubVer;\n-    bool fInbound;\n-    bool m_bip152_highbandwidth_to;\n-    bool m_bip152_highbandwidth_from;\n-    int m_starting_height;\n-    uint64_t nSendBytes;\n-    mapMsgCmdSize mapSendBytesPerMsgCmd;\n-    uint64_t nRecvBytes;\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n-    NetPermissionFlags m_permissionFlags;\n-    int64_t m_ping_usec;\n-    int64_t m_ping_wait_usec;\n-    int64_t m_min_ping_usec;\n-    CAmount minFeeFilter;\n-    // Our address, as reported by the peer\n-    std::string addrLocal;\n-    // Address of this peer\n-    CAddress addr;\n-    // Bind address of our side of the connection\n-    CAddress addrBind;\n-    // Network the peer connected through\n-    Network m_network;\n-    uint32_t m_mapped_as;\n-    std::string m_conn_type_string;\n-};\n \n+    NodeId GetId() const {\n+        return id;\n+    }\n \n+    uint64_t GetLocalNonce() const {\n+        return nLocalHostNonce;\n+    }\n \n-/** Transport protocol agnostic message container.\n- * Ideally it should only contain receive time, payload,\n- * command and size.\n- */\n-class CNetMessage {\n-public:\n-    CDataStream m_recv;                  //!< received message data\n-    std::chrono::microseconds m_time{0}; //!< time of message receipt\n-    uint32_t m_message_size{0};          //!< size of the payload\n-    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n-    std::string m_command;\n+    int GetRefCount() const\n+    {\n+        assert(nRefCount >= 0);\n+        return nRefCount;\n+    }\n \n-    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n+    /**\n+     * Receive bytes from the buffer and deserialize them into messages.\n+     *\n+     * @param[in]   msg_bytes   The raw data\n+     * @param[out]  complete    Set True if at least one message has been\n+     *                          deserialized and is ready to be processed\n+     * @return  True if the peer should stay connected,\n+     *          False if the peer should be disconnected from.\n+     */\n+    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n \n-    void SetVersion(int nVersionIn)\n+    void SetCommonVersion(int greatest_common_version)\n     {\n-        m_recv.SetVersion(nVersionIn);\n+        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n+        m_greatest_common_version = greatest_common_version;\n+    }\n+    int GetCommonVersion() const\n+    {\n+        return m_greatest_common_version;\n     }\n-};\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (command & payload)\n- */\n-class TransportDeserializer {\n-public:\n-    // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n-    // decomposes a message from the context\n-    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n-    virtual ~TransportDeserializer() {}\n-};\n+    CService GetAddrLocal() const;\n+    //! May not be called more than once\n+    void SetAddrLocal(const CService& addrLocalIn);\n \n-class V1TransportDeserializer final : public TransportDeserializer\n-{\n-private:\n-    const CChainParams& m_chain_params;\n-    const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n+    CNode* AddRef()\n+    {\n+        nRefCount++;\n+        return this;\n+    }\n \n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n+    void Release()\n+    {\n+        nRefCount--;\n+    }\n \n-    void Reset() {\n-        vRecv.clear();\n-        hdrbuf.clear();\n-        hdrbuf.resize(24);\n-        in_data = false;\n-        nHdrPos = 0;\n-        nDataPos = 0;\n-        data_hash.SetNull();\n-        hasher.Reset();\n+\n+\n+    void AddAddressKnown(const CAddress& _addr)\n+    {\n+        assert(m_addr_known);\n+        m_addr_known->insert(_addr.GetKey());\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    /**\n+     * Whether the peer supports the address. For example, a peer that does not\n+     * implement BIP155 cannot receive Tor v3 addresses because it requires\n+     * ADDRv2 (BIP155) encoding.\n+     */\n+    bool IsAddrCompatible(const CAddress& addr) const\n     {\n-        Reset();\n+        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n     }\n \n-    bool Complete() const override\n+    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        // Known checking here is only to save space from duplicates.\n+        // SendMessages will filter it again for knowns that were added\n+        // after addresses were pushed.\n+        assert(m_addr_known);\n+        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n+            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n+            } else {\n+                vAddrToSend.push_back(_addr);\n+            }\n+        }\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+\n+    void AddKnownTx(const uint256& hash)\n     {\n-        hdrbuf.SetVersion(nVersionIn);\n-        vRecv.SetVersion(nVersionIn);\n+        if (m_tx_relay != nullptr) {\n+            LOCK(m_tx_relay->cs_tx_inventory);\n+            m_tx_relay->filterInventoryKnown.insert(hash);\n+        }\n     }\n-    int Read(Span<const uint8_t>& msg_bytes) override\n+\n+    void PushTxInventory(const uint256& hash)\n     {\n-        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n-        if (ret < 0) {\n-            Reset();\n-        } else {\n-            msg_bytes = msg_bytes.subspan(ret);\n+        if (m_tx_relay == nullptr) return;\n+        LOCK(m_tx_relay->cs_tx_inventory);\n+        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n+            m_tx_relay->setInventoryTxToSend.insert(hash);\n         }\n-        return ret;\n     }\n-    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+\n+    void CloseSocketDisconnect();\n+\n+    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+\n+    ServiceFlags GetLocalServices() const\n+    {\n+        return nLocalServices;\n+    }\n+\n+    std::string GetAddrName() const;\n+    //! Sets the addrName only if it was not previously set\n+    void MaybeSetAddrName(const std::string& addrNameIn);\n+\n+    std::string ConnectionTypeAsString() const;\n+\n+    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n+    bool IsInboundOnion() const { return m_inbound_onion; }\n };\n \n-/** The TransportSerializer prepares messages for the network transport\n+/**\n+ * Interface for message handling\n  */\n-class TransportSerializer {\n+class NetEventsInterface\n+{\n public:\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n-    virtual ~TransportSerializer() {}\n-};\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;\n+    virtual void InitializeNode(CNode* pnode) = 0;\n+    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n \n-class V1TransportSerializer  : public TransportSerializer {\n-public:\n-    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+protected:\n+    /**\n+     * Protected destructor so that instances can only be deleted by derived classes.\n+     * If that restriction is no longer desired, this should be made public and virtual.\n+     */\n+    ~NetEventsInterface() = default;\n };\n \n-/** Information about a peer */\n-class CNode\n+class CConnman\n {\n-    friend class CConnman;\n-    friend struct ConnmanTestMsg;\n-\n public:\n-    std::unique_ptr<TransportDeserializer> m_deserializer;\n-    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // socket\n-    std::atomic<ServiceFlags> nServices{NODE_NONE};\n-    SOCKET hSocket GUARDED_BY(cs_hSocket);\n-    /** Total size of all vSendMsg entries */\n-    size_t nSendSize GUARDED_BY(cs_vSend){0};\n-    /** Offset inside the first vSendMsg already sent */\n-    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n-    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n-    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n-    Mutex cs_vSend;\n-    Mutex cs_hSocket;\n-    Mutex cs_vRecv;\n+    enum NumConnections {\n+        CONNECTIONS_NONE = 0,\n+        CONNECTIONS_IN = (1U << 0),\n+        CONNECTIONS_OUT = (1U << 1),\n+        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n+    };\n \n-    RecursiveMutex cs_vProcessMsg;\n-    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n-    size_t nProcessQueueSize{0};\n+    struct Options\n+    {\n+        ServiceFlags nLocalServices = NODE_NONE;\n+        int nMaxConnections = 0;\n+        int m_max_outbound_full_relay = 0;\n+        int m_max_outbound_block_relay = 0;\n+        int nMaxAddnode = 0;\n+        int nMaxFeeler = 0;\n+        CClientUIInterface* uiInterface = nullptr;\n+        NetEventsInterface* m_msgproc = nullptr;\n+        BanMan* m_banman = nullptr;\n+        unsigned int nSendBufferMaxSize = 0;\n+        unsigned int nReceiveFloodSize = 0;\n+        uint64_t nMaxOutboundLimit = 0;\n+        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n+        std::vector<std::string> vSeedNodes;\n+        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+        std::vector<NetWhitebindPermissions> vWhiteBinds;\n+        std::vector<CService> vBinds;\n+        std::vector<CService> onion_binds;\n+        bool m_use_addrman_outgoing = true;\n+        std::vector<std::string> m_specified_outgoing;\n+        std::vector<std::string> m_added_nodes;\n+        std::vector<bool> m_asmap;\n+    };\n \n-    RecursiveMutex cs_sendProcessing;\n+    void Init(const Options& connOptions) {\n+        nLocalServices = connOptions.nLocalServices;\n+        nMaxConnections = connOptions.nMaxConnections;\n+        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n+        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n+        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n+        nMaxAddnode = connOptions.nMaxAddnode;\n+        nMaxFeeler = connOptions.nMaxFeeler;\n+        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n+        clientInterface = connOptions.uiInterface;\n+        m_banman = connOptions.m_banman;\n+        m_msgproc = connOptions.m_msgproc;\n+        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n+        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n+        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n+        {\n+            LOCK(cs_totalBytesSent);\n+            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n+        }\n+        vWhitelistedRange = connOptions.vWhitelistedRange;\n+        {\n+            LOCK(cs_vAddedNodes);\n+            vAddedNodes = connOptions.m_added_nodes;\n+        }\n+        m_onion_binds = connOptions.onion_binds;\n+    }\n \n-    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n+    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n+    ~CConnman();\n+    bool Start(CScheduler& scheduler, const Options& options);\n \n-    std::atomic<int64_t> nLastSend{0};\n-    std::atomic<int64_t> nLastRecv{0};\n-    const int64_t nTimeConnected;\n-    std::atomic<int64_t> nTimeOffset{0};\n-    // Address of this peer\n-    const CAddress addr;\n-    // Bind address of our side of the connection\n-    const CAddress addrBind;\n-    std::atomic<int> nVersion{0};\n-    RecursiveMutex cs_SubVer;\n-    /**\n-     * cleanSubVer is a sanitized string of the user agent byte array we read\n-     * from the wire. This cleaned string can safely be logged or displayed.\n-     */\n-    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n-    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n-    bool HasPermission(NetPermissionFlags permission) const {\n-        return NetPermissions::HasFlag(m_permissionFlags, permission);\n-    }\n-    bool fClient{false}; // set by version message\n-    bool m_limited_node{false}; //after BIP159, set by version message\n-    /**\n-     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n-     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n-     */\n-    std::atomic_bool m_wants_addrv2{false};\n-    std::atomic_bool fSuccessfullyConnected{false};\n-    // Setting fDisconnect to true will cause the node to be disconnected the\n-    // next time DisconnectNodes() runs\n-    std::atomic_bool fDisconnect{false};\n-    bool fSentAddr{false};\n-    CSemaphoreGrant grantOutbound;\n-    std::atomic<int> nRefCount{0};\n+    void StopThreads();\n+    void StopNodes();\n+    void Stop()\n+    {\n+        StopThreads();\n+        StopNodes();\n+    };\n+\n+    void Interrupt();\n+    bool GetNetworkActive() const { return fNetworkActive; };\n+    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n+    void SetNetworkActive(bool active);\n+    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n+    bool CheckIncomingNonce(uint64_t nonce);\n+\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n+\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n+\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    void ForEachNode(const NodeFn& func) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    const uint64_t nKeyedNetGroup;\n-    std::atomic_bool fPauseRecv{false};\n-    std::atomic_bool fPauseSend{false};\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    bool IsOutboundOrBlockRelayConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-                return true;\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::ADDR_FETCH:\n-            case ConnectionType::FEELER:\n-                return false;\n-        } // no default case, so the compiler can warn about missing cases\n+    // Addrman functions\n+    void SetServices(const CService &addr, ServiceFlags nServices);\n+    void MarkAddressGood(const CAddress& addr);\n+    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n+    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n+    /**\n+     * Cache is used to minimize topology leaks, so it should\n+     * be used for all non-trusted calls, for example, p2p.\n+     * A non-malicious call (from RPC or a peer with addr permission) should\n+     * call the function without a parameter to avoid using the cache.\n+     */\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n \n-        assert(false);\n-    }\n+    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n+    // a peer that is better than all our current peers.\n+    void SetTryNewOutboundPeer(bool flag);\n+    bool GetTryNewOutboundPeer();\n \n-    bool IsFullOutboundConn() const {\n-        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    void StartExtraBlockRelayPeers() {\n+        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n+        m_start_extra_block_relay_peers = true;\n     }\n \n-    bool IsManualConn() const {\n-        return m_conn_type == ConnectionType::MANUAL;\n-    }\n+    // Return the number of outbound peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // to false, we may have extra peers that we wish to disconnect). This may\n+    // return a value less than (num_outbound_connections - num_outbound_slots)\n+    // in cases where some outbound connections are not yet fully connected, or\n+    // not yet fully disconnected.\n+    int GetExtraFullOutboundCount();\n+    // Count the number of block-relay-only peers we have over our limit.\n+    int GetExtraBlockRelayCount();\n \n-    bool IsBlockOnlyConn() const {\n-        return m_conn_type == ConnectionType::BLOCK_RELAY;\n-    }\n+    bool AddNode(const std::string& node);\n+    bool RemoveAddedNode(const std::string& node);\n+    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    bool IsFeelerConn() const {\n-        return m_conn_type == ConnectionType::FEELER;\n-    }\n+    size_t GetNodeCount(NumConnections num);\n+    void GetNodeStats(std::vector<CNodeStats>& vstats);\n+    bool DisconnectNode(const std::string& node);\n+    bool DisconnectNode(const CSubNet& subnet);\n+    bool DisconnectNode(const CNetAddr& addr);\n+    bool DisconnectNode(NodeId id);\n \n-    bool IsAddrFetchConn() const {\n-        return m_conn_type == ConnectionType::ADDR_FETCH;\n-    }\n+    //! Used to convey which local services we are offering peers during node\n+    //! connection.\n+    //!\n+    //! The data returned by this is used in CNode construction,\n+    //! which is used to advertise which services we are offering\n+    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n+    ServiceFlags GetLocalServices() const;\n \n-    bool IsInboundConn() const {\n-        return m_conn_type == ConnectionType::INBOUND;\n-    }\n+    uint64_t GetMaxOutboundTarget();\n+    std::chrono::seconds GetMaxOutboundTimeframe();\n \n-    /* Whether we send addr messages over this connection */\n-    bool RelayAddrsWithConn() const\n-    {\n-        // Don't relay addr messages to peers that we connect to as block-relay-only\n-        // peers (to prevent adversaries from inferring these links from addr\n-        // traffic).\n-        return m_conn_type != ConnectionType::BLOCK_RELAY;\n-    }\n+    //! check if the outbound target is reached\n+    //! if param historicalBlockServingLimit is set true, the function will\n+    //! response true if the limit for serving historical blocks has been reached\n+    bool OutboundTargetReached(bool historicalBlockServingLimit);\n \n-    bool ExpectServicesFromConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::FEELER:\n-                return false;\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-            case ConnectionType::ADDR_FETCH:\n-                return true;\n-        } // no default case, so the compiler can warn about missing cases\n+    //! response the bytes left in the current max outbound cycle\n+    //! in case of no limit, it will always response 0\n+    uint64_t GetOutboundTargetBytesLeft();\n \n-        assert(false);\n-    }\n+    //! returns the time left in the current max outbound cycle\n+    //! in case of no limit, it will always return 0\n+    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n \n-    /**\n-     * Get network the peer connected through.\n-     *\n-     * Returns Network::NET_ONION for *inbound* onion connections,\n-     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n-     * because it doesn't detect the former, and it's not the responsibility of\n-     * the CNetAddr class to know the actual network a peer is connected through.\n-     *\n-     * @return network the peer connected through.\n-     */\n-    Network ConnectedThroughNetwork() const;\n+    uint64_t GetTotalBytesRecv();\n+    uint64_t GetTotalBytesSent();\n \n-protected:\n-    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n+    /** Get a unique deterministic randomizer. */\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-public:\n-    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_to{false};\n-    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+    unsigned int GetReceiveFloodSize() const;\n \n-    // flood relay\n-    std::vector<CAddress> vAddrToSend;\n-    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n-    bool fGetAddr{false};\n-    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n-    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    void WakeMessageHandler();\n \n-    struct TxRelay {\n-        mutable RecursiveMutex cs_filter;\n-        // We use fRelayTxes for two purposes -\n-        // a) it allows us to not relay tx invs before receiving the peer's version message\n-        // b) the peer may tell us in its version message that we should not relay tx invs\n-        //    unless it loads a bloom filter.\n-        bool fRelayTxes GUARDED_BY(cs_filter){false};\n-        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n+        Works assuming that a single interval is used.\n+        Variable intervals will result in privacy decrease.\n+    */\n+    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n \n-        mutable RecursiveMutex cs_tx_inventory;\n-        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n-        // Set of transaction ids we still have to announce.\n-        // They are sorted by the mempool before relay, so the order is not important.\n-        std::set<uint256> setInventoryTxToSend;\n-        // Used for BIP35 mempool sending\n-        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n-        // Last time a \"MEMPOOL\" request was serviced.\n-        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n-        std::chrono::microseconds nNextInvSend{0};\n+    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n \n-        RecursiveMutex cs_feeFilter;\n-        // Minimum fee rate with which to filter inv's to this node\n-        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n-        CAmount lastSentFeeFilter{0};\n-        int64_t nextSendTimeFeeFilter{0};\n+private:\n+    struct ListenSocket {\n+    public:\n+        SOCKET socket;\n+        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n+        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n+    private:\n+        NetPermissionFlags m_permissions;\n     };\n \n-    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n-    std::unique_ptr<TxRelay> m_tx_relay;\n+    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n+    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n+    bool InitBinds(\n+        const std::vector<CService>& binds,\n+        const std::vector<NetWhitebindPermissions>& whiteBinds,\n+        const std::vector<CService>& onion_binds);\n \n-    /** UNIX epoch time of the last block received from this peer that we had\n-     * not yet seen (e.g. not already received from another peer), that passed\n-     * preliminary validity checks and was saved to disk, even if we don't\n-     * connect the block or it eventually fails connection. Used as an inbound\n-     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastBlockTime{0};\n+    void ThreadOpenAddedConnections();\n+    void AddAddrFetch(const std::string& strDest);\n+    void ProcessAddrFetch();\n+    void ThreadOpenConnections(std::vector<std::string> connect);\n+    void ThreadMessageHandler();\n+    void AcceptConnection(const ListenSocket& hListenSocket);\n+    void DisconnectNodes();\n+    void NotifyNumConnectionsChanged();\n+    void InactivityCheck(CNode *pnode);\n+    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketHandler();\n+    void ThreadSocketHandler();\n+    void ThreadDNSAddressSeed();\n \n-    /** UNIX epoch time of the last transaction received from this peer that we\n-     * had not yet seen (e.g. not already received from another peer) and that\n-     * was accepted into our mempool. Used as an inbound peer eviction criterium\n-     * in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastTXTime{0};\n+    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n \n-    // Ping time measurement:\n-    // The pong reply we're expecting, or 0 if no pong expected.\n-    std::atomic<uint64_t> nPingNonceSent{0};\n-    /** When the last ping was sent, or 0 if no ping was ever sent */\n-    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n-    // Last measured round-trip time.\n-    std::atomic<int64_t> nPingUsecTime{0};\n-    // Best measured round-trip time.\n-    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n-    // Whether a ping is requested.\n-    std::atomic<bool> fPingQueued{false};\n+    CNode* FindNode(const CNetAddr& ip);\n+    CNode* FindNode(const CSubNet& subNet);\n+    CNode* FindNode(const std::string& addrName);\n+    CNode* FindNode(const CService& addr);\n+\n+    /**\n+     * Determine whether we're already connected to a given address, in order to\n+     * avoid initiating duplicate connections.\n+     */\n+    bool AlreadyConnectedToAddress(const CAddress& addr);\n+\n+    bool AttemptToEvictConnection();\n+    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n+    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n+\n+    void DeleteNode(CNode* pnode);\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n-    ~CNode();\n-    CNode(const CNode&) = delete;\n-    CNode& operator=(const CNode&) = delete;\n+    NodeId GetNewNodeId();\n \n-private:\n-    const NodeId id;\n-    const uint64_t nLocalHostNonce;\n-    const ConnectionType m_conn_type;\n-    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n+    size_t SocketSendData(CNode& node) const EXCLUSIVE_LOCKS_REQUIRED(node.cs_vSend);\n+    void DumpAddresses();\n \n-    //! Services offered to this peer.\n-    //!\n-    //! This is supplied by the parent CConnman during peer connection\n-    //! (CConnman::ConnectNode()) from its attribute of the same name.\n-    //!\n-    //! This is const because there is no protocol defined for renegotiating\n-    //! services initially offered to a peer. The set of local services we\n-    //! offer should not change after initialization.\n-    //!\n-    //! An interesting example of this is NODE_NETWORK and initial block\n-    //! download: a node which starts up from scratch doesn't have any blocks\n-    //! to serve, but still advertises NODE_NETWORK because it will eventually\n-    //! fulfill this role after IBD completes. P2P code is written in such a\n-    //! way that it can gracefully handle peers who don't make good on their\n-    //! service advertisements.\n-    const ServiceFlags nLocalServices;\n+    // Network stats\n+    void RecordBytesRecv(uint64_t bytes);\n+    void RecordBytesSent(uint64_t bytes);\n \n-    NetPermissionFlags m_permissionFlags{ PF_NONE };\n-    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n+    /**\n+     * Return vector of current BLOCK_RELAY peers.\n+     */\n+    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n \n-    mutable RecursiveMutex cs_addrName;\n-    std::string addrName GUARDED_BY(cs_addrName);\n+    // Whether the node should be passed out in ForEach* callbacks\n+    static bool NodeFullyConnected(const CNode* pnode);\n \n-    // Our address, as reported by the peer\n-    CService addrLocal GUARDED_BY(cs_addrLocal);\n-    mutable RecursiveMutex cs_addrLocal;\n+    // Network usage totals\n+    RecursiveMutex cs_totalBytesRecv;\n+    RecursiveMutex cs_totalBytesSent;\n+    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n+    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n \n-    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n-    const bool m_inbound_onion{false};\n+    // outbound limit & stats\n+    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n+    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n+    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n \n-public:\n+    // P2P timeout in seconds\n+    int64_t m_peer_connect_timeout;\n \n-    NodeId GetId() const {\n-        return id;\n-    }\n+    // Whitelisted ranges. Any node connecting from these is automatically\n+    // whitelisted (as well as those connecting to whitelisted binds).\n+    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n \n-    uint64_t GetLocalNonce() const {\n-        return nLocalHostNonce;\n-    }\n+    unsigned int nSendBufferMaxSize{0};\n+    unsigned int nReceiveFloodSize{0};\n \n-    int GetRefCount() const\n-    {\n-        assert(nRefCount >= 0);\n-        return nRefCount;\n-    }\n+    std::vector<ListenSocket> vhListenSocket;\n+    std::atomic<bool> fNetworkActive{true};\n+    bool fAddressesInitialized{false};\n+    CAddrMan addrman;\n+    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n+    RecursiveMutex m_addr_fetches_mutex;\n+    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n+    RecursiveMutex cs_vAddedNodes;\n+    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n+    std::list<CNode*> vNodesDisconnected;\n+    mutable RecursiveMutex cs_vNodes;\n+    std::atomic<NodeId> nLastNodeId{0};\n+    unsigned int nPrevNodeCount{0};\n \n     /**\n-     * Receive bytes from the buffer and deserialize them into messages.\n-     *\n-     * @param[in]   msg_bytes   The raw data\n-     * @param[out]  complete    Set True if at least one message has been\n-     *                          deserialized and is ready to be processed\n-     * @return  True if the peer should stay connected,\n-     *          False if the peer should be disconnected from.\n+     * Cache responses to addr requests to minimize privacy leak.\n+     * Attack example: scraping addrs in real-time may allow an attacker\n+     * to infer new connections of the victim by detecting new records\n+     * with fresh timestamps (per self-announcement).\n      */\n-    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n-\n-    void SetCommonVersion(int greatest_common_version)\n-    {\n-        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n-        m_greatest_common_version = greatest_common_version;\n-    }\n-    int GetCommonVersion() const\n-    {\n-        return m_greatest_common_version;\n-    }\n+    struct CachedAddrResponse {\n+        std::vector<CAddress> m_addrs_response_cache;\n+        std::chrono::microseconds m_cache_entry_expiration{0};\n+    };\n \n-    CService GetAddrLocal() const;\n-    //! May not be called more than once\n-    void SetAddrLocal(const CService& addrLocalIn);\n+    /**\n+     * Addr responses stored in different caches\n+     * per (network, local socket) prevent cross-network node identification.\n+     * If a node for example is multi-homed under Tor and IPv6,\n+     * a single cache (or no cache at all) would let an attacker\n+     * to easily detect that it is the same node by comparing responses.\n+     * Indexing by local socket prevents leakage when a node has multiple\n+     * listening addresses on the same network.\n+     *\n+     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n+     * distinct Network (up to 5) we have/had an inbound peer from,\n+     * resulting in at most ~196 KB. Every separate local socket may\n+     * add up to ~196 KB extra.\n+     */\n+    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n \n-    CNode* AddRef()\n-    {\n-        nRefCount++;\n-        return this;\n-    }\n+    /**\n+     * Services this instance offers.\n+     *\n+     * This data is replicated in each CNode instance we create during peer\n+     * connection (in ConnectNode()) under a member also called\n+     * nLocalServices.\n+     *\n+     * This data is not marked const, but after being set it should not\n+     * change. See the note in CNode::nLocalServices documentation.\n+     *\n+     * \\sa CNode::nLocalServices\n+     */\n+    ServiceFlags nLocalServices;\n \n-    void Release()\n-    {\n-        nRefCount--;\n-    }\n+    std::unique_ptr<CSemaphore> semOutbound;\n+    std::unique_ptr<CSemaphore> semAddnode;\n+    int nMaxConnections;\n \n+    // How many full-relay (tx, block, addr) outbound peers we want\n+    int m_max_outbound_full_relay;\n \n+    // How many block-relay only outbound peers we want\n+    // We do not relay tx or addr messages with these peers\n+    int m_max_outbound_block_relay;\n \n-    void AddAddressKnown(const CAddress& _addr)\n-    {\n-        assert(m_addr_known);\n-        m_addr_known->insert(_addr.GetKey());\n-    }\n+    int nMaxAddnode;\n+    int nMaxFeeler;\n+    int m_max_outbound;\n+    bool m_use_addrman_outgoing;\n+    CClientUIInterface* clientInterface;\n+    NetEventsInterface* m_msgproc;\n+    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n+    BanMan* m_banman;\n \n     /**\n-     * Whether the peer supports the address. For example, a peer that does not\n-     * implement BIP155 cannot receive Tor v3 addresses because it requires\n-     * ADDRv2 (BIP155) encoding.\n+     * Addresses that were saved during the previous clean shutdown. We'll\n+     * attempt to make block-relay-only connections to them.\n      */\n-    bool IsAddrCompatible(const CAddress& addr) const\n-    {\n-        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n-    }\n+    std::vector<CAddress> m_anchors;\n \n-    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n-    {\n-        // Known checking here is only to save space from duplicates.\n-        // SendMessages will filter it again for knowns that were added\n-        // after addresses were pushed.\n-        assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n-            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n-            } else {\n-                vAddrToSend.push_back(_addr);\n-            }\n-        }\n-    }\n+    /** SipHasher seeds for deterministic randomness */\n+    const uint64_t nSeed0, nSeed1;\n \n+    /** flag for waking the message processor. */\n+    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n \n-    void AddKnownTx(const uint256& hash)\n-    {\n-        if (m_tx_relay != nullptr) {\n-            LOCK(m_tx_relay->cs_tx_inventory);\n-            m_tx_relay->filterInventoryKnown.insert(hash);\n-        }\n-    }\n+    std::condition_variable condMsgProc;\n+    Mutex mutexMsgProc;\n+    std::atomic<bool> flagInterruptMsgProc{false};\n \n-    void PushTxInventory(const uint256& hash)\n-    {\n-        if (m_tx_relay == nullptr) return;\n-        LOCK(m_tx_relay->cs_tx_inventory);\n-        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            m_tx_relay->setInventoryTxToSend.insert(hash);\n-        }\n-    }\n+    CThreadInterrupt interruptNet;\n \n-    void CloseSocketDisconnect();\n+    std::thread threadDNSAddressSeed;\n+    std::thread threadSocketHandler;\n+    std::thread threadOpenAddedConnections;\n+    std::thread threadOpenConnections;\n+    std::thread threadMessageHandler;\n \n-    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+    /** flag for deciding to connect to an extra outbound peer,\n+     *  in excess of m_max_outbound_full_relay\n+     *  This takes the place of a feeler connection */\n+    std::atomic_bool m_try_another_outbound_peer;\n \n-    ServiceFlags GetLocalServices() const\n-    {\n-        return nLocalServices;\n-    }\n+    /** flag for initiating extra block-relay-only peer connections.\n+     *  this should only be enabled after initial chain sync has occurred,\n+     *  as these connections are intended to be short-lived and low-bandwidth.\n+     */\n+    std::atomic_bool m_start_extra_block_relay_peers{false};\n \n-    std::string GetAddrName() const;\n-    //! Sets the addrName only if it was not previously set\n-    void MaybeSetAddrName(const std::string& addrNameIn);\n+    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n \n-    std::string ConnectionTypeAsString() const;\n+    /**\n+     * A vector of -bind=<address>:<port>=onion arguments each of which is\n+     * an address and port that are designated for incoming Tor connections.\n+     */\n+    std::vector<CService> m_onion_binds;\n \n-    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n-    bool IsInboundOnion() const { return m_inbound_onion; }\n+    friend struct CConnmanTest;\n+    friend struct ConnmanTestMsg;\n };",
      "path": "src/net.h",
      "position": 1906,
      "original_position": 1906,
      "commit_id": "fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "original_commit_id": "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "in_reply_to_id": 552621025,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "thanks, done",
      "created_at": "2021-01-07T08:42:52Z",
      "updated_at": "2021-01-07T08:42:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#discussion_r553182212",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/553182212"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1216,
      "original_line": 1216,
      "side": "RIGHT"
    }
  ]
}