{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
    "id": 1884900870,
    "node_id": "PR_kwDOABII585wWU4G",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30160",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30160.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30160.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
    "number": 30160,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "util: add BitSet",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Extracted from #30126.\r\n\r\nThis introduces the `BitSet` data structure, inspired by `std::bitset`, but with a few features that cannot be implemented on top without efficiency loss:\r\n* Finding the first set bit (`First`)\r\n* Finding the last set bit (`Last`)\r\n* Iterating over all set bits (`begin` and `end`).\r\n\r\nAnd a few other operators/member functions that help readability for #30126:\r\n* `operator-` for set subtraction\r\n* `Overlaps()` for testing whether intersection is non-empty\r\n* `IsSupersetOf()` for testing (non-strict) supersetness\r\n* `IsSubsetOf()` for testing (non-strict) subsetness\r\n* `Fill()` to construct a set with all numbers from 0 to n-1, inclusive\r\n* `Singleton()` to construct a set with one specific element.\r\n\r\nEverything is tested through a simulation-based fuzz test that compares the behavior with normal `std::bitset` equivalent operations.\r\n",
    "labels": [
      {
        "id": 241832923,
        "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
        "name": "Utils/log/libs",
        "description": "",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 6861582155,
        "node_id": "LA_kwDOABII588AAAABmPtvSw",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20CMake%20port",
        "name": "Needs CMake port",
        "description": "",
        "color": "0e8a16",
        "default": false
      }
    ],
    "created_at": "2024-05-23T15:42:28Z",
    "updated_at": "2024-05-29T15:46:04Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "b38baaa10e353f143bb96743b5a17073b400105f",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202405_bitset",
      "ref": "202405_bitset",
      "sha": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 21,
        "stargazers_count": 85,
        "watchers_count": 85,
        "size": 239947,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-05-29T15:44:56Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-05-05T10:02:28Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "10164916f712bd3c92f0b3ac329ba2e1209746fe",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35445,
        "stargazers_count": 76578,
        "watchers_count": 76578,
        "size": 259940,
        "default_branch": "master",
        "open_issues_count": 689,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-05-29T15:44:59Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-05-29T15:58:26Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 824,
    "deletions": 0,
    "changed_files": 5,
    "commits": 2,
    "review_comments": 16,
    "comments": 2
  },
  "events": [
    {
      "event": "commented",
      "id": 2127454745,
      "node_id": "IC_kwDOABII585-zmIZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127454745",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:42:31Z",
      "updated_at": "2024-05-28T12:39:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30160).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2082445138) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29625](https://github.com/bitcoin/bitcoin/pull/29625) (Several randomness improvements by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2127454745",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "labeled",
      "id": 12911543348,
      "node_id": "LE_lADOABII586J4VcvzwAAAAMBloQ0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911543348",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:42:33Z",
      "label": {
        "name": "Utils/log/libs",
        "color": "5319e7"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:48:15Z",
      "updated_at": "2024-05-23T15:48:15Z",
      "source": {
        "issue": {
          "id": 2301284495,
          "node_id": "PR_kwDOABII585vttq-",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
          "number": 30126,
          "state": "open",
          "state_reason": null,
          "title": "Low-level cluster linearization code",
          "body": "Depends on #30160 and #30161. Eventually #28676 will end up being based on this.\r\n\r\nThis introduces low-level optimized cluster linearization code, including tests and some benchmarks. It is currently not hooked up to anything.\r\n\r\nRoughly the commits are organized into 3 groups:\r\n* Repeat of part of #29625.\r\n* Introduce unoptimized versions of candidate finding and linearizations, plus benchmarks and tests.\r\n* Add various optimizations step by step.\r\n\r\nUltimately, what this PR adds is two functions `Linearize` and `PostLinearize`, which operate on instances of `DepGraph` (instances of which represent pre-processed transaction clusters) to produce and/or improve linearizations for that cluster.\r\n\r\nAlong the way two new data structures are introduced (`util/bitset.h` and `util/ringbuffer.h`), which could be useful more broadly. They have their own commits, which include tests.\r\n\r\n---\r\n\r\nTo provide assurance, the code heavily relies on fuzz tests. A novel approach is used here, where the fuzz input is parsed using the serialization.h framework rather than `FuzzedDataProvider`, with a custom serializer/deserializer for `DepGraph` objects. By including serialization, it's possible to ascertain that the format can represent every relevant cluster, as well as potentially permitting the construction of ad-hoc fuzz inputs from clusters (not included in this PR, but used during development).\r\n\r\n---\r\n\r\nThe `Linearize(depgraph, iteration_limit, rng_seed, old_linearization)` function is an implementation of the (single) [LIMO](https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825) algorithm, with the $S$ in every iteration found as the best out of (a) the best remaining ancestor set and (b) randomized computationally-bounded search. It incrementally builds up a linearization by finding good topologically-valid subsets to move to the front, in such a way that the resulting linearization has a diagram that is at least as good as the `old_linearization` passed in (if any).\r\n* Despite using both best ancestor set and search, this is not Double LIMO, as no intersections between these are involved; just the best of the two.\r\n* The `iteration_limit` and `rng_seed` only control the (b) randomized search. Even with 0 iterations, the result will be as good as the old linearization, and the included sets at every point will have a feerate at least as high as the best remaining ancestor set at that point.\r\n\r\nThe search algorithm used in the (b) step above largely follows Section 2 of [How to linearize your cluster](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-2-finding-high-feerate-subsets-5), though with a few changes:\r\n* Connected component analysis is performed inside the search algorithm (creating initial work items per component for each candidate), rather than once at a higher level. This duplicates some work but is significantly simpler in implementation.\r\n* No ancestor-set based presplitting inside the search is performed; instead, the `best` value is initialized with the best topologically valid set known to the LIMO algorithm before search starts: the better one out of the highest-feerate remaining ancestor set, and the highest-feerate prefix of remaining transactions in `old_linearization`.\r\n* Work items are represented using an included set *inc* and an undefined set *und*, rather than included and excluded.\r\n* Potential sets *pot* are not computed for work items with empty *inc*.\r\n\r\nAt a high level, the only missing optimization from that post is bottleneck analysis; my thinking is that it only really helps with clusters that are already relatively cheap to linearize (doing so would need to be done at a higher level, not inside the search algorithm).\r\n\r\nThe `PostLinearize(depgraph, linearization)` function performs an in-place improvement of `linearization`, using two iterations of the [Linearization post-processing](https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201/8) algorithm. The first running from back to front, the second from front to back.\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 164208572,
              "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
              "name": "Mempool",
              "color": "fef2c0",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/30126.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/30126.patch"
          },
          "created_at": "2024-05-16T20:29:15Z",
          "updated_at": "2024-05-28T13:50:27Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12913402292,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMBsuG0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913402292",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T17:55:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12913691028,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMBt0mU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913691028",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:23:57Z"
    },
    {
      "event": "reviewed",
      "id": 2074881667,
      "node_id": "PRR_kwDOABII5857rC6D",
      "url": null,
      "actor": null,
      "commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2074881667",
      "submitted_at": "2024-05-23T19:55:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "reviewed",
      "id": 2074894349,
      "node_id": "PRR_kwDOABII5857rGAN",
      "url": null,
      "actor": null,
      "commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2074894349",
      "submitted_at": "2024-05-23T20:03:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T00:35:24Z",
      "updated_at": "2024-05-24T00:35:24Z",
      "source": {
        "issue": {
          "id": 2180060071,
          "node_id": "PR_kwDOABII585pS0SQ",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29625",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29625/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29625/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29625/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/29625",
          "number": 29625,
          "state": "open",
          "state_reason": null,
          "title": "Several randomness improvements",
          "body": "This PR contains a number of vaguely-related improvements to the random module.\r\n\r\nThe specific changes and more detailed rationale is in the commit messages, but the highlights are:\r\n\r\n* `XoRoShiRo128PlusPlus` (previously a test-only RNG) moves to random.h and becomes `InsecureRandomContext`, which is even faster than `FastRandomContext` but non-cryptographic. It also gets all helper randomness functions (`randrange`, `fillrand`, ...), making it a lot more succinct to use.\r\n* During tests, **all** randomness is made deterministic (except for `GetStrongRandBytes`) but non-repeating (like `GetRand()` used to be when `g_mock_deterministic_tests` was used), either fixed, or from a random seed (overridden by env var).\r\n* Several infrequently used top-level functions (`GetRandMillis`, `GetRandMicros`, `GetExponentialRand`) are converted into member functions of `FastRandomContext` (and `InsecureRandomContext`).\r\n* `GetRand<T>()` (without argument) can now return the maximum value of the type (previously e.g. `GetRand<uint32_t>()` would never return 0xffffffff).",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 13,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29625",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/29625",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/29625.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/29625.patch"
          },
          "created_at": "2024-03-11T19:36:49Z",
          "updated_at": "2024-05-29T14:02:35Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12925383411,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMCabLz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12925383411",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T13:48:25Z"
    },
    {
      "event": "reviewed",
      "id": 2077061355,
      "node_id": "PRR_kwDOABII5857zXDr",
      "url": null,
      "actor": null,
      "commit_id": "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2077061355",
      "submitted_at": "2024-05-24T14:17:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12926722640,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMCfiJQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12926722640",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T15:35:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934056317,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMC7gl9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934056317",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T22:07:52Z"
    },
    {
      "event": "labeled",
      "id": 12945169502,
      "node_id": "LE_lADOABII586J4VcvzwAAAAMDl5xe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12945169502",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:09:59Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "reviewed",
      "id": 2076257466,
      "node_id": "PRR_kwDOABII5857wSy6",
      "url": null,
      "actor": null,
      "commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Looked at 3bc131a85ce826aa171f0328c014ea51b8740fed\r\n\r\nConcept: Bummer that `std::countr_zero` and `std::countl_zero` aren't implemented for `std::bitset`. And for iterating it seems like one would be using `std::vector<bool>` and hoping for the best in terms of implementation. So makes sense to introduce `BitSet`.\r\n\r\nSummary still mentions `operator/` instead of `operator-`.\r\n\r\n(Fuzz-code is too new to me to comment).",
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2076257466",
      "submitted_at": "2024-05-28T11:52:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "reviewed",
      "id": 2082445138,
      "node_id": "PRR_kwDOABII5858H5dS",
      "url": null,
      "actor": null,
      "commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2082445138",
      "submitted_at": "2024-05-28T12:20:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12957008979,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMETERT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12957008979",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T12:39:15Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGExYTBjNGMyYmM0ZTZhZGQ1MmY4ZGZiMDM3ODhlZDJiYjJkYWJiZjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "tree": {
        "sha": "742e9d6dffe1b28dea34470194f67f61ce921ce7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/742e9d6dffe1b28dea34470194f67f61ce921ce7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/10164916f712bd3c92f0b3ac329ba2e1209746fe",
          "sha": "10164916f712bd3c92f0b3ac329ba2e1209746fe",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/10164916f712bd3c92f0b3ac329ba2e1209746fe"
        }
      ],
      "message": "util: add BitSet\n\nThis adds a bitset module that implements a BitSet<N> class, a variant\nof std::bitset with a few additional features that cannot be implemented\nin a wrapper without performance loss (specifically, finding first and\nlast bit set, or iterating over all set bits).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-29T15:44:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-01-22T00:20:06Z"
      },
      "sha": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE4ZWMzZmMwYmRlODU1ZDc3N2JhNzAyZjBhMGE1ZDVhNGQzMjNjYmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "tree": {
        "sha": "65726f487ad426e851c78b454195281040485156",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/65726f487ad426e851c78b454195281040485156"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
          "sha": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1"
        }
      ],
      "message": "tests: add fuzz tests for BitSet",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-29T15:44:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-23T15:32:05Z"
      },
      "sha": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12973968539,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMFTwyb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12973968539",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T15:44:58Z"
    },
    {
      "event": "commented",
      "id": 2137732304,
      "node_id": "IC_kwDOABII585_azTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2137732304",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T15:46:03Z",
      "updated_at": "2024-05-29T15:46:03Z",
      "author_association": "MEMBER",
      "body": "Added additional `Assume()`s to prevent `operator++` on iterators past the end:\r\n\r\n```diff\r\n--- a/src/util/bitset.h\r\n+++ b/src/util/bitset.h\r\n@@ -101,6 +101,7 @@ class IntBitSet\r\n         /** Progress to the next 1 bit (only if != IteratorEnd). */\r\n         constexpr Iterator& operator++() noexcept\r\n         {\r\n+            Assume(m_val != 0);\r\n             m_val &= m_val - I{1U};\r\n             if (m_val != 0) m_pos = std::countr_zero(m_val);\r\n             return *this;\r\n@@ -272,6 +273,7 @@ class MultiIntBitSet\r\n         /** Progress to the next 1 bit (only if != IteratorEnd). */\r\n         constexpr Iterator& operator++() noexcept\r\n         {\r\n+            Assume(m_idx < N);\r\n             m_val &= m_val - I{1U};\r\n             if (m_val == 0) {\r\n                 while (true) {\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2137732304",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612232560",
      "pull_request_review_id": 2074881667,
      "id": 1612232560,
      "node_id": "PRRC_kwDOABII585gGLdw",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 144,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`std::bitset` throws for these if pos is out of range.\r\n\r\nMaybe add `Assume()`s? Or were you trying to keep the header self-contained?",
      "created_at": "2024-05-23T19:55:17Z",
      "updated_at": "2024-05-23T19:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612232560",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612232560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612240218",
      "pull_request_review_id": 2074894349,
      "id": 1612240218,
      "node_id": "PRRC_kwDOABII585gGNVa",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 172,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I know you like dense code, but...\r\n\r\nI suspect function names would make reviewing uses of this easier than operators. Especially for the non-obvious ones like `&&` that `std::bitset` doesn't support.\r\n\r\nI know that personally I'd have an easier time reviewing `a.intersects(b)`.",
      "created_at": "2024-05-23T20:03:01Z",
      "updated_at": "2024-05-23T20:03:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612240218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612240218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613105680",
      "pull_request_review_id": 2076257466,
      "id": 1613105680,
      "node_id": "PRRC_kwDOABII585gJgoQ",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "path": "src/util/bitset.h",
      "position": 519,
      "original_position": 461,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Have you considered using `__int128`, `__int256` etc when available, before falling back to `MultiIntBitSet`? Maybe something for a follow-up PR.",
      "created_at": "2024-05-24T08:44:43Z",
      "updated_at": "2024-05-28T11:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613105680",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613105680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 518,
      "original_start_line": 460,
      "start_side": "RIGHT",
      "line": 519,
      "original_line": 519,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613223825",
      "pull_request_review_id": 2076257466,
      "id": 1613223825,
      "node_id": "PRRC_kwDOABII585gJ9eR",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "path": "src/util/bitset.h",
      "position": 360,
      "original_position": 309,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Superfluous `I()`",
      "created_at": "2024-05-24T10:05:10Z",
      "updated_at": "2024-05-28T11:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613223825",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613223825"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 360,
      "original_line": 360,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613558242",
      "pull_request_review_id": 2077061355,
      "id": 1613558242,
      "node_id": "PRRC_kwDOABII585gLPHi",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 212,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`.Subset()` and `.Superset()`?\r\n\r\nWithout these comments, I would have to guess at the meanings (and I would have guessed wrong).",
      "created_at": "2024-05-24T14:17:56Z",
      "updated_at": "2024-05-24T14:17:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613558242",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613558242"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674776",
      "pull_request_review_id": 2077267486,
      "id": 1613674776,
      "node_id": "PRRC_kwDOABII585gLrkY",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 144,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": 1612232560,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T15:37:28Z",
      "updated_at": "2024-05-24T15:37:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613674776",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674776"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675392",
      "pull_request_review_id": 2077268563,
      "id": 1613675392,
      "node_id": "PRRC_kwDOABII585gLruA",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 172,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": 1612240218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Replaced with `Overlaps()`.",
      "created_at": "2024-05-24T15:37:50Z",
      "updated_at": "2024-05-24T15:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675392",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675392"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675918",
      "pull_request_review_id": 2077269480,
      "id": 1613675918,
      "node_id": "PRRC_kwDOABII585gLr2O",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 212,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "in_reply_to_id": 1613558242,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Replaced with `IsSubsetOf()` and `IsSupersetOf()`.",
      "created_at": "2024-05-24T15:38:09Z",
      "updated_at": "2024-05-24T15:38:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675918",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617026499",
      "pull_request_review_id": 2082445138,
      "id": 1617026499,
      "node_id": "PRRC_kwDOABII585gYd3D",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 393,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "beb535680b85b511709240a8e1f7de59864b3524",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's a bit scary that `MultiIntBitSet::{First,Last}` lead to buffer over/under-reads if no bit is set. I understand that we wouldn't want to do assert for `Any` in production for performance reasons, but it's maybe worth it do it for debug builds, e.g. with somethink like the `ASSERT_IF_DEBUG` construct used in src/span.h.",
      "created_at": "2024-05-28T11:01:55Z",
      "updated_at": "2024-05-28T12:20:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617026499",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617026499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617040989",
      "pull_request_review_id": 2076257466,
      "id": 1617040989,
      "node_id": "PRRC_kwDOABII585gYhZd",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 247,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: `ptr` could be passed as a reference to signify non-nullness. (But the member still needs to be a pointer). Not at all significant as it is a private function.",
      "created_at": "2024-05-28T11:13:46Z",
      "updated_at": "2024-05-28T11:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617040989",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617040989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617148751",
      "pull_request_review_id": 2082633346,
      "id": 1617148751,
      "node_id": "PRRC_kwDOABII585gY7tP",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "path": "src/util/bitset.h",
      "position": 519,
      "original_position": 461,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613105680,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have not benchmarked this, but I have a hard time imagining how that can be faster, as common hardware doesn't have general-purpose registers bigger than `size_t`, so `__int128` operations get simulated using multiple variables anyway. Some architectures do have vector extensions (SSE, AVX, ...) which introduce native 128-, 256-, or 512-bit registers, but those generally only support operations of units up to 32 to 64 bits in them (including leading-zero counting, or popcount, which we need here).",
      "created_at": "2024-05-28T12:21:47Z",
      "updated_at": "2024-05-28T12:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617148751",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617148751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 518,
      "original_start_line": 460,
      "start_side": "RIGHT",
      "line": 519,
      "original_line": 519,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617153576",
      "pull_request_review_id": 2082640599,
      "id": 1617153576,
      "node_id": "PRRC_kwDOABII585gY84o",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "path": "src/util/bitset.h",
      "position": 360,
      "original_position": 309,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613223825,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't believe this is superfluous. If `I` is smaller than an `int` (e.g. `I = uint16_t`) then `~I{0}` undergoes [integer promotion](https://en.cppreference.com/w/c/language/conversion) to `int`, and right-shifting that would sign-extend, which would incorrect here. The `I(...)` around it forces it to be unsigned before the right-shift.",
      "created_at": "2024-05-28T12:25:11Z",
      "updated_at": "2024-05-28T12:25:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617153576",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617153576"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 360,
      "original_line": 360,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175155",
      "pull_request_review_id": 2082674196,
      "id": 1617175155,
      "node_id": "PRRC_kwDOABII585gZCJz",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 393,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "beb535680b85b511709240a8e1f7de59864b3524",
      "in_reply_to_id": 1617026499,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added `Assume()`s in `First()` and `Last()` to avoid this.",
      "created_at": "2024-05-28T12:39:37Z",
      "updated_at": "2024-05-28T12:39:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175155",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175296",
      "pull_request_review_id": 2082674439,
      "id": 1617175296,
      "node_id": "PRRC_kwDOABII585gZCMA",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 247,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "in_reply_to_id": 1617040989,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-28T12:39:44Z",
      "updated_at": "2024-05-28T12:39:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190868",
      "pull_request_review_id": 2082699927,
      "id": 1617190868,
      "node_id": "PRRC_kwDOABII585gZF_U",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "path": "src/util/bitset.h",
      "position": 519,
      "original_position": 461,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613105680,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd consider SSE supporting CPUs quite common. Seems like using such instructions can offer efficiency gains but are sufficiently complex to write papers about - https://stackoverflow.com/a/42675620, something for the future maybe.",
      "created_at": "2024-05-28T12:50:32Z",
      "updated_at": "2024-05-28T12:50:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617190868",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 518,
      "original_start_line": 460,
      "start_side": "RIGHT",
      "line": 519,
      "original_line": 519,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618814697",
      "pull_request_review_id": 2085289550,
      "id": 1618814697,
      "node_id": "PRRC_kwDOABII585gfSbp",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "path": "src/util/bitset.h",
      "position": 360,
      "original_position": 309,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613223825,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added `std::conditional_t<(BITS <= 16), bitset_detail::IntBitSet<uint16_t>, ... ` and removed the `I()`, wrote unit test in bc36241f5a0a23d16645155eb819e94b0db2813e, and it indeed proves you are correct. Right now it cannot occur since `IntBitSet<uint32_t>` is the smallest we go, but better not to leave loaded footguns lying around.\r\n\r\n<details>\r\n<summary>Test Log</summary>\r\n\r\n```\r\n$ src/test/test_bitcoin -t bitset_tests\r\n...\r\nRunning 1 test case...\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [1 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [2 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [3 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [4 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [5 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [6 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [7 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [8 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [9 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [10 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [11 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [12 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [13 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [14 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [15 != 16]\r\n```\r\n</details>",
      "created_at": "2024-05-29T12:41:44Z",
      "updated_at": "2024-05-29T12:41:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1618814697",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618814697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 360,
      "original_line": 360,
      "side": "RIGHT"
    }
  ]
}