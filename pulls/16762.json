{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
    "id": 312482495,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MzEyNDgyNDk1",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/16762",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/16762.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/16762.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/2c0dda33c51324686bc143d8bed89ebba088ab8a",
    "number": 16762,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "Rust-based Backup over-REST block downloader",
    "user": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is based on #15798.\r\n\r\nI'm increasingly worried about censorship and other attacks in the P2P network (see, eg, https://twitter.com/TheBlueMatt/status/1160620919775211520). While obviously making the net_processing p2p implementation more robust should be the focus (eg #15759), adding more redundancy in every way is also key. To avoid needless review burden on such systems, I think rust is an ideal candidate: it is wholly optional so we don't just right to requiring Rust for Bitcoin Core, but building with it still provides real benefit, plus we can use compile-time checks to catch any overflows and memory corruption bugs to reduce review burden.\r\n\r\nThis PR implements a simple API for Rust code to fetch headers and blocks and then implements a sample client that can sync the chain using a REST endpoint. As a demo, I provide a rest endpoint over cloudflare at http://cloudflare.deanonymizingseed.com/rest/ so you should be able to fully sync the chain (albeit very slowly) with bitcoind -blockfetchrest=http://cloudflare.deanonymizingseed.com/rest/ -connect=0\r\n\r\nThere's a few things to do before this is mergable, but I'd like feedback on the idea, and would like to also have a fully parallel, in rust, P2P net layer that is similarly simple and provides a nice redundant implementation in the future.",
    "labels": [
      {
        "id": 64583,
        "node_id": "MDU6TGFiZWw2NDU4Mw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature",
        "name": "Feature",
        "color": "7cf575",
        "default": false
      },
      {
        "id": 64584,
        "node_id": "MDU6TGFiZWw2NDU4NA==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Brainstorming",
        "name": "Brainstorming",
        "color": "ebd775",
        "default": false
      },
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      },
      {
        "id": 955867938,
        "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
        "name": "Needs rebase",
        "description": "",
        "color": "cccccc",
        "default": false
      },
      {
        "id": 1392286103,
        "node_id": "MDU6TGFiZWwxMzkyMjg2MTAz",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20Conceptual%20Review",
        "name": "Needs Conceptual Review",
        "description": "",
        "color": "fef2c0",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/42",
      "html_url": "https://github.com/bitcoin/bitcoin/milestone/42",
      "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/42/labels",
      "id": 4116761,
      "node_id": "MDk6TWlsZXN0b25lNDExNjc2MQ==",
      "number": 42,
      "state": "closed",
      "title": "0.20.0",
      "description": "",
      "creator": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 0,
      "closed_issues": 91,
      "created_at": "2019-03-06T20:02:40Z",
      "updated_at": "2020-06-02T07:55:47Z",
      "closed_at": "2020-06-02T07:55:47Z"
    },
    "active_lock_reason": "resolved",
    "created_at": "2019-08-29T20:30:51Z",
    "updated_at": "2022-02-15T10:41:43Z",
    "closed_at": "2020-03-05T19:48:04Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merge_commit_sha": "c37f5aaffea72b4cc3957f59b66a2274da2543cc",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "TheBlueMatt:2019-08-rusty-block-download",
      "ref": "2019-08-rusty-block-download",
      "sha": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1443291,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDQzMjkx",
        "name": "bitcoin",
        "full_name": "TheBlueMatt/bitcoin",
        "owner": {
          "login": "TheBlueMatt",
          "id": 649246,
          "node_id": "MDQ6VXNlcjY0OTI0Ng==",
          "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/TheBlueMatt",
          "html_url": "https://github.com/TheBlueMatt",
          "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
          "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
          "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
          "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
          "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/TheBlueMatt/bitcoin",
        "description": "Bitcoin (dont fork from here, fork from bitcoin/bitcoin)",
        "fork": true,
        "url": "https://api.github.com/repos/TheBlueMatt/bitcoin",
        "archive_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/events",
        "forks_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/TheBlueMatt/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:TheBlueMatt/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/TheBlueMatt/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/hooks",
        "svn_url": "https://github.com/TheBlueMatt/bitcoin",
        "homepage": "http://www.bitcoin.org/",
        "language": "C++",
        "forks_count": 6,
        "stargazers_count": 19,
        "watchers_count": 19,
        "size": 171686,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-02T11:57:49Z",
        "created_at": "2011-03-05T14:14:49Z",
        "updated_at": "2022-12-15T18:21:13Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "6fff333c9f00cf379562ed38c2599997f9821cfb",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35475,
        "stargazers_count": 70608,
        "watchers_count": 70608,
        "size": 236222,
        "default_branch": "master",
        "open_issues_count": 672,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-02T19:06:37Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-08-02T18:21:18Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 1189,
    "deletions": 124,
    "changed_files": 20,
    "commits": 13,
    "review_comments": 29,
    "comments": 18
  },
  "events": [
    {
      "event": "labeled",
      "id": 2595253087,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI1OTUyNTMwODc=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595253087",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T20:31:49Z",
      "label": {
        "name": "Brainstorming",
        "color": "ebd775"
      }
    },
    {
      "event": "labeled",
      "id": 2595253088,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI1OTUyNTMwODg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595253088",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T20:31:49Z",
      "label": {
        "name": "Needs Conceptual Review",
        "color": "fef2c0"
      }
    },
    {
      "event": "labeled",
      "id": 2595253783,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI1OTUyNTM3ODM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595253783",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T20:32:02Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2595395746,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NTM5NTc0Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595395746",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T21:28:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2595584581,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NTU4NDU4MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595584581",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T23:18:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2595613598,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NTYxMzU5OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595613598",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T23:40:44Z"
    },
    {
      "event": "commented",
      "id": 526402501,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjQwMjUwMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526402501",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T23:53:44Z",
      "updated_at": "2020-01-03T20:22:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#17783](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17783.html) (util: Fix -norpcwhitelist, -norpcallowip, and similar corner case behavior by ryanofsky)\n* [#17581](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17581.html) (refactor: Remove settings merge reverse precedence code by ryanofsky)\n* [#17580](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17580.html) (refactor: Add ALLOW_LIST flags and enforce usage in CheckArgFlags by ryanofsky)\n* [#17493](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17493.html) (util: Forbid ambiguous multiple assignments in config file by ryanofsky)\n* [#17452](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17452.html) (test: update fuzz directory in .gitignore by jonatack)\n* [#17398](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17398.html) (build: Update leveldb to 1.22+ by laanwj)\n* [#17383](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17383.html) (Refactor: Move consts to their correct translation units by jnewbery)\n* [#17227](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17227.html) (Qt: Add Android packaging support by icota)\n* [#16722](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16722.html) (build: Disable warnings for leveldb subtree by default by hebasto)\n* [#15606](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15606.html) ([experimental] UTXO snapshots by jamesob)\n* [#15367](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15367.html) (feature: Added ability for users to add a startup command by benthecarman)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526402501",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2595947862,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NTk0Nzg2Mg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595947862",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T04:17:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2596194004,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NjE5NDAwNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2596194004",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T06:57:27Z"
    },
    {
      "event": "reviewed",
      "id": 281872721,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgxODcyNzIx",
      "url": null,
      "actor": null,
      "commit_id": "cf221a2410a066fa95f526be343b8fa4c63d5184",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#pullrequestreview-281872721",
      "submitted_at": "2019-08-30T07:38:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
    },
    {
      "event": "mentioned",
      "id": 2596299799,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjU5NjI5OTc5OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2596299799",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T07:44:25Z"
    },
    {
      "event": "subscribed",
      "id": 2596299801,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI1OTYyOTk4MDE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2596299801",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T07:44:25Z"
    },
    {
      "event": "commented",
      "id": 526588120,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjU4ODEyMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526588120",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T12:46:43Z",
      "updated_at": "2019-08-30T13:13:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Interesting idea: cautious concept ACK -- more redundancy is good and it is hard to see how this would make us worse off in any way as long as the existing P2P logic is kept unchanged. (Intentionally not commenting on the implementation and more specifically the pros and cons of pulling in Rust code: that is an implementation detail that I'm sure will be discussed separately post concept ACK/NACK.)\r\n\r\nCensorship scenarios worth thinking about:\r\n\r\nEven if we do the over-REST block downloads over HTTPS it should be noted that the TLS handshake leaks the hostname of the connected to service to passive eavesdroppers. (Unless TLS 1.3 + Encrypted SNI is used: super rare in practice though.)\r\n\r\nThe hostname is obviously also leaked when doing the DNS lookup. (Unless DoH (DNS over HTTPS) or DoT (DNS over TLS) is used: quite rare in practice.)\r\n\r\nThis allows for active censorship attacks if the hostnames used are **only**  used for Bitcoin purposes (such as in the `cloudflare.deanonymizingseed.com` example – I understand it is just used here as an example).\r\n\r\n(The same obviously goes for the IP-address used: if the IP-address connected to is only used for Bitcoin purposes then access to that IP-address could trivially be null routed without any non-Bitcoin users noticing.)\r\n\r\nI guess one way to achieve (partial) censorship resistance is to download over HTTPS URLs where the hostnames used are mostly used for non-Bitcoin purposes (such as `github.com` – just used here as an example: I'm sure we can come up with other examples). That would leak the hostname but since the hostname and the IP address is used for other purposes it would still be hard for an attacker to block it without having non-Bitcoin users complain.\r\n\r\nAnother route would be to use TLS 1.3 + Encrypted SNI + DoH/DoT to connect to a service whose IP-address(es) are used mostly for non-Bitcoin purposes (such as CloudFlare which luckily supports both TLS 1.3 and Encrypted SNI). That wouldn't leak the hostname and the IP-address would be hard to null route for an attacker without having non-Bitcoin users complain.",
      "user": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526588120",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 526704470,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjcwNDQ3MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526704470",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T18:33:03Z",
      "updated_at": "2019-08-30T18:33:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Intentionally not commenting on the implementation and more specifically the pros and cons of pulling in Rust code: that is an implementation detail that I'm sure will be discussed separately post concept ACK/NACK\r\n\r\nRight, there's a few things that would need to happen to get this in mergeable state (notably buildsystem things), so no need for that just yet.\r\n\r\n> Censorship scenarios worth thinking about:\r\n\r\nRight, two things I'd like to support in the blocks-over-REST module: domain fronting avoids most of the gnarly issues with SNI/DNS lookups breaking your privacy, though sadly many providers don't like it anymore, and Tor support, possibly even with some default onion service recommended as a backup cause privacy is less of a concern there.\r\n\r\nI'd also like to build a whole second P2P implementation (though with an explicit goal of being inefficient and simple, with the same trick as here where you wait 30 seconds before deciding to download anything to avoid wasting bandwidth), but first need to land some bit of rust downloading, and this seemed like an easier target.",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526704470",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2598095199,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5ODA5NTE5OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2598095199",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T19:16:13Z"
    },
    {
      "event": "commented",
      "id": 526725811,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjcyNTgxMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526725811",
      "actor": {
        "login": "kristapsk",
        "id": 4500994,
        "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kristapsk",
        "html_url": "https://github.com/kristapsk",
        "followers_url": "https://api.github.com/users/kristapsk/followers",
        "following_url": "https://api.github.com/users/kristapsk/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kristapsk/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kristapsk/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
        "organizations_url": "https://api.github.com/users/kristapsk/orgs",
        "repos_url": "https://api.github.com/users/kristapsk/repos",
        "events_url": "https://api.github.com/users/kristapsk/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kristapsk/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T19:46:50Z",
      "updated_at": "2019-08-30T19:46:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "But why Rust not C++?",
      "user": {
        "login": "kristapsk",
        "id": 4500994,
        "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kristapsk",
        "html_url": "https://github.com/kristapsk",
        "followers_url": "https://api.github.com/users/kristapsk/followers",
        "following_url": "https://api.github.com/users/kristapsk/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kristapsk/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kristapsk/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
        "organizations_url": "https://api.github.com/users/kristapsk/orgs",
        "repos_url": "https://api.github.com/users/kristapsk/repos",
        "events_url": "https://api.github.com/users/kristapsk/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kristapsk/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526725811",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 526803517,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjgwMzUxNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526803517",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-31T05:59:49Z",
      "updated_at": "2019-08-31T05:59:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "> But why Rust not C++?\r\n\r\nBecause we can trivially turn on compile-time checking preventing a ton of classes of vulnerabilities (especially for network-facing code), and runtime checking for many other classes (like buffer overflows, at least those the compiler can't prove aren't possible).",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526803517",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 526803615,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjgwMzYxNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526803615",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-31T06:01:14Z",
      "updated_at": "2019-08-31T06:01:14Z",
      "author_association": "MEMBER",
      "body": "I'm fairly Concept ACK on this. It's been in discussion for a little while, and I'm pretty sure it came up at the last Core dev meetup as well?\r\n\r\n> But why Rust not C++?\r\n\r\n@kristapsk This PR isn't really the place to have that discussion and is only going to distract from what's actually trying to be achieved. Although Matt points out one big advantage:\r\n\r\n> plus we can use compile-time checks to catch any overflows and memory corruption bugs to reduce review burden.\r\n\r\n\r\nIf you'd like to discuss Rust inside Bitcoin Core further, I'd suggest taking a look at #15798. Here are Cory's thoughts on Rust from that thread:\r\n\r\n> Why rust? I don't know. Maybe not. But I think it's a fair assumption to say that Rust code will eventually end up in Bitcoin Core as the result of adding a new dependency. Adoption is happing quickly. So, I think it prudent to look ahead and not only be prepared, but actively help usher it in. Already I have a few things that I would like to work on and upstream to rust-lang to make our integration nicer, and I assume that more will be uncovered as it actually gets used.\r\n\r\nI built and tested that this functions using the instructions above. The backup downloader kicked off after a 10 minute wait\r\n```bash\r\nsrc/bitcoind -blockfetchrest=http://cloudflare.deanonymizingseed.com/rest/ -connect=0\r\n\r\n2019-08-31T05:37:06Z nBestHeight = 311015\r\n2019-08-31T05:37:06Z init message: Loading P2P addresses...\r\n2019-08-31T05:37:06Z Imported mempool transactions from disk: 0 succeeded, 0 failed, 0 expired, 0 already there\r\n2019-08-31T05:37:06Z Loaded 63409 addresses from peers.dat  159ms\r\n2019-08-31T05:37:06Z init message: Starting network threads...\r\n2019-08-31T05:37:06Z DNS seeding disabled\r\n2019-08-31T05:37:06Z net thread start\r\n2019-08-31T05:37:06Z msghand thread start\r\n2019-08-31T05:37:06Z addcon thread start\r\n2019-08-31T05:37:06Z init message: Done loading\r\n2019-08-31T05:47:10Z Synchronizing blockheaders, height: 313014 (~53.91%)\r\n2019-08-31T05:47:13Z Synchronizing blockheaders, height: 315013 (~54.23%)\r\n2019-08-31T05:47:15Z Synchronizing blockheaders, height: 317012 (~54.55%)\r\n2019-08-31T05:47:17Z Synchronizing blockheaders, height: 319011 (~54.87%)\r\n< snip >\r\n2019-08-31T05:52:27Z Synchronizing blockheaders, height: 574883 (~97.17%)\r\n2019-08-31T05:52:34Z Synchronizing blockheaders, height: 576882 (~97.49%)\r\n2019-08-31T05:52:36Z Synchronizing blockheaders, height: 578881 (~97.81%)\r\n2019-08-31T05:52:39Z Synchronizing blockheaders, height: 580880 (~98.14%)\r\n2019-08-31T05:52:41Z Synchronizing blockheaders, height: 582879 (~98.46%)\r\n2019-08-31T05:52:44Z Synchronizing blockheaders, height: 584878 (~98.76%)\r\n2019-08-31T05:52:47Z Synchronizing blockheaders, height: 586877 (~99.09%)\r\n2019-08-31T05:52:49Z Synchronizing blockheaders, height: 588876 (~99.40%)\r\n2019-08-31T05:52:56Z Synchronizing blockheaders, height: 590875 (~99.73%)\r\n2019-08-31T05:52:59Z Synchronizing blockheaders, height: 592551 (~100.00%)\r\n2019-08-31T05:53:35Z Pre-allocating up to position 0x3000000 in blk00158.dat\r\n2019-08-31T05:53:35Z Pre-allocating up to position 0x100000 in rev00158.dat\r\n2019-08-31T05:53:35Z UpdateTip: new best=0000000000000000246039d52e90fb6b7cd442dda19861fb948c28e3a44f7a4e height=311016 version=0x00000002 log2_work=79.744641 tx=42644694 date='2014-07-16T13:51:22Z' progress=0.095646 cache=0.5MiB(3475txo)\r\n2019-08-31T05:53:38Z UpdateTip: new best=000000000000000014c552ced25645452a0b8632753e9288e2decedd273c5828 height=311017 version=0x00000002 log2_work=79.744747 tx=42645541 date='2014-07-16T14:10:17Z' progress=0.095648 cache=1.0MiB(7067txo)\r\n2019-08-31T05:53:40Z UpdateTip: new best=0000000000000000260ef522f4875fb0d5207e4e3ac97ce373a47209bcee52b6 height=311018 version=0x00000002 log2_work=79.744853 tx=42645990 date='2014-07-16T14:18:18Z' progress=0.095649 cache=1.2MiB(8621txo)\r\n2019-08-31T05:53:42Z UpdateTip: new best=0000000000000000007dabdebadfde7beaef31d13133600d0d88695146e2fac6 height=311019 version=0x00000002 log2_work=79.744959 tx=42646068 date='2014-07-16T14:19:50Z' progress=0.095649 cache=1.2MiB(8821txo)\r\n2019-08-31T05:53:45Z UpdateTip: new best=00000000000000001fc78d459e2480177ceea92d53f75cdbd856501b60cbdc3a height=311020 version=0x00000002 log2_work=79.745065 tx=42646933 date='2014-07-16T14:34:32Z' progress=0.095651 cache=1.6MiB(11938txo)\r\n< snip >\r\n2019-08-31T06:00:41Z UpdateTip: new best=000000000000000017de2992c0de3e98d711253582fa7ee626645e395e4fd0e5 height=311697 version=0x00000002 log2_work=79.815121 tx=42899222 date='2014-07-20T16:20:21Z' progress=0.096217 cache=67.4MiB(497634txo)\r\n2019-08-31T06:00:44Z UpdateTip: new best=000000000000000022aeedbb76913a3666d997897c23efc8e92fe38ec79728a7 height=311698 version=0x00000002 log2_work=79.815222 tx=42899470 date='2014-07-20T16:25:14Z' progress=0.096217 cache=68.0MiB(502949txo)\r\n2019-08-31T06:00:47Z UpdateTip: new best=000000000000000027a68e70c9c02985173c56e8c8ce210c02eb975530d77f0d height=311699 version=0x00000002 log2_work=79.815323 tx=42899561 date='2014-07-20T16:27:06Z' progress=0.096218 cache=68.3MiB(505709txo)\r\n2019-08-31T06:00:51Z UpdateTip: new best=000000000000000038730cd937f594452e96b97a496afc03a84fc90a18119113 height=311700 version=0x00000002 log2_work=79.815424 tx=42900165 date='2014-07-20T16:40:48Z' progress=0.096219 cache=68.8MiB(509386txo)\r\n```\r\n\r\nFWIW I've also rebased and added another commit for a more recent Rust onto https://github.com/fanquake/bitcoin/tree/theuni-with-rust-example-working-rebased. Will add another commit on top for the `--start-group` workaround. Given that you've dropped `cbindgen` here, I can also maintain a branch with that dropped.",
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526803615",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "mentioned",
      "id": 2598678118,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjU5ODY3ODExOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2598678118",
      "actor": {
        "login": "kristapsk",
        "id": 4500994,
        "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kristapsk",
        "html_url": "https://github.com/kristapsk",
        "followers_url": "https://api.github.com/users/kristapsk/followers",
        "following_url": "https://api.github.com/users/kristapsk/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kristapsk/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kristapsk/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
        "organizations_url": "https://api.github.com/users/kristapsk/orgs",
        "repos_url": "https://api.github.com/users/kristapsk/repos",
        "events_url": "https://api.github.com/users/kristapsk/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kristapsk/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-31T06:01:15Z"
    },
    {
      "event": "subscribed",
      "id": 2598678119,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI1OTg2NzgxMTk=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2598678119",
      "actor": {
        "login": "kristapsk",
        "id": 4500994,
        "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kristapsk",
        "html_url": "https://github.com/kristapsk",
        "followers_url": "https://api.github.com/users/kristapsk/followers",
        "following_url": "https://api.github.com/users/kristapsk/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kristapsk/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kristapsk/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
        "organizations_url": "https://api.github.com/users/kristapsk/orgs",
        "repos_url": "https://api.github.com/users/kristapsk/repos",
        "events_url": "https://api.github.com/users/kristapsk/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kristapsk/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-31T06:01:15Z"
    },
    {
      "event": "commented",
      "id": 527549359,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNzU0OTM1OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527549359",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-03T17:04:31Z",
      "updated_at": "2019-09-03T21:34:25Z",
      "author_association": "MEMBER",
      "body": "Concept ACK on adding more redundancy.\r\nAgree that Tor support is desirable, and also measures suggested by @practicalswift are important, but this feature even before those measures is already a big improvement (without trading any privacy comparing to the current threat model with unencrypted p2p I believe).",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-527549359",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "mentioned",
      "id": 2604330267,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjYwNDMzMDI2Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2604330267",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-03T17:04:31Z"
    },
    {
      "event": "subscribed",
      "id": 2604330270,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI2MDQzMzAyNzA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2604330270",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-03T17:04:31Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-03T20:28:07Z",
      "updated_at": "2019-09-03T20:28:07Z",
      "source": {
        "issue": {
          "id": 487806736,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MzEyOTc4OTMx",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16774",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16774/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16774/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16774/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/16774",
          "number": 16774,
          "state": "closed",
          "state_reason": null,
          "title": "Avoid unnecessary \"Synchronizing blockheaders\" log messages",
          "body": "Fixes #16773 \r\n\r\nI'm not entirely sure why 16773 happend, but probably due to headers fallback in a compact block.\r\n\r\nHowever, this PR should fix it and should have been included in #15615.",
          "user": {
            "login": "jonasschnelli",
            "id": 178464,
            "node_id": "MDQ6VXNlcjE3ODQ2NA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonasschnelli",
            "html_url": "https://github.com/jonasschnelli",
            "followers_url": "https://api.github.com/users/jonasschnelli/followers",
            "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
            "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
            "repos_url": "https://api.github.com/users/jonasschnelli/repos",
            "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16774",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/16774",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/16774.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/16774.patch"
          },
          "closed_at": "2019-09-03T20:41:19Z",
          "created_at": "2019-08-31T20:05:11Z",
          "updated_at": "2021-12-16T14:01:44Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "referenced",
      "id": 2604920038,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI2MDQ5MjAwMzg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2604920038",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8e00a68552404160583f7fb340e53f7b8128a550",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e00a68552404160583f7fb340e53f7b8128a550",
      "created_at": "2019-09-03T20:40:19Z"
    },
    {
      "event": "referenced",
      "id": 2605110552,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI2MDUxMTA1NTI=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2605110552",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b3459434c902f1a6a77751dcad048139edcfe00c",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/b3459434c902f1a6a77751dcad048139edcfe00c",
      "created_at": "2019-09-03T21:54:00Z"
    },
    {
      "event": "commented",
      "id": 527816563,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNzgxNjU2Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527816563",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-04T09:15:40Z",
      "updated_at": "2019-09-04T09:15:40Z",
      "author_association": "MEMBER",
      "body": "Concept ACK!",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-527816563",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 528223954,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyODIyMzk1NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528223954",
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-05T06:47:01Z",
      "updated_at": "2019-09-05T06:56:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "Could we try and use something like https://github.com/dtolnay/no-panic on parts of the code? (if we can, this will give us compile time guarantees of no panics)\r\n\r\nAnother Idea, checking nullness at the boundaries and then use https://doc.rust-lang.org/std/ptr/struct.NonNull.html (can even use `NonNull::new()` to check for nullness)\r\n\r\nOther than that I like this and would love to review it when it's reviewable :)",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-528223954",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 528459579,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyODQ1OTU3OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528459579",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-05T16:53:55Z",
      "updated_at": "2019-09-05T16:53:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "I'd rather deliberately use panics so that we can enable overflow checking and catch the panics to kill the Rust thread(s) but leave the rest of Core running. Good call on NonNull, will update to use that!",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-528459579",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615202955,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTIwMjk1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615202955",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T18:18:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615343866,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTM0Mzg2Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615343866",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:12:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615345437,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTM0NTQzNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615345437",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:13:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615358223,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTM1ODIyMw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615358223",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:19:03Z"
    },
    {
      "event": "ready_for_review",
      "id": 2615358713,
      "node_id": "MDE5OlJlYWR5Rm9yUmV2aWV3RXZlbnQyNjE1MzU4NzEz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615358713",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:19:16Z"
    },
    {
      "event": "commented",
      "id": 528981929,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyODk4MTkyOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528981929",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:19:51Z",
      "updated_at": "2019-09-06T19:19:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "Aside from the final commit working around one last build issue, I believe this is ready for review. Doesn't make sense to land for 19, but would be nice to land early in the cycle for 20.",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-528981929",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615560818,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTU2MDgxOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615560818",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T20:46:45Z"
    },
    {
      "event": "commented",
      "id": 529010545,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyOTAxMDU0NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529010545",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T20:53:01Z",
      "updated_at": "2019-09-06T20:53:01Z",
      "author_association": "MEMBER",
      "body": "I'm taking a look at a proper fix for the circular dependency.",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529010545",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615600922,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTYwMDkyMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615600922",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T21:04:33Z"
    },
    {
      "event": "commented",
      "id": 529074057,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyOTA3NDA1Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529074057",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T05:13:08Z",
      "updated_at": "2019-09-07T05:13:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "> https://github.com/bitcoin/bitcoin/blob/3f1ceb95edeb9f58b0a702520a2c452012c63974/src/rusty/src/rest_downloader.rs#L254-L262\r\n\r\nIs there any particular reason that the Rust code is using a hand-rolled HTTP client implementation?\r\n\r\n> https://github.com/bitcoin/bitcoin/blob/3f1ceb95edeb9f58b0a702520a2c452012c63974/src/rusty/src/rest_downloader.rs#L246-L248\r\n\r\nTLS support would be more or less free if we didn't roll our own implementation? :-)\r\n\r\nTLS would be really nice to have since our goal with this PR is to increase censorship resistance.",
      "user": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529074057",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "milestoned",
      "id": 2616005895,
      "node_id": "MDE1Ok1pbGVzdG9uZWRFdmVudDI2MTYwMDU4OTU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616005895",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T05:14:22Z",
      "milestone": {
        "title": "0.20.0"
      }
    },
    {
      "event": "labeled",
      "id": 2616159436,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI2MTYxNTk0MzY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616159436",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T11:32:27Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2616324922,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNjMyNDkyMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616324922",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T17:30:05Z"
    },
    {
      "event": "commented",
      "id": 529128639,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyOTEyODYzOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529128639",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T17:33:12Z",
      "updated_at": "2019-09-07T17:33:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased.\r\n\r\nYea, probably makes sense to switch to a non-handrolled-HTTP-parser eventually, but:\r\na) I haven't yet had the time to look into existing rust ones to see if I can find anything suitable (ie doesn't pull in a million dependencies, implying its probably not async/tokio based, and easy to review), which in my previous experience implies this may be hard,\r\nb) if we add any dependencies we have to have a process for vendoring the entire recursive dependency tree, which is gonna be its own hurdle, so I figured leave that for a follow-up PR.",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529128639",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "unlabeled",
      "id": 2616330048,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50MjYxNjMzMDA0OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616330048",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T17:42:15Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 285188001,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1MTg4MDAx",
      "url": null,
      "actor": null,
      "commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed all the rust code and FFI except `read_http_resp` which haven't had time to review it with the HTTP specs.\r\n\r\nDon't know enough about bitcoin's P2P to comment if the logic itself makes a lot of sense.\r\nDidn't try to run it yet.",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#pullrequestreview-285188001",
      "submitted_at": "2019-09-07T22:57:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-08T20:35:05Z",
      "updated_at": "2019-09-08T20:35:05Z",
      "source": {
        "issue": {
          "id": 490803093,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MzE1MzA1NDg3",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16834",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16834/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16834/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16834/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/16834",
          "number": 16834,
          "state": "closed",
          "state_reason": null,
          "title": "Fetch Headers over DNS",
          "body": "This allows us to fetch headers from the DNS. While this isn't very useful on its own, its a somewhat cool demo of how low the review burden could be to add new fetch methods in Rust code, and could be a useful to know whether we're behind (eg for stale tip checking). You can test with -headersfetchdns=headers.bitcoinheaders.net which is served from a standard bind named with the following generation scripts:\r\n\r\n```\r\nfor I in {0..100}; do\r\n\techo \"\" > headers-$I.zone\r\ndone\r\nCOUNT=$(~/bitcoin-cli getblockcount)\r\n\r\nfor I in `seq 0 2000 $COUNT`; do\r\n\tHASH=$(~/bitcoin-cli getblockhash $I)\r\n\twget -q -O - http://127.0.0.1/rest/headers/2000/$HASH.hex | ./split $I $COUNT >> headers-$(($I / 10000)).zone\r\ndone\r\n```\r\n\r\n```\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n\r\n// Primes with 2 replaced with 1:\r\nstatic const int PRIMES[] = {1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973, 10007, 10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247, 10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 10357, 10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 10663, 10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733, 10739, 10753, 10771, 10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859, 10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 10957, 10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 11069, 11071, 11083, 11087, 11093, 11113, 11117, 11119, 11131, 11149, 11159, 11161, 11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251, 11257, 11261, 11273, 11279, 11287, 11299, 11311, 11317, 11321, 11329, 11351, 11353, 11369, 11383, 11393, 11399, 11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483, 11489, 11491, 11497, 11503, 11519, 11527, 11549, 11551, 11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657, 11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731, 11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831, 11833, 11839, 11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933, 11939, 11941, 11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011, 12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 12113, 12119, 12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 12227, 12239, 12241, 12251, 12253, 12263, 12269, 12277, 12281, 12289, 12301, 12323, 12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401, 12409, 12413, 12421, 12433, 12437, 12451, 12457, 12473, 12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527, 12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589, 12601, 12611, 12613, 12619, 12637, 12641, 12647, 12653, 12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739, 12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821, 12823, 12829, 12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923, 12941, 12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 13009, 13033, 13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109, 13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 13217, 13219, 13229, 13241, 13249, 13259, 13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337, 13339, 13367, 13381, 13397, 13399, 13411, 13417, 13421, 13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499, 13513, 13523, 13537, 13553, 13567, 13577, 13591, 13597, 13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681, 13687, 13691, 13693, 13697, 13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759, 13763, 13781, 13789, 13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879, 13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933, 13963, 13967, 13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 14083, 14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221, 14243, 14249, 14251, 14281, 14293, 14303, 14321, 14323, 14327, 14341, 14347, 14369, 14387, 14389, 14401, 14407, 14411, 14419, 14423, 14431, 14437, 14447, 14449, 14461, 14479, 14489, 14503, 14519, 14533, 14537, 14543, 14549, 14551, 14557, 14561, 14563, 14591, 14593, 14621, 14627, 14629, 14633, 14639, 14653, 14657, 14669, 14683, 14699, 14713, 14717, 14723, 14731, 14737, 14741, 14747, 14753, 14759, 14767, 14771, 14779, 14783, 14797, 14813, 14821, 14827, 14831, 14843, 14851, 14867, 14869, 14879, 14887, 14891, 14897, 14923, 14929, 14939, 14947, 14951, 14957, 14969, 14983, 15013, 15017, 15031, 15053, 15061, 15073, 15077, 15083, 15091, 15101, 15107, 15121, 15131, 15137, 15139, 15149, 15161, 15173, 15187, 15193, 15199, 15217, 15227, 15233, 15241, 15259, 15263, 15269, 15271, 15277, 15287, 15289, 15299, 15307, 15313, 15319, 15329, 15331, 15349, 15359, 15361, 15373, 15377, 15383, 15391, 15401, 15413, 15427, 15439, 15443, 15451, 15461, 15467, 15473, 15493, 15497, 15511, 15527, 15541, 15551, 15559, 15569, 15581, 15583, 15601, 15607, 15619, 15629, 15641, 15643, 15647, 15649, 15661, 15667, 15671, 15679, 15683, 15727, 15731, 15733, 15737, 15739, 15749, 15761, 15767, 15773, 15787, 15791, 15797, 15803, 15809, 15817, 15823, 15859, 15877, 15881, 15887, 15889, 15901, 15907, 15913, 15919, 15923, 15937, 15959, 15971, 15973, 15991, 16001, 16007, 16033, 16057, 16061, 16063, 16067, 16069, 16073, 16087, 16091, 16097, 16103, 16111, 16127, 16139, 16141, 16183, 16187, 16189, 16193, 16217, 16223, 16229, 16231, 16249, 16253, 16267, 16273, 16301, 16319, 16333, 16339, 16349, 16361, 16363, 16369, 16381, 16411, 16417, 16421, 16427, 16433, 16447, 16451, 16453, 16477, 16481, 16487, 16493, 16519, 16529, 16547, 16553, 16561, 16567, 16573, 16603, 16607, 16619, 16631, 16633, 16649, 16651, 16657, 16661, 16673, 16691, 16693, 16699, 16703, 16729, 16741, 16747, 16759, 16763, 16787, 16811, 16823, 16829, 16831, 16843, 16871, 16879, 16883, 16889, 16901, 16903, 16921, 16927, 16931, 16937, 16943, 16963, 16979, 16981, 16987, 16993, 17011, 17021, 17027, 17029, 17033, 17041, 17047, 17053, 17077, 17093, 17099, 17107, 17117, 17123, 17137, 17159, 17167, 17183, 17189, 17191, 17203, 17207, 17209, 17231, 17239, 17257, 17291, 17293, 17299, 17317, 17321, 17327, 17333, 17341, 17351, 17359, 17377, 17383, 17387, 17389, 17393, 17401, 17417, 17419, 17431, 17443, 17449, 17467, 17471, 17477, 17483, 17489, 17491, 17497, 17509, 17519, 17539, 17551, 17569, 17573, 17579, 17581, 17597, 17599, 17609, 17623, 17627, 17657, 17659, 17669, 17681, 17683, 17707, 17713, 17729, 17737, 17747, 17749, 17761, 17783, 17789, 17791, 17807, 17827, 17837, 17839, 17851, 17863, 17881, 17891, 17903, 17909, 17911, 17921, 17923, 17929, 17939, 17957, 17959, 17971, 17977, 17981, 17987, 17989, 18013, 18041, 18043, 18047, 18049, 18059, 18061, 18077, 18089, 18097, 18119, 18121, 18127, 18131, 18133, 18143, 18149, 18169, 18181, 18191, 18199, 18211, 18217, 18223, 18229, 18233, 18251, 18253, 18257, 18269, 18287, 18289, 18301, 18307, 18311, 18313, 18329, 18341, 18353, 18367, 18371, 18379, 18397, 18401, 18413, 18427, 18433, 18439, 18443, 18451, 18457, 18461, 18481, 18493, 18503, 18517, 18521, 18523, 18539, 18541, 18553, 18583, 18587, 18593, 18617, 18637, 18661, 18671, 18679, 18691, 18701, 18713, 18719, 18731, 18743, 18749, 18757, 18773, 18787, 18793, 18797, 18803, 18839, 18859, 18869, 18899, 18911, 18913, 18917, 18919, 18947, 18959, 18973, 18979, 19001, 19009, 19013, 19031, 19037, 19051, 19069, 19073, 19079, 19081, 19087, 19121, 19139, 19141, 19157, 19163, 19181, 19183, 19207, 19211, 19213, 19219, 19231, 19237, 19249, 19259, 19267, 19273, 19289, 19301, 19309, 19319, 19333, 19373, 19379, 19381, 19387, 19391, 19403, 19417, 19421, 19423, 19427, 19429, 19433, 19441, 19447, 19457, 19463, 19469, 19471, 19477, 19483, 19489, 19501, 19507, 19531, 19541, 19543, 19553, 19559, 19571, 19577, 19583, 19597, 19603, 19609, 19661, 19681, 19687, 19697, 19699, 19709, 19717, 19727, 19739, 19751, 19753, 19759, 19763, 19777, 19793, 19801, 19813, 19819, 19841, 19843, 19853, 19861, 19867, 19889, 19891, 19913, 19919, 19927, 19937, 19949, 19961, 19963, 19973, 19979, 19991, 19993, 19997, 20011, 20021, 20023, 20029, 20047, 20051, 20063, 20071, 20089, 20101, 20107, 20113, 20117, 20123, 20129, 20143, 20147, 20149, 20161, 20173, 20177, 20183, 20201, 20219, 20231, 20233, 20249, 20261, 20269, 20287, 20297, 20323, 20327, 20333, 20341, 20347, 20353, 20357, 20359, 20369, 20389, 20393, 20399, 20407, 20411, 20431, 20441, 20443, 20477, 20479, 20483, 20507, 20509, 20521, 20533, 20543, 20549, 20551, 20563, 20593, 20599, 20611, 20627, 20639, 20641, 20663, 20681, 20693, 20707, 20717, 20719, 20731, 20743, 20747, 20749, 20753, 20759, 20771, 20773, 20789, 20807, 20809, 20849, 20857, 20873, 20879, 20887, 20897, 20899, 20903, 20921, 20929, 20939, 20947, 20959, 20963, 20981, 20983, 21001, 21011, 21013, 21017, 21019, 21023, 21031, 21059, 21061, 21067, 21089, 21101, 21107, 21121, 21139, 21143, 21149, 21157, 21163, 21169, 21179, 21187, 21191, 21193, 21211, 21221, 21227, 21247, 21269, 21277, 21283, 21313, 21317, 21319, 21323, 21341, 21347, 21377, 21379, 21383, 21391, 21397, 21401, 21407, 21419, 21433, 21467, 21481, 21487, 21491, 21493, 21499, 21503, 21517, 21521, 21523, 21529, 21557, 21559, 21563, 21569, 21577, 21587, 21589, 21599, 21601, 21611, 21613, 21617, 21647, 21649, 21661, 21673, 21683, 21701, 21713, 21727, 21737, 21739, 21751, 21757, 21767, 21773, 21787, 21799, 21803, 21817, 21821, 21839, 21841, 21851, 21859, 21863, 21871, 21881, 21893, 21911, 21929, 21937, 21943, 21961, 21977, 21991, 21997, 22003, 22013, 22027, 22031, 22037, 22039, 22051, 22063, 22067, 22073, 22079, 22091, 22093, 22109, 22111, 22123, 22129, 22133, 22147, 22153, 22157, 22159, 22171, 22189, 22193, 22229, 22247, 22259, 22271, 22273, 22277, 22279, 22283, 22291, 22303, 22307};\r\n\r\n\r\nint main(int argc, char* argv[]) {\r\n\tassert(argc >= 3);\r\n\tint start_height = atoi(argv[1]);\r\n\tint total_height = atoi(argv[2]);\r\n\t// We don't want to constantly update old header zones, but we do want their TTLs\r\n\t// to get updated slowly, so we update zones on prime intervals of block count:\r\n\tint chunk = start_height / 10000;\r\n\tint chunk_count = total_height / 10000;\r\n\tint update_every = PRIMES[(chunk_count - chunk) * 5];\r\n\tint ttl = ((total_height - start_height) / update_every) * update_every;\r\n\tif (ttl > update_every * 60 * 10 && ttl > 86400/2) {\r\n\t\tfprintf(stderr, \"Bad TTL %d for updating every %d blocks (%d sec)\\n\", ttl, update_every, update_every * 60 * 10);\r\n\t\tttl = update_every * 60 * 10;\r\n\t}\r\n\r\n\tchar* hex = NULL;\r\n\tsize_t linelen = 0;\r\n\tgetline(&hex, &linelen, stdin);\r\n\tsize_t len = strlen(hex);\r\n\tfor (int i = 0; i < len / 80 / 2; i++) {\r\n\t\tfor (int j = 0; j < 6; j++) {\r\n\t\t\tchar fmt[7*5];\r\n\t\t\tmemset(fmt, 0, sizeof(fmt));\r\n\t\t\tsize_t offs = 0;\r\n\t\t\tif (j == 0) {\r\n\t\t\t\tfmt[0] = '0';\r\n\t\t\t\tfmt[1] = '0';\r\n\t\t\t\tfmt[2] = hex[i * 80*2];\r\n\t\t\t\toffs = 1;\r\n\t\t\t} else {\r\n\t\t\t\toffs = (j-1)*27 + 25;\r\n\t\t\t\tmemcpy(fmt, &hex[i * 80*2 + offs], 3);\r\n\t\t\t\toffs += 3;\r\n\t\t\t}\r\n\t\t\tmemcpy(fmt + 1*5, &hex[i * 80*2 + 0*4 + offs], 4);\r\n\t\t\tmemcpy(fmt + 2*5, &hex[i * 80*2 + 1*4 + offs], 4);\r\n\t\t\tmemcpy(fmt + 3*5, &hex[i * 80*2 + 2*4 + offs], 4);\r\n\t\t\tmemcpy(fmt + 4*5, &hex[i * 80*2 + 3*4 + offs], 4);\r\n\t\t\tmemcpy(fmt + 5*5, &hex[i * 80*2 + 4*4 + offs], 4);\r\n\t\t\tmemcpy(fmt + 6*5, &hex[i * 80*2 + 5*4 + offs], 4);\r\n\t\t\tint zttl = ttl - i;\r\n\t\t\tif (zttl < 60) { zttl = 60; }\r\n\t\t\tprintf(\"%d\t%d\tIN\tAAAA\t2001:%d%s:%s:%s:%s:%s:%s:%s\\n\",\r\n\t\t\t\tstart_height + i, zttl, j,\r\n\t\t\t\t&fmt[0 * 5],\r\n\t\t\t\t&fmt[1 * 5],\r\n\t\t\t\t&fmt[2 * 5],\r\n\t\t\t\t&fmt[3 * 5],\r\n\t\t\t\t&fmt[4 * 5],\r\n\t\t\t\t&fmt[5 * 5],\r\n\t\t\t\t&fmt[6 * 5]);\r\n\t\t}\r\n\t}\r\n}\r\n```",
          "user": {
            "login": "TheBlueMatt",
            "id": 649246,
            "node_id": "MDQ6VXNlcjY0OTI0Ng==",
            "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/TheBlueMatt",
            "html_url": "https://github.com/TheBlueMatt",
            "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
            "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
            "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
            "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
            "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 64583,
              "node_id": "MDU6TGFiZWw2NDU4Mw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature",
              "name": "Feature",
              "color": "7cf575",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            },
            {
              "id": 1392286103,
              "node_id": "MDU6TGFiZWwxMzkyMjg2MTAz",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20Conceptual%20Review",
              "name": "Needs Conceptual Review",
              "description": "",
              "color": "fef2c0",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/42",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/42",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/42/labels",
            "id": 4116761,
            "node_id": "MDk6TWlsZXN0b25lNDExNjc2MQ==",
            "number": 42,
            "state": "closed",
            "title": "0.20.0",
            "description": "",
            "creator": {
              "login": "MarcoFalke",
              "id": 6399679,
              "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
              "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/MarcoFalke",
              "html_url": "https://github.com/MarcoFalke",
              "followers_url": "https://api.github.com/users/MarcoFalke/followers",
              "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
              "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
              "repos_url": "https://api.github.com/users/MarcoFalke/repos",
              "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 91,
            "created_at": "2019-03-06T20:02:40Z",
            "updated_at": "2020-06-02T07:55:47Z",
            "closed_at": "2020-06-02T07:55:47Z"
          },
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 22,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16834",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/16834",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/16834.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/16834.patch"
          },
          "closed_at": "2020-03-05T19:48:09Z",
          "created_at": "2019-09-08T20:35:05Z",
          "updated_at": "2022-02-15T10:48:41Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2616988101,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNjk4ODEwMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616988101",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-08T20:58:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2617243007,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNzI0MzAwNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2617243007",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-09T03:08:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2617248164,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNzI0ODE2NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2617248164",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-09T03:13:59Z"
    },
    {
      "event": "reviewed",
      "id": 285575526,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NTc1NTI2",
      "url": null,
      "actor": null,
      "commit_id": "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#pullrequestreview-285575526",
      "submitted_at": "2019-09-09T15:04:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2620157163,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYyMDE1NzE2Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2620157163",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-09T21:05:04Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2670289727,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjY3MDI4OTcyNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2670289727",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-28T03:15:01Z"
    },
    {
      "event": "labeled",
      "id": 2672851860,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI2NzI4NTE4NjA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2672851860",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-30T11:14:27Z",
      "label": {
        "name": "Feature",
        "color": "7cf575"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2675149839,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjY3NTE0OTgzOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2675149839",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-30T23:53:19Z"
    },
    {
      "event": "commented",
      "id": 536799717,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzNjc5OTcxNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/536799717",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-30T23:57:35Z",
      "updated_at": "2019-09-30T23:57:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "Now based on #16834 instead of the other way around, but otherwise this should be mostly good to go!",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-536799717",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2690180328,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjY5MDE4MDMyOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2690180328",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-06T22:04:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2690285897,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjY5MDI4NTg5Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2690285897",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-07T01:12:29Z"
    },
    {
      "event": "labeled",
      "id": 2699528733,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI2OTk1Mjg3MzM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2699528733",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-09T15:41:49Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-09T21:01:31Z",
      "updated_at": "2019-10-09T21:01:31Z",
      "source": {
        "issue": {
          "id": 504893181,
          "node_id": "MDU6SXNzdWU1MDQ4OTMxODE=",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17090",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17090/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17090/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17090/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/17090",
          "number": 17090,
          "state": "closed",
          "state_reason": "completed",
          "title": "RFC: Rust code integration",
          "body": "Moving the discussion from #15798 here, as it makes more sense to have it in an issue instead of a PR. #15798 no longer reflects the current proposed Rust changes, and Rust related work is now happening across multiple others.\r\n\r\n[Corys](https://github.com/theuni/) thoughts / introduction from #15798:\r\n\r\n> This is not intended to be merged as-is, but instead to serve as a reference for anyone who might be interested in trying out some rust code inside of Bitcoin Core. I have no idea what works. I have lots of questions about debugging, threading, etc. But instead of trying to hack and document how things work, we thought it'd be fun for everyone to be able to poke at it and scratch our heads together :). If something interesting comes out of it, a discussion about merging can happen then.\r\n\r\n> It is surprisingly functional. The rust tools are impeccable. I would've thought this would be a project that would take months/years, but the rust devs have done such a good job that mostly everything already just works. The gitian descriptors have been modified to actually incorporate working rust code. All of our currently supported platforms seem to already work (even macOS cross!) with the exception of 32bit windows and ancient linux distros. The specific issues are documented in the gitian descriptors. For now, Gitian needs net access and a larger disk volume, but those are both very temporary issues\r\n\r\n> Why rust? I don't know. Maybe not. But I think it's a fair assumption to say that Rust code will eventually end up in Bitcoin Core as the result of adding a new dependency. Adoption is happing quickly. So, I think it prudent to look ahead and not only be prepared, but actively help usher it in. Already I have a few things that I would like to work on and upstream to rust-lang to make our integration nicer, and I assume that more will be uncovered as it actually gets used.\r\n\r\n> Anybody have any fun ideas?\r\n\r\nThere's still discussion to be had / documentation to be added around various Rust related decisions, such as:\r\n* Whether to use/require the `2015` or `2018` Editions.\r\n* A minimum required version of the language.\r\n* How failures in the Rust code are (expected to be) handled by the c++ code.\r\n\r\nAs well as higher level discussions around how far we might take the Rust integration/re-writing of certain parts of the code, and the complexities that could introduce in regards which contributors can/can't write/review Rust, or have more/less experience with the language compared to `C++` etc.\r\n\r\nPersonally, I'd like to think that we'll have some off-by-default Rust as part of the Bitcoin Core 0.20.0 release; and I think something like #16834 might be a good first approach. Regardless of approach, the idea of using Rust inside Bitcoin Core seems to resonate with some of the (still limited set) of other contributors I've discussed it with.\r\n\r\n#### Using `rustc` directly instead of Cargo\r\nThe initial Rust [integration PR](https://github.com/bitcoin/bitcoin/pull/15798) used [Cargo](https://doc.rust-lang.org/cargo) for managing compiling, dependencies etc. Since then, the Rust changes have been refactored to remove the `cbindgen` dependency and drop any usage of Cargo altogether, in favour of using [`rustc` directly](https://github.com/bitcoin/bitcoin/pull/16834/files#diff-480477e89f9b6ddafb30c4383dcdd705R371).\r\n\r\nSee also the recent [Security advisory for Cargo](https://blog.rust-lang.org/2019/09/30/Security-advisory-for-cargo.html).\r\n\r\n#### Related PRs\r\n[Fetch Headers over DNS](https://github.com/bitcoin/bitcoin/pull/16834)\r\n[Rust-based Backup over-REST block downloader](https://github.com/bitcoin/bitcoin/pull/16762)\r\n[Add Parallel P2P Client in Rust](https://github.com/bitcoin/bitcoin/pull/17376)\r\n\r\n\r\n#### Related Reading\r\n[Bootstrapping Rust using Guix](https://guix.gnu.org/blog/2018/bootstrapping-rust/)",
          "user": {
            "login": "fanquake",
            "id": 863730,
            "node_id": "MDQ6VXNlcjg2MzczMA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fanquake",
            "html_url": "https://github.com/fanquake",
            "followers_url": "https://api.github.com/users/fanquake/followers",
            "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
            "organizations_url": "https://api.github.com/users/fanquake/orgs",
            "repos_url": "https://api.github.com/users/fanquake/repos",
            "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fanquake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 64584,
              "node_id": "MDU6TGFiZWw2NDU4NA==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Brainstorming",
              "name": "Brainstorming",
              "color": "ebd775",
              "default": false
            },
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 1392286103,
              "node_id": "MDU6TGFiZWwxMzkyMjg2MTAz",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20Conceptual%20Review",
              "name": "Needs Conceptual Review",
              "description": "",
              "color": "fef2c0",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 38,
          "closed_at": "2022-08-15T13:13:54Z",
          "created_at": "2019-10-09T21:01:30Z",
          "updated_at": "2022-08-15T13:13:55Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2704395493,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjcwNDM5NTQ5Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2704395493",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-10T22:22:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2715878314,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjcxNTg3ODMxNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2715878314",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-16T00:52:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2715950519,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjcxNTk1MDUxOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2715950519",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-16T01:47:18Z"
    },
    {
      "event": "unlabeled",
      "id": 2715967350,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50MjcxNTk2NzM1MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2715967350",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-16T02:00:01Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 2746017920,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI3NDYwMTc5MjA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2746017920",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-26T11:13:21Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2746290780,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc0NjI5MDc4MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2746290780",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-26T20:55:56Z"
    },
    {
      "event": "unlabeled",
      "id": 2746304705,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50Mjc0NjMwNDcwNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2746304705",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-26T21:29:21Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2753504517,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc1MzUwNDUxNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2753504517",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-29T19:26:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2765737779,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc2NTczNzc3OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2765737779",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-03T04:40:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2765746604,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc2NTc0NjYwNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2765746604",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-03T05:09:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2765782905,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc2NTc4MjkwNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2765782905",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-03T07:12:21Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-05T05:11:10Z",
      "updated_at": "2019-11-05T05:11:10Z",
      "source": {
        "issue": {
          "id": 517551360,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MzM2NTk4NDIw",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17376",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17376/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17376/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17376/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/17376",
          "number": 17376,
          "state": "closed",
          "state_reason": null,
          "title": "Add Parallel P2P Client in Rust",
          "body": "This was actually the original goal of the Rust work, but we had to start somewhere a bit simpler. This adds a full parallel P2P client, written in Rust, which can download and serve both headers and blocks, listening on a separate port. It is designed to be simple and robust, letting the C++ net_processing handle being optimized. It avoids wasting bandwidth needlessly by not (like all Rust modules so far) starting up until either IBD completes or it seems stuck and by waiting 30 seconds any time it hears about a new block that it decides to fetch before *actually* fetching it.\r\n\r\nBased on (but could probably go in independently of) #16834, #16762, and #16974.\r\n\r\nSome tasks that need to happen to clean this up a bit:\r\n\r\n- [ ] Build out the Rust addrman a bit - it currently always queries DNS seeds until its built out a database of 500 addresses and then never changes it. I don't think this is a particularly terrible design at a high level for something with a goal of simply having a different failure model from the C++ addrman, but the over-reliance on the DNS seeds needs to go, at least (plus we dont want to ever query them after we've built up an addrman that works, eg upon upgrade).\r\n- [x] Build out connection logic a bit - we currently just open connections willy nilly very aggressively if our best header falls behind our best tip. This is great, but we should probably, like, disconnect peers that don't manage to help us along our journey (especially since the Rust code is hard-limited to 128MB of memory allocations, though this may want to change to 256MB, we have very little room for peers given our socket buffers are like 8-16MB just to receive a block and send one).\r\n- [ ] Support Windows. Currently uses poll() for socket handling and a pipe() to wake up the poll() thread. Needs a Windows version of that module, though that shouldn't be too hard...right?\r\n- [ ] A XXX or two, at least one of them probably requires @elichai explain Rust to me.\r\n- [ ] Subtree the libsecp bump, and the addition of rust-bitcoin crates (all managed in the rust-bitcoin org on GH by the Usual Folks) and libc crates (which just exposes libc functions and little more, though in theory we could probably drop this if we wanted to expose them ourselves, but it should be pretty simple). Subtrees are a PITA to handle, so this will just happen right before merge.\r\n",
          "user": {
            "login": "TheBlueMatt",
            "id": 649246,
            "node_id": "MDQ6VXNlcjY0OTI0Ng==",
            "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/TheBlueMatt",
            "html_url": "https://github.com/TheBlueMatt",
            "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
            "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
            "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
            "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
            "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/17376",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/17376",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/17376.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/17376.patch"
          },
          "closed_at": "2020-03-05T19:48:18Z",
          "created_at": "2019-11-05T05:11:10Z",
          "updated_at": "2022-02-15T10:41:44Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 2784591198,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI3ODQ1OTExOTg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2784591198",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-08T21:25:43Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2789901567,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc4OTkwMTU2Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2789901567",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-12T02:07:51Z"
    },
    {
      "event": "unlabeled",
      "id": 2790036881,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50Mjc5MDAzNjg4MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2790036881",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-12T03:40:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 2810548418,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI4MTA1NDg0MTg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2810548418",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-19T09:03:38Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2813400932,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjgxMzQwMDkzMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2813400932",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-19T23:35:38Z"
    },
    {
      "event": "unlabeled",
      "id": 2813614118,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50MjgxMzYxNDExOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2813614118",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-20T01:40:07Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 2815868206,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI4MTU4NjgyMDY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2815868206",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-20T16:12:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2821383578,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjgyMTM4MzU3OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2821383578",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-21T22:24:53Z"
    },
    {
      "event": "unlabeled",
      "id": 2821503870,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50MjgyMTUwMzg3MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2821503870",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-21T23:20:58Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 2855301736,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI4NTUzMDE3MzY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2855301736",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-04T19:48:36Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDBjZTI4ZjVhMzEzYWZhNzcyMTc4ZmJlODk3MDU1NmMxNzYwNWVj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/100ce28f5a313afa772178fbe8970556c17605ec",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/100ce28f5a313afa772178fbe8970556c17605ec",
      "tree": {
        "sha": "74e6aa3e04612ee44767f5261babd73c432de486",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/74e6aa3e04612ee44767f5261babd73c432de486"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6fff333c9f00cf379562ed38c2599997f9821cfb",
          "sha": "6fff333c9f00cf379562ed38c2599997f9821cfb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6fff333c9f00cf379562ed38c2599997f9821cfb"
        }
      ],
      "message": "Adds a rust library to bitcoin to demonstrate linking and building rust code.\n\nThe demonstration library compiles a rust hello world example and auto-generates\na header which can be included in C++ code.\n\nCo-Authored-By: Jeremy Rubin <j@rubin.io>\nCo-Authored-By: Cory Fields <cory-nospam-@coryfields.com>\nVarious changes by: Matt Corallo <git@bluematt.me>",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2019-03-29T21:48:20Z"
      },
      "sha": "100ce28f5a313afa772178fbe8970556c17605ec"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODMwZDllMGM4ZDYwZmEzZDE5ZGNkOThkNjkzYWZkNjU1ZjlhY2Ni",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
      "tree": {
        "sha": "15379f2040f943f35335fe4d333e86454335bbfb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/15379f2040f943f35335fe4d333e86454335bbfb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/100ce28f5a313afa772178fbe8970556c17605ec",
          "sha": "100ce28f5a313afa772178fbe8970556c17605ec",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/100ce28f5a313afa772178fbe8970556c17605ec"
        }
      ],
      "message": "build: show rust enabled in configure output",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2019-06-15T10:44:20Z"
      },
      "sha": "4830d9e0c8d60fa3d19dcd98d693afd655f9accb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MjhhOTgyMmEwMGQwZjlmNzUwMmNlMjNiZDYyNzZiYWUzMDY4MWNm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/828a9822a00d0f9f7502ce23bd6276bae30681cf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/828a9822a00d0f9f7502ce23bd6276bae30681cf",
      "tree": {
        "sha": "903433080f7ea84a5f95b3de8bf055b2fb258ae2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/903433080f7ea84a5f95b3de8bf055b2fb258ae2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
          "sha": "4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4830d9e0c8d60fa3d19dcd98d693afd655f9accb"
        }
      ],
      "message": "build: gitignore src/rusty_test",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2019-06-15T10:44:58Z"
      },
      "sha": "828a9822a00d0f9f7502ce23bd6276bae30681cf"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmQ1ZjZmYmEwYjU3ZTZmYzI4NzY0M2RkNWYxYTk3ZDZjMDViOTAx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
      "tree": {
        "sha": "597d14d253ba45f068963a50e300d8a75125fc46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/597d14d253ba45f068963a50e300d8a75125fc46"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/828a9822a00d0f9f7502ce23bd6276bae30681cf",
          "sha": "828a9822a00d0f9f7502ce23bd6276bae30681cf",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/828a9822a00d0f9f7502ce23bd6276bae30681cf"
        }
      ],
      "message": "Add basic ffi bindings for Rust header download\n\nAlso, break circular dependency with a new helper lib courtesy of\nCory Fields <cory-nospam-@coryfields.com>.",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2019-09-30T20:31:47Z"
      },
      "sha": "9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMDc2M2IyOGVhMWFhMmNiZDgwNTVlN2ViYzQ1NGU4MmViZDE3OThm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
      "tree": {
        "sha": "b4f5cd77a7e270a93ffa08938b4b979f03cdb95d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b4f5cd77a7e270a93ffa08938b4b979f03cdb95d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
          "sha": "9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901"
        }
      ],
      "message": "Add headers-over-DNS fetcher in Rust",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-10T21:58:42Z"
      },
      "sha": "f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYjIxYjY5ODEwYzZjNzBjZTdkMTZjNWMwZmMxOWJmMTI5MjdkYzZl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
      "tree": {
        "sha": "ef285217f45acd5e6c7732e34ed53f5f8f2ea4d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef285217f45acd5e6c7732e34ed53f5f8f2ea4d2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
          "sha": "f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f"
        }
      ],
      "message": "Limit total memory allocated by all Rust code to 128MB",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-06T16:16:14Z"
      },
      "sha": "eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NDA1MWFkZGQ5OWM5MzMzMzhkNDBhNDg4Y2Y4ZTgxMGQ5Y2ZkZDM0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94051addd99c933338d40a488cf8e810d9cfdd34",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/94051addd99c933338d40a488cf8e810d9cfdd34",
      "tree": {
        "sha": "1fb764403fdeb8e4d18f1fa141741562ae495674",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1fb764403fdeb8e4d18f1fa141741562ae495674"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
          "sha": "eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e"
        }
      ],
      "message": "Enable rustc building + testing on xenial Tsan Travis job",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-10T22:28:27Z"
      },
      "sha": "94051addd99c933338d40a488cf8e810d9cfdd34"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjY2JkOTI4Y2Y1MWYyZWJmZTBmZDc4MjdkMGU2MzJjMjJmY2ZkNDE5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
      "tree": {
        "sha": "25146882ed9d538226686038415b6a018f5d5f40",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/25146882ed9d538226686038415b6a018f5d5f40"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94051addd99c933338d40a488cf8e810d9cfdd34",
          "sha": "94051addd99c933338d40a488cf8e810d9cfdd34",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/94051addd99c933338d40a488cf8e810d9cfdd34"
        }
      ],
      "message": "Move CNode's FindNextBlocksToDownload state into its own strut\n\nThis starts the process of moving the last bits of\nvalidation-critical logic out of net_processing - the fallback\nlogic of which blocks to download is incredibly critical to\nvalidation and would likely also be used for any parallel block\nsync systems. Further, assumeutxo will require additional ability\nto select blocks for download, which is a validation-specific\nconcept and shouldn't really live in net_processing.\n\nThis moves a few responsibilities to the FindNextBlocksToDownload\ncallsite instead of passing in a CNodeId, but otherwise has no\nfunctional changes.",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-21T20:25:04Z"
      },
      "sha": "ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNjk2YWIxYmFiMjhiMWM5YzJmMGNjY2NhMjc1OTBmZDUzZDk2ODY1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
      "tree": {
        "sha": "82bc403b88b0f892e7337397fce5a9aae921d27b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/82bc403b88b0f892e7337397fce5a9aae921d27b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
          "sha": "ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419"
        }
      ],
      "message": "Make FindNextBlocksToDownload a member func on BlockProviderState",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T21:28:57Z"
      },
      "sha": "0696ab1bab28b1c9c2f0cccca27590fd53d96865"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZmM1NTZkMWY4NmJiMjcxZTViMDhhMWNhMTVkYTg4ZmMxOTRlOWFi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
      "tree": {
        "sha": "414f9343dbe73be48dcec7fe5d629d2fb8293de9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/414f9343dbe73be48dcec7fe5d629d2fb8293de9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
          "sha": "0696ab1bab28b1c9c2f0cccca27590fd53d96865",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0696ab1bab28b1c9c2f0cccca27590fd53d96865"
        }
      ],
      "message": "Make FindNextBlocksToDownload not use mapBlockIndex for in-progress\n\nThis makes it more general than just net_processing",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T22:00:36Z"
      },
      "sha": "6fc556d1f86bb271e5b08a1ca15da88fc194e9ab"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNTEzODM1ZTIwMTA2NWNhZDIyZmRjN2E3ODMwYjUxZDgxYTkzNDEw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e513835e201065cad22fdc7a7830b51d81a93410",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e513835e201065cad22fdc7a7830b51d81a93410",
      "tree": {
        "sha": "ba60797a2dfcd6ebb2139cd0e7df008919efc989",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ba60797a2dfcd6ebb2139cd0e7df008919efc989"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
          "sha": "6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab"
        }
      ],
      "message": "Move BlockProvider to validation.{h,cpp} from net_processing",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T22:07:19Z"
      },
      "sha": "e513835e201065cad22fdc7a7830b51d81a93410"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzYxMTA3Yzg5ZDk1ODFhOTU3NjM4NjZhMzlkOTU0MTk3ZjcxZTcw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1361107c89d9581a95763866a39d954197f71e70",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1361107c89d9581a95763866a39d954197f71e70",
      "tree": {
        "sha": "13d9921413636f153dc0faf956a948775c8b306e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13d9921413636f153dc0faf956a948775c8b306e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e513835e201065cad22fdc7a7830b51d81a93410",
          "sha": "e513835e201065cad22fdc7a7830b51d81a93410",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e513835e201065cad22fdc7a7830b51d81a93410"
        }
      ],
      "message": "Add ffis to access BlockProviderState and hand blocks to C++",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-12T04:53:41Z"
      },
      "sha": "1361107c89d9581a95763866a39d954197f71e70"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYzBkZGEzM2M1MTMyNDY4NmJjMTQzZDhiZWQ4OWViYmEwODhhYjhh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "tree": {
        "sha": "84dfd0322bad2df6531242b58489123328c05e34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/84dfd0322bad2df6531242b58489123328c05e34"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1361107c89d9581a95763866a39d954197f71e70",
          "sha": "1361107c89d9581a95763866a39d954197f71e70",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1361107c89d9581a95763866a39d954197f71e70"
        }
      ],
      "message": "Add a rust-based backup over-REST block downloader",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-18T19:30:52Z"
      },
      "sha": "2c0dda33c51324686bc143d8bed89ebba088ab8a"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2858233731,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjg1ODIzMzczMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2858233731",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-05T15:24:05Z"
    },
    {
      "event": "unlabeled",
      "id": 2858499692,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50Mjg1ODQ5OTY5Mg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2858499692",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-05T16:35:09Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 571825358,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU3MTgyNTM1OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/571825358",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-07T23:43:11Z",
      "updated_at": "2020-01-07T23:43:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-571825358",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "labeled",
      "id": 2929421662,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI5Mjk0MjE2NjI=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2929421662",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-07T23:43:11Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 575867541,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU3NTg2NzU0MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/575867541",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-18T05:08:04Z",
      "updated_at": "2020-01-18T05:08:04Z",
      "author_association": "MEMBER",
      "body": ">would be nice to land early in the cycle for 20.\r\n\r\nRust is still a concept NACK...",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-575867541",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "icota",
        "id": 762502,
        "node_id": "MDQ6VXNlcjc2MjUwMg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/762502?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/icota",
        "html_url": "https://github.com/icota",
        "followers_url": "https://api.github.com/users/icota/followers",
        "following_url": "https://api.github.com/users/icota/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/icota/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/icota/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/icota/subscriptions",
        "organizations_url": "https://api.github.com/users/icota/orgs",
        "repos_url": "https://api.github.com/users/icota/repos",
        "events_url": "https://api.github.com/users/icota/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/icota/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-02-20T09:32:18Z",
      "updated_at": "2020-02-20T09:32:18Z",
      "source": {
        "issue": {
          "id": 567647462,
          "node_id": "MDExOlB1bGxSZXF1ZXN0Mzc3MjMzOTQ4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18179",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18179/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18179/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18179/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/18179",
          "number": 18179,
          "state": "closed",
          "state_reason": null,
          "title": "Add Lightning Network support",
          "body": "Configure with `--enable-rust`. Here's how to use:\r\n```\r\n$ ./bitcoin-cli help\r\n...\r\n == Lightning ==\r\nlnclosechannel \"channel_id\"\r\nlnconnect \"node\"\r\nlncreateinvoice \"description\" amount\r\nlnfundchannel \"node_id\" amount\r\nlngetchannels\r\nlngetpeers\r\nlnpayinvoice \"invoice\"\r\n...\r\n```\r\nConnect to ACINQ [testnet node](https://1ml.com/testnet/node/03933884aaf1d6b108397e5efe5c86bcf2d8ca8d2f700eda99db9214fc2712b134):\r\n```\r\n$ ./bitcoin-cli  lnconnect 03933884aaf1d6b108397e5efe5c86bcf2d8ca8d2f700eda99db9214fc2712b134@34.250.234.192:9735\r\n```\r\n\r\nSee that we are connected:\r\n```\r\n$ ./bitcoin-cli lngetpeers \r\n[ \r\n  { \r\n    \"id\": \"03933884aaf1d6b108397e5efe5c86bcf2d8ca8d2f700eda99db9214fc2712b134\"\r\n  } \r\n]\r\n```\r\n\r\nCheck if we have enough in our wallet:\r\n```\r\n$ ./bitcoin-cli getbalances \r\n{ \r\n  \"mine\": { \r\n    \"trusted\": 0.01000000, \r\n    \"untrusted_pending\": 0.00000000, \r\n    \"immature\": 0.00000000 \r\n  } \r\n}\r\n```\r\n\r\nFund a 0.001 tBTC channel with our peer:\r\n```\r\n$ ./bitcoin-cli lnfundchannel 03933884aaf1d6b108397e5efe5c86bcf2d8ca8d2f700eda99db9214fc2712b134 0.001\r\n\r\n$ ./bitcoin-cli lngetchannels \r\n[ \r\n  { \r\n    \"id\": \"09e43999ea4fc33c0c8aa134727ea17ac1e2ac7e9356b1434fed9bfc8f091e1f\", \r\n    \"shortid\": 0, \r\n    \"capacity\": 100000, \r\n    \"status\": \"unconfirmed\" \r\n  } \r\n]\r\n```\r\nWait a couple of blocks and try again:\r\n\r\n```\r\n$ ./bitcoin-cli lngetchannels \r\n[ \r\n  { \r\n    \"id\": \"09e43999ea4fc33c0c8aa134727ea17ac1e2ac7e9356b1434fed9bfc8f091e1f\", \r\n    \"shortid\": 1831367457947189249, \r\n    \"capacity\": 100000, \r\n    \"status\": \"confirmed\" \r\n  } \r\n]\r\n\r\n$ ./bitcoin-cli getbalances \r\n{ \r\n  \"mine\": { \r\n    \"trusted\": 0.00896940, \r\n    \"untrusted_pending\": 0.00000000, \r\n    \"immature\": 0.00000000 \r\n  } \r\n}\r\n```\r\n\r\nOur channel is operational! Immediately go and purchase some beers on [yalls.org](https://testnet.yalls.org/reactions/):\r\n\r\n```\r\n$ ./bitcoin-cli lnpayinvoice lntb1500n1p0yxfm6pp5098ss9punvma2xusvdez40dnrnrr7zlf2hpqm5kvnc4g9fjk7pjqdp6g9jxggrjv4skxarfdahzpuyl3kazqar0ypuk7atjyp3k7mrvv43hg6t0dccqzpgxqr23ssp5kjpejv09t6yweaf02x7ywzpdr3z8utpnyw67x9lcvfuf6f6kwdns9qy9qsqx323heyl6e54cmrxn9gnuqsef7juacsl7w7cngvrvg2vft6qtll5f7c07vx004n62uwklnhfwd62tnjzw30gt5ucsz32yz3j6uanvhqqqgpkru\r\n```\r\n\r\nClose the channel:\r\n```\r\n$ ./bitcoin-cli lnclosechannel 09e43999ea4fc33c0c8aa134727ea17ac1e2ac7e9356b1434fed9bfc8f091e1f\r\n```\r\nHot on the heels of [rust-lightning](https://github.com/rust-bitcoin/rust-lightning) 0.0.10 release and the [LDK](https://medium.com/@squarecrypto/what-were-building-lightning-development-kit-1ed58b0cab06) announcement I present you CoreLightning.\r\n\r\nThis PR is based on https://github.com/bitcoin/bitcoin/pull/17376 and it adds 4 more crates to the mix:\r\n`rust-lightning`, `rust-lightning-invoice`, `rust-bech32-bitcoin` and `num-traits`. Peers and channels data is in `lightning`. Code will be impossible to review on GitHub due to submodule mess but for now this is a one-commit PR anyway so take a look there.\r\n\r\nEven though this is nowhere near production ready I'm excited to see it work. Credit to @TheBlueMatt and the rust-bitcoin/lightning team. Truly awesome work.\r\n\r\nFor the sake of argument let's say everyone agrees that Lightning is a good thing and helpes Bitcoin scale. In that case I see built-in CoreLightning as useful in two ways:\r\n\r\n- Makes it easy for the Core install-base to adopt Lightning in one fell swoop. People will be more likely to use and build on top of Lightning if it's one upgrade away. You can use your existing wallet funds. No separate daemons or needless transactions. Institutional users such as exchanges would have no excuse not leverage Lightning.\r\n- I feel that Core could be more of a universal client in the future. It's somewhat industrial nowadays but I'd like 2021 to be the year of Core on the Phone :sunglasses:. I wrote about this a bit [here](https://icota.github.io/).\r\n\r\nCode is not very robust, it needs a lot of love in regards to making it more \"rusty\" and figuring how to better manage the C++/Rust FFI boundary. Before I invest any more time in this I'd like to get some guidance and concept (N)ACKs.",
          "user": {
            "login": "icota",
            "id": 762502,
            "node_id": "MDQ6VXNlcjc2MjUwMg==",
            "avatar_url": "https://avatars.githubusercontent.com/u/762502?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/icota",
            "html_url": "https://github.com/icota",
            "followers_url": "https://api.github.com/users/icota/followers",
            "following_url": "https://api.github.com/users/icota/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/icota/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/icota/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/icota/subscriptions",
            "organizations_url": "https://api.github.com/users/icota/orgs",
            "repos_url": "https://api.github.com/users/icota/repos",
            "events_url": "https://api.github.com/users/icota/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/icota/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 64583,
              "node_id": "MDU6TGFiZWw2NDU4Mw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature",
              "name": "Feature",
              "color": "7cf575",
              "default": false
            },
            {
              "id": 149424,
              "node_id": "MDU6TGFiZWwxNDk0MjQ=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Wallet",
              "name": "Wallet",
              "color": "08a781",
              "default": false
            },
            {
              "id": 98279177,
              "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
              "name": "RPC/REST/ZMQ",
              "color": "0052cc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 13,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/18179",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/18179",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/18179.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/18179.patch"
          },
          "closed_at": "2020-02-20T19:06:13Z",
          "created_at": "2020-02-19T15:51:15Z",
          "updated_at": "2022-02-15T10:41:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 595413891,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU5NTQxMzg5MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/595413891",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-05T19:48:04Z",
      "updated_at": "2020-03-05T19:48:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "Closing due to lack of interest.",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-595413891",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "closed",
      "id": 3102656353,
      "node_id": "MDExOkNsb3NlZEV2ZW50MzEwMjY1NjM1Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/3102656353",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-05T19:48:04Z"
    },
    {
      "event": "referenced",
      "id": 5612481392,
      "node_id": "REFE_lADOABII584dCYAYzwAAAAFOh6tw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5612481392",
      "actor": {
        "login": "humbleDasher",
        "id": 93728168,
        "node_id": "U_kgDOBZYtqA",
        "avatar_url": "https://avatars.githubusercontent.com/u/93728168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/humbleDasher",
        "html_url": "https://github.com/humbleDasher",
        "followers_url": "https://api.github.com/users/humbleDasher/followers",
        "following_url": "https://api.github.com/users/humbleDasher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/humbleDasher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/humbleDasher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/humbleDasher/subscriptions",
        "organizations_url": "https://api.github.com/users/humbleDasher/orgs",
        "repos_url": "https://api.github.com/users/humbleDasher/repos",
        "events_url": "https://api.github.com/users/humbleDasher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/humbleDasher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2996f593ef2e829f2d2c3310aac3edc9fdb011a1",
      "commit_url": "https://api.github.com/repos/humbleDasher/dash/commits/2996f593ef2e829f2d2c3310aac3edc9fdb011a1",
      "created_at": "2021-11-13T00:17:54Z"
    },
    {
      "event": "referenced",
      "id": 5640695343,
      "node_id": "REFE_lADOABII584dCYAYzwAAAAFQNi4v",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5640695343",
      "actor": {
        "login": "pravblockc",
        "id": 51935684,
        "node_id": "MDQ6VXNlcjUxOTM1Njg0",
        "avatar_url": "https://avatars.githubusercontent.com/u/51935684?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pravblockc",
        "html_url": "https://github.com/pravblockc",
        "followers_url": "https://api.github.com/users/pravblockc/followers",
        "following_url": "https://api.github.com/users/pravblockc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pravblockc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pravblockc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pravblockc/subscriptions",
        "organizations_url": "https://api.github.com/users/pravblockc/orgs",
        "repos_url": "https://api.github.com/users/pravblockc/repos",
        "events_url": "https://api.github.com/users/pravblockc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pravblockc/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0b4f279949590a5ee4d351decb9667ec068672b2",
      "commit_url": "https://api.github.com/repos/pravblockc/dash/commits/0b4f279949590a5ee4d351decb9667ec068672b2",
      "created_at": "2021-11-18T18:27:58Z"
    },
    {
      "event": "locked",
      "id": 6073861860,
      "node_id": "LOE_lADOABII584dCYAYzwAAAAFqB8bk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6073861860",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-02-15T10:41:43Z",
      "lock_reason": "resolved"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319390967",
      "pull_request_review_id": 281872721,
      "id": 319390967,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTM5MDk2Nw==",
      "diff_hunk": "@@ -529,7 +537,7 @@ nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n bitcoind_SOURCES = bitcoind.cpp\n bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+bitcoind_LDFLAGS = -Wl,--start-group $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)",
      "path": "src/Makefile.am",
      "position": null,
      "original_position": 38,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "cf221a2410a066fa95f526be343b8fa4c63d5184",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "AFAICS `--start-group` is not supported in clang (https://bitcoinbuilds.org/index.php?ansilog=6ccfb93d-3437-41c0-99d4-3b6653264739.log#l1705)",
      "created_at": "2019-08-30T07:38:07Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r319390967",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319390967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 538,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319393006",
      "pull_request_review_id": 281875349,
      "id": 319393006,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTM5MzAwNg==",
      "diff_hunk": "@@ -529,7 +537,7 @@ nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n bitcoind_SOURCES = bitcoind.cpp\n bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+bitcoind_LDFLAGS = -Wl,--start-group $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)",
      "path": "src/Makefile.am",
      "position": null,
      "original_position": 38,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "cf221a2410a066fa95f526be343b8fa4c63d5184",
      "in_reply_to_id": 319390967,
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@jonasschnelli Yes `ld` on macOS doesn't support `--start-group` or `--end-group`. This was a bit of a hack to fix a circular dependency issue Matt was seeing on his Debian machine. If you want to compile on macOS you should just be able to drop the `-Wl,--start-group` additions, as that has been working for me. We'll need to fix this **properly** soon.",
      "created_at": "2019-08-30T07:44:25Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r319393006",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319393006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 538,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983533",
      "pull_request_review_id": 285188001,
      "id": 321983533,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4MzUzMw==",
      "diff_hunk": "@@ -137,3 +137,7 @@ db4/\n osx_volname\n dist/\n *.background.tiff\n+\n+# Rust\n+src/rusty/Cargo.lock",
      "path": ".gitignore",
      "position": null,
      "original_position": 6,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think tracking changes to Cargo.lock might be a good thing. (especially if we will have some dependencies in the future)\r\n\r\n(I know it's against the official recommendation)",
      "created_at": "2019-09-07T21:10:57Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983533",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983747",
      "pull_request_review_id": 285188001,
      "id": 321983747,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4Mzc0Nw==",
      "diff_hunk": "@@ -1824,5 +1831,13 @@ bool AppInitMain(InitInterfaces& interfaces)\n         g_banman->DumpBanlist();\n     }, DUMP_BANS_INTERVAL * 1000);\n \n+    // ********************************************************* Step 14: kick off backup block downloaders\n+\n+#if ENABLE_RUSTY\n+    for (const std::string& uri : gArgs.GetArgs(\"-blockfetchrest\")) {\n+        rust_block_fetch::init_fetch_rest_blocks((const unsigned char*)uri.c_str());",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "why not use the regular `const char*`? why cast it into an unsigned char pointer?\r\nYou could then use rust's `CStr` instead of manually looping and offsetting the pointer:\r\nhttps://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_ptr",
      "created_at": "2019-09-07T21:20:17Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983747",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1838,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983940",
      "pull_request_review_id": 285188001,
      "id": 321983940,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4Mzk0MA==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 212,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A. I'm not sure dereferencing a char* casted to *const u8, is safe.\r\nB. if you pass this as `*const c_char` and then use rust's `CStr` (as I wrote above) you can replace these ~10 lines with:\r\n```\r\nlet uri_str = match CStr::from_ptr(uri).to_str() {\r\n    Ok(r) => r,\r\n    Err(_) => return false,\r\n};\r\n```",
      "created_at": "2019-09-07T21:28:29Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983940",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983986",
      "pull_request_review_id": 285188001,
      "id": 321983986,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4Mzk4Ng==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 60,
      "original_position": 56,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "currently the test is pretty small, but maybe still feature gate it with `#[cfg(test)]` so that it won't be compiled normally?",
      "created_at": "2019-09-07T21:30:28Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983986",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983986"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 60,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984009",
      "pull_request_review_id": 285188001,
      "id": 321984009,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDAwOQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 15,
      "original_position": 10,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could you add a doc explaining what the function is doing?",
      "created_at": "2019-09-07T21:31:50Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984009",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 15,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984146",
      "pull_request_review_id": 285188001,
      "id": 321984146,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDE0Ng==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 21,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe replace with `host_path.starts_with(\"/\")`? (which also solves possible utf-8 problems)",
      "created_at": "2019-09-07T21:39:18Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984146",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984187",
      "pull_request_review_id": 285188001,
      "id": 321984187,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDE4Nw==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 22,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Then you can replace this with `host_path = host_path.trim_start_matches(\"/\");`",
      "created_at": "2019-09-07T21:41:36Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984187",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984187"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984418",
      "pull_request_review_id": 285188001,
      "id": 321984418,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDQxOA==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 27,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same, unless we have something that `if !uri.is_ascii() return None;` at the start of the function we should really try and not index into strings",
      "created_at": "2019-09-07T21:52:33Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984465",
      "pull_request_review_id": 285188001,
      "id": 321984465,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDQ2NQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 27,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984418,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "and btw you can do `b'['` instead of `'[' as u8` :)",
      "created_at": "2019-09-07T21:54:19Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984465",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984701",
      "pull_request_review_id": 285188001,
      "id": 321984701,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDcwMQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 231,
      "original_position": 225,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could we easily log a panic easily somehow? (although this introduces a lot of complications to pass the `datadir` location somehow, could we maybe use some tmp location just as a jump start?)",
      "created_at": "2019-09-07T22:03:14Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984701",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984701"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 231,
      "original_line": 231,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984797",
      "pull_request_review_id": 285188001,
      "id": 321984797,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDc5Nw==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 226,
      "original_position": 221,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this should be reversed to check if SSL is true.\r\nBecause if this returns None we might as well also return false and finish this early, because we unwrap this few lines after \r\n\r\nBetter yet, run it once and check for `if ssl {return False;}` so that we won't need to run this twice(not that it really matters that much...)",
      "created_at": "2019-09-07T22:06:33Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984797",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984797"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 226,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985047",
      "pull_request_review_id": 285188001,
      "id": 321985047,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTA0Nw==",
      "diff_hunk": "@@ -367,6 +371,9 @@ void SetupServerArgs()\n #endif\n     gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-blocksonly\", strprintf(\"Whether to reject transactions from network peers. Transactions from the wallet, RPC and relay whitelisted inbound peers are not affected. (default: %u)\", DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+#if ENABLE_RUSTY\n+    gArgs.AddArg(\"-blockfetchrest=<uri>\", \"A REST endpoint from which to fetch blocks. Acts as a redundant backup for P2P connectivity\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe add an example of how the uri should be formatted? (especially because currently there's no feedback from `split_uri`)",
      "created_at": "2019-09-07T22:18:22Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985329",
      "pull_request_review_id": 285188001,
      "id": 321985329,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTMyOQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 243,
      "original_position": 237,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ideally we would match against the exact error match so that if it returns something like `InvalidData` then there's no need to keep the loop running. (so stop unless it's a timeout, broken pipe, would block etc.)  ",
      "created_at": "2019-09-07T22:31:49Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985329",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985329"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 243,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985493",
      "pull_request_review_id": 285188001,
      "id": 321985493,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTQ5Mw==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 268,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Add a comment that this should only ever trip on the *second* connection?",
      "created_at": "2019-09-07T22:40:51Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985493",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985515",
      "pull_request_review_id": 285188001,
      "id": 321985515,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTUxNQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?\n+                            continue 'reconnect;",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 269,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If we're on completely separate chains why reconnect?",
      "created_at": "2019-09-07T22:41:39Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985515",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985689",
      "pull_request_review_id": 285188001,
      "id": 321985689,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTY4OQ==",
      "diff_hunk": "@@ -0,0 +1,178 @@\n+use std::ffi::c_void;\n+extern \"C\" {\n+    pub fn rusty_IsInitialBlockDownload() -> bool;\n+    pub fn rusty_ShutdownRequested() -> bool;\n+\n+    fn rusty_ProcessNewBlock(blockdata: *const u8, blockdatalen: usize, blockindex_requested: *const c_void);\n+\n+    /// Connects count headers serialized in a block of memory, each stride bytes from each other.\n+    /// Returns the last header which was connected, if any (or NULL).\n+    fn rusty_ConnectHeaders(headers: *const u8, stride: usize, count: usize) -> *const c_void;\n+\n+    // Utilities to work with CBlockIndex pointers. Wrapped in a safe wrapper below.\n+\n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the current tip.\n+    /// Guaranteed to never be NULL (but may be genesis)\n+    fn rusty_GetChainTip() -> *const c_void;\n+\n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the genesis block.\n+    /// Guaranteed to never be NULL\n+    fn rusty_GetGenesisIndex() -> *const c_void;\n+\n+    #[allow(dead_code)]\n+    /// Finds a CBlockIndex* for a given block hash, or NULL if none is found\n+    fn rusty_HashToIndex(hash: *const u8) -> *const c_void;\n+\n+    #[allow(dead_code)]\n+    /// Gets the height of a given CBlockIndex* pointer\n+    fn rusty_IndexToHeight(index: *const c_void) -> i32;\n+\n+    /// Gets the hash of a given CBlockIndex* pointer\n+    fn rusty_IndexToHash(index: *const c_void) -> *const u8;\n+}\n+\n+#[allow(dead_code)]\n+/// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n+/// Returns the last header which was connected, if any.\n+pub fn connect_headers(headers: &[[u8; 80]]) -> Option<BlockIndex> {\n+    if headers.is_empty() { return None; }\n+    let first_header = headers[0].as_ptr();\n+    let index = if headers.len() == 1 {\n+        unsafe { rusty_ConnectHeaders(first_header, 80, 1) }\n+    } else {\n+        let second_header = headers[1].as_ptr();\n+        let stride = second_header as usize - first_header as usize;\n+        unsafe { rusty_ConnectHeaders(first_header, stride, headers.len()) }\n+    };\n+    if index.is_null() { None } else { Some(BlockIndex { index }) }\n+}\n+\n+/// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n+/// Returns the last header which was connected, if any.\n+pub fn connect_headers_flat_bytes(headers: &[u8]) -> Option<BlockIndex> {\n+    if headers.len() % 80 != 0 { return None; }\n+    if headers.is_empty() { return None; }\n+    let index = unsafe { rusty_ConnectHeaders(headers.as_ptr(), 80, headers.len() / 80) };\n+    if index.is_null() { None } else { Some(BlockIndex { index }) }\n+}\n+\n+/// Processes a new block, in serialized form.\n+/// blockindex_requested_by_state shouild be set *only* if the given BlockIndex was provided by\n+/// BlockProviderState::get_next_block_to_download(), and may be set to None always.\n+pub fn connect_block(blockdata: &[u8], blockindex_requested_by_state: Option<BlockIndex>) {\n+    let blockindex = match blockindex_requested_by_state { Some(index) => index.index, None => std::ptr::null(), };\n+    unsafe {\n+        rusty_ProcessNewBlock(blockdata.as_ptr(), blockdata.len(), blockindex);\n+    }\n+}\n+\n+#[derive(PartialEq, Clone, Copy)]\n+pub struct BlockIndex {\n+    index: *const c_void,\n+}\n+\n+impl BlockIndex {\n+    pub fn tip() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetChainTip() },\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn get_from_hash(hash: &[u8; 32]) -> Option<Self> {\n+        let index = unsafe { rusty_HashToIndex(hash.as_ptr()) };\n+        if index.is_null() {\n+            None\n+        } else {\n+            Some(Self { index })\n+        }\n+    }\n+\n+    pub fn genesis() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetGenesisIndex() },\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn height(&self) -> i32 {\n+        unsafe { rusty_IndexToHeight(self.index) }\n+    }\n+\n+    pub fn hash(&self) -> [u8; 32] {\n+        let hashptr = unsafe { rusty_IndexToHash(self.index) };\n+        let mut res = [0u8; 32];\n+        unsafe { std::ptr::copy(hashptr, (&mut res).as_mut_ptr(), 32) };",
      "path": "src/rusty/src/bridge.rs",
      "position": null,
      "original_position": 105,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`res.as_mut_ptr()` should also work",
      "created_at": "2019-09-07T22:51:47Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985689",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028115",
      "pull_request_review_id": 285234118,
      "id": 322028115,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjAyODExNQ==",
      "diff_hunk": "@@ -137,3 +137,7 @@ db4/\n osx_volname\n dist/\n *.background.tiff\n+\n+# Rust\n+src/rusty/Cargo.lock",
      "path": ".gitignore",
      "position": null,
      "original_position": 6,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321983533,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we'll vendor all our dependencies, so hopefully no need, but we can look into it more once we have a dependency.",
      "created_at": "2019-09-08T20:37:05Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322028115",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028115"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028393",
      "pull_request_review_id": 285234379,
      "id": 322028393,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjAyODM5Mw==",
      "diff_hunk": "@@ -1824,5 +1831,13 @@ bool AppInitMain(InitInterfaces& interfaces)\n         g_banman->DumpBanlist();\n     }, DUMP_BANS_INTERVAL * 1000);\n \n+    // ********************************************************* Step 14: kick off backup block downloaders\n+\n+#if ENABLE_RUSTY\n+    for (const std::string& uri : gArgs.GetArgs(\"-blockfetchrest\")) {\n+        rust_block_fetch::init_fetch_rest_blocks((const unsigned char*)uri.c_str());",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321983747,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Cause I didn't know CStr existed :p",
      "created_at": "2019-09-08T20:43:48Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322028393",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1838,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050160",
      "pull_request_review_id": 285261436,
      "id": 322050160,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDE2MA==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?\n+                            continue 'reconnect;",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 269,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321985515,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The server may also be broken and be returning empty responses, so best to keep trying.",
      "created_at": "2019-09-09T02:58:45Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050160",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050241",
      "pull_request_review_id": 285261556,
      "id": 322050241,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDI0MQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 268,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321985493,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I mean that seems pretty obvious given the code?",
      "created_at": "2019-09-09T02:59:39Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050241",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050241"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050361",
      "pull_request_review_id": 285261700,
      "id": 322050361,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDM2MQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 243,
      "original_position": 237,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321985329,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ehh, I'd rather keep polling. Better to keep polling so that when the rest endpoint fixes their misconfiguration (eg its returning a 500 or 404 or whatever) the downloader picks back up.",
      "created_at": "2019-09-09T03:00:42Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050361",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 243,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050537",
      "pull_request_review_id": 285261919,
      "id": 322050537,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDUzNw==",
      "diff_hunk": "@@ -367,6 +371,9 @@ void SetupServerArgs()\n #endif\n     gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-blocksonly\", strprintf(\"Whether to reject transactions from network peers. Transactions from the wallet, RPC and relay whitelisted inbound peers are not affected. (default: %u)\", DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+#if ENABLE_RUSTY\n+    gArgs.AddArg(\"-blockfetchrest=<uri>\", \"A REST endpoint from which to fetch blocks. Acts as a redundant backup for P2P connectivity\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321985047,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I went ahead and added the deanonymizingseed.com one, if folks complain I can use example.com.",
      "created_at": "2019-09-09T03:02:14Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050537",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050675",
      "pull_request_review_id": 285262098,
      "id": 322050675,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDY3NQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 226,
      "original_position": 221,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984797,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm? The pattern hers is if let Some() {} else { return; }. It reads a bit weird but its the easiest way to write it out.",
      "created_at": "2019-09-09T03:03:34Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050675",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050675"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 226,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050763",
      "pull_request_review_id": 285262204,
      "id": 322050763,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDc2Mw==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 231,
      "original_position": 225,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984701,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, it would be really nice to be able to call LogPrintf from rust code, but I'd prefer to leave that to a future PR.",
      "created_at": "2019-09-09T03:04:15Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050763",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 231,
      "original_line": 231,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050941",
      "pull_request_review_id": 285262464,
      "id": 322050941,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDk0MQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 22,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984187,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm, thats only available in 1.30. For now lets avoid it until we have a clear min version.",
      "created_at": "2019-09-09T03:06:12Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050941",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050941"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322292885",
      "pull_request_review_id": 285573787,
      "id": 322292885,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjI5Mjg4NQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 22,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984187,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So you have `trim_left_matches()` which predates it (is in rust since 1.0)\r\nhttps://doc.rust-lang.org/std/primitive.str.html#method.trim_left_matches",
      "created_at": "2019-09-09T15:01:43Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322292885",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322292885"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322294202",
      "pull_request_review_id": 285575526,
      "id": 322294202,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjI5NDIwMg==",
      "diff_hunk": "@@ -0,0 +1,324 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+use std::ffi::CStr;\n+use std::os::raw::c_char;\n+\n+/// Splits an HTTP URI into its component part - (is_ssl, hostname, port number, and HTTP path)\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while host_path.starts_with(\"/\") {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = r.starts_with(\"[\");\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const c_char) -> bool {\n+    let uri_str: String = match unsafe { CStr::from_ptr(uri) }.to_str() {\n+        Ok(r) => r.to_string(),",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 222,
      "original_position": 216,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Great catch :)\r\nthat way we won't have a dangling pointer at some point",
      "created_at": "2019-09-09T15:04:02Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322294202",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322294202"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 222,
      "original_line": 222,
      "side": "RIGHT"
    }
  ]
}