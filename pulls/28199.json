{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
    "id": 1459601417,
    "node_id": "PR_kwDOABII585W_8AJ",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/28199",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/28199.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/28199.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/29ec234654f8490d0d2c608af5c9565819010b4f",
    "number": 28199,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "test: tx orphan handling",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I was doing some mutation testing (through reckless refactoring) locally and found some specific behaviors in orphan handling that weren't picked up by tests. Adding some of these test cases now can maybe help with reviewing refactors like #28031.\r\n\r\n- Parent requests aren't sent immediately. A delay is added and the requests are filtered by AlreadyHaveTx before they are sent, which means you can't use fake orphans to probe precise arrival timing of a tx.\r\n- Parent requests include all that are not AlreadyHaveTx. This means old confirmed parents may be requested.\r\n- The node does not give up on orphans if the peer responds to a parent request with notfound. This means that if a parent is an old confirmed transaction (in which notfound is expected), the orphan should still be resolved.\r\n- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based on txid.\r\n- Rejected parents can cause an orphan to be rejected too, by both wtxid and txid.\r\n- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent has the same hash as an in-flight request, it shouldn't be requested.\r\n- Multiple orphans with overlapping parents should not cause duplicated parent requests.",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "created_at": "2023-08-02T11:14:20Z",
    "updated_at": "2023-08-02T20:56:54Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "95f0edd244005521e2dfe4f6faab8275ee419deb",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "glozow:2023-08-test-orphan-handling",
      "ref": "2023-08-test-orphan-handling",
      "sha": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 244262754,
        "node_id": "MDEwOlJlcG9zaXRvcnkyNDQyNjI3NTQ=",
        "name": "bitcoin",
        "full_name": "glozow/bitcoin",
        "owner": {
          "login": "glozow",
          "id": 25183001,
          "node_id": "MDQ6VXNlcjI1MTgzMDAx",
          "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/glozow",
          "html_url": "https://github.com/glozow",
          "followers_url": "https://api.github.com/users/glozow/followers",
          "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
          "organizations_url": "https://api.github.com/users/glozow/orgs",
          "repos_url": "https://api.github.com/users/glozow/repos",
          "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/glozow/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/glozow/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/glozow/bitcoin",
        "archive_url": "https://api.github.com/repos/glozow/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/glozow/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/glozow/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/glozow/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/glozow/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/glozow/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/glozow/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/glozow/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/glozow/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/glozow/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/glozow/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/glozow/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/glozow/bitcoin/events",
        "forks_url": "https://api.github.com/repos/glozow/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/glozow/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/glozow/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/glozow/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/glozow/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/glozow/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/glozow/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/glozow/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/glozow/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/glozow/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/glozow/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/glozow/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/glozow/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/glozow/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/glozow/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/glozow/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:glozow/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/glozow/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/glozow/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/glozow/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/glozow/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/glozow/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/glozow/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/glozow/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/glozow/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/glozow/bitcoin/hooks",
        "svn_url": "https://github.com/glozow/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 2,
        "stargazers_count": 9,
        "watchers_count": 9,
        "size": 227503,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-02T16:54:17Z",
        "created_at": "2020-03-02T02:31:56Z",
        "updated_at": "2023-07-18T03:26:20Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "2dea6c5ca01861fb027ee9a852d6a95736e7b0d2",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35476,
        "stargazers_count": 70608,
        "watchers_count": 70608,
        "size": 236222,
        "default_branch": "master",
        "open_issues_count": 673,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-03T00:03:27Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-08-02T18:21:18Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 446,
    "deletions": 0,
    "changed_files": 3,
    "commits": 1,
    "review_comments": 11,
    "comments": 5
  },
  "events": [
    {
      "event": "labeled",
      "id": 9986839950,
      "node_id": "LE_lADOABII585tQPuGzwAAAAJTQxWO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9986839950",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:14:20Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "commented",
      "id": 1662019735,
      "node_id": "IC_kwDOABII585jEGiX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662019735",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:14:23Z",
      "updated_at": "2023-08-02T20:56:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [dergoegge](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662073675), [jamesob](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662122993), [brunoerg](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662147529), [jonatack](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662205614) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#20892](https://github.com/bitcoin/bitcoin/pull/20892) (tests: Run both descriptor and legacy tests within a single test invocation by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662019735",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "renamed",
      "id": 9986992853,
      "node_id": "RTE_lADOABII585tQPuGzwAAAAJTRWrV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9986992853",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:31:40Z",
      "rename": {
        "from": "functional test: tx orphan handling",
        "to": "test: tx orphan handling"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI5ZWMyMzQ2NTRmODQ5MGQwZDJjNjA4YWY1Yzk1NjU4MTkwMTBiNGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/29ec234654f8490d0d2c608af5c9565819010b4f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/29ec234654f8490d0d2c608af5c9565819010b4f",
      "tree": {
        "sha": "f4a523b1b8a9ad9795c703ead41835568201ad51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f4a523b1b8a9ad9795c703ead41835568201ad51"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e92013e178727429fdf81ef180efffdad9f0ff5a",
          "sha": "e92013e178727429fdf81ef180efffdad9f0ff5a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e92013e178727429fdf81ef180efffdad9f0ff5a"
        }
      ],
      "message": "[functional test] transaction orphan handling",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-08-02T11:42:06Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-04-19T14:40:18Z"
      },
      "sha": "29ec234654f8490d0d2c608af5c9565819010b4f"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9987090350,
      "node_id": "HRFPE_lADOABII585tQPuGzwAAAAJTRueu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9987090350",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:42:28Z"
    },
    {
      "event": "labeled",
      "id": 9987092148,
      "node_id": "LE_lADOABII585tQPuGzwAAAAJTRu60",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9987092148",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:42:40Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1662073675,
      "node_id": "IC_kwDOABII585jETtL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662073675",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:54:40Z",
      "updated_at": "2023-08-02T11:54:40Z",
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nGood to have these tests prior to refactoring",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662073675",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "commented",
      "id": 1662122993,
      "node_id": "IC_kwDOABII585jEfvx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662122993",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T12:29:21Z",
      "updated_at": "2023-08-02T12:29:21Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, looks like some great additional coverage.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662122993",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "commented",
      "id": 1662147529,
      "node_id": "IC_kwDOABII585jElvJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662147529",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T12:46:32Z",
      "updated_at": "2023-08-02T12:46:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK ",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662147529",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "unlabeled",
      "id": 9988041812,
      "node_id": "UNLE_lADOABII585tQPuGzwAAAAJTVWxU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9988041812",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T13:17:00Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1662205614,
      "node_id": "IC_kwDOABII585jEz6u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662205614",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T13:22:36Z",
      "updated_at": "2023-08-02T13:22:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662205614",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "reviewed",
      "id": 1559366940,
      "node_id": "PRR_kwDOABII585c8g0c",
      "url": null,
      "actor": null,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "moar coverage good",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1559366940",
      "submitted_at": "2023-08-02T18:24:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242",
      "pull_request_review_id": 1559366940,
      "id": 1282131242,
      "node_id": "PRRC_kwDOABII585Ma8Uq",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 6,
      "original_position": 6,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "comment block seems extraneous if there's logging for each test",
      "created_at": "2023-08-02T16:14:00Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282131242",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 6,
      "original_line": 6,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201",
      "pull_request_review_id": 1559366940,
      "id": 1282208201,
      "node_id": "PRRC_kwDOABII585MbPHJ",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 57,
      "original_position": 57,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Stick the constant inside `cleanup` and move the comment for `cleanup`, since it explains what the whole thing is doing.",
      "created_at": "2023-08-02T17:17:38Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282208201",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 57,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657",
      "pull_request_review_id": 1559366940,
      "id": 1282234657,
      "node_id": "PRRC_kwDOABII585MbVkh",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 258,
      "original_position": 258,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        # The parent should be requested since the unstripped wtxid would differ. Delayed because it's by txid and this is not a preferred relay peer.\r\n```",
      "created_at": "2023-08-02T17:44:18Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282234657",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 258,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358",
      "pull_request_review_id": 1559366940,
      "id": 1282243358,
      "node_id": "PRRC_kwDOABII585MbXse",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 280,
      "original_position": 280,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can't we just reconsider it again?",
      "created_at": "2023-08-02T17:53:41Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282243358",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 280,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680",
      "pull_request_review_id": 1559366940,
      "id": 1282251680,
      "node_id": "PRRC_kwDOABII585MbZug",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 293,
      "original_position": 293,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "took me a second, just assert it's not in mempool for those quickly reading ",
      "created_at": "2023-08-02T18:02:11Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282251680",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 293,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631",
      "pull_request_review_id": 1559366940,
      "id": 1282257631,
      "node_id": "PRRC_kwDOABII585MbbLf",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        \"\"\"Check that the node does not immediately respond to this message with any of\r\n```",
      "created_at": "2023-08-02T18:06:00Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282257631",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402",
      "pull_request_review_id": 1559366940,
      "id": 1282258402,
      "node_id": "PRRC_kwDOABII585MbbXi",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 180,
      "original_position": 180,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can we assert that peer_spy hasn't received the INV, just to be sure?",
      "created_at": "2023-08-02T18:06:57Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282258402",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": 180,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677",
      "pull_request_review_id": 1559366940,
      "id": 1282259677,
      "node_id": "PRRC_kwDOABII585Mbbrd",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 191,
      "original_position": 191,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't get this case. Why wouldn't you request a \"fake\" parent if you don't know it's fake already?",
      "created_at": "2023-08-02T18:08:27Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282259677",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 191,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573",
      "pull_request_review_id": 1559366940,
      "id": 1282261573,
      "node_id": "PRRC_kwDOABII585MbcJF",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 326,
      "original_position": 326,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "does this wallet never use 0-conf change? would be nice to assert to make it clear the lack of utxo connection",
      "created_at": "2023-08-02T18:09:53Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282261573",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 326,
      "original_line": 326,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679",
      "pull_request_review_id": 1559366940,
      "id": 1282268679,
      "node_id": "PRRC_kwDOABII585Mbd4H",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 351,
      "original_position": 351,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"The node should not request a parent if it has an in-flight txrequest\" ? Seems like parents are being reqiested. Maybe a typo or I can't tell what scenario it's covering.",
      "created_at": "2023-08-02T18:17:38Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282268679",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 351,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277",
      "pull_request_review_id": 1559366940,
      "id": 1282274277,
      "node_id": "PRRC_kwDOABII585MbfPl",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 391,
      "original_position": 391,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "bit of a repeat with test_orphan_rejected_parents_exceptions ?",
      "created_at": "2023-08-02T18:23:51Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282274277",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 391,
      "original_line": 391,
      "side": "RIGHT"
    }
  ]
}