{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
    "id": 599182749,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTk5MTgyNzQ5",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/21515",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/21515.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/21515.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/3e08dab56b111d48970dc19bd771ba96c73506b1",
    "number": 21515,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Erlay: bandwidth-efficient transaction relay protocol",
    "user": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Erlay Project Tracking: #28646\r\n\r\n-----------\r\n\r\nThis is an implementation of  [Erlay](https://arxiv.org/abs/1905.10518) , using primitives in the BIP-330 (see the updated spec  [here](https://github.com/naumenkogs/bips/blob/bip_0330_updates/bip-0330.mediawiki) ). Please refer to these two to understand the design. My talk is [here](https://youtu.be/YxsjdIl0034?t=670).\r\n\r\n### Abstract\r\n\r\nErlay uses both flooding (announcing using INV messages to all peers) and reconciliation to announce transactions. Flooding is expensive, so Erlay seeks to use it sparingly and in strategic locations - only well-connected publicly reachable nodes flood transactions to other publicly reachable nodes via outbound connections. Since every unreachable node is directly connected to several reachable nodes, this policy ensures that a transaction is quickly propagated to be within one hop from most of the nodes in the network.\r\n\r\nAll transactions not propagated through flooding are propagated through efficient set reconciliation. To do this, every node keeps a reconciliation set for each peer, in which transactions are placed which would have been announced using INV messages absent this protocol. Every 2 seconds every node chooses a peer from its outbound connections in a predetermined order to reconcile with, resulting in both sides learning the transactions known to the other side. After every reconciliation round, the corresponding reconciliation set is cleared.\r\n\r\nI think both paper and the BIP motives the changes, but I’ll mention them briefly once again here:\r\n* save 40% of the bandwidth consumed by a node\r\n* increase network connectivity for almost no bandwidth or latency cost\r\n* improves privacy as a side-effect\r\n\r\n### How to review\r\n\r\nI suggest doing `make clean && autogen.sh && configure` before you try building it locally.",
    "labels": [
      {
        "id": 61889416,
        "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
        "name": "Build system",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      },
      {
        "id": 241832923,
        "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
        "name": "Utils/log/libs",
        "description": "",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2021-03-23T20:58:32Z",
    "updated_at": "2023-10-19T02:10:01Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "da08bc25c7edf244e52686747ed747ed9739993c",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "naumenkogs:2021-03-erlay",
      "ref": "2021-03-erlay",
      "sha": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 115054139,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTUwNTQxMzk=",
        "name": "bitcoin",
        "full_name": "naumenkogs/bitcoin",
        "owner": {
          "login": "naumenkogs",
          "id": 7975071,
          "node_id": "MDQ6VXNlcjc5NzUwNzE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/naumenkogs",
          "html_url": "https://github.com/naumenkogs",
          "followers_url": "https://api.github.com/users/naumenkogs/followers",
          "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
          "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
          "repos_url": "https://api.github.com/users/naumenkogs/repos",
          "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/naumenkogs/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/naumenkogs/bitcoin",
        "archive_url": "https://api.github.com/repos/naumenkogs/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/naumenkogs/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/naumenkogs/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/naumenkogs/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/naumenkogs/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/naumenkogs/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/naumenkogs/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/naumenkogs/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/naumenkogs/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/naumenkogs/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/naumenkogs/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/naumenkogs/bitcoin/events",
        "forks_url": "https://api.github.com/repos/naumenkogs/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/naumenkogs/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/naumenkogs/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/naumenkogs/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/naumenkogs/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/naumenkogs/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/naumenkogs/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/naumenkogs/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/naumenkogs/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/naumenkogs/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/naumenkogs/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/naumenkogs/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/naumenkogs/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:naumenkogs/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/naumenkogs/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/naumenkogs/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/naumenkogs/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/naumenkogs/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/naumenkogs/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/naumenkogs/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/naumenkogs/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/naumenkogs/bitcoin/hooks",
        "svn_url": "https://github.com/naumenkogs/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 2,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 231671,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-10-18T08:09:10Z",
        "created_at": "2017-12-21T22:52:17Z",
        "updated_at": "2021-03-02T13:21:27Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "f1a9fd627b1a669c4dfab797da42825230708f2a",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35839,
        "stargazers_count": 71840,
        "watchers_count": 71840,
        "size": 241645,
        "default_branch": "master",
        "open_issues_count": 638,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-10-18T22:00:52Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-10-19T01:52:49Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
      }
    },
    "author_association": "MEMBER",
    "draft": true,
    "additions": 2486,
    "deletions": 58,
    "changed_files": 18,
    "commits": 28,
    "review_comments": 111,
    "comments": 24
  },
  "events": [
    {
      "event": "convert_to_draft",
      "id": 4498526080,
      "node_id": "MDE5OkNvbnZlcnRUb0RyYWZ0RXZlbnQ0NDk4NTI2MDgw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4498526080",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-23T20:58:46Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-23T21:00:28Z",
      "updated_at": "2021-03-23T21:00:28Z",
      "source": {
        "issue": {
          "id": 575726877,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MzgzODM3MDY2",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18261/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18261/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/18261/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/18261",
          "number": 18261,
          "state": "closed",
          "state_reason": null,
          "title": "Erlay: bandwidth-efficient transaction relay protocol",
          "body": "This is an implementation of [Erlay](https://arxiv.org/abs/1905.10518), using primitives in the BIP-330 (see the updated spec [here](https://github.com/naumenkogs/bips/blob/bip_0330_updates/bip-0330.mediawiki)). Please refer to these two to understand the design. My talk on the topic is [here](https://youtu.be/YxsjdIl0034?t=670).\r\n\r\nErlay uses both flooding (announcing using INV messages to all peers) and reconciliation to announce transactions. Flooding is expensive, so Erlay seeks to use it sparingly and in strategic locations - only well-connected publicly reachable nodes flood transactions to other publicly reachable nodes via outbound connections. Since every unreachable node is directly connected to several reachable nodes, this policy ensures that a transaction is quickly propagated to be within one hop from most of the nodes in the network.\r\n\r\nAll transactions not propagated through flooding are propagated through efficient set reconciliation. To do this, every node keeps a reconciliation set for each peer, in which transactions are placed which would have been announced using INV messages absent this protocol. Every 2 seconds every node chooses a peer from its outbound connections in a predetermined order to reconcile with, resulting in both sides learning the transactions known to the other side. After every reconciliation round, the corresponding reconciliation set is cleared.\r\n\r\nI think both paper and the BIP motives the changes, but I'll mention them briefly once again here:\r\n- save 40% of the bandwidth consumed by a node\r\n- increase network connectivity for almost no bandwidth or latency cost\r\n- improves privacy as a side-effect\r\n\r\nObviously looking for review, let's try to start with a high-level concerns, and keep nits for later.\r\n\r\nP.S.\r\nPlease don't be scared of 8,000 LOC added. 7,000 of them is minisketch added as a subtree.\r\n\r\nP.P.S.\r\nMy experiments of running this code live (slightly outdated) with a script to replicate the experiment: [here1](https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-599241490) and [here2](https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-600388543).\r\n",
          "user": {
            "login": "naumenkogs",
            "id": 7975071,
            "node_id": "MDQ6VXNlcjc5NzUwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/naumenkogs",
            "html_url": "https://github.com/naumenkogs",
            "followers_url": "https://api.github.com/users/naumenkogs/followers",
            "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
            "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
            "repos_url": "https://api.github.com/users/naumenkogs/repos",
            "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 38,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/18261",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/18261.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/18261.patch"
          },
          "closed_at": "2021-03-23T22:51:05Z",
          "created_at": "2020-03-04T20:01:31Z",
          "updated_at": "2022-08-16T17:22:24Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 4498549340,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQ0OTg1NDkzNDA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4498549340",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-23T21:04:23Z",
      "label": {
        "name": "Build system",
        "color": "5319e7"
      }
    },
    {
      "event": "labeled",
      "id": 4498549341,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQ0OTg1NDkzNDE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4498549341",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-23T21:04:23Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "labeled",
      "id": 4498549345,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQ0OTg1NDkzNDU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4498549345",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-23T21:04:24Z",
      "label": {
        "name": "Utils/log/libs",
        "color": "5319e7"
      }
    },
    {
      "event": "reviewed",
      "id": 619102655,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MTAyNjU1",
      "url": null,
      "actor": null,
      "commit_id": "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Just noticed it's marked as draft, I'll resume once you mark it ready for review.",
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-619102655",
      "submitted_at": "2021-03-23T21:50:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4498845173,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDQ5ODg0NTE3Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4498845173",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-23T22:30:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4499048299,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDQ5OTA0ODI5OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4499048299",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-23T23:48:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4500749274,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUwMDc0OTI3NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4500749274",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-24T09:30:06Z"
    },
    {
      "event": "commented",
      "id": 805662879,
      "node_id": "MDEyOklzc3VlQ29tbWVudDgwNTY2Mjg3OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/805662879",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-24T09:59:06Z",
      "updated_at": "2023-10-19T02:10:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept NACK | [ghost](https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885899988), [rebroad](https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885743229) |\n| Concept ACK | [glozow](https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981672502) |\n| Stale ACK | [promag](https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-619157940) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#28676](https://github.com/bitcoin/bitcoin/pull/28676) ([WIP] Cluster mempool implementation by sdaftuar)\n* [#28463](https://github.com/bitcoin/bitcoin/pull/28463) (p2p: Increase inbound capacity for block-relay only connections by mzumsande)\n* [#28429](https://github.com/bitcoin/bitcoin/pull/28429) (Do not log p2p bip61 reject messages, improve log, add tests by jonatack)\n* [#27826](https://github.com/bitcoin/bitcoin/pull/27826) (validation: log which peer sent us a header by Sjors)\n* [#26283](https://github.com/bitcoin/bitcoin/pull/26283) (p2p: Fill reconciliation sets and request reconciliation (Erlay) by naumenkogs)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-805662879",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-24T12:47:28Z",
      "updated_at": "2021-03-24T12:47:28Z",
      "source": {
        "issue": {
          "id": 807217968,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTcyNTAzNTY1",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21160",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21160/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21160/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21160/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21160",
          "number": 21160,
          "state": "closed",
          "state_reason": null,
          "title": "net/net processing: Move tx inventory into net_processing",
          "body": "This continues the work of moving application layer data into net_processing, by moving all tx data into the new Peer object added in #19607.\r\n\r\nFor motivation, see #19398.",
          "user": {
            "login": "jnewbery",
            "id": 1063656,
            "node_id": "MDQ6VXNlcjEwNjM2NTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jnewbery",
            "html_url": "https://github.com/jnewbery",
            "followers_url": "https://api.github.com/users/jnewbery/followers",
            "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
            "organizations_url": "https://api.github.com/users/jnewbery/orgs",
            "repos_url": "https://api.github.com/users/jnewbery/repos",
            "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jnewbery/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 47,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21160",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21160",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21160.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21160.patch"
          },
          "closed_at": "2022-03-25T15:16:26Z",
          "created_at": "2021-02-12T13:02:58Z",
          "updated_at": "2023-08-24T12:09:07Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-24T13:13:14Z",
      "updated_at": "2021-03-24T13:13:14Z",
      "source": {
        "issue": {
          "id": 798844282,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTY1NTkwNjcw",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21061",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21061/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21061/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21061/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21061",
          "number": 21061,
          "state": "closed",
          "state_reason": null,
          "title": "[p2p] Introduce node rebroadcast module ",
          "body": "## Status\r\n(this section will be updated as the PR progresses, and eventually removed)\r\n- I'm reworking some of the approach, will mark ready for review once that is done. \r\n\r\n## Motivation:\r\nOur legacy rebroadcast mechanism lives in the wallet code. It rebroadcasts only & all transactions which are “mine”, not discerning if the fee rate indicates the transaction should actually have been confirmed by now. This is bad for privacy because it leaks information that allows spy nodes to link bitcoin addresses with IP addresses, a relationship we aim to obfuscate. \r\n\r\n## PR Overview:\r\nThis PR introduces a rebroadcast mechanism in the node. Instead of only rebroadcasting our own transactions, we will notify the network about _any_ transactions we identified as missing from blocks based on fee rate expectations in our own mempool. \r\n\r\nThe new module is currently behind a configuration flag that defaults to off.\r\n\r\nThe end goal is to enable node rebroadcast by default, and remove wallet rebroadcast. This would improve privacy for a few main reasons: \r\n1. We would no longer eagerly rebroadcast all of our wallet transactions regardless of fee-rate. We add logic to rebroadcast the ones which have a competitive rate according to the current blocks being mined. \r\n2. If a spy observes a bitcoin core node rebroadcasting a transaction, it would no longer know that the node has wallet enabled. \r\n3. If a spy observed a bitcoin core node rebroadcasting a transaction, it would no longer be able to deduce with high confidence that the associated wallet is participating in that transaction.\r\n\r\n## Approach: \r\nConceptually, we want to rebroadcast transactions that we believe “should” have been mined by now.  Since we expect miners to prioritize transactions with the highest package fee rates, we select high fee rate transactions that have been in our mempool for some time, but have not yet been mined. \r\n\r\nThis PR introduces a `txrebroadcast` module that encapsulates the selection logic. When `PeerManager` gets notified that we have received and processed a block, we trigger the rebroadcast logic. The module calculates the highest fee rate mempool packages that meet some additional conditions- the transaction must be > 30 minutes old, and surpass a fee threshold. This threshold is calculated by periodically (every minute) identifying the top block of transactions in our mempool, and caching the fee rate for a package to be included. We eliminate any of these candidates that we have rebroadcasted recently (last 4 hours), or already rebroadcast more than a maximum amount of times (6). We store any remaining candidates on each peer’s `setInventoryTxToSend`, which they will potentially relay next time we hit `SendMessages` for that peer (subject to general transaction relay conditions). \r\n",
          "user": {
            "login": "amitiuttarwar",
            "id": 1500952,
            "node_id": "MDQ6VXNlcjE1MDA5NTI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/amitiuttarwar",
            "html_url": "https://github.com/amitiuttarwar",
            "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
            "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
            "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
            "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
            "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 45,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21061",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21061",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21061.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21061.patch"
          },
          "closed_at": "2022-03-22T14:43:03Z",
          "created_at": "2021-02-02T01:28:53Z",
          "updated_at": "2023-03-22T10:20:16Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4503225444,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUwMzIyNTQ0NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4503225444",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-24T17:07:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4503329022,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUwMzMyOTAyMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4503329022",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-24T17:27:57Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-25T08:57:08Z",
      "updated_at": "2021-03-25T08:57:08Z",
      "source": {
        "issue": {
          "id": 840540283,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjAwNDEyMDM4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21527",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21527/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21527/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21527/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21527",
          "number": 21527,
          "state": "closed",
          "state_reason": null,
          "title": "net_processing: lock clean up",
          "body": "`cs_sendProcessing` is replaced by a private mutex in net_processing, non-orphan-specific things are moved out from `g_cs_orphans` and `g_cs_orphans` is replaced by a private mutex in txorphanage.",
          "user": {
            "login": "ajtowns",
            "id": 127186,
            "node_id": "MDQ6VXNlcjEyNzE4Ng==",
            "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ajtowns",
            "html_url": "https://github.com/ajtowns",
            "followers_url": "https://api.github.com/users/ajtowns/followers",
            "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
            "organizations_url": "https://api.github.com/users/ajtowns/orgs",
            "repos_url": "https://api.github.com/users/ajtowns/repos",
            "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ajtowns/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 24,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21527",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21527",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21527.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21527.patch"
          },
          "closed_at": "2022-08-29T06:54:34Z",
          "created_at": "2021-03-25T04:16:30Z",
          "updated_at": "2023-08-29T12:09:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4506615610,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUwNjYxNTYxMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4506615610",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-25T09:14:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4512778304,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxMjc3ODMwNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4512778304",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-26T09:33:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4512795156,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxMjc5NTE1Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4512795156",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-26T09:37:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4513142243,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxMzE0MjI0Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4513142243",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-26T10:53:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4513400853,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxMzQwMDg1Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4513400853",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-26T11:50:59Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4513560708,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxMzU2MDcwOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4513560708",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-26T12:26:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4515113211,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxNTExMzIxMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4515113211",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-26T17:09:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4516124408,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxNjEyNDQwOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4516124408",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-26T21:43:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4516178674,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxNjE3ODY3NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4516178674",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-26T22:05:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4517559721,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxNzU1OTcyMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4517559721",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-27T21:31:07Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-27T22:32:20Z",
      "updated_at": "2021-03-27T22:32:20Z",
      "source": {
        "issue": {
          "id": 840541049,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjAwNDEyNjkz",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21528",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21528/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21528/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21528/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21528",
          "number": 21528,
          "state": "closed",
          "state_reason": null,
          "title": "[p2p] Reduce addr blackholes ",
          "body": "This PR builds on the test refactors extracted into #22306 (first 5 commits). \r\n\r\nThis PR aims to reduce addr blackholes. When we receive an `addr` message that contains 10 or less addresses, we forward them to 1-2 peers. This is the main technique we use for self advertisements, so sending to peers that wouldn't relay would effectively \"blackhole\" the trickle. Although we cannot prevent this in a malicious case, we can improve it for the normal, honest cases, and reduce the overall likelihood of occurrence. Two known cases where peers would not participate in addr relay are if they have connected to you as a block-relay-only connection, or if they are a light client. \r\n\r\nThis implementation defers initialization of `m_addr_known` until it is needed, then uses its presence to decide if the peer is participating in addr relay. For outbound (not block-relay-only) peers, we initialize the filter before sending the initial self announcement when processing their `version` message. For inbound peers, we initialize the filter if/when we get an addr related message (`ADDR`, `ADDRV2`, `GETADDR`). We do NOT initialize the filter based on a `SENDADDRV2` message. \r\n\r\nTo communicate about these changes beyond bitcoin core & to (try to) ensure that no other software would be disrupted, I have: \r\n- Posted to the [mailing list](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-April/018784.html)\r\n- Researched other open source clients to confirm compatibility, opened issues in all the projects & documented in https://github.com/bitcoin/bitcoin/pull/21528#issuecomment-809906430. Many have confirmed that this change would not be problematic.\r\n- Raised as topic during [bitcoin-core-dev meeting](https://www.erisian.com.au/bitcoin-core-dev/log-2021-03-25.html#l-954)\r\n- Raised as topic during [bitcoin p2p meeting](https://www.erisian.com.au/bitcoin-core-dev/log-2021-04-20.html#l-439)",
          "user": {
            "login": "amitiuttarwar",
            "id": 1500952,
            "node_id": "MDQ6VXNlcjE1MDA5NTI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/amitiuttarwar",
            "html_url": "https://github.com/amitiuttarwar",
            "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
            "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
            "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
            "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
            "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 31,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21528",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21528",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21528.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21528.patch"
          },
          "closed_at": "2021-08-03T01:48:25Z",
          "created_at": "2021-03-25T04:18:07Z",
          "updated_at": "2022-08-18T19:52:03Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-27T23:36:09Z",
      "updated_at": "2021-03-27T23:36:09Z",
      "source": {
        "issue": {
          "id": 812007772,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTc2NDQ0OTQ5",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21236",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21236/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21236/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21236/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21236",
          "number": 21236,
          "state": "closed",
          "state_reason": null,
          "title": "net processing: Extract `addr` send functionality into MaybeSendAddr()",
          "body": "This continues the work of moving application layer data into net_processing. It refactors `addr` send functionality into its own function `MaybeSendAddr()` and flattens/simplifies the code. Isolating and simplifying the addr handling code makes subsequent changes (which will move addr data and logic into net processing) easier to review.\r\n\r\nThis is a pure refactor. There are no functional changes.\r\n\r\nFor motivation of the project, see #19398.",
          "user": {
            "login": "jnewbery",
            "id": 1063656,
            "node_id": "MDQ6VXNlcjEwNjM2NTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jnewbery",
            "html_url": "https://github.com/jnewbery",
            "followers_url": "https://api.github.com/users/jnewbery/followers",
            "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
            "organizations_url": "https://api.github.com/users/jnewbery/orgs",
            "repos_url": "https://api.github.com/users/jnewbery/repos",
            "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jnewbery/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 18,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21236",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21236",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21236.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21236.patch"
          },
          "closed_at": "2021-04-01T06:33:38Z",
          "created_at": "2021-02-19T13:06:04Z",
          "updated_at": "2022-08-16T17:07:14Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "closed",
      "id": 4517659906,
      "node_id": "MDExOkNsb3NlZEV2ZW50NDUxNzY1OTkwNg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4517659906",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-28T00:14:04Z"
    },
    {
      "event": "reopened",
      "id": 4517659938,
      "node_id": "MDEzOlJlb3BlbmVkRXZlbnQ0NTE3NjU5OTM4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4517659938",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-28T00:14:07Z"
    },
    {
      "event": "ready_for_review",
      "id": 4517899018,
      "node_id": "MDE5OlJlYWR5Rm9yUmV2aWV3RXZlbnQ0NTE3ODk5MDE4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4517899018",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-28T07:55:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4518083711,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxODA4MzcxMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4518083711",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-28T12:26:21Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4518154051,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxODE1NDA1MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4518154051",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-28T13:53:04Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4518426120,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxODQyNjEyMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4518426120",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-28T18:50:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4518530611,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUxODUzMDYxMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4518530611",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-28T20:46:14Z"
    },
    {
      "event": "reviewed",
      "id": 619157940,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MTU3OTQw",
      "url": null,
      "actor": null,
      "commit_id": "54dc74bb736596974c9ce813186e19f0b3b37217",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code review ACK up to 99906e0c3399225ee361ce85291074971d2025e1.",
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-619157940",
      "submitted_at": "2021-03-28T22:43:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4520608046,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUyMDYwODA0Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4520608046",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-29T10:12:56Z"
    },
    {
      "event": "reviewed",
      "id": 623130809,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzMTMwODA5",
      "url": null,
      "actor": null,
      "commit_id": "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-623130809",
      "submitted_at": "2021-03-29T11:34:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "reviewed",
      "id": 623106592,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzMTA2NTky",
      "url": null,
      "actor": null,
      "commit_id": "3692db74f86186789c9dad4005f7b768721d5afe",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code review up to f842ec7839e36adf24782228934f4fff223279a5.",
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-623106592",
      "submitted_at": "2021-03-29T11:38:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "reviewed",
      "id": 623133260,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzMTMzMjYw",
      "url": null,
      "actor": null,
      "commit_id": "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-623133260",
      "submitted_at": "2021-03-29T11:41:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4522353224,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUyMjM1MzIyNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4522353224",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-29T15:50:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4523811713,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDUyMzgxMTcxMw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4523811713",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-29T20:47:38Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-01T04:24:01Z",
      "updated_at": "2021-04-01T04:24:01Z",
      "source": {
        "issue": {
          "id": 847379953,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjA2Mzk4MjUw",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21563",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21563/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21563/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21563/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21563",
          "number": 21563,
          "state": "closed",
          "state_reason": null,
          "title": "net: Restrict period when cs_vNodes mutex is locked",
          "body": "This PR restricts the period when the `cs_vNodes` mutex is locked, prevents the only case when `cs_vNodes` could be locked before the `::cs_main`.\r\n\r\nThis change makes the explicit locking of recursive mutexes in the explicit order redundant.",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 23,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21563",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21563",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21563.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21563.patch"
          },
          "closed_at": "2021-04-25T08:10:51Z",
          "created_at": "2021-03-31T21:35:56Z",
          "updated_at": "2022-08-16T17:21:57Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 4539506626,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQ1Mzk1MDY2MjY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4539506626",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-01T07:02:29Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4546837879,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDU0NjgzNzg3OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4546837879",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-02T19:42:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4546972456,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDU0Njk3MjQ1Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4546972456",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-02T20:27:59Z"
    },
    {
      "event": "unlabeled",
      "id": 4546985795,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50NDU0Njk4NTc5NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4546985795",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-02T20:31:54Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-03T01:28:36Z",
      "updated_at": "2021-04-03T01:28:36Z",
      "source": {
        "issue": {
          "id": 849344843,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjA4MTM0OTcx",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21573",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21573/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21573/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21573/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21573",
          "number": 21573,
          "state": "closed",
          "state_reason": null,
          "title": "Update libsecp256k1 subtree to latest master",
          "body": "This updates our src/secp256k1 subtree to the latest upstream master. The changes include:\r\n\r\n* The introduction of safegcd-based modular inverses, reducing ECDSA signing time by 25%-30% and ECDSA verification time by 15%-17%.\r\n  * [Original paper](https://gcd.cr.yp.to/papers.html) by Daniel J. Bernstein and Bo-Yin Yang\r\n  * [Implementation](https://github.com/bitcoin-core/secp256k1/pull/767) by Peter Dettman; [final](https://github.com/bitcoin-core/secp256k1/pull/831) version\r\n  * [Explanation](https://github.com/bitcoin-core/secp256k1/blob/master/doc/safegcd_implementation.md) of the algorithm using Python snippets\r\n  * [Analysis](https://github.com/sipa/safegcd-bounds) of the maximum number of iterations the algorithm needs\r\n  * [Formal proof in Coq](https://medium.com/blockstream/a-formal-proof-of-safegcd-bounds-695e1735a348) by Russell O'Connor, for a high-level equivalent algorithm\r\n* Removal of libgmp as an (optional) dependency (which wasn't used in the Bitcoin Core build)\r\n* CI changes (Travis -> Cirrus)\r\n* Build system improvements\r\n\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            },
            {
              "id": 159815356,
              "node_id": "MDU6TGFiZWwxNTk4MTUzNTY=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Upstream",
              "name": "Upstream",
              "color": "bfd4f2",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 18,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21573",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21573",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21573.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21573.patch"
          },
          "closed_at": "2021-06-07T15:05:42Z",
          "created_at": "2021-04-02T17:12:43Z",
          "updated_at": "2022-08-18T18:24:41Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-03T02:07:26Z",
      "updated_at": "2021-04-03T02:07:26Z",
      "source": {
        "issue": {
          "id": 838150287,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTk4Mzc1NzQx",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21506",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21506/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21506/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21506/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21506",
          "number": 21506,
          "state": "closed",
          "state_reason": null,
          "title": "p2p, refactor: make NetPermissionFlags an enum class",
          "body": "While reviewing #20196, I noticed the `NetPermissionFlags` enums are frequently called as if they were scoped, yet are still global. This patch upgrades `NetPermissionFlags` to a scoped class enum and updates the enumerator naming, similarly to #19771. See https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#enum-enumerations for more info.\r\n\r\nThis change would eliminate the class of bugs like https://github.com/bitcoin/bitcoin/pull/20196#discussion_r610770148 and #21644, as only defined operations on the flags would compile.\r\n",
          "user": {
            "login": "jonatack",
            "id": 2415484,
            "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonatack",
            "html_url": "https://github.com/jonatack",
            "followers_url": "https://api.github.com/users/jonatack/followers",
            "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
            "organizations_url": "https://api.github.com/users/jonatack/orgs",
            "repos_url": "https://api.github.com/users/jonatack/repos",
            "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonatack/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/47",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47/labels",
            "id": 5347322,
            "node_id": "MDk6TWlsZXN0b25lNTM0NzMyMg==",
            "number": 47,
            "state": "closed",
            "title": "22.0",
            "description": "",
            "creator": {
              "login": "maflcko",
              "id": 6399679,
              "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
              "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/maflcko",
              "html_url": "https://github.com/maflcko",
              "followers_url": "https://api.github.com/users/maflcko/followers",
              "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
              "organizations_url": "https://api.github.com/users/maflcko/orgs",
              "repos_url": "https://api.github.com/users/maflcko/repos",
              "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/maflcko/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 124,
            "created_at": "2020-04-25T00:14:49Z",
            "updated_at": "2021-09-14T07:16:53Z",
            "closed_at": "2021-09-09T12:47:52Z"
          },
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 17,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21506",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21506",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21506.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21506.patch"
          },
          "closed_at": "2021-05-19T09:58:05Z",
          "created_at": "2021-03-22T22:17:43Z",
          "updated_at": "2022-08-18T18:24:02Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-03T03:31:36Z",
      "updated_at": "2021-04-03T03:31:36Z",
      "source": {
        "issue": {
          "id": 808479458,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTczNTE0Mjk2",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21186",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21186/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21186/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21186/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21186",
          "number": 21186,
          "state": "closed",
          "state_reason": null,
          "title": "net/net processing: Move addr data into net_processing",
          "body": "This continues the work of moving application layer data into net_processing, by moving all addr data into the new Peer object added in #19607.\r\n\r\nFor motivation, see #19398.",
          "user": {
            "login": "jnewbery",
            "id": 1063656,
            "node_id": "MDQ6VXNlcjEwNjM2NTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jnewbery",
            "html_url": "https://github.com/jnewbery",
            "followers_url": "https://api.github.com/users/jnewbery/followers",
            "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
            "organizations_url": "https://api.github.com/users/jnewbery/orgs",
            "repos_url": "https://api.github.com/users/jnewbery/repos",
            "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jnewbery/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 15,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21186",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21186",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21186.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21186.patch"
          },
          "closed_at": "2021-05-24T12:28:54Z",
          "created_at": "2021-02-15T12:04:37Z",
          "updated_at": "2022-08-16T17:22:54Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 636090761,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2MDkwNzYx",
      "url": null,
      "actor": null,
      "commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I think PR description might incorporate a test plan describing in details functional/unit/fuzz coverage/manual testing coverage. Working on a suggestion.\r\n\r\nAt least for manual testing, we should start to run nodes on a signet with this branch. But should add a preferential peering to find erlay peers on the default signet network or should we encourage signet node operators to upgrade their peers with this branch ? Or even boostrap a new signet ? ",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-636090761",
      "submitted_at": "2021-04-14T21:32:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "reviewed",
      "id": 636820159,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2ODIwMTU5",
      "url": null,
      "actor": null,
      "commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-636820159",
      "submitted_at": "2021-04-15T16:53:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4600973778,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDYwMDk3Mzc3OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4600973778",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-15T18:34:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4601087998,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDYwMTA4Nzk5OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4601087998",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-15T18:58:18Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-15T19:26:40Z",
      "updated_at": "2021-04-15T19:26:40Z",
      "source": {
        "issue": {
          "id": 858985887,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjE2MTM5MTUz",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21700",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21700/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21700/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21700/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21700",
          "number": 21700,
          "state": "closed",
          "state_reason": null,
          "title": "net: expand Sock and fuzz-test more of CConnman",
          "body": "* Expand the `Sock` class\r\n  * Add wrapper methods for `setsockopt()`, `getsockname()`, `bind()` and `listen()`\r\n  * Convert the standalone functions `SetSocketNoDelay()` and `IsSelectableSocket()` to `Sock` methods\r\n* Expand the usage of `Sock`: `CConnman::CreateNodeFromAcceptedSocket()` and `GetBindAddress()` changed to take `Sock` as an argument instead of `SOCKET`\r\n* Add fuzz tests for `OpenNetworkConnection()`, `CreateNodeFromAcceptedSocket()` and `InitBinds()` `CConnman` methods.",
          "user": {
            "login": "vasild",
            "id": 266751,
            "node_id": "MDQ6VXNlcjI2Njc1MQ==",
            "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vasild",
            "html_url": "https://github.com/vasild",
            "followers_url": "https://api.github.com/users/vasild/followers",
            "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
            "organizations_url": "https://api.github.com/users/vasild/orgs",
            "repos_url": "https://api.github.com/users/vasild/repos",
            "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/vasild/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 13,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21700",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21700",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21700.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21700.patch"
          },
          "closed_at": "2021-05-07T16:18:31Z",
          "created_at": "2021-04-15T15:15:36Z",
          "updated_at": "2022-08-16T17:21:58Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 637839318,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODM5MzE4",
      "url": null,
      "actor": null,
      "commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-637839318",
      "submitted_at": "2021-04-16T15:37:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "reviewed",
      "id": 637847119,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODQ3MTE5",
      "url": null,
      "actor": null,
      "commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-637847119",
      "submitted_at": "2021-04-16T15:45:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "reviewed",
      "id": 637848006,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODQ4MDA2",
      "url": null,
      "actor": null,
      "commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-637848006",
      "submitted_at": "2021-04-16T15:46:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-17T10:29:21Z",
      "updated_at": "2021-04-17T10:29:21Z",
      "source": {
        "issue": {
          "id": 860258968,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjE3MTk3MTQ3",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21713",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21713/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21713/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21713/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21713",
          "number": 21713,
          "state": "closed",
          "state_reason": null,
          "title": "Refactor ProcessNewBlock to reduce code duplication",
          "body": "There are probably a few issues with this code (maybe there's even a reason this code is duplicated as it currently is), so apologies in advance that I'm still a little (maybe very) bad with C++",
          "user": {
            "login": "rebroad",
            "id": 1530283,
            "node_id": "MDQ6VXNlcjE1MzAyODM=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rebroad",
            "html_url": "https://github.com/rebroad",
            "followers_url": "https://api.github.com/users/rebroad/followers",
            "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
            "organizations_url": "https://api.github.com/users/rebroad/orgs",
            "repos_url": "https://api.github.com/users/rebroad/repos",
            "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/rebroad/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21713",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21713",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21713.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21713.patch"
          },
          "closed_at": "2021-04-19T07:03:25Z",
          "created_at": "2021-04-16T23:47:14Z",
          "updated_at": "2022-04-07T06:14:04Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 638283440,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MjgzNDQw",
      "url": null,
      "actor": null,
      "commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-638283440",
      "submitted_at": "2021-04-18T00:26:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "labeled",
      "id": 4610881283,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQ2MTA4ODEyODM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4610881283",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-19T07:45:38Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 640132240,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMTMyMjQw",
      "url": null,
      "actor": null,
      "commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-640132240",
      "submitted_at": "2021-04-20T17:51:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4624219458,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDYyNDIxOTQ1OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4624219458",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-21T10:43:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4624337994,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDYyNDMzNzk5NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4624337994",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-21T11:10:27Z"
    },
    {
      "event": "unlabeled",
      "id": 4624538088,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50NDYyNDUzODA4OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4624538088",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-21T11:54:46Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 641193149,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxMTkzMTQ5",
      "url": null,
      "actor": null,
      "commit_id": "eede5dc518502fd31c2b83ffc8a212f645f75cf8",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-641193149",
      "submitted_at": "2021-04-21T14:52:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4625981194,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDYyNTk4MTE5NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4625981194",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-21T16:09:07Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-21T17:33:57Z",
      "updated_at": "2021-04-21T17:33:57Z",
      "source": {
        "issue": {
          "id": 863375335,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjE5Nzk1OTEy",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21740",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21740/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21740/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21740/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21740",
          "number": 21740,
          "state": "closed",
          "state_reason": null,
          "title": "test: add new python linter to check file names and permissions",
          "body": "Adds a new python linter test which tests for correct filenames and file permissions in the repository.\r\n\r\nReplaces the existing tests in the `test/lint/lint-filenames.sh` and `test/lint/lint-shebang.sh` linter tests, as well as adding some new and increased testing. This increased coverage is intended to catch issues such as in #21728 and https://github.com/bitcoin/bitcoin/pull/16807/files#r345547050\r\n\r\nSummary of tests:\r\n* Checks every file in the repository against an allowed regexp to make sure only lowercase or uppercase alphanumerics (a-zA-Z0-9), underscores (_), hyphens (-), at (@) and dots (.) are used in repository filenames.\r\n\r\n* Checks only source files (*.cpp, *.h, *.py, *.sh) against a stricter allowed regexp to make sure only lowercase alphanumerics (a-z0-9), underscores (_), hyphens (-) and dots (.) are used in source code filenames. Additionally there is an exception regexp for directories or files which are excepted from matching this regexp (This should replicate the existing `test/lint/lint-filenames.sh` test)\r\n\r\n* Checks all files in the repository match an allowed executable or non-executable file permission octal. Additionally checks that for executable files, the file contains a shebang line.\r\n\r\n* Checks that for executable `.py` and `.sh` files, the shebang line used matches an allowable list of shebangs (This should replicate the existing `test/lint/lint-shebang.sh` test)\r\n\r\n* Checks every file that contains a shebang line to ensure it has an executable permission\r\n\r\nAdditionally updates the permissions on various files to comply with the new tests.\r\n\r\nFixes #21729",
          "user": {
            "login": "windsok",
            "id": 8359865,
            "node_id": "MDQ6VXNlcjgzNTk4NjU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8359865?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/windsok",
            "html_url": "https://github.com/windsok",
            "followers_url": "https://api.github.com/users/windsok/followers",
            "following_url": "https://api.github.com/users/windsok/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/windsok/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/windsok/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/windsok/subscriptions",
            "organizations_url": "https://api.github.com/users/windsok/orgs",
            "repos_url": "https://api.github.com/users/windsok/repos",
            "events_url": "https://api.github.com/users/windsok/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/windsok/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21740",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21740",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21740.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21740.patch"
          },
          "closed_at": "2021-05-05T15:17:38Z",
          "created_at": "2021-04-21T01:50:24Z",
          "updated_at": "2022-08-16T17:22:57Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 641380591,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxMzgwNTkx",
      "url": null,
      "actor": null,
      "commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-641380591",
      "submitted_at": "2021-04-21T19:02:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4630916369,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDYzMDkxNjM2OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4630916369",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-22T13:40:18Z"
    },
    {
      "event": "reviewed",
      "id": 642279533,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyMjc5NTMz",
      "url": null,
      "actor": null,
      "commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-642279533",
      "submitted_at": "2021-04-22T14:32:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-26T01:31:33Z",
      "updated_at": "2021-04-26T01:31:33Z",
      "source": {
        "issue": {
          "id": 867083588,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjIyODE3OTEy",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21775",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21775/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21775/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21775/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21775",
          "number": 21775,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: Limit m_block_inv_mutex",
          "body": "Keeping the lock longer than needed is confusing to reviewers and thread analysis. For example, keeping the lock while appending tx-invs, which requires the mempool lock, will tell thread analysis tools an incorrect lock order of `(1) m_block_inv_mutex, (2) pool.cs`.",
          "user": {
            "login": "maflcko",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/maflcko",
            "html_url": "https://github.com/maflcko",
            "followers_url": "https://api.github.com/users/maflcko/followers",
            "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
            "organizations_url": "https://api.github.com/users/maflcko/orgs",
            "repos_url": "https://api.github.com/users/maflcko/repos",
            "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/maflcko/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21775",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21775",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21775.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21775.patch"
          },
          "closed_at": "2021-05-03T09:14:56Z",
          "created_at": "2021-04-25T18:44:07Z",
          "updated_at": "2022-08-16T17:21:31Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 647321593,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ3MzIxNTkz",
      "url": null,
      "actor": null,
      "commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-647321593",
      "submitted_at": "2021-04-28T18:28:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-29T11:15:34Z",
      "updated_at": "2021-04-29T11:15:34Z",
      "source": {
        "issue": {
          "id": 791418755,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTU5NDgxMjMw",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20980",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20980/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20980/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20980/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20980",
          "number": 20980,
          "state": "closed",
          "state_reason": null,
          "title": "guix: Test security-check sanity before performing them",
          "body": "These changes allow us to make use of the `test-security-check` target to check the sanity\r\nof our security/symbol checking suite before running them.",
          "user": {
            "login": "dongcarl",
            "id": 3445290,
            "node_id": "MDQ6VXNlcjM0NDUyOTA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dongcarl",
            "html_url": "https://github.com/dongcarl",
            "followers_url": "https://api.github.com/users/dongcarl/followers",
            "following_url": "https://api.github.com/users/dongcarl/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dongcarl/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dongcarl/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
            "organizations_url": "https://api.github.com/users/dongcarl/orgs",
            "repos_url": "https://api.github.com/users/dongcarl/repos",
            "events_url": "https://api.github.com/users/dongcarl/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dongcarl/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/47",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47/labels",
            "id": 5347322,
            "node_id": "MDk6TWlsZXN0b25lNTM0NzMyMg==",
            "number": 47,
            "state": "closed",
            "title": "22.0",
            "description": "",
            "creator": {
              "login": "maflcko",
              "id": 6399679,
              "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
              "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/maflcko",
              "html_url": "https://github.com/maflcko",
              "followers_url": "https://api.github.com/users/maflcko/followers",
              "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
              "organizations_url": "https://api.github.com/users/maflcko/orgs",
              "repos_url": "https://api.github.com/users/maflcko/repos",
              "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/maflcko/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 124,
            "created_at": "2020-04-25T00:14:49Z",
            "updated_at": "2021-09-14T07:16:53Z",
            "closed_at": "2021-09-09T12:47:52Z"
          },
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 24,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20980",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20980",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20980.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20980.patch"
          },
          "closed_at": "2021-07-01T13:03:20Z",
          "created_at": "2021-01-21T19:07:26Z",
          "updated_at": "2022-08-16T17:25:00Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-29T18:34:17Z",
      "updated_at": "2021-04-29T18:34:17Z",
      "source": {
        "issue": {
          "id": 484649284,
          "node_id": "MDU6SXNzdWU0ODQ2NDkyODQ=",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16700",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16700/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16700/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16700/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/16700",
          "number": 16700,
          "state": "closed",
          "state_reason": "completed",
          "title": "test: boost unit tests don't handle assert very well",
          "body": "When running into an assert failure, the boost unit test framework does not shut down cleanly. It does not call the `BasicTestingSetup` destructor. Thus, the test process will never shut down. As a result of that, the failure is never passed back to the caller.\r\n\r\nOn travis, this will result in frustrating and hard-to-debug timeouts: E.g. https://travis-ci.org/bitcoin/bitcoin/jobs/575909995#L3584\r\n\r\nI see two ways to fix this:\r\n\r\n* Use exceptions instead of assertions, especially in non-validation debug code\r\n* Teach the boost unit test framework how to handle `asserts`\r\n",
          "user": {
            "login": "maflcko",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/maflcko",
            "html_url": "https://github.com/maflcko",
            "followers_url": "https://api.github.com/users/maflcko/followers",
            "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
            "organizations_url": "https://api.github.com/users/maflcko/orgs",
            "repos_url": "https://api.github.com/users/maflcko/repos",
            "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/maflcko/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 5,
          "closed_at": "2020-02-21T23:03:30Z",
          "created_at": "2019-08-23T18:06:23Z",
          "updated_at": "2022-08-18T19:53:13Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 648417961,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ4NDE3OTYx",
      "url": null,
      "actor": null,
      "commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Currently looking through unit tests.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-648417961",
      "submitted_at": "2021-04-29T18:58:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4668483063,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDY2ODQ4MzA2Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4668483063",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-30T10:21:48Z"
    },
    {
      "event": "commented",
      "id": 830164004,
      "node_id": "MDEyOklzc3VlQ29tbWVudDgzMDE2NDAwNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/830164004",
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-30T15:11:30Z",
      "updated_at": "2021-04-30T15:11:30Z",
      "author_association": "MEMBER",
      "body": "See comment here if you think replacing assert with exception is better to exercise coverage in unit tests : https://github.com/bitcoin/bitcoin/issues/16700#issuecomment-829494172",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-830164004",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "reviewed",
      "id": 649348312,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ5MzQ4MzEy",
      "url": null,
      "actor": null,
      "commit_id": "96c261630cc42e3bad41a61ba2a589bf2ae22676",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-649348312",
      "submitted_at": "2021-04-30T15:54:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-03T07:51:56Z",
      "updated_at": "2021-05-03T07:51:56Z",
      "source": {
        "issue": {
          "id": 874218642,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjI4ODIyNTI2",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21837",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21837/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21837/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21837/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21837",
          "number": 21837,
          "state": "closed",
          "state_reason": null,
          "title": "[POC] Rust based Cuckoo Filter for m_addr_known",
          "body": "This proof of concept PR (leveraging work done by Cory Fields & Jeremy Rubin, see #16834) replaces the [rolling bloom filter](https://github.com/bitcoin/bitcoin/blob/2448457cca1858c2fcf3dfcb53de3f388ea72079/src/bloom.cpp#L173) used for [`m_addr_known`](https://github.com/bitcoin/bitcoin/blob/2448457cca1858c2fcf3dfcb53de3f388ea72079/src/net.h#L550) with a [Cuckoo Filter written in Rust](https://github.com/axiomhq/rust-cuckoofilter). I've have made some minor build related adjustments to the Rust code, which can be seen here: https://github.com/fanquake/rust-cuckoofilter/tree/cabi_build_adjustments.\r\n\r\nSee [\"Cuckoo Filter: Practically Better Than Bloom\"](https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf):\r\n\r\n> In many networking systems, Bloom filters are used for high-speed set membership tests. They permit a small fraction of false positive answers with very good space efficiency. However, they do not permit deletion of items from the set, and previous attempts to extend “standard” Bloom filters to support deletion all degrade either space or performance.\r\n\r\n> We propose a new data structure called the cuckoo filter that can replace Bloom filters for approximate set member- ship tests. Cuckoo filters support adding and removing items dynamically while achieving even higher performance than Bloom filters. \r\n\r\n> For applications that store many items and target moderately low false positive rates, cuckoo filters have lower space overhead than space-optimized Bloom filters. Our experimental results also show that cuckoo filters out-perform previous data structures that extend Bloom filters to support deletions substantially in both time and space.\r\n\r\nUsing this is a matter of:\r\n```bash\r\n./autogen.sh\r\n./configure --enable-experimental-rust\r\nmake\r\nmake -C src rusty-check\r\nsrc/bitcoind \r\n```\r\nNote that sometimes compilation will finish (i.e due to `ccache`) before `cargo` has finished generating the header and Rust lib, which will result in a compile error:\r\n```bash\r\n./net.h:43:10: fatal error: rusty/out/rcf_cuckoofilter.h: No such file or directory\r\n   43 | #include <rusty/out/rcf_cuckoofilter.h>\r\n```\r\n\r\nIn this case you can just re-run `make`. Has been tested on macOS and Linux. Sometimes `p2p_getaddr_caching.py` fails, because the number of records returned falls a few short of `MAX_ADDR_TO_SEND`. Need investigating.\r\n\r\nI'm not suggesting that this be merged as-is, or that this is the ideal way of integrating Rust code (i.e copying sources in tree, using `cbindgen`), into Bitcoin Core. What I am suggesting is that the Rust discussion should continue, particularly in regards to integrations that can be done in a very non-invasive / modular fashion.\r\n\r\nDoesn't crash, but may catch your machine on fire 🔥, use with caution. More Rust related discussion available in #17090.",
          "user": {
            "login": "fanquake",
            "id": 863730,
            "node_id": "MDQ6VXNlcjg2MzczMA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fanquake",
            "html_url": "https://github.com/fanquake",
            "followers_url": "https://api.github.com/users/fanquake/followers",
            "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
            "organizations_url": "https://api.github.com/users/fanquake/orgs",
            "repos_url": "https://api.github.com/users/fanquake/repos",
            "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fanquake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 64584,
              "node_id": "MDU6TGFiZWw2NDU4NA==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Brainstorming",
              "name": "Brainstorming",
              "color": "ebd775",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21837",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21837",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21837.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21837.patch"
          },
          "closed_at": "2021-06-09T07:58:14Z",
          "created_at": "2021-05-03T04:37:39Z",
          "updated_at": "2022-11-09T16:32:01Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 4677120890,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQ2NzcxMjA4OTA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4677120890",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-03T09:22:02Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 831142156,
      "node_id": "MDEyOklzc3VlQ29tbWVudDgzMTE0MjE1Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/831142156",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-03T09:32:58Z",
      "updated_at": "2021-05-03T09:32:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\n🕵️ @hebasto @sipa @practicalswift have been requested to review this pull request as specified in the REVIEWERS file.",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-831142156",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "mentioned",
      "id": 4677165729,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDY3NzE2NTcyOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4677165729",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-03T09:32:58Z"
    },
    {
      "event": "subscribed",
      "id": 4677165730,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ2NzcxNjU3MzA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4677165730",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-03T09:32:58Z"
    },
    {
      "event": "mentioned",
      "id": 4677165735,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDY3NzE2NTczNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4677165735",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-03T09:32:58Z"
    },
    {
      "event": "subscribed",
      "id": 4677165740,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ2NzcxNjU3NDA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4677165740",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-03T09:32:58Z"
    },
    {
      "event": "mentioned",
      "id": 4677165749,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDY3NzE2NTc0OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4677165749",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-03T09:32:59Z"
    },
    {
      "event": "subscribed",
      "id": 4677165754,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ2NzcxNjU3NTQ=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4677165754",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-03T09:32:59Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-05T01:23:13Z",
      "updated_at": "2021-05-05T01:23:13Z",
      "source": {
        "issue": {
          "id": 875965590,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjMwMjAxNzky",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21859",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21859/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21859/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21859/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21859",
          "number": 21859,
          "state": "closed",
          "state_reason": null,
          "title": "Add minisketch subtree and integrate in build/test",
          "body": "This adds a `src/minisketch` subtree, taken from the master branch of https://github.com/sipa/minisketch, to prepare for Erlay implementation (see #21515). It gets configured for just supporting 32-bit fields (the only ones we're interested in in the context of Erlay), and some code on top is added:\r\n* A very basic unit test (just to make sure compilation & running works; actual correctness checking is done through minisketch's own tests).\r\n* A wrapper in `minisketchwrapper.{cpp,h}` that runs a benchmark to determine which field implementation to use.",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 159815356,
              "node_id": "MDU6TGFiZWwxNTk4MTUzNTY=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Upstream",
              "name": "Upstream",
              "color": "bfd4f2",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 57,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21859",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21859",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21859.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21859.patch"
          },
          "closed_at": "2021-09-28T07:08:42Z",
          "created_at": "2021-05-05T01:23:13Z",
          "updated_at": "2022-10-30T19:10:04Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4688248615,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDY4ODI0ODYxNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4688248615",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-05T10:52:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4688286653,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDY4ODI4NjY1Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4688286653",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-05T11:01:21Z"
    },
    {
      "event": "unlabeled",
      "id": 4688438712,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50NDY4ODQzODcxMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4688438712",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-05T11:35:13Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-05T15:36:53Z",
      "updated_at": "2021-05-05T15:36:53Z",
      "source": {
        "issue": {
          "id": 876144544,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjMwMzQ4MjU2",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21862",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21862/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21862/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21862/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21862",
          "number": 21862,
          "state": "closed",
          "state_reason": null,
          "title": "test: Set regtest.BIP65Height = 111 to speed up tests",
          "body": "No need to waste time by forcing creation of more than 1000 blocks to get the benefits of being able to test BIP 65. Also, reducing the height makes it more likely that (third-party) tests are conforming to BIP 65, which is enforced on mainnet for all new blocks.",
          "user": {
            "login": "maflcko",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/maflcko",
            "html_url": "https://github.com/maflcko",
            "followers_url": "https://api.github.com/users/maflcko/followers",
            "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
            "organizations_url": "https://api.github.com/users/maflcko/orgs",
            "repos_url": "https://api.github.com/users/maflcko/repos",
            "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/maflcko/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 6,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21862",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21862",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21862.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21862.patch"
          },
          "closed_at": "2021-08-26T23:53:49Z",
          "created_at": "2021-05-05T07:22:32Z",
          "updated_at": "2022-08-27T13:19:53Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 4689904425,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQ2ODk5MDQ0MjU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4689904425",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-05T15:49:38Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 654524878,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0NTI0ODc4",
      "url": null,
      "actor": null,
      "commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Good with unit tests for now, pretty fine coverage :)",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-654524878",
      "submitted_at": "2021-05-07T17:35:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "commented",
      "id": 841946130,
      "node_id": "MDEyOklzc3VlQ29tbWVudDg0MTk0NjEzMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/841946130",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-17T02:58:34Z",
      "updated_at": "2021-05-17T03:00:14Z",
      "author_association": "MEMBER",
      "body": "@naumenkogs #21859 should be sufficiently ready to rebase on, if you want CI-testable code. Note the src/minisketchwrapper module, which automatically benchmarks.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-841946130",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "mentioned",
      "id": 4751843755,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDc1MTg0Mzc1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4751843755",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-17T02:58:34Z"
    },
    {
      "event": "subscribed",
      "id": 4751843760,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ3NTE4NDM3NjA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4751843760",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-17T02:58:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4819739583,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDgxOTczOTU4Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4819739583",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-31T09:50:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4949791087,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk0OTc5MTA4Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4949791087",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-28T20:48:00Z"
    },
    {
      "event": "unlabeled",
      "id": 4950081987,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50NDk1MDA4MTk4Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4950081987",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-28T22:07:33Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4954446974,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk1NDQ0Njk3NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4954446974",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-29T15:24:10Z"
    },
    {
      "event": "commented",
      "id": 870975622,
      "node_id": "MDEyOklzc3VlQ29tbWVudDg3MDk3NTYyMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/870975622",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-29T23:07:08Z",
      "updated_at": "2021-06-29T23:07:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "How can I help test this? I've been running it for a few hours so far on mainnet, but haven't noticed much difference compared to the master branch.",
      "user": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-870975622",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "commented",
      "id": 871564829,
      "node_id": "MDEyOklzc3VlQ29tbWVudDg3MTU2NDgyOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/871564829",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-30T16:43:32Z",
      "updated_at": "2021-06-30T17:15:13Z",
      "author_association": "MEMBER",
      "body": "@rebroad It only makes a difference if your erlay-enabled node connects to other erlay-enabled nodes :)\r\nI'm planning to invite people to a such sub-network soon (where we can connect to each other by --addnode manually). I'll let you know once I start that :)\r\n\r\nYou can obviously run several nodes with this patch by yourself too, just make sure to connect them.",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-871564829",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "mentioned",
      "id": 4960934215,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDk2MDkzNDIxNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4960934215",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-30T16:43:32Z"
    },
    {
      "event": "subscribed",
      "id": 4960934218,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ5NjA5MzQyMTg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4960934218",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-30T16:43:32Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4961184576,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk2MTE4NDU3Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4961184576",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-30T17:35:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4965619069,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk2NTYxOTA2OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4965619069",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-01T12:20:21Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4967286381,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk2NzI4NjM4MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4967286381",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-01T17:18:21Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-02T01:46:19Z",
      "updated_at": "2021-07-02T01:46:19Z",
      "source": {
        "issue": {
          "id": 934820350,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjgxODM2NTc3",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22381",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22381/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22381/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22381/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/22381",
          "number": 22381,
          "state": "closed",
          "state_reason": null,
          "title": "guix: Test security-check sanity before performing them (with macOS)",
          "body": "This is #20980 rebased (to include the Boost Process fix), and with an additional commit (892d6897f1e613084aa0517a660eab2412308e6e) to fix running the `test-security-check` target for the macOS build. It should pass inside Guix, as well as when cross-compiling on Ubuntu, or building natively on macOS.\r\n\r\nNote that the `test-security-check` may output some warnings (similar too):\r\n```bash\r\nld: warning: passed two min versions (10.14, 11.4) for platform macOS. Using 11.4.\r\nld: warning: passed two min versions (10.14, 11.4) for platform macOS. Using 11.4.\r\nld: warning: passed two min versions (10.14, 10.14) for platform macOS. Using 10.14.\r\n```\r\nbut those can be ignored, and come about due to us passing `-platform_version` when `-mmacosx-version-min` is already part of `CC`.\r\n\r\nGuix builds:\r\n```bash\r\n71ed0c7a13a4726300779ffc87f7d271086a2744c36896fe6dc51fe3dc33df2e  guix-build-5b4703c6a70d/output/aarch64-linux-gnu/SHA256SUMS.part\r\n9273980a17052c8ec45b77579781c14ab5d189fa25aa29907d5115513dd302b1  guix-build-5b4703c6a70d/output/aarch64-linux-gnu/bitcoin-5b4703c6a70d-aarch64-linux-gnu-debug.tar.gz\r\n9c042179af43c8896eb95a34294df15d4910308dcdba40b2010cd36e192938b8  guix-build-5b4703c6a70d/output/aarch64-linux-gnu/bitcoin-5b4703c6a70d-aarch64-linux-gnu.tar.gz\r\n1ceddecac113f50a952ba6a201cdcdb722e3dc804e663f219bfac8268ce42bf0  guix-build-5b4703c6a70d/output/arm-linux-gnueabihf/SHA256SUMS.part\r\n759597c4e925e75db4a2381c06cda9b9f4e4674c23436148676b31c9be05c7aa  guix-build-5b4703c6a70d/output/arm-linux-gnueabihf/bitcoin-5b4703c6a70d-arm-linux-gnueabihf-debug.tar.gz\r\n34e3b6beabaf8c95d7c2ca0d2c3ac4411766694ef43e00bd9783badbbaf045a7  guix-build-5b4703c6a70d/output/arm-linux-gnueabihf/bitcoin-5b4703c6a70d-arm-linux-gnueabihf.tar.gz\r\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  guix-build-5b4703c6a70d/output/dist-archive/SKIPATTEST.TAG\r\n3664f6ceee7898caa374281fd877a7597fe491fa2e9f0c174c28d889d60b559c  guix-build-5b4703c6a70d/output/dist-archive/bitcoin-5b4703c6a70d.tar.gz\r\nd6bc35ba0750c1440bb32831b8c12cddee62f6dce10fec2650897444c2bf4748  guix-build-5b4703c6a70d/output/powerpc64-linux-gnu/SHA256SUMS.part\r\na836edf6474ba0c16c19bb217549bac7936c1b44306ed512df58f607ee5568f2  guix-build-5b4703c6a70d/output/powerpc64-linux-gnu/bitcoin-5b4703c6a70d-powerpc64-linux-gnu-debug.tar.gz\r\n7cc91c6805d5069ca3bd1771e77d95f83eb184b137198cbf84d1d11d0a5c5afe  guix-build-5b4703c6a70d/output/powerpc64-linux-gnu/bitcoin-5b4703c6a70d-powerpc64-linux-gnu.tar.gz\r\n93b4cb7b83c4975120ad5de5a92f050f5760a2a3f2c37c204c647f5a581c924a  guix-build-5b4703c6a70d/output/powerpc64le-linux-gnu/SHA256SUMS.part\r\n2266e2c5d0dafa28c6c057ccfc1c439baeab1d714d8c3f64a83015d2827116d2  guix-build-5b4703c6a70d/output/powerpc64le-linux-gnu/bitcoin-5b4703c6a70d-powerpc64le-linux-gnu-debug.tar.gz\r\n85f41f42c319b83d049d6fd2e2278c07b40a1e28a2eac596427822c0eef9dc3f  guix-build-5b4703c6a70d/output/powerpc64le-linux-gnu/bitcoin-5b4703c6a70d-powerpc64le-linux-gnu.tar.gz\r\n1499ca9119926083d8c3714ca10d8d4c8d864cbeee8848fd8445b7a1d081222d  guix-build-5b4703c6a70d/output/riscv64-linux-gnu/SHA256SUMS.part\r\n1995fc1a2e45c49d4b0718aff5dcdac931917e8ae9e762fd23f1126abcecc248  guix-build-5b4703c6a70d/output/riscv64-linux-gnu/bitcoin-5b4703c6a70d-riscv64-linux-gnu-debug.tar.gz\r\n266889eb58429a470f0fd7bb123f2ae09b0aef86c47b0390938b3634a8f748a9  guix-build-5b4703c6a70d/output/riscv64-linux-gnu/bitcoin-5b4703c6a70d-riscv64-linux-gnu.tar.gz\r\ncdc3a0dcf80b110443dac5ddf8bc951001a776a651c898c5ea49bb2d487bfe29  guix-build-5b4703c6a70d/output/x86_64-apple-darwin18/SHA256SUMS.part\r\n8538d1eab96c97866b24546c453d95822f24cf9c6638b42ba523eb7aa441cb26  guix-build-5b4703c6a70d/output/x86_64-apple-darwin18/bitcoin-5b4703c6a70d-osx-unsigned.dmg\r\nd1b73133f1da68586b07292a8425f7f851e93f599c016376f23728c041cf39cc  guix-build-5b4703c6a70d/output/x86_64-apple-darwin18/bitcoin-5b4703c6a70d-osx-unsigned.tar.gz\r\n5ad94c5f8a5f29405955ff3ab35d137de1acc04398d6c8298fb187b57a6e316a  guix-build-5b4703c6a70d/output/x86_64-apple-darwin18/bitcoin-5b4703c6a70d-osx64.tar.gz\r\n8c6d7b3f847faa7b4d16ceecf228f26f146ea982615c1d7a00c57f9230a0c484  guix-build-5b4703c6a70d/output/x86_64-linux-gnu/SHA256SUMS.part\r\nd0a8c99750319ad8046cfa132a54e5c13a08351f94439ae9af0f8e5486c2c2ea  guix-build-5b4703c6a70d/output/x86_64-linux-gnu/bitcoin-5b4703c6a70d-x86_64-linux-gnu-debug.tar.gz\r\nd816bb26dd4b0e309f2f576b1cccc6d78743fb2f357daad2da09bb1177330971  guix-build-5b4703c6a70d/output/x86_64-linux-gnu/bitcoin-5b4703c6a70d-x86_64-linux-gnu.tar.gz\r\n65caaa7f648c7eab1eb82c3331a2ca25b8cd4fe41439de55604501e02571de55  guix-build-5b4703c6a70d/output/x86_64-w64-mingw32/SHA256SUMS.part\r\n5bf6f7328cbceb0db22a2d7babb07b60cb6dcc19a6db84a1698589b7f5173a06  guix-build-5b4703c6a70d/output/x86_64-w64-mingw32/bitcoin-5b4703c6a70d-win-unsigned.tar.gz\r\n7aabcb56115decef78d3797840b6e49dbc9b202d56f892490e92616fb06fec9e  guix-build-5b4703c6a70d/output/x86_64-w64-mingw32/bitcoin-5b4703c6a70d-win64-debug.zip\r\n2f369694648ff9dc5ca1261a1e5874b1c7408ccf2802f9caef56c1334e8a5b7c  guix-build-5b4703c6a70d/output/x86_64-w64-mingw32/bitcoin-5b4703c6a70d-win64-setup-unsigned.exe\r\n1c1f92513c4aad38419ff49a7b80bf10e6b1eca01ee8c5e3b2acd1768cf1e3d5  guix-build-5b4703c6a70d/output/x86_64-w64-mingw32/bitcoin-5b4703c6a70d-win64.zip\r\n``` ",
          "user": {
            "login": "fanquake",
            "id": 863730,
            "node_id": "MDQ6VXNlcjg2MzczMA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fanquake",
            "html_url": "https://github.com/fanquake",
            "followers_url": "https://api.github.com/users/fanquake/followers",
            "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
            "organizations_url": "https://api.github.com/users/fanquake/orgs",
            "repos_url": "https://api.github.com/users/fanquake/repos",
            "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fanquake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/47",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47/labels",
            "id": 5347322,
            "node_id": "MDk6TWlsZXN0b25lNTM0NzMyMg==",
            "number": 47,
            "state": "closed",
            "title": "22.0",
            "description": "",
            "creator": {
              "login": "maflcko",
              "id": 6399679,
              "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
              "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/maflcko",
              "html_url": "https://github.com/maflcko",
              "followers_url": "https://api.github.com/users/maflcko/followers",
              "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
              "organizations_url": "https://api.github.com/users/maflcko/orgs",
              "repos_url": "https://api.github.com/users/maflcko/repos",
              "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/maflcko/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 124,
            "created_at": "2020-04-25T00:14:49Z",
            "updated_at": "2021-09-14T07:16:53Z",
            "closed_at": "2021-09-09T12:47:52Z"
          },
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22381",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/22381",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/22381.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/22381.patch"
          },
          "closed_at": "2021-07-09T02:21:12Z",
          "created_at": "2021-07-01T13:01:59Z",
          "updated_at": "2022-08-18T18:31:53Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4970857989,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk3MDg1Nzk4OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4970857989",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-02T11:06:25Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-03T12:37:34Z",
      "updated_at": "2021-07-03T12:37:34Z",
      "source": {
        "issue": {
          "id": 860170761,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjE3MTIzNzMy",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21711",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21711/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21711/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21711/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21711",
          "number": 21711,
          "state": "closed",
          "state_reason": null,
          "title": "guix: Add full installation and usage documentation",
          "body": "Based on: #21462\r\n\r\nKeeping the README in one file so that it's easy to search through. Will add more jumping links later so navigation is easier.\r\n\r\nCurrent TODOs:\r\n- [x] Shell installer option: prompt user to re-login for `/etc/profile.d` entry to be picked up\r\n- [x] Binary tarball option: prompt user to create `/etc/profile.d` entry and re-login\r\n- [x] Fanquake docker option: complete section\r\n- [x] Arch Linux AUR option: prompt to start `guix-daemon-latest` unit after finishing \"optional setup\" section\r\n- [x] Building from source option: Insert dependency tree diagram that I made\r\n- [x] Building from source option: redo sectioning, kind of a mess right now\r\n- [x] Optional setup: make clear which parts are only needed if building from source\r\n- [x] Workaround 1 for GnuTLS: perhaps mention how to remove Guix build farm's key\r\n- [x] Overall (after everything): Make the links work.\r\n\r\nNote to self: wherever possible, tell user how to check that something is true rather than branching by installation option.",
          "user": {
            "login": "dongcarl",
            "id": 3445290,
            "node_id": "MDQ6VXNlcjM0NDUyOTA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3445290?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dongcarl",
            "html_url": "https://github.com/dongcarl",
            "followers_url": "https://api.github.com/users/dongcarl/followers",
            "following_url": "https://api.github.com/users/dongcarl/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dongcarl/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dongcarl/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dongcarl/subscriptions",
            "organizations_url": "https://api.github.com/users/dongcarl/orgs",
            "repos_url": "https://api.github.com/users/dongcarl/repos",
            "events_url": "https://api.github.com/users/dongcarl/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dongcarl/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 231994551,
              "node_id": "MDU6TGFiZWwyMzE5OTQ1NTE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Scripts%20and%20tools",
              "name": "Scripts and tools",
              "color": "ffffee",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/47",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/47/labels",
            "id": 5347322,
            "node_id": "MDk6TWlsZXN0b25lNTM0NzMyMg==",
            "number": 47,
            "state": "closed",
            "title": "22.0",
            "description": "",
            "creator": {
              "login": "maflcko",
              "id": 6399679,
              "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
              "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/maflcko",
              "html_url": "https://github.com/maflcko",
              "followers_url": "https://api.github.com/users/maflcko/followers",
              "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
              "organizations_url": "https://api.github.com/users/maflcko/orgs",
              "repos_url": "https://api.github.com/users/maflcko/repos",
              "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/maflcko/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 124,
            "created_at": "2020-04-25T00:14:49Z",
            "updated_at": "2021-09-14T07:16:53Z",
            "closed_at": "2021-09-09T12:47:52Z"
          },
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 10,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21711",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21711",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21711.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21711.patch"
          },
          "closed_at": "2021-07-20T03:09:54Z",
          "created_at": "2021-04-16T21:03:19Z",
          "updated_at": "2022-08-16T17:25:38Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4975418465,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk3NTQxODQ2NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4975418465",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-04T19:09:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4975469128,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk3NTQ2OTEyOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4975469128",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-04T20:17:35Z"
    },
    {
      "event": "reviewed",
      "id": 698947525,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4OTQ3NTI1",
      "url": null,
      "actor": null,
      "commit_id": "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "kiminuo",
        "id": 58662979,
        "node_id": "MDQ6VXNlcjU4NjYyOTc5",
        "avatar_url": "https://avatars.githubusercontent.com/u/58662979?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kiminuo",
        "html_url": "https://github.com/kiminuo",
        "followers_url": "https://api.github.com/users/kiminuo/followers",
        "following_url": "https://api.github.com/users/kiminuo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kiminuo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kiminuo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kiminuo/subscriptions",
        "organizations_url": "https://api.github.com/users/kiminuo/orgs",
        "repos_url": "https://api.github.com/users/kiminuo/repos",
        "events_url": "https://api.github.com/users/kiminuo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kiminuo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-698947525",
      "submitted_at": "2021-07-05T08:53:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "reviewed",
      "id": 698951767,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4OTUxNzY3",
      "url": null,
      "actor": null,
      "commit_id": "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "kiminuo",
        "id": 58662979,
        "node_id": "MDQ6VXNlcjU4NjYyOTc5",
        "avatar_url": "https://avatars.githubusercontent.com/u/58662979?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kiminuo",
        "html_url": "https://github.com/kiminuo",
        "followers_url": "https://api.github.com/users/kiminuo/followers",
        "following_url": "https://api.github.com/users/kiminuo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kiminuo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kiminuo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kiminuo/subscriptions",
        "organizations_url": "https://api.github.com/users/kiminuo/orgs",
        "repos_url": "https://api.github.com/users/kiminuo/repos",
        "events_url": "https://api.github.com/users/kiminuo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kiminuo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-698951767",
      "submitted_at": "2021-07-05T08:57:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-05T15:57:52Z",
      "updated_at": "2021-07-05T15:57:52Z",
      "source": {
        "issue": {
          "id": 937200015,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjgzNzk1MDM4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22405",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22405/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22405/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22405/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/22405",
          "number": 22405,
          "state": "closed",
          "state_reason": null,
          "title": "build: remove --enable-glibc-back-compat from Guix build",
          "body": "Now that our Guix toolchains are based on glibc 2.24 and 2.27 (RISCV), we don't need to use the `--enable-glibc-back-compat` option to produce binaries that don't use any symbols from glibc 2.17 and 2.27 or later.\r\n\r\nThis also adds additional documentation to some Guix patches (pointed out in #22365) and removes Guix patches from the spelling linter, because that isn't our spelling.\r\n\r\nSymbol usage: https://gist.github.com/fanquake/d15604fc580718444c5aa4b3c3c75fdc.\r\n\r\nGuix Builds:\r\n```bash\r\nbash-5.1# find guix-build-$(git rev-parse --short=12 HEAD)/output/ -type f -print0 | env LC_ALL=C sort -z | xargs -r0 sha256sum\r\ned54e6a6cf4fab328557c0c72eb08c73f2a58c6c70959544cf4b1882e75ea69e  guix-build-797b3ed90900/output/aarch64-linux-gnu/SHA256SUMS.part\r\n83bd9dadc59f89f848d143fa4fc3964f16fe0b4bdf35e5093b577ff2c4bd1f43  guix-build-797b3ed90900/output/aarch64-linux-gnu/bitcoin-797b3ed90900-aarch64-linux-gnu-debug.tar.gz\r\n94cb8c35281f12dec6ea5b390b66cad5e27ac8c45a30c42c8d38c438695d54c0  guix-build-797b3ed90900/output/aarch64-linux-gnu/bitcoin-797b3ed90900-aarch64-linux-gnu.tar.gz\r\n7318b63d65c0aa52d2446de8e1f40658d2e47ab8fb0268820c3b7585d140fb23  guix-build-797b3ed90900/output/arm-linux-gnueabihf/SHA256SUMS.part\r\n95e1ffb372964b73f539653ca703b70cf0c018801a9c4c0ffc46a0b63539253c  guix-build-797b3ed90900/output/arm-linux-gnueabihf/bitcoin-797b3ed90900-arm-linux-gnueabihf-debug.tar.gz\r\n039d3842e6499626cf955ae0a7590dd6b3d0935cdc217c98aaf9d156b0ebd3b4  guix-build-797b3ed90900/output/arm-linux-gnueabihf/bitcoin-797b3ed90900-arm-linux-gnueabihf.tar.gz\r\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  guix-build-797b3ed90900/output/dist-archive/SKIPATTEST.TAG\r\n2c4e7b6e7aff63ba811e5bf59362d16866c3a358f8844fba8739a61192870622  guix-build-797b3ed90900/output/dist-archive/bitcoin-797b3ed90900.tar.gz\r\n955029b949c368eabd517dd33040d2f01e2ac6a55e7b4f9107907a7c6e0c6060  guix-build-797b3ed90900/output/powerpc64-linux-gnu/SHA256SUMS.part\r\nfd6d6b137f8efedf58a879d11205b1d4649e1f97d7f91e193239ef206fcc285d  guix-build-797b3ed90900/output/powerpc64-linux-gnu/bitcoin-797b3ed90900-powerpc64-linux-gnu-debug.tar.gz\r\n51736ac8e77737999f1b5bd4c381b0016f19a8d5e40e786fe941ff04e84c11c9  guix-build-797b3ed90900/output/powerpc64-linux-gnu/bitcoin-797b3ed90900-powerpc64-linux-gnu.tar.gz\r\n8c244c16bfa46c1efdb120e1d91fdd14d3f14eefee8d7e1fbb0a9b4664a5c315  guix-build-797b3ed90900/output/powerpc64le-linux-gnu/SHA256SUMS.part\r\n704ee593251a1b1c65a5bebeef93b23f266af4e8cbf8ae556150c3b2e8f06a6c  guix-build-797b3ed90900/output/powerpc64le-linux-gnu/bitcoin-797b3ed90900-powerpc64le-linux-gnu-debug.tar.gz\r\n0ec06ae7d344de20d61e3965d8b383747ef20b0e9d93a3165733ea23bdf2ead8  guix-build-797b3ed90900/output/powerpc64le-linux-gnu/bitcoin-797b3ed90900-powerpc64le-linux-gnu.tar.gz\r\n2dd6c6ecc67b0ea40ca9c43f92efca81ccd054b8db8c197ad84ad9674d510a25  guix-build-797b3ed90900/output/riscv64-linux-gnu/SHA256SUMS.part\r\n5ebb27a855a677f7a188d83995be6b2a3ea8606be152abb7fc7832713fb0677a  guix-build-797b3ed90900/output/riscv64-linux-gnu/bitcoin-797b3ed90900-riscv64-linux-gnu-debug.tar.gz\r\nbdaf1783f5e1861597afa37c1880364e118d9a7a7af8017302d82202791019f6  guix-build-797b3ed90900/output/riscv64-linux-gnu/bitcoin-797b3ed90900-riscv64-linux-gnu.tar.gz\r\n726c9092b60ac2e7d7e14b2c24467fcf276a6f89170a871ddab9dce6ac230699  guix-build-797b3ed90900/output/x86_64-apple-darwin18/SHA256SUMS.part\r\n2af4d709b44952654f3c08c86593bf2ccc9a44ed422783a1b95b8a199a894db2  guix-build-797b3ed90900/output/x86_64-apple-darwin18/bitcoin-797b3ed90900-osx-unsigned.dmg\r\nfd49ba445aa6cf3d8c47019a05e9e5740cb0f53349344dd80671297127f49f1a  guix-build-797b3ed90900/output/x86_64-apple-darwin18/bitcoin-797b3ed90900-osx-unsigned.tar.gz\r\n3f51cbf8cf18420d4be70e656aa993675cf5e828a255c2030047ae2e059ed5b7  guix-build-797b3ed90900/output/x86_64-apple-darwin18/bitcoin-797b3ed90900-osx64.tar.gz\r\nafd1edee1447bb88d81e972abfae4c4e065b5b1827769f033cff9472084c7c1b  guix-build-797b3ed90900/output/x86_64-linux-gnu/SHA256SUMS.part\r\nec468ef886d25e685f4f7a18b4f7d497dedf757495e0d5beb72c23cc32ab69b5  guix-build-797b3ed90900/output/x86_64-linux-gnu/bitcoin-797b3ed90900-x86_64-linux-gnu-debug.tar.gz\r\n1934d7294f0c9e083d38a3f68d4a61cd679defa79ce0a89f77386978692b9b18  guix-build-797b3ed90900/output/x86_64-linux-gnu/bitcoin-797b3ed90900-x86_64-linux-gnu.tar.gz\r\n94c11c328a628052eb6f50e9816aa768f87ea7acfbbbafdab60f6928da766811  guix-build-797b3ed90900/output/x86_64-w64-mingw32/SHA256SUMS.part\r\nfd371922ba93d81bd4a2b711d617af6756f9f0494db6d83aa0e5f491a24168ef  guix-build-797b3ed90900/output/x86_64-w64-mingw32/bitcoin-797b3ed90900-win-unsigned.tar.gz\r\n4e4ad976bc029bbbf9596ad8493accaaba8b0d5c598dd342f8da330609bbdf21  guix-build-797b3ed90900/output/x86_64-w64-mingw32/bitcoin-797b3ed90900-win64-debug.zip\r\n3a89a16b9101e9a17d98efb9234b5bdd264c0bba2c6326511017730e1a08311f  guix-build-797b3ed90900/output/x86_64-w64-mingw32/bitcoin-797b3ed90900-win64-setup-unsigned.exe\r\ne285ab737e3c843fd3f1c26c2f053e421a3c39b33995747ce48281884d3f28d1  guix-build-797b3ed90900/output/x86_64-w64-mingw32/bitcoin-797b3ed90900-win64.zip\r\n```",
          "user": {
            "login": "fanquake",
            "id": 863730,
            "node_id": "MDQ6VXNlcjg2MzczMA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fanquake",
            "html_url": "https://github.com/fanquake",
            "followers_url": "https://api.github.com/users/fanquake/followers",
            "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
            "organizations_url": "https://api.github.com/users/fanquake/orgs",
            "repos_url": "https://api.github.com/users/fanquake/repos",
            "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fanquake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 5,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22405",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/22405",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/22405.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/22405.patch"
          },
          "closed_at": "2021-07-07T11:22:16Z",
          "created_at": "2021-07-05T15:33:45Z",
          "updated_at": "2022-08-18T18:32:06Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4981396974,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk4MTM5Njk3NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4981396974",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-06T07:21:44Z"
    },
    {
      "event": "labeled",
      "id": 4988868386,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQ5ODg4NjgzODY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4988868386",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-07T12:33:14Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5024406846,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTAyNDQwNjg0Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5024406846",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-15T09:56:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5043819622,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTA0MzgxOTYyMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5043819622",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-20T11:47:39Z"
    },
    {
      "event": "unlabeled",
      "id": 5044145861,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50NTA0NDE0NTg2MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5044145861",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-20T12:57:17Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 885743229,
      "node_id": "IC_kwDOABII5840y159",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/885743229",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-23T16:07:29Z",
      "updated_at": "2021-07-27T16:12:42Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've been testing this, and so far I've found that the efficiency is reduced with this patch - i.e. a lower PERCENTAGE of the bandwidth is used for ACCEPTED transactions compared to not using this patch. Therefore it is better NOT to use this patch. Therefore, NACK, for now, perhaps premature.\r\n\r\nI'll continue testing, and share my data in the near future.",
      "user": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885743229",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "commented",
      "id": 885868272,
      "node_id": "IC_kwDOABII5840zUbw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/885868272",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-23T19:29:56Z",
      "updated_at": "2021-07-23T19:40:27Z",
      "author_association": "MEMBER",
      "body": "@rebroad That's interesting, and surprising. Can you share your data? Which other Erlay-capable nodes have you been testing with? Substantial improvements are only expected once significant subgraphs adopt it.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885868272",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "mentioned",
      "id": 5062671688,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NTA2MjY3MTY4OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5062671688",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-23T19:29:56Z"
    },
    {
      "event": "subscribed",
      "id": 5062671693,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDUwNjI2NzE2OTM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5062671693",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-23T19:29:56Z"
    },
    {
      "event": "commented",
      "id": 885899988,
      "node_id": "IC_kwDOABII5840zcLU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/885899988",
      "actor": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-23T20:34:30Z",
      "updated_at": "2021-07-23T20:35:50Z",
      "author_association": "NONE",
      "body": "rebroad: \r\n> How can I help test this? I've been running it for a few hours so far on mainnet, but haven't noticed much difference compared to the master branch.\r\n\r\n> I've been testing this, and so far I've found that the efficiency is reduced with this patch - i.e. a lower PERCENTAGE of the bandwidth is used for ACCEPTED transactions compared to not using this patch. Therefore it is better NOT to use this patch. Therefore, NACK.\r\n\r\nsipa: \r\n> **Can you share your data?**\r\n\r\n+1 I love NACK data. Please share else NACK is meaningless. ",
      "user": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885899988",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "commented",
      "id": 886060698,
      "node_id": "IC_kwDOABII58400Daa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/886060698",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-24T14:23:47Z",
      "updated_at": "2021-07-24T14:30:26Z",
      "author_association": "MEMBER",
      "body": "@sipa @prayank23 @rebroad \r\nI've spent last couple days running my own subnetwork of Erlay nodes connected to mainnet. I was slightly tuning implementation/configurations and observing savings of 20-50% of overall bandwidth.\r\n\r\nI can imagine this PR with no modifications yeilding suboptimal results. I will update the PR with good actual-peformance (according to my real-time experiments) in the next few days, and bring that up at the meeting.\r\n\r\nI think judging/nacking this based on the perf is premature.\r\n\r\nSorry for spending your time testing this commit. At this point, the PR was open mainly for concept/code review rather than pefr (maybe it could have been a draft PR, yeah).\r\n",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-886060698",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "mentioned",
      "id": 5064100882,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NTA2NDEwMDg4Mg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5064100882",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-24T14:23:47Z"
    },
    {
      "event": "subscribed",
      "id": 5064100883,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDUwNjQxMDA4ODM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5064100883",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-24T14:23:47Z"
    },
    {
      "event": "mentioned",
      "id": 5064100886,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NTA2NDEwMDg4Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5064100886",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-24T14:23:47Z"
    },
    {
      "event": "subscribed",
      "id": 5064100887,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDUwNjQxMDA4ODc=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5064100887",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-24T14:23:47Z"
    },
    {
      "event": "mentioned",
      "id": 5064100889,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NTA2NDEwMDg4OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5064100889",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-24T14:23:47Z"
    },
    {
      "event": "subscribed",
      "id": 5064100891,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDUwNjQxMDA4OTE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5064100891",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-24T14:23:47Z"
    },
    {
      "event": "convert_to_draft",
      "id": 5064120783,
      "node_id": "MDE5OkNvbnZlcnRUb0RyYWZ0RXZlbnQ1MDY0MTIwNzgz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5064120783",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-24T14:48:48Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5102959071,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTEwMjk1OTA3MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5102959071",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-03T07:15:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5105089290,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTEwNTA4OTI5MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5105089290",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-03T14:12:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5105118290,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTEwNTExODI5MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5105118290",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-03T14:16:28Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5105296778,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTEwNTI5Njc3OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5105296778",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-03T14:43:35Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-03T20:29:02Z",
      "updated_at": "2021-08-03T20:29:02Z",
      "source": {
        "issue": {
          "id": 959008967,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NzAyMTg4ODQy",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22616",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22616/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22616/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22616/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/22616",
          "number": 22616,
          "state": "closed",
          "state_reason": null,
          "title": "p2p, rpc: address relay fixups",
          "body": "Following review of new changes merged today, move a use of `statestats` in getpeerinfo to within the section guarded by `if (fStateStats)`, e.g. `PeerManagerImpl::GetNodeStateStats` true, and pass an in-param by reference to const.",
          "user": {
            "login": "jonatack",
            "id": 2415484,
            "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonatack",
            "html_url": "https://github.com/jonatack",
            "followers_url": "https://api.github.com/users/jonatack/followers",
            "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
            "organizations_url": "https://api.github.com/users/jonatack/orgs",
            "repos_url": "https://api.github.com/users/jonatack/repos",
            "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonatack/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98279177,
              "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
              "name": "RPC/REST/ZMQ",
              "color": "0052cc",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 13,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22616",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/22616",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/22616.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/22616.patch"
          },
          "closed_at": "2021-08-04T15:51:29Z",
          "created_at": "2021-08-03T11:17:20Z",
          "updated_at": "2022-08-16T17:26:29Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 892542075,
      "node_id": "IC_kwDOABII5841Mxx7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/892542075",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-04T10:19:27Z",
      "updated_at": "2021-08-05T20:30:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "![image](https://user-images.githubusercontent.com/1530283/128164829-cb1eef81-705d-433a-b1ce-1cb42106a660.png)\r\nI'm now running the latest erlay patch on 2 nodes, and created a manual connection between them. Compared to non-erlay nodes, the percentage of mempool-successful receive traffic seems below average, and the upload bps seems significantly higher than for the other nodes.\r\n\r\nUpdate (5th August 2021) - still getting very poor TX percentage compared to regular nodes - and a lot of wasted bandwidth - far more than any other connection. I get better percentage with an onion connection even though it has a much larger minimum ping - usually the lower the ping the higher the TX percentage, but not with erlay!\r\n\r\n![image](https://user-images.githubusercontent.com/1530283/128416897-d8cd7829-76d6-4c66-abb0-240b534094f9.png)\r\n",
      "user": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-892542075",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5115556340,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTExNTU1NjM0MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5115556340",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-05T06:55:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5115793693,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTExNTc5MzY5Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5115793693",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-05T07:48:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5116288965,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTExNjI4ODk2NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5116288965",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-05T09:23:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5119632222,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTExOTYzMjIyMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5119632222",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-05T20:32:23Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-06T09:31:27Z",
      "updated_at": "2021-08-06T09:31:27Z",
      "source": {
        "issue": {
          "id": 962357650,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NzA1MTU4NTg3",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22646",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22646/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22646/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22646/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/22646",
          "number": 22646,
          "state": "closed",
          "state_reason": null,
          "title": "build: tighter Univalue integration, remove `--with-system-univalue`",
          "body": "This PR more tightly integrates building Univalue into our build system. This follows the same approach we use for [LevelDB](https://github.com/bitcoin-core/leveldb/), ([`Makefile.leveldb.include`](https://github.com/bitcoin/bitcoin/blob/master/src/Makefile.leveldb.include)), and [CRC32C](https://github.com/bitcoin-core/crc32c) ([`Makefile.crc32c.include`](https://github.com/bitcoin/bitcoin/blob/master/src/Makefile.crc32c.include)), and will be the same approach we use for [minisketch](https://github.com/sipa/minisketch); see #23114.\r\n\r\nThis approach yields a number of benefits, including:\r\n* Faster configuration due to one less subconfigure being run during `./configure` i.e 22s with this PR vs 26s\r\n* Faster autoconf i.e 13s with this PR vs 17s\r\n* Improved caching\r\n* No more issues with compiler flags i.e https://github.com/bitcoin/bitcoin/pull/12467\r\n* More direct control means we can build exactly the objects we want\r\n\r\nThere might be one argument against making this change, which is that builders should have the option to use \"proper shared/system libraries\". However, I think that falls down for a few reasons. The first being that we already don't support building with a number of system libraries (secp256k1, leveldb, crc32c); some for good reason. Univalue is really the odd one out at the moment. \r\n\r\nNote that the only fork of Core I'm aware of, that actively patches in support for using system libs, also explicitly marks them as [\"DANGEROUS\"](https://github.com/bitcoinknots/bitcoin/blob/a886811721ce66eb586871706b3f5dd27518ac3e/configure.ac#L1430) and [\"NOT SUPPORTED\"](https://github.com/bitcoinknots/bitcoin/blob/a886811721ce66eb586871706b3f5dd27518ac3e/configure.ac#L1312). So it would seem they exist more to satisfy a distro requirement, as opposed to something that anyone should, or would actually use in practice.\r\n\r\nPRs like #22412 highlight the \"issue\" with us operating with our own Univalue fork, where we actively fix bugs, and make improvements, when upstream (https://github.com/jgarzik/univalue) may not be taking those improvements, and by all accounts, is not currently actively maintained. Bitcoin Core should not be hamstrung into not being able to fix bugs in a library, and/or have to litter our source with \"workarounds\", i.e #22412, for bugs we've already fixed, based on the fact that an upstream project is not actively being maintained. Allowing builders to use system libs is really only exacerbating this problem, with little benefit to our project. Bitcoin Core is not quite like your average piece of distro packaged software.\r\n\r\nThere is the potential for us to give the same treatment to libsecp256k1, however it seems doing that is currently less straightforward.",
          "user": {
            "login": "fanquake",
            "id": 863730,
            "node_id": "MDQ6VXNlcjg2MzczMA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fanquake",
            "html_url": "https://github.com/fanquake",
            "followers_url": "https://api.github.com/users/fanquake/followers",
            "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
            "organizations_url": "https://api.github.com/users/fanquake/orgs",
            "repos_url": "https://api.github.com/users/fanquake/repos",
            "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fanquake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 28,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22646",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/22646",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/22646.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/22646.patch"
          },
          "closed_at": "2021-10-20T03:02:36Z",
          "created_at": "2021-08-06T03:14:20Z",
          "updated_at": "2022-11-27T09:59:51Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5125725855,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTEyNTcyNTg1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5125725855",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-07T12:59:16Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5125955840,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTEyNTk1NTg0MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5125955840",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-07T18:03:21Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5126441524,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTEyNjQ0MTUyNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5126441524",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-08T08:51:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5126445913,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTEyNjQ0NTkxMw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5126445913",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-08T08:57:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5126457637,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTEyNjQ1NzYzNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5126457637",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-08T09:12:31Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-10T18:55:54Z",
      "updated_at": "2021-08-10T18:55:54Z",
      "source": {
        "issue": {
          "id": 964911074,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NzA3MjkyOTIw",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22674",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22674/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22674/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22674/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/22674",
          "number": 22674,
          "state": "closed",
          "state_reason": null,
          "title": "validation: mempool validation and submission for packages of 1 child + parents",
          "body": "This is 1 chunk of [Package Mempool Accept](https://gist.github.com/glozow/dc4e9d5c5b14ade7cdfac40f43adb18a); it restricts packages to 1 child with its parents, doesn't allow conflicts, and doesn't have CPFP (yet).  Future PRs (see #22290) will add RBF and CPFP within packages.",
          "user": {
            "login": "glozow",
            "id": 25183001,
            "node_id": "MDQ6VXNlcjI1MTgzMDAx",
            "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/glozow",
            "html_url": "https://github.com/glozow",
            "followers_url": "https://api.github.com/users/glozow/followers",
            "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
            "organizations_url": "https://api.github.com/users/glozow/orgs",
            "repos_url": "https://api.github.com/users/glozow/repos",
            "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/glozow/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 82428251,
              "node_id": "MDU6TGFiZWw4MjQyODI1MQ==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/TX%20fees%20and%20policy",
              "name": "TX fees and policy",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            },
            {
              "id": 1648013533,
              "node_id": "MDU6TGFiZWwxNjQ4MDEzNTMz",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Review%20club",
              "name": "Review club",
              "description": "",
              "color": "0052cc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 20,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22674",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/22674",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/22674.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/22674.patch"
          },
          "closed_at": "2021-12-15T19:43:06Z",
          "created_at": "2021-08-10T12:06:09Z",
          "updated_at": "2023-01-17T10:08:15Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-10T21:42:14Z",
      "updated_at": "2021-08-10T21:42:14Z",
      "source": {
        "issue": {
          "id": 925627435,
          "node_id": "MDExOlB1bGxSZXF1ZXN0Njc0MDU2NTg1",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22290/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/22290",
          "number": 22290,
          "state": "closed",
          "state_reason": null,
          "title": "Package Mempool Submission with Package Fee-Bumping",
          "body": "This implements mempool validation logic for fee-bumping transactions using CPFP and RBFing mempool transactions within a package, and the combination of both (i.e. a child in a package can pay to RBF its parents' conflicts). This does not implement package relay; there are no P2P changes.\r\n\r\nFor more info, see full proposal [gist](https://gist.github.com/glozow/dc4e9d5c5b14ade7cdfac40f43adb18a).\r\n\r\n**Package Mempool Accept Progress**:\r\n- [x] #21062\r\n- [x] #20833\r\n- [x] #21800\r\n- [x] #22675 \r\n- [x] #23381\r\n- [x] #22674\r\n- [x] #23804\r\n- [x] #24152\r\n- [x] #24836 \r\n- [ ] #25038\r\n\r\nNote that, until package relay exists, fee-bumped package transactions that are otherwise too-low-fee won't go any further than the user's mempool. This PR doesn't expose the package validation codepath to users because it would be misleading.",
          "user": {
            "login": "glozow",
            "id": 25183001,
            "node_id": "MDQ6VXNlcjI1MTgzMDAx",
            "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/glozow",
            "html_url": "https://github.com/glozow",
            "followers_url": "https://api.github.com/users/glozow/followers",
            "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
            "organizations_url": "https://api.github.com/users/glozow/orgs",
            "repos_url": "https://api.github.com/users/glozow/repos",
            "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/glozow/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98279177,
              "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
              "name": "RPC/REST/ZMQ",
              "color": "0052cc",
              "default": false
            },
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            },
            {
              "id": 164208572,
              "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
              "name": "Mempool",
              "color": "fef2c0",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 13,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22290",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/22290",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/22290.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/22290.patch"
          },
          "closed_at": "2022-12-22T12:14:04Z",
          "created_at": "2021-06-20T15:49:10Z",
          "updated_at": "2023-01-04T11:08:32Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5140219553,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTE0MDIxOTU1Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5140219553",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-11T07:59:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5140377850,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTE0MDM3Nzg1MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5140377850",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-11T08:25:20Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-16T18:44:45Z",
      "updated_at": "2021-08-16T18:44:45Z",
      "source": {
        "issue": {
          "id": 971170927,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NzEyOTYyOTEz",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22707",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22707/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22707/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22707/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/22707",
          "number": 22707,
          "state": "closed",
          "state_reason": null,
          "title": "test: refactor use of getrawmempool in functional tests for efficiency",
          "body": "I don't think this changes the intention of the test. But it does shave ~30 seconds off the time it takes to run. From what I've seen our CI `macOS 11 native [gui] [no depends]` runs `mempool_updatefrom.py` in ~135 seconds. After this PR it should run in ~105 seconds\r\n\r\nI noticed this improvement should probably be made when testing performance/runtimes of https://github.com/bitcoin/bitcoin/pull/22698. But I wanted to separate this out from that PR so the affects of each is decoupled\r\n\r\nEdit: The major change in this PR is improving mempool_updatefrom.py's runtime as this is a very long running test. Then made the same efficiency improvements across all the functional tests as it made since to do that here",
          "user": {
            "login": "mjdietzx",
            "id": 7217256,
            "node_id": "MDQ6VXNlcjcyMTcyNTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mjdietzx",
            "html_url": "https://github.com/mjdietzx",
            "followers_url": "https://api.github.com/users/mjdietzx/followers",
            "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
            "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
            "repos_url": "https://api.github.com/users/mjdietzx/repos",
            "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22707",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/22707",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/22707.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/22707.patch"
          },
          "closed_at": "2021-08-20T15:41:02Z",
          "created_at": "2021-08-15T16:16:58Z",
          "updated_at": "2022-08-20T17:25:36Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 900511655,
      "node_id": "IC_kwDOABII5841rLen",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900511655",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-17T17:54:36Z",
      "updated_at": "2021-08-17T17:54:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Debug build is clean. I'll try to start looking at this soon.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-900511655",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5182698376,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTE4MjY5ODM3Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5182698376",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-19T17:41:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5182717182,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTE4MjcxNzE4Mg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5182717182",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-19T17:45:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5182792274,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTE4Mjc5MjI3NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5182792274",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-19T18:02:31Z"
    },
    {
      "event": "commented",
      "id": 902149222,
      "node_id": "IC_kwDOABII5841xbRm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902149222",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-19T18:37:42Z",
      "updated_at": "2021-08-19T18:37:52Z",
      "author_association": "MEMBER",
      "body": "I created 2 discussion boards, please discuss not-code-related topics there:\r\n1. [Understanding bandwidth savings](https://github.com/naumenkogs/txrelaysim/issues/7)\r\n2. [Joining mainnet testing](https://github.com/naumenkogs/txrelaysim/issues/8)",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-902149222",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "commented",
      "id": 902758735,
      "node_id": "IC_kwDOABII5841zwFP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902758735",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-20T15:04:11Z",
      "updated_at": "2021-08-20T15:04:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "After running this for a few minutes, I'm so far seeing better performance from non-erlay nodes, but perhaps we need more erlay nodes for testing to really see if there's really an improvement.\r\n![image](https://user-images.githubusercontent.com/1530283/130253576-76edc275-b00d-4888-8606-f7adee87634d.png)\r\n",
      "user": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-902758735",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "commented",
      "id": 902839760,
      "node_id": "IC_kwDOABII58410D3Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902839760",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-20T17:17:09Z",
      "updated_at": "2021-08-20T17:17:09Z",
      "author_association": "MEMBER",
      "body": "@rebroad no, the bandwidth savings should come immediately for your node. Maybe the difference is that you run too many conns (I always tested 8/12 erlay conns and that's it)...\r\n\r\nWe could also try to understand why it eats more bandwidth in your case, but perhaps we should stick to the realistic case? E.g., 4 erlay conns + 4 legacy conns for. \r\n\r\nAnyway, could we continue the bandwidth-related discussion [here](https://github.com/naumenkogs/txrelaysim/issues/7)?",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-902839760",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "mentioned",
      "id": 5187915677,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NTE4NzkxNTY3Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5187915677",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-20T17:17:10Z"
    },
    {
      "event": "subscribed",
      "id": 5187915682,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDUxODc5MTU2ODI=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5187915682",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-08-20T17:17:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5318121179,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAE8_Bbb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5318121179",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-09-17T09:20:15Z"
    },
    {
      "event": "ready_for_review",
      "id": 5326816393,
      "node_id": "RFRE_lADOABII584yA-tHzwAAAAE9gMSJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5326816393",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-09-20T08:47:48Z"
    },
    {
      "event": "commented",
      "id": 922753000,
      "node_id": "IC_kwDOABII5843ABfo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/922753000",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-09-20T09:10:24Z",
      "updated_at": "2021-09-20T09:13:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "Maybe this is an \"the emperor has no clothes moment\", but I shall say what's on my mind without fear of appearing stupid.\r\n\r\nTo me, this change looks like the improvements are simply due to reducing the delay between sending TXs. With this change I see greater bandwidth, greater TX throughput but reduced efficiency (i.e. percentage of useful bandwidth). I've been seeing this since I started testing months ago.\r\n\r\nFor example, there's a node in Toronto currently that is managing to be the main provider of TXs, and is not using erlay. I suspect they have changed the code to reduce the delay between TXs:-\r\n\r\n![image](https://user-images.githubusercontent.com/1530283/133979106-690e62c1-c724-4022-9b69-66fb57dc9f3f.png)\r\n\r\nThis seems easily achieveable without erlay. Erlay also reduces the delay between sending TXs, so it's an easy hack to get better TX throughput, but the difference with erlay is that it also reduces efficiency (in all my tests so far).\r\n\r\nErlay does well with throughput:-\r\n![image](https://user-images.githubusercontent.com/1530283/133979283-9a4b6476-c0b0-4708-a9bb-760819127954.png)\r\n\r\nbut badly with efficency:-\r\n![image](https://user-images.githubusercontent.com/1530283/133979323-39f1f1c2-0490-49a9-867d-eeceb4066c1a.png)\r\n\r\nI'd like to see some test results from others that contradict mine though.",
      "user": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-922753000",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-09-24T19:16:57Z",
      "updated_at": "2021-09-24T19:16:57Z",
      "source": {
        "issue": {
          "id": 976972751,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NzE3Nzg0MTkw",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22778",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22778/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22778/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22778/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/22778",
          "number": 22778,
          "state": "closed",
          "state_reason": null,
          "title": "net processing: Reduce resource usage for inbound block-relay-only connections",
          "body": "block-relay-only connections are additional outbound connections that bitcoind makes since v0.19. They participate in block relay, but do not propagate transactions or addresses. They were introduced in #15759.\r\n\r\nWhen creating an outbound block-relay-only connection, since we know that we're never going to announce transactions over that connection, we can save on memory usage by not a `TxRelay` data structure for that connection. When receiving an inbound connection, we don't know whether the connection was opened by the peer as block-relay-only or not, and therefore we always construct a `TxRelay` data structure for inbound connections.\r\n\r\nHowever, it is possible to tell whether an inbound connection will ever request that we start announcing transactions to it. The `fRelay` field in the `version` message may be set to `0` to indicate that the peer does not wish to receive transaction announcements. The peer may later request that we start announcing transactions to it by sending a `filterload` or `filterclear` message, **but only if we have offered `NODE_BLOOM` services to that peer**. `NODE_BLOOM` services are disabled by default, and it has been recommended for some time that users not enable `NODE_BLOOM` services on public connections, for privacy and anti-DoS reasons.\r\n\r\nTherefore, if we have not offered `NODE_BLOOM` to the peer _and_ it has set `fRelay` to `0`, then we know that it will never request transaction announcements, and that we can save resources by not initializing the `TxRelay` data structure.",
          "user": {
            "login": "jnewbery",
            "id": 1063656,
            "node_id": "MDQ6VXNlcjEwNjM2NTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jnewbery",
            "html_url": "https://github.com/jnewbery",
            "followers_url": "https://api.github.com/users/jnewbery/followers",
            "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
            "organizations_url": "https://api.github.com/users/jnewbery/orgs",
            "repos_url": "https://api.github.com/users/jnewbery/repos",
            "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jnewbery/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 1648013533,
              "node_id": "MDU6TGFiZWwxNjQ4MDEzNTMz",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Review%20club",
              "name": "Review club",
              "description": "",
              "color": "0052cc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 33,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22778",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/22778",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/22778.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/22778.patch"
          },
          "closed_at": "2022-05-19T08:27:39Z",
          "created_at": "2021-08-23T12:20:15Z",
          "updated_at": "2023-06-09T10:05:41Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-09-28T07:08:23Z",
      "updated_at": "2021-09-28T07:08:23Z",
      "source": {
        "issue": {
          "id": 1009368822,
          "node_id": "PR_kwDOABII584sYEd8",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23114",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23114/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23114/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23114/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23114",
          "number": 23114,
          "state": "closed",
          "state_reason": null,
          "title": "Add minisketch subtree and integrate into build/test",
          "body": "This takes over #21859, which has [recently switched](https://github.com/bitcoin/bitcoin/pull/21859#issuecomment-921899200) to my integration branch. A few more build issues came up (and have been fixed) since, and after discussing with sipa it was decided I would open a PR to shepherd any final changes through. \r\n\r\n> This adds a `src/minisketch` subtree, taken from the master branch of https://github.com/sipa/minisketch, to prepare for Erlay implementation (see #21515). It gets configured for just supporting 32-bit fields (the only ones we're interested in in the context of Erlay), and some code on top is added:\r\n> * A very basic unit test (just to make sure compilation & running works; actual correctness checking is done through minisketch's own tests).\r\n> * A wrapper in `minisketchwrapper.{cpp,h}` that runs a benchmark to determine which field implementation to use.\r\n\r\nOnly changes since my last update to the branch in the previous PR have been rebasing on master and fixing an issue with a header in an introduced file.",
          "user": {
            "login": "fanquake",
            "id": 863730,
            "node_id": "MDQ6VXNlcjg2MzczMA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fanquake",
            "html_url": "https://github.com/fanquake",
            "followers_url": "https://api.github.com/users/fanquake/followers",
            "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
            "organizations_url": "https://api.github.com/users/fanquake/orgs",
            "repos_url": "https://api.github.com/users/fanquake/repos",
            "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fanquake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 159815356,
              "node_id": "MDU6TGFiZWwxNTk4MTUzNTY=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Upstream",
              "name": "Upstream",
              "color": "bfd4f2",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/52",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/52",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/52/labels",
            "id": 6179837,
            "node_id": "MDk6TWlsZXN0b25lNjE3OTgzNw==",
            "number": 52,
            "state": "closed",
            "title": "23.0",
            "description": "",
            "creator": {
              "login": "maflcko",
              "id": 6399679,
              "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
              "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/maflcko",
              "html_url": "https://github.com/maflcko",
              "followers_url": "https://api.github.com/users/maflcko/followers",
              "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
              "organizations_url": "https://api.github.com/users/maflcko/orgs",
              "repos_url": "https://api.github.com/users/maflcko/repos",
              "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/maflcko/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 123,
            "created_at": "2020-12-04T08:54:20Z",
            "updated_at": "2022-04-25T20:51:00Z",
            "closed_at": "2022-04-22T18:08:30Z"
          },
          "locked": true,
          "comments": 29,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23114",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23114",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23114.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23114.patch"
          },
          "closed_at": "2021-11-12T02:01:26Z",
          "created_at": "2021-09-28T07:08:22Z",
          "updated_at": "2022-11-12T17:47:03Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-09-29T17:33:35Z",
      "updated_at": "2021-09-29T17:33:35Z",
      "source": {
        "issue": {
          "id": 1010563882,
          "node_id": "PR_kwDOABII584sbmbN",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23126",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23126/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23126/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23126/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23126",
          "number": 23126,
          "state": "closed",
          "state_reason": null,
          "title": "doc: update developer docs for subtree renaming",
          "body": "Update the developer docs after the [recent subtree renaming](https://github.com/bitcoin/bitcoin/pull/22646#issuecomment-921154730).",
          "user": {
            "login": "fanquake",
            "id": 863730,
            "node_id": "MDQ6VXNlcjg2MzczMA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fanquake",
            "html_url": "https://github.com/fanquake",
            "followers_url": "https://api.github.com/users/fanquake/followers",
            "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
            "organizations_url": "https://api.github.com/users/fanquake/orgs",
            "repos_url": "https://api.github.com/users/fanquake/repos",
            "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fanquake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 148216,
              "node_id": "MDU6TGFiZWwxNDgyMTY=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Docs",
              "name": "Docs",
              "color": "02d7e1",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23126",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23126",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23126.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23126.patch"
          },
          "closed_at": "2021-09-30T00:53:07Z",
          "created_at": "2021-09-29T06:53:44Z",
          "updated_at": "2021-10-21T07:19:34Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 5384392064,
      "node_id": "LE_lADOABII584yA-tHzwAAAAFA702A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5384392064",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-09-30T01:33:26Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5573917664,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAFMOzvg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5573917664",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-05T11:45:34Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-05T12:56:20Z",
      "updated_at": "2021-11-05T12:56:20Z",
      "source": {
        "issue": {
          "id": 1045818438,
          "node_id": "PR_kwDOABII584uJavG",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23443",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23443/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23443/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23443/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23443",
          "number": 23443,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: Erlay support signaling",
          "body": "This is a part of the Erlay project:\r\n- [parent PR](https://github.com/bitcoin/bitcoin/pull/21515)\r\n- [associated BIP-330](https://github.com/bitcoin/bips/pull/1376).\r\n\r\n-------\r\n\r\nThis PR adds a new p2p message `sendtxrcncl` signaling for reconciliation support.\r\nBefore sending that message, a node is supposed to \"pre-register\" the peer by generating and storing an associated reconciliation salt component.\r\nOnce the salts are exchanged within this new message, nodes \"register\" each other for future reconciliations by computing and storing the aggregate salt, along with the reconciliation parameters based on the connection direction.",
          "user": {
            "login": "naumenkogs",
            "id": 7975071,
            "node_id": "MDQ6VXNlcjc5NzUwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/naumenkogs",
            "html_url": "https://github.com/naumenkogs",
            "followers_url": "https://api.github.com/users/naumenkogs/followers",
            "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
            "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
            "repos_url": "https://api.github.com/users/naumenkogs/repos",
            "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 33,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23443",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23443",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23443.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23443.patch"
          },
          "closed_at": "2022-10-17T17:11:41Z",
          "created_at": "2021-11-05T12:51:10Z",
          "updated_at": "2022-10-25T00:42:29Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "unlabeled",
      "id": 5574259201,
      "node_id": "UNLE_lADOABII584yA-tHzwAAAAFMQHIB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5574259201",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-05T12:59:08Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-05T20:20:28Z",
      "updated_at": "2021-11-05T20:20:28Z",
      "source": {
        "issue": {
          "id": 1044275962,
          "node_id": "PR_kwDOABII584uElWW",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23437",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23437/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23437/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23437/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23437",
          "number": 23437,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: AcceptToMemoryPool",
          "body": "This PR refactors AcceptToMemoryPool.\r\n\r\n. Remove `AcceptToMemoryPoolWithTime` (after #23173, this function is no longer needed).\r\n. Remove the `CChainParams chainparams` parameter from ATMP as they can be inferred from the current chain state.\r\n. Update the `tx_pool` test with new function signature.",
          "user": {
            "login": "lsilva01",
            "id": 84432093,
            "node_id": "MDQ6VXNlcjg0NDMyMDkz",
            "avatar_url": "https://avatars.githubusercontent.com/u/84432093?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lsilva01",
            "html_url": "https://github.com/lsilva01",
            "followers_url": "https://api.github.com/users/lsilva01/followers",
            "following_url": "https://api.github.com/users/lsilva01/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/lsilva01/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/lsilva01/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/lsilva01/subscriptions",
            "organizations_url": "https://api.github.com/users/lsilva01/orgs",
            "repos_url": "https://api.github.com/users/lsilva01/repos",
            "events_url": "https://api.github.com/users/lsilva01/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/lsilva01/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23437",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23437",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23437.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23437.patch"
          },
          "closed_at": "2021-12-01T16:59:28Z",
          "created_at": "2021-11-04T01:36:49Z",
          "updated_at": "2022-12-02T10:00:42Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-05T21:34:12Z",
      "updated_at": "2021-11-05T21:34:12Z",
      "source": {
        "issue": {
          "id": 1034429640,
          "node_id": "PR_kwDOABII584tlzNr",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23345",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23345/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23345/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23345/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23345",
          "number": 23345,
          "state": "closed",
          "state_reason": null,
          "title": "build: Drop unneeded dependencies for bitcoin-wallet tool",
          "body": "`bitcoin-wallet` is an offline tool, and its code does not depend on networking stuff (ZMQ, UPnP, NAT-PMP, and LIBBITCOIN_SERVER).\r\n\r\nAlso `bitcoin-wallet`  does not interacts with the chainstate, therefore dependency on LevelDB is not needed.",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23345",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23345",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23345.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23345.patch"
          },
          "closed_at": "2021-11-15T15:30:11Z",
          "created_at": "2021-10-24T14:25:28Z",
          "updated_at": "2023-01-12T10:07:32Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-05T22:09:27Z",
      "updated_at": "2021-11-05T22:09:27Z",
      "source": {
        "issue": {
          "id": 1021384855,
          "node_id": "PR_kwDOABII584s9UYg",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23233",
          "number": 23233,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Add encrypted p2p transport {de}serializer",
          "body": "Revives #18242. Depends on #25361 (please review that first, the last 4 commits are to be reviewed here).\r\n\r\nThis PR adds a p2p message transport {de}serializer for encrypted packets leveraging the BIP324 specification.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 34,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23233",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23233",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23233.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23233.patch"
          },
          "closed_at": "2023-05-06T11:11:30Z",
          "created_at": "2021-10-08T19:01:33Z",
          "updated_at": "2023-05-06T11:11:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-05T22:30:40Z",
      "updated_at": "2021-11-05T22:30:40Z",
      "source": {
        "issue": {
          "id": 1015179519,
          "node_id": "PR_kwDOABII584so9va",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23173",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23173/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23173/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23173/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23173",
          "number": 23173,
          "state": "closed",
          "state_reason": null,
          "title": "Add `ChainstateManager::ProcessTransaction`",
          "body": "Similarly to how #18698 added `ProcessNewBlock()` and `ProcessNewBlockHeaders()` methods to the `ChainstateManager` class, this PR adds a new `ProcessTransaction()` method. Code outside validation no longer calls `AcceptToMemoryPool()` directly, but calls through the higher-level `ProcessTransaction()` method. Advantages:\r\n\r\n- The interface is simplified. Calling code no longer needs to know about the active chainstate or mempool object, since `AcceptToMemoryPool()` can only ever be called for the active chainstate, and that chainstate knows which mempool it's using. We can also remove the `bypass_limits` argument, since that can only be used internally in validation.\r\n- responsibility for calling `CTxMemPool::check()` is removed from the callers, and run automatically by `ChainstateManager` every time `ProcessTransaction()` is called.",
          "user": {
            "login": "jnewbery",
            "id": 1063656,
            "node_id": "MDQ6VXNlcjEwNjM2NTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jnewbery",
            "html_url": "https://github.com/jnewbery",
            "followers_url": "https://api.github.com/users/jnewbery/followers",
            "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
            "organizations_url": "https://api.github.com/users/jnewbery/orgs",
            "repos_url": "https://api.github.com/users/jnewbery/repos",
            "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jnewbery/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 10,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23173",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23173",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23173.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23173.patch"
          },
          "closed_at": "2021-11-10T13:37:02Z",
          "created_at": "2021-10-04T13:23:59Z",
          "updated_at": "2022-11-10T17:38:15Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-06T10:12:11Z",
      "updated_at": "2021-11-06T10:12:11Z",
      "source": {
        "issue": {
          "id": 1046261062,
          "node_id": "PR_kwDOABII584uK3td",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23448",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23448/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23448/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23448/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23448",
          "number": 23448,
          "state": "closed",
          "state_reason": null,
          "title": "refactor, consensus: remove calls to global `Params()` in validation layer",
          "body": "This PR removes calls to global `Params()` in validation layer (except in the `CChainState` constructor).\r\n\r\nMotivation: Reducing the use of global variables makes code more predictable. \r\n\r\nRequires #23437 as it changes the visibility of `CChainState::m_params` to public.",
          "user": {
            "login": "lsilva01",
            "id": 84432093,
            "node_id": "MDQ6VXNlcjg0NDMyMDkz",
            "avatar_url": "https://avatars.githubusercontent.com/u/84432093?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lsilva01",
            "html_url": "https://github.com/lsilva01",
            "followers_url": "https://api.github.com/users/lsilva01/followers",
            "following_url": "https://api.github.com/users/lsilva01/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/lsilva01/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/lsilva01/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/lsilva01/subscriptions",
            "organizations_url": "https://api.github.com/users/lsilva01/orgs",
            "repos_url": "https://api.github.com/users/lsilva01/repos",
            "events_url": "https://api.github.com/users/lsilva01/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/lsilva01/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23448",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23448",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23448.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23448.patch"
          },
          "closed_at": "2022-06-14T08:31:50Z",
          "created_at": "2021-11-05T21:36:27Z",
          "updated_at": "2023-06-14T10:06:21Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-08T05:01:35Z",
      "updated_at": "2021-11-08T05:01:35Z",
      "source": {
        "issue": {
          "id": 1047014111,
          "node_id": "PR_kwDOABII584uNF84",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23465",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23465/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23465/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23465/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23465",
          "number": 23465,
          "state": "closed",
          "state_reason": null,
          "title": "Remove CTxMemPool params from ATMP ",
          "body": "Remove `CTxMemPool` parameter from `AcceptToMemoryPool` function, as suggested in https://github.com/bitcoin/bitcoin/pull/23437#issuecomment-962536149 .\r\n\r\nThis requires that `CChainState` has access to `MockedTxPool` in  `tx_pool.cpp` as mentioned https://github.com/bitcoin/bitcoin/pull/23173#discussion_r731895386. So the `MockedTxPool` is attributed to `CChainState::m_mempool` before calling `AcceptToMemoryPool`.\r\n\r\nRequires #23437.",
          "user": {
            "login": "lsilva01",
            "id": 84432093,
            "node_id": "MDQ6VXNlcjg0NDMyMDkz",
            "avatar_url": "https://avatars.githubusercontent.com/u/84432093?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/lsilva01",
            "html_url": "https://github.com/lsilva01",
            "followers_url": "https://api.github.com/users/lsilva01/followers",
            "following_url": "https://api.github.com/users/lsilva01/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/lsilva01/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/lsilva01/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/lsilva01/subscriptions",
            "organizations_url": "https://api.github.com/users/lsilva01/orgs",
            "repos_url": "https://api.github.com/users/lsilva01/repos",
            "events_url": "https://api.github.com/users/lsilva01/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/lsilva01/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 5,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23465",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23465",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23465.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23465.patch"
          },
          "closed_at": "2021-12-08T09:02:18Z",
          "created_at": "2021-11-08T04:43:37Z",
          "updated_at": "2022-12-08T10:01:54Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-08T05:08:36Z",
      "updated_at": "2021-11-08T05:08:36Z",
      "source": {
        "issue": {
          "id": 1046803918,
          "node_id": "PR_kwDOABII584uMco4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23462",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23462/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23462/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23462/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23462",
          "number": 23462,
          "state": "closed",
          "state_reason": null,
          "title": "test: Enable SC2046 and SC2086 shellcheck rules",
          "body": "Closes #20879.\r\nReplaces #22695.\r\n\r\n**Note for reviewers**. Some touched shell scripts are not being run in CI, therefore they require more thorough reviewing:\r\n- `contrib/devtools/gen-manpages.sh`\r\n- `contrib/macdeploy/detached-sig-apply.sh`\r\n- `contrib/windeploy/detached-sig-create.sh`\r\n- `src/qt/res/animation/makespinner.sh`",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 231994551,
              "node_id": "MDU6TGFiZWwyMzE5OTQ1NTE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Scripts%20and%20tools",
              "name": "Scripts and tools",
              "color": "ffffee",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23462",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23462",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23462.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23462.patch"
          },
          "closed_at": "2021-11-15T15:23:26Z",
          "created_at": "2021-11-07T17:27:03Z",
          "updated_at": "2022-11-15T13:10:31Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-10T03:12:10Z",
      "updated_at": "2021-11-10T03:12:10Z",
      "source": {
        "issue": {
          "id": 1048264560,
          "node_id": "PR_kwDOABII584uRKR6",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23473",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23473/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23473/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23473/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23473",
          "number": 23473,
          "state": "closed",
          "state_reason": null,
          "title": "build: boring autotools cleanup",
          "body": "This is mostly just being consistent with how we do things, and migrating towards a style (we have already been doing so ad-hoc) that is clearer for anyone who cares to read `.m4`. For example:\r\n\r\n`master`:\r\n```m4\r\n  AX_CHECK_COMPILE_FLAG(\r\n    [-g3],\r\n    [[DEBUG_CXXFLAGS=\"$DEBUG_CXXFLAGS -g3\"]],\r\n    [AX_CHECK_COMPILE_FLAG([-g],[[DEBUG_CXXFLAGS=\"$DEBUG_CXXFLAGS -g\"]],,[[$CXXFLAG_WERROR]])],\r\n    [[$CXXFLAG_WERROR]])\r\n```\r\n\r\nThis PR:\r\n```m4\r\n  AX_CHECK_COMPILE_FLAG(\r\n    [-g3],\r\n    [DEBUG_CXXFLAGS=\"$DEBUG_CXXFLAGS -g3\"],\r\n    [AX_CHECK_COMPILE_FLAG([-g], [DEBUG_CXXFLAGS=\"$DEBUG_CXXFLAGS -g\"], [], [$CXXFLAG_WERROR])],\r\n    [$CXXFLAG_WERROR])\r\n```\r\n\r\nDrop unneeded double-quoting (which we use inconsistently), use `[]` for empty arguments, space things out.\r\n\r\nThere should be no functional change, before & after binaries identical. Very boring.\r\n\r\nGuix build:\r\n```bash\r\nbash-5.1# find guix-build-$(git rev-parse --short=12 HEAD)/output/ -type f -print0 | env LC_ALL=C sort -z | xargs -r0 sha256sum\r\n22097cd621cd88348f827b916f4b4b120b40c3515a3752595347e36d57dc9158  guix-build-34094aff1348/output/aarch64-linux-gnu/SHA256SUMS.part\r\n43f10bb857afa7ea52a8ed9beed36ff0e3ee02dba31100fc04c8e0b2443d94eb  guix-build-34094aff1348/output/aarch64-linux-gnu/bitcoin-34094aff1348-aarch64-linux-gnu-debug.tar.gz\r\n9095a8228376094065103f4adc9cdcb8189111fb9536ad88e4f8cecc3df6fc75  guix-build-34094aff1348/output/aarch64-linux-gnu/bitcoin-34094aff1348-aarch64-linux-gnu.tar.gz\r\n9c73179059c6fe1f7643445ec5a530003fc41187aa0a94cb1f5c106097161e5b  guix-build-34094aff1348/output/arm-linux-gnueabihf/SHA256SUMS.part\r\n70ddd4dd0a06c7491937084125f690c1d62fa2647c16048fc1a4a9a09d8b10b4  guix-build-34094aff1348/output/arm-linux-gnueabihf/bitcoin-34094aff1348-arm-linux-gnueabihf-debug.tar.gz\r\n0a338fdc9788c33a0d519b6c09fdf6271e3bd68846ee61eef0a06a2df6bab419  guix-build-34094aff1348/output/arm-linux-gnueabihf/bitcoin-34094aff1348-arm-linux-gnueabihf.tar.gz\r\n25eda7fae2984b9dadf47420d1dc09b0224d425144233482602bd9e6d348255c  guix-build-34094aff1348/output/dist-archive/bitcoin-34094aff1348.tar.gz\r\nd70d84e43ffa2d809063cda868f708539e9114b2d14edb6ddcf05fdf73f3187b  guix-build-34094aff1348/output/powerpc64-linux-gnu/SHA256SUMS.part\r\n8d1291e576d2b5f8f7120fe6e6ed4b23415249e22a657a350ccce68ff261e088  guix-build-34094aff1348/output/powerpc64-linux-gnu/bitcoin-34094aff1348-powerpc64-linux-gnu-debug.tar.gz\r\neab448186aee18ac33c39eed4d24501208d10d257fe6e2739adf589b1d4b693a  guix-build-34094aff1348/output/powerpc64-linux-gnu/bitcoin-34094aff1348-powerpc64-linux-gnu.tar.gz\r\n4d28617b4d0ddb88c8b20d06ca21314ee40814043f92cabcd9ea3e3d8ee39183  guix-build-34094aff1348/output/powerpc64le-linux-gnu/SHA256SUMS.part\r\ndea02168e170e92600012f5806ec8b39209282c2270669f2040682f74bc3f320  guix-build-34094aff1348/output/powerpc64le-linux-gnu/bitcoin-34094aff1348-powerpc64le-linux-gnu-debug.tar.gz\r\nc7122e89d3186a183ac08e7f3020654722c98bf8acc8b790bb292b39f5ba8225  guix-build-34094aff1348/output/powerpc64le-linux-gnu/bitcoin-34094aff1348-powerpc64le-linux-gnu.tar.gz\r\n0802a52720d2bec1264dc13f6554a9da347baa3d096242b29bb524f4b121eb10  guix-build-34094aff1348/output/riscv64-linux-gnu/SHA256SUMS.part\r\n4aee9fc41f35d2adb2d0562902dd8584a8413a73c015ddcdcef00586779f63a7  guix-build-34094aff1348/output/riscv64-linux-gnu/bitcoin-34094aff1348-riscv64-linux-gnu-debug.tar.gz\r\n3f0c4d6096ac7e08389e851c2d252632c044a700ce0174473ac4d7f66290e8cc  guix-build-34094aff1348/output/riscv64-linux-gnu/bitcoin-34094aff1348-riscv64-linux-gnu.tar.gz\r\nc5149c46b9b7081d5715daf3e22fd30ffca23d333f664da1fabc8143ff8bf76c  guix-build-34094aff1348/output/x86_64-apple-darwin19/SHA256SUMS.part\r\n81848355751e55a8a60636e3ea2f03ca6abb78736a5431715cd51cebd46bb961  guix-build-34094aff1348/output/x86_64-apple-darwin19/bitcoin-34094aff1348-osx-unsigned.dmg\r\nd2f6f689cbedddd865f90dba9ddf21479c71c61b0350fda62804b2f233116a43  guix-build-34094aff1348/output/x86_64-apple-darwin19/bitcoin-34094aff1348-osx-unsigned.tar.gz\r\n99d8fe428fcb67f9975e6b8d9a63d84946215a0a6b8f94967ce96cc3af4b7772  guix-build-34094aff1348/output/x86_64-apple-darwin19/bitcoin-34094aff1348-osx64.tar.gz\r\n3dac13c7556d9a25ff5513bbb2638fe4fa74d8a88304bbdce52364df7832a3ab  guix-build-34094aff1348/output/x86_64-linux-gnu/SHA256SUMS.part\r\ne4baa7da80fdabbb50953efaaa7b4867c7e575a7a156b728e8e197142df55697  guix-build-34094aff1348/output/x86_64-linux-gnu/bitcoin-34094aff1348-x86_64-linux-gnu-debug.tar.gz\r\nf82f5bcc7197c1741b106f62be7b468aadbdf5b3198091582026cd450bf13b3a  guix-build-34094aff1348/output/x86_64-linux-gnu/bitcoin-34094aff1348-x86_64-linux-gnu.tar.gz\r\ndb22b5f48783917f985920ddb26aa170b4d6cc65112406548847a883099505b8  guix-build-34094aff1348/output/x86_64-w64-mingw32/SHA256SUMS.part\r\nead0809193ca1d462553a6f3f233cdbff7a3f8419100d825abfc10835508e485  guix-build-34094aff1348/output/x86_64-w64-mingw32/bitcoin-34094aff1348-win-unsigned.tar.gz\r\ne1006b6c114eaf33274144d8e9a20abc0cee01e26a4594063ee615bf09c1b344  guix-build-34094aff1348/output/x86_64-w64-mingw32/bitcoin-34094aff1348-win64-debug.zip\r\n2d3fbc593b58d353a6859e02c0dd096d453cf5f1e3150c2a1c234bdfc97b4f24  guix-build-34094aff1348/output/x86_64-w64-mingw32/bitcoin-34094aff1348-win64-setup-unsigned.exe\r\n25cfa8a3655727572593f100b7a70c1061fa6f3b017014ad7444059611c3ddda  guix-build-34094aff1348/output/x86_64-w64-mingw32/bitcoin-34094aff1348-win64.zip\r\n```",
          "user": {
            "login": "fanquake",
            "id": 863730,
            "node_id": "MDQ6VXNlcjg2MzczMA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fanquake",
            "html_url": "https://github.com/fanquake",
            "followers_url": "https://api.github.com/users/fanquake/followers",
            "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
            "organizations_url": "https://api.github.com/users/fanquake/orgs",
            "repos_url": "https://api.github.com/users/fanquake/repos",
            "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fanquake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 13,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23473",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23473",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23473.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23473.patch"
          },
          "closed_at": "2021-11-12T23:12:58Z",
          "created_at": "2021-11-09T07:13:38Z",
          "updated_at": "2022-11-12T17:47:02Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 5597240144,
      "node_id": "LE_lADOABII584yA-tHzwAAAAFNnxtQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5597240144",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-10T13:59:18Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "referenced",
      "id": 5607042362,
      "node_id": "REFE_lADOABII584yA-tHzwAAAAFONK06",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5607042362",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "c1fb30633b6dcbf32db7d53c9f538019af80d6c5",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1fb30633b6dcbf32db7d53c9f538019af80d6c5",
      "created_at": "2021-11-12T02:01:14Z"
    },
    {
      "event": "commented",
      "id": 967011885,
      "node_id": "IC_kwDOABII5845o24t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/967011885",
      "actor": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-12T10:59:53Z",
      "updated_at": "2021-11-12T10:59:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "Minisketch is merged! Please rebase :)",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-967011885",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "commented",
      "id": 967016604,
      "node_id": "IC_kwDOABII5845o4Cc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/967016604",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-12T11:07:10Z",
      "updated_at": "2021-11-12T11:07:10Z",
      "author_association": "MEMBER",
      "body": "#23491 will conflict with this pull after rebase. Let me know if this acceptable or if you prefer to defer 23491 until after all other changes are merged.",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-967016604",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "referenced",
      "id": 5623100249,
      "node_id": "REFE_lADOABII584yA-tHzwAAAAFPKbNZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5623100249",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "d0923098c69233414a9c284d707e31e2d4f91e8e",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0923098c69233414a9c284d707e31e2d4f91e8e",
      "created_at": "2021-11-16T08:09:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5632339150,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAFPtqzO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5632339150",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-17T14:36:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5632562318,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAFPuhSO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5632562318",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-17T15:08:18Z"
    },
    {
      "event": "unlabeled",
      "id": 5632882951,
      "node_id": "UNLE_lADOABII584yA-tHzwAAAAFPvvkH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5632882951",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-17T15:53:58Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 979209269,
      "node_id": "IC_kwDOABII5846XYw1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/979209269",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-25T13:20:02Z",
      "updated_at": "2021-11-25T13:20:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "what is the 2021-11-erlay1 branch please? confused as it looks more recent (from the name) but this one is also getting updated.",
      "user": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-979209269",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "commented",
      "id": 979436224,
      "node_id": "IC_kwDOABII5846YQLA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/979436224",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-25T19:26:48Z",
      "updated_at": "2021-11-25T19:26:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "This does not compile:-\r\n\r\n```\r\n8d4354499f39a49bbb8675494c532802ef034b03 is the first bad commit\r\ncommit 8d4354499f39a49bbb8675494c532802ef034b03\r\nAuthor: Gleb Naumenko <naumenko.gs@gmail.com>\r\nDate:   Sat Mar 20 17:36:08 2021 +0200\r\n\r\n    Respond to a reconciliation request\r\n\r\n    When the time comes, we should send a sketch of our\r\n    local reconciliation set to the reconciliation initiator.\r\n\r\n src/net_processing.cpp   | 15 +++++++++++++++\r\n src/protocol.cpp         |  2 ++\r\n src/protocol.h           |  6 ++++++\r\n src/txreconciliation.cpp | 50 +++++++++++++++++++++++++++++++++++++++++++++++-\r\n src/txreconciliation.h   |  8 ++++++++\r\n 5 files changed, 80 insertions(+), 1 deletion(-)\r\n8d4354499f39a49bbb8675494c532802ef034b03 is the first bad commit\r\n```",
      "user": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-979436224",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "commented",
      "id": 981466935,
      "node_id": "IC_kwDOABII5846f_83",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/981466935",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-29T09:53:43Z",
      "updated_at": "2021-11-29T09:53:43Z",
      "author_association": "MEMBER",
      "body": "@rebroad hey\r\n\r\n>what is the 2021-11-erlay1 branch please? confused as it looks more recent (from the name) but this one is also getting updated.\r\n\r\nThat branch is a first batch of this PR commits, forked to be merged separately within [that PR](https://github.com/bitcoin/bitcoin/pull/23443).\r\nI try to keep the OP PR up-to-date with that one, but also not too often to avoid too many notifications here.\r\n\r\n>8d4354499f39a49bbb8675494c532802ef034b03 is the first bad commit\r\n\r\nYeah I somehow can't reproduce CI compiler errors neither on my mac nor on my linux, are you referring to those as well? Or can you share your compilation output?",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981466935",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "mentioned",
      "id": 5683703668,
      "node_id": "MEE_lADOABII584yA-tHzwAAAAFSxm90",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5683703668",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-29T09:53:44Z"
    },
    {
      "event": "subscribed",
      "id": 5683703677,
      "node_id": "SE_lADOABII584yA-tHzwAAAAFSxm99",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5683703677",
      "actor": {
        "login": "rebroad",
        "id": 1530283,
        "node_id": "MDQ6VXNlcjE1MzAyODM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rebroad",
        "html_url": "https://github.com/rebroad",
        "followers_url": "https://api.github.com/users/rebroad/followers",
        "following_url": "https://api.github.com/users/rebroad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rebroad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rebroad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
        "organizations_url": "https://api.github.com/users/rebroad/orgs",
        "repos_url": "https://api.github.com/users/rebroad/repos",
        "events_url": "https://api.github.com/users/rebroad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rebroad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-29T09:53:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5684515853,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAFS0tQN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5684515853",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-29T12:17:00Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5684866294,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAFS2Cz2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5684866294",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-29T13:18:53Z"
    },
    {
      "event": "commented",
      "id": 981672502,
      "node_id": "IC_kwDOABII5846gyI2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/981672502",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-29T14:13:21Z",
      "updated_at": "2021-11-29T14:13:21Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, thanks for splitting the big PR up :) Will review soon.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981672502",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "commented",
      "id": 981712350,
      "node_id": "IC_kwDOABII5846g73e",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/981712350",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-11-29T14:57:40Z",
      "updated_at": "2021-11-29T14:57:40Z",
      "author_association": "MEMBER",
      "body": "Fixing new CI issues here, for now please review the first batch separately [here](https://github.com/bitcoin/bitcoin/pull/23443) :)",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981712350",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 5698995963,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAFTr8b7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5698995963",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-12-01T13:25:30Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-12-06T22:24:49Z",
      "updated_at": "2021-12-06T22:24:49Z",
      "source": {
        "issue": {
          "id": 1072682689,
          "node_id": "PR_kwDOFolFdc4vd0XA",
          "url": "https://api.github.com/repos/naumenkogs/txrelaysim/issues/9",
          "repository_url": "https://api.github.com/repos/naumenkogs/txrelaysim",
          "labels_url": "https://api.github.com/repos/naumenkogs/txrelaysim/issues/9/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/naumenkogs/txrelaysim/issues/9/comments",
          "events_url": "https://api.github.com/repos/naumenkogs/txrelaysim/issues/9/events",
          "html_url": "https://github.com/naumenkogs/txrelaysim/pull/9",
          "number": 9,
          "state": "closed",
          "state_reason": null,
          "title": "Use correct capacity estimator function",
          "body": "The estimator function used in the simulation is different to the one described in the Erlay paper and the one used in the [Bitcoin Core PR](https://github.com/bitcoin/bitcoin/pull/21515).\r\n\r\n`capacity=|set_size - local_set_size| + q * (set_size + local_set_size) + 1` (currently used in the sim)\r\nvs.\r\n`capacity=|set_size - local_set_size| + q * min(set_size, local_set_size) + 1` (From the paper)\r\n\r\nI am not sure how much this affects the results of the simulation, but the current function does overestimate when compared to the `min` version.\r\n\r\n(i did not test this code change)",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 3,
          "pull_request": {
            "url": "https://api.github.com/repos/naumenkogs/txrelaysim/pulls/9",
            "html_url": "https://github.com/naumenkogs/txrelaysim/pull/9",
            "diff_url": "https://github.com/naumenkogs/txrelaysim/pull/9.diff",
            "patch_url": "https://github.com/naumenkogs/txrelaysim/pull/9.patch"
          },
          "closed_at": "2022-01-25T08:34:42Z",
          "created_at": "2021-12-06T22:24:48Z",
          "updated_at": "2022-01-25T08:34:43Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-12-21T19:52:01Z",
      "updated_at": "2021-12-21T19:52:01Z",
      "source": {
        "issue": {
          "id": 1085765463,
          "node_id": "PR_kwDOABII584wISCX",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23832",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23832/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23832/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23832/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23832",
          "number": 23832,
          "state": "closed",
          "state_reason": null,
          "title": "Refactor: Changes time variables from int to chrono",
          "body": "This PR is a follow-up to #23801.\r\nThis PR aims to make the following changes to all the time variables in **net_processing.cpp** wherever possible.\r\n\r\n- Convert all time variables to `std::chrono.`\r\n- Use `chorno::literals` wherever possible.\r\n- Use `auto` keywords wherever possible.\r\n- Use `var{val}` convention of initialization.\r\n\r\nThis PR also minimizes the number of times, serialization of time `count_seconds(..)` occurs.\r\n",
          "user": {
            "login": "shaavan",
            "id": 85434418,
            "node_id": "MDQ6VXNlcjg1NDM0NDE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/85434418?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/shaavan",
            "html_url": "https://github.com/shaavan",
            "followers_url": "https://api.github.com/users/shaavan/followers",
            "following_url": "https://api.github.com/users/shaavan/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/shaavan/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/shaavan/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/shaavan/subscriptions",
            "organizations_url": "https://api.github.com/users/shaavan/orgs",
            "repos_url": "https://api.github.com/users/shaavan/repos",
            "events_url": "https://api.github.com/users/shaavan/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/shaavan/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 5,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23832",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23832",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23832.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23832.patch"
          },
          "closed_at": "2022-01-06T12:39:21Z",
          "created_at": "2021-12-21T12:08:51Z",
          "updated_at": "2023-01-06T10:06:44Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-01-05T15:59:25Z",
      "updated_at": "2022-01-05T15:59:25Z",
      "source": {
        "issue": {
          "id": 771452944,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTQyOTc3MTM4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20726",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20726/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20726/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20726/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20726",
          "number": 20726,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: Add DISABLETX message for negotiating block-relay-only connections",
          "body": "Implement BIP 338.\r\n\r\nWhen we initiate a block-relay-only connection today, our peer doesn't know that we won't send transactions ourselves, or even that we won't try to turn on transaction relay at some later point during the connection's lifetime.\r\n\r\nThis PR adds a new p2p message, DISABLETX, to be sent between VERSION and VERACK so that peers can signal to each other that they only want blocks/compactblocks/headers to be sent on the link, and not transaction-relay traffic (or addr messages, unless otherwise indicated).",
          "user": {
            "login": "sdaftuar",
            "id": 7463573,
            "node_id": "MDQ6VXNlcjc0NjM1NzM=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sdaftuar",
            "html_url": "https://github.com/sdaftuar",
            "followers_url": "https://api.github.com/users/sdaftuar/followers",
            "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
            "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
            "repos_url": "https://api.github.com/users/sdaftuar/repos",
            "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 55,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20726",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20726",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20726.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20726.patch"
          },
          "closed_at": "2022-05-19T12:47:00Z",
          "created_at": "2020-12-19T20:55:36Z",
          "updated_at": "2023-05-19T10:02:28Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 5852483428,
      "node_id": "LE_lADOABII584yA-tHzwAAAAFc1c9k",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5852483428",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-01-06T14:14:16Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-01-19T10:43:15Z",
      "updated_at": "2022-01-19T10:43:15Z",
      "source": {
        "issue": {
          "id": 974908690,
          "node_id": "MDU6SXNzdWU5NzQ5MDg2OTA=",
          "url": "https://api.github.com/repos/naumenkogs/txrelaysim/issues/8",
          "repository_url": "https://api.github.com/repos/naumenkogs/txrelaysim",
          "labels_url": "https://api.github.com/repos/naumenkogs/txrelaysim/issues/8/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/naumenkogs/txrelaysim/issues/8/comments",
          "events_url": "https://api.github.com/repos/naumenkogs/txrelaysim/issues/8/events",
          "html_url": "https://github.com/naumenkogs/txrelaysim/issues/8",
          "number": 8,
          "state": "open",
          "state_reason": null,
          "title": "Erlay meta-issue: mainnet testing",
          "body": "Based on the experimental results from #7, I currently suggest using [the following patch](https://github.com/naumenkogs/bitcoin/tree/2021-03-erlay) for testing. I currently run 12 Erlay-supporting nodes running that patch.\r\n\r\nTo test Erlay, you can connect to my nodes with the following bitcoind CLI option: `-maxconnections=0 -addnode=143.198.185.21:8201 -addnode=143.198.185.21:8202 -addnode=143.198.185.21:8203 -addnode=143.198.185.21:8204 -addnode=143.198.185.21:8205 -addnode=143.198.185.21:8206 -addnode=143.198.185.21:8207 -addnode=143.198.185.21:8208`. I might be restarting those nodes from time to time, so expect that.\r\n\r\nMy nodes are currently pruned, so please sync from the network first, and restart with the command above only when you're at the tip.\r\n\r\nThen, you can use a similar to mine command to see your own node's bandwidth: `bitcoin-0.21.1/bin/bitcoin-cli -rpcport=8109  getpeerinfo | grep 'inv\\|sketch\\|reqrecon\\|reqsketchext\\|reconcildiff' | awk '/[0-9]+/ {gsub(/[^0-9]/, \"\", $0); sum+=$0} END {print sum}'`.\r\n\r\nYou can compare this number to the regular pre-Erlay Bitcoin node of the latest release running in parallel to the Erlay node.\r\nThe expected result is around 30-55% saving, or 15-30% of bandwidth saved overall.",
          "user": {
            "login": "naumenkogs",
            "id": 7975071,
            "node_id": "MDQ6VXNlcjc5NzUwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/naumenkogs",
            "html_url": "https://github.com/naumenkogs",
            "followers_url": "https://api.github.com/users/naumenkogs/followers",
            "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
            "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
            "repos_url": "https://api.github.com/users/naumenkogs/repos",
            "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "OWNER",
          "locked": false,
          "comments": 14,
          "created_at": "2021-08-19T17:53:24Z",
          "updated_at": "2022-01-21T20:28:48Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 880981819,
      "node_id": "PRR_kwDOABII5840grc7",
      "url": null,
      "actor": null,
      "commit_id": "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-880981819",
      "submitted_at": "2022-02-13T13:27:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "reviewed",
      "id": 965341350,
      "node_id": "PRR_kwDOABII5845ifCm",
      "url": null,
      "actor": null,
      "commit_id": "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Here is a rebase of the pull at https://github.com/jonatack/bitcoin/commits/erlay-PR21515-rebase, if helpful. It may be good to keep this parent PR up to date to provide an overall view of the proposed changes. At first glance it also looks like there are some changes in #23443 that are not present here.\r\n\r\nDue to the net_processing renamings and refactoring changes in the interim, there were quite a few updates and some silent merge conflicts that only show up when building each commit, so please reverify: `git range-diff 59ac8ba 5728fac 9d93cbe`\r\n\r\nDoing this helped become acquainted with the changes. Next will begin review of #23443.\r\n\r\nIndependently of the rebase, most of the commits have one or several build `-Wunused-function` warnings and re-organizing is needed to add functions in the same commit where they are first used (which facilitates review as well). In order:\r\n\r\nBeginning with commit \"Add helper to compute reconciliation salt\":\r\n\r\n```\r\ntxreconciliation.cpp:21:16: warning: unused function 'ComputeSalt' [-Wunused-function]\r\nstatic uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\r\n               ^\r\n1 warning generated.\r\n```\r\n\r\nBeginning with commit \"Add helper to store transactions in recon set\":\r\n```\r\ntxreconciliation.cpp:40:10: warning: unused member function 'Clear' [-Wunused-member-function]\r\n    void Clear() {\r\n         ^\r\n1 warning generated.\r\n```\r\n\r\nBeginning with commit \"Add helper to see whether we should respond to recon request\":\r\n\r\n```\r\ntxreconciliation.cpp:77:10: warning: unused member function 'Clear' [-Wunused-member-function]\r\n    void Clear() {\r\n         ^\r\ntxreconciliation.cpp:118:10: warning: unused member function 'ConsiderInitResponseAndTrack' [-Wunused-member-function]\r\n    bool ConsiderInitResponseAndTrack() {\r\n         ^\r\n2 warnings generated.\r\n```\r\n\r\nBeginning with commit \"Add helper to compute reconciliation tx short id\":\r\n\r\n```\r\ntxreconciliation.cpp:77:10: warning: unused member function 'Clear' [-Wunused-member-function]\r\n    void Clear() {\r\n         ^\r\ntxreconciliation.cpp:118:10: warning: unused member function 'ConsiderInitResponseAndTrack' [-Wunused-member-function]\r\n    bool ConsiderInitResponseAndTrack() {\r\n         ^\r\ntxreconciliation.cpp:172:14: warning: unused member function 'ComputeShortID' [-Wunused-member-function]\r\n    uint32_t ComputeShortID(const uint256 wtxid) const\r\n             ^\r\n3 warnings generated.\r\n```\r\n\r\nBeginning with commit \"Add helper to compute sketches for tx reconciliation\":\r\n\r\n```\r\ntxreconciliation.cpp:103:10: error: unused member function 'Clear' [-Werror,-Wunused-member-function]\r\n    void Clear() {\r\n         ^\r\ntxreconciliation.cpp:145:10: error: unused member function 'ConsiderInitResponseAndTrack' [-Werror,-Wunused-member-function]\r\n    bool ConsiderInitResponseAndTrack() {\r\n         ^\r\ntxreconciliation.cpp:161:14: error: unused member function 'EstimateSketchCapacity' [-Werror,-Wunused-member-function]\r\n    uint32_t EstimateSketchCapacity(size_t local_set_size) const\r\n             ^\r\ntxreconciliation.cpp:224:16: error: unused member function 'ComputeSketch' [-Werror,-Wunused-member-function]\r\n    Minisketch ComputeSketch(uint32_t& capacity)               ^\r\n```\r\n\r\nBeginning with commit \"Add a function to identify local/remote missing txs\":\r\n\r\n```\r\ntxreconciliation.cpp:108:10: error: unused member function 'GetRelevantIDsFromShortIDs' [-Werror,-Wunused-member-function]\r\n    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\r\n         ^\r\n```\r\n\r\nBeginning with commit \"Add a function to announce transactions after reconciliation\":\r\n\r\n```\r\nnet_processing.cpp:2640:23: error: unused member function 'AnnounceTxs' [-Werror,-Wunused-member-function]\r\nvoid PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\r\n                      ^\r\n1 error generated.\r\n```\r\n\r\nBeginning with commit \"Be ready to receive sketch extension\":\r\n\r\n```\r\n  CXX      libbitcoin_node_a-validation.o\r\ntxreconciliation.cpp:304:16: warning: unused member function 'ComputeExtendedSketch' [-Wunused-member-function]\r\n    Minisketch ComputeExtendedSketch(uint32_t extended_capacity)\r\n               ^\r\n1 warning generated.\r\n```\r\n\r\nBeginning with commit \"Add a function to get wtxids by shortids\":\r\n\r\n```\r\ntxreconciliation.cpp:137:26: warning: unused member function 'GetWTXIDsFromShortIDs' [-Wunused-member-function]\r\n    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\r\n                         ^\r\n1 warning generated.\r\n```\r\n",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-965341350",
      "submitted_at": "2022-05-07T16:00:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6590379415,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAGI0TWX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6590379415",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-11T13:25:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6590453426,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAGI0lay",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6590453426",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-11T13:34:34Z"
    },
    {
      "event": "unlabeled",
      "id": 6590651797,
      "node_id": "UNLE_lADOABII584yA-tHzwAAAAGI1V2V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6590651797",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-11T13:57:56Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6595319544,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAGJHJb4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6595319544",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-12T05:50:42Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-12T07:50:55Z",
      "updated_at": "2022-05-12T07:50:55Z",
      "source": {
        "issue": {
          "id": 1230994817,
          "node_id": "PR_kwDOABII5843kXfc",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25101",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25101/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25101/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25101/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25101",
          "number": 25101,
          "state": "closed",
          "state_reason": null,
          "title": "Add mockable clock type",
          "body": "This will be used primarily by the addr time refactor (https://github.com/bitcoin/bitcoin/pull/24697) to make addr relay time type safe. However, it can also be used in other places, and can be reviewed independently, so I split it up.",
          "user": {
            "login": "maflcko",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/maflcko",
            "html_url": "https://github.com/maflcko",
            "followers_url": "https://api.github.com/users/maflcko/followers",
            "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
            "organizations_url": "https://api.github.com/users/maflcko/orgs",
            "repos_url": "https://api.github.com/users/maflcko/repos",
            "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/maflcko/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 6,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25101",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25101",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25101.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25101.patch"
          },
          "closed_at": "2022-05-20T06:48:23Z",
          "created_at": "2022-05-10T11:10:51Z",
          "updated_at": "2023-05-20T10:02:37Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6596065743,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAGJJ_nP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6596065743",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-12T08:05:49Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-12T11:36:25Z",
      "updated_at": "2022-05-12T11:36:25Z",
      "source": {
        "issue": {
          "id": 1214474312,
          "node_id": "PR_kwDOABII5842uX-4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24974",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24974/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24974/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24974/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24974",
          "number": 24974,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: Make FEELER_SLEEP_WINDOW type safe (std::chrono)",
          "body": "This gets rid of the `value*1000` manual conversion.",
          "user": {
            "login": "maflcko",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/maflcko",
            "html_url": "https://github.com/maflcko",
            "followers_url": "https://api.github.com/users/maflcko/followers",
            "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
            "organizations_url": "https://api.github.com/users/maflcko/orgs",
            "repos_url": "https://api.github.com/users/maflcko/repos",
            "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/maflcko/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 7,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24974",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24974",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24974.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24974.patch"
          },
          "closed_at": "2022-07-26T14:09:44Z",
          "created_at": "2022-04-25T13:01:31Z",
          "updated_at": "2023-07-26T10:16:56Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-12T11:42:54Z",
      "updated_at": "2022-05-12T11:42:54Z",
      "source": {
        "issue": {
          "id": 1214389435,
          "node_id": "PR_kwDOABII5842uF53",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24970",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24970/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24970/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24970/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24970",
          "number": 24970,
          "state": "closed",
          "state_reason": null,
          "title": "net processing: Move cleanSubVer, fPreferredDownload and nLocalHostNonce to Peer",
          "body": "Next step in #19398. Moves additional members from CNode and CNodeState into Peer.\r\n\r\nAlso renames CNodeStateStats to PeerStats, since most of the stats are now taken from the Peer object.",
          "user": {
            "login": "jnewbery",
            "id": 1063656,
            "node_id": "MDQ6VXNlcjEwNjM2NTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jnewbery",
            "html_url": "https://github.com/jnewbery",
            "followers_url": "https://api.github.com/users/jnewbery/followers",
            "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
            "organizations_url": "https://api.github.com/users/jnewbery/orgs",
            "repos_url": "https://api.github.com/users/jnewbery/repos",
            "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jnewbery/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 10,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24970",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24970",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24970.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24970.patch"
          },
          "closed_at": "2022-06-20T11:13:26Z",
          "created_at": "2022-04-25T11:48:12Z",
          "updated_at": "2023-06-20T10:07:18Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-12T16:31:58Z",
      "updated_at": "2022-05-12T16:31:58Z",
      "source": {
        "issue": {
          "id": 1183587266,
          "node_id": "PR_kwDOABII5841Kd7I",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24697",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24697/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24697/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24697/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24697",
          "number": 24697,
          "state": "closed",
          "state_reason": null,
          "title": "refactor address relay time",
          "body": "Those refactors are overlapping with, but otherwise largely unrelated to #24662.",
          "user": {
            "login": "maflcko",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/maflcko",
            "html_url": "https://github.com/maflcko",
            "followers_url": "https://api.github.com/users/maflcko/followers",
            "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
            "organizations_url": "https://api.github.com/users/maflcko/orgs",
            "repos_url": "https://api.github.com/users/maflcko/repos",
            "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/maflcko/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24697",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24697",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24697.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24697.patch"
          },
          "closed_at": "2022-07-27T09:30:54Z",
          "created_at": "2022-03-28T15:10:54Z",
          "updated_at": "2023-07-29T10:17:20Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-12T21:35:41Z",
      "updated_at": "2022-05-12T21:35:41Z",
      "source": {
        "issue": {
          "id": 1120958552,
          "node_id": "PR_kwDOABII584x6sdb",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24230",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24230/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24230/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24230/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24230",
          "number": 24230,
          "state": "open",
          "state_reason": null,
          "title": "indexes: Stop using node internal types and locking cs_main, improve sync logic",
          "body": "This PR lets indexing code mostly run outside of the node process. It also improves indexing sync logic, which is moved out of indexing code to a new [`node::SyncChain()`](https://github.com/ryanofsky/bitcoin/blob/8d8cdcb37005030f646ba3c45f7f54f556efb8bf/src/node/chain.h#L24-L39) function.\r\n\r\nAlmost all the commits in this PR are small refactoring changes that move code from `src/index/` to `src/node/`, or replace references to node types like `CBlockIndex`, `CChain`, `CChainState` in index code. There are only two commits affecting indexing sync logic which make complicated or substantive changes:\r\n\r\n- [`8746b35301c5` indexes: Rewrite chain sync logic, remove racy init](https://github.com/bitcoin/bitcoin/pull/24230/commits/8746b35301c5f65ff3200555fb2b82417fd2c758)\r\n- [`ad88f50ddd12` indexes: Initialize indexes without holding cs_main](https://github.com/bitcoin/bitcoin/pull/24230/commits/ad88f50ddd129dddd974bbf9fd7d86ec86b65508)\r\n\r\n\r\nThe commit messages have more details about these and other changes. Followups to this PR will reuse indexing sync code for wallets (#15719, #11756) and let indexes run in separate processes (#10102)",
          "user": {
            "login": "ryanofsky",
            "id": 7133040,
            "node_id": "MDQ6VXNlcjcxMzMwNDA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ryanofsky",
            "html_url": "https://github.com/ryanofsky",
            "followers_url": "https://api.github.com/users/ryanofsky/followers",
            "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
            "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
            "repos_url": "https://api.github.com/users/ryanofsky/repos",
            "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 97470796,
              "node_id": "MDU6TGFiZWw5NzQ3MDc5Ng==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/UTXO%20Db%20and%20Indexes",
              "name": "UTXO Db and Indexes",
              "color": "fbca04",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 39,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24230",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24230",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24230.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24230.patch"
          },
          "created_at": "2022-02-01T16:56:28Z",
          "updated_at": "2023-09-26T13:52:37Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-13T08:22:55Z",
      "updated_at": "2022-05-13T08:22:55Z",
      "source": {
        "issue": {
          "id": 850343512,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjA4OTMyOTkx",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21603",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21603/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21603/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21603/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21603",
          "number": 21603,
          "state": "closed",
          "state_reason": null,
          "title": "log: Mitigate disk filling attacks by rate limiting LogPrintf",
          "body": "This picks up #19995 in an attempt to solve #21559.\r\n\r\nThe goal of this PR is to mitigate disk filling attacks by temporarily rate limiting `LogPrintf(…)`.\r\n\r\nA disk fill attack is an attack where an untrusted party (such as a peer) is able to cheaply make your node log to disk excessively. The excessive logging may fill your disk and thus make your node crash either cleanly (best case: if disk fill rate is relatively slow) or uncleanly (worst case: if disk fill rate is relatively fast).\r\n\r\n## Approach\r\n\r\nThe hourly logging quota is set **per source location**. Every single source location (say net_processing.cpp:418) gets a quota of 1 MB of logging per hour. Logging is only dropped from source locations that exceed the quota.\r\n\r\n- Only logging to disk is rate limited. Logging to console is not rate limited.\r\n- Only `LogPrintf(…)` is rate limited. `LogPrint(category, …)` (`-debug`) is not rate limited.\r\n- `UpdateTip: new best=[…]` is logged using `LogPrintfWithoutRateLimiting(…)` to avoid rate limiting. High log volume is expected for that source location during IBD.\r\n- When logging is restarted a tally of how many messages/bytes were dropped is printed.\r\n- Log rate limiting can be disabled with the `-ratelimitlogging` config option.\r\n- All logs will be prefixed with `[*]` if there is at least one source location that is currently being suppressed.\r\n\r\n### Alternatives\r\n\r\nIn a recent [PR Review Club meeting](https://bitcoincore.reviews/21603) we discussed this PR and evaluated alternative approaches.\r\n\r\n<details>\r\n<summary>Global rate limiting </summary>\r\n\r\n#### Global rate limiting\r\n\r\nThere was some discussion around an alternative approach which would be to globally rate limit `LogPrintf(…)`.  This approach was implemented in a competing PR #21706. The main point [1] in favor of global rate limiting is that it could be confusing to have incomplete logs when logs from one source location are dropped but not from others. The main point against global rate limiting is that it opens another attack vector where an attacker could trigger rate limiting and then execute a 2. attack which would then not be document in the logs at all. With regard to the attack vector on the global approach and the overall reviews the two approaches have gotten I have chosen to continue with the approach in this PR. \r\n(To address the concern of [1] i have chosen to prefix all logs with `[*]` if there is at least one source location that is currently being suppressed.)\r\n</details>\r\n\r\n<details>\r\n<summary>logrotate</summary>\r\n\r\n#### logrotate\r\n\r\nLarryRuane brought up [logrotate](https://linux.die.net/man/8/logrotate) which can be used on linux to monitor log files and perform actions (delete, compress, send somewhere, etc.) on them when a certain size or point in time is reached. `logrotate` could be used to rate limit log but since we would like log rate limiting to be enabled by default it is not the best solution. Also on windows an alternative would have to be used.\r\n\r\n</details>\r\n\r\n## Testing\r\n\r\nI have a written a unit test which is contained in this PR. (Not the greatest test, it currently does not work on windows thanks to `\\r\\n`. If someone has an idea how to improve the test i would appreciate it)\r\n\r\nFurther more I made a RPC [here](https://github.com/dergoegge/bitcoin/commit/8e6d15d6be06834d1f634f4a54ea646be8bc3491) that can log excessive amounts of \"a\"s from different locations which i have found useful during my own testing.\r\n`bitcoin-cli excessivelog <location (1-5)> <num_bytes>`\r\n\r\n⚠️One thing to note with that rpc is that the rate limiting logic still prints the last message that triggered the limiting to disk, so something like `bitcoin-cli excessivelog 1 536870912` would still log ~512MiB to disk. Logging to console is also never suppressed (unless -printtoconsole=0)  ⚠️\r\n\r\nA simple example to use the rpc:\r\n```bash\r\nbitcoin-cli -regtest setmocktime 1\r\nbitcoin-cli -regtest excessivelog 1 1048500 # log just under 1MiB\r\nbitcoin-cli -regtest excessivelog 1 100 # this should get the total amount logged above 1MiB\r\n                                        # and the rate limiting logic should kick in\r\nbitcoin-cli -regtest setmocktime 3602 # let 1 hour pass (only works in regtest)\r\nbitcoin-cli -regtest excessivelog 1 100 # this should trigger logging to resume\r\n```\r\n",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 41,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21603",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21603",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21603.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21603.patch"
          },
          "closed_at": "2022-10-07T10:18:05Z",
          "created_at": "2021-04-05T12:47:33Z",
          "updated_at": "2023-10-07T12:13:33Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 6641255933,
      "node_id": "LE_lADOABII584yA-tHzwAAAAGL2YX9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6641255933",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-19T10:21:36Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-09-01T10:36:28Z",
      "updated_at": "2022-09-01T10:36:28Z",
      "source": {
        "issue": {
          "id": 1344091938,
          "node_id": "PR_kwDOABII5849camF",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25871",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25871/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25871/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25871/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25871",
          "number": 25871,
          "state": "closed",
          "state_reason": null,
          "title": "contrib: add vasild to trusted keys",
          "body": "_(this is a followup from yesterday's [IRC discussion](https://www.erisian.com.au/bitcoin-core-dev/log-2022-08-18.html#l-299))_\r\n\r\nFor Networking scope maintenance.\r\n\r\nI have been signing commits with that key and it is available at `keys.openpgp.org`.",
          "user": {
            "login": "vasild",
            "id": 266751,
            "node_id": "MDQ6VXNlcjI2Njc1MQ==",
            "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vasild",
            "html_url": "https://github.com/vasild",
            "followers_url": "https://api.github.com/users/vasild/followers",
            "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
            "organizations_url": "https://api.github.com/users/vasild/orgs",
            "repos_url": "https://api.github.com/users/vasild/repos",
            "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/vasild/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 231994551,
              "node_id": "MDU6TGFiZWwyMzE5OTQ1NTE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Scripts%20and%20tools",
              "name": "Scripts and tools",
              "color": "ffffee",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 65,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25871",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25871",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25871.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25871.patch"
          },
          "closed_at": "2023-01-14T08:29:04Z",
          "created_at": "2022-08-19T08:02:03Z",
          "updated_at": "2023-01-14T08:29:05Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T07:29:52Z",
      "updated_at": "2022-10-08T07:29:52Z",
      "source": {
        "issue": {
          "id": 1401856133,
          "node_id": "PR_kwDOABII585AbffS",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26283",
          "number": 26283,
          "state": "open",
          "state_reason": null,
          "title": "p2p: Fill reconciliation sets and request reconciliation (Erlay)",
          "body": "First, this PR enables keeping track of per-peer reconciliation sets, containing those transactions which we intend to exchange efficiently. The remaining transactions are announced via flooding, as usual.\r\n\r\nSecond, this PR enables periodically initiating a reconciliation round via a new p2p message.\r\n\r\nErlay Project Tracking: #28646",
          "user": {
            "login": "naumenkogs",
            "id": 7975071,
            "node_id": "MDQ6VXNlcjc5NzUwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/naumenkogs",
            "html_url": "https://github.com/naumenkogs",
            "followers_url": "https://api.github.com/users/naumenkogs/followers",
            "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
            "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
            "repos_url": "https://api.github.com/users/naumenkogs/repos",
            "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26283",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26283.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26283.patch"
          },
          "created_at": "2022-10-08T07:29:52Z",
          "updated_at": "2023-10-18T16:18:43Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1276571833,
      "node_id": "IC_kwDOABII585MFvC5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276571833",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-12T18:28:19Z",
      "updated_at": "2022-10-12T18:28:19Z",
      "author_association": "MEMBER",
      "body": "Should this be marked as draft since it's a parent/meta PR?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-1276571833",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515"
    },
    {
      "event": "convert_to_draft",
      "id": 7576475396,
      "node_id": "CTDE_lADOABII584yA-tHzwAAAAHDl9cE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7576475396",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-13T01:20:53Z"
    },
    {
      "event": "referenced",
      "id": 7604264777,
      "node_id": "REFE_lADOABII584yA-tHzwAAAAHFP99J",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7604264777",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "e7a0e9627196655be5aa6c2738d4b57646a03726",
      "commit_url": "https://api.github.com/repos/bitcoin-core/gui/commits/e7a0e9627196655be5aa6c2738d4b57646a03726",
      "created_at": "2022-10-17T17:11:26Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-28T14:12:29Z",
      "updated_at": "2022-10-28T14:12:29Z",
      "source": {
        "issue": {
          "id": 957969,
          "node_id": "MDU6SXNzdWU5NTc5Njk=",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/273",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/273/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/273/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/273/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/273",
          "number": 273,
          "state": "closed",
          "state_reason": "completed",
          "title": "Speed limit / throttle network usage",
          "body": "I noticed the other day Bitcoin was maxing out my upload bandwidth on ADSL.  Probably due to sending the block chain to fellow bitcoin users ( I had about 65 connections at the time )..\n\nThe ability to limit / throttle the network usage like most other p2p programs would be beneficial.  Otherwise I have to ensure I close the Bitcoin application to keep it from killing my upload.\n",
          "user": {
            "login": "slothbag",
            "id": 811824,
            "node_id": "MDQ6VXNlcjgxMTgyNA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/811824?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/slothbag",
            "html_url": "https://github.com/slothbag",
            "followers_url": "https://api.github.com/users/slothbag/followers",
            "following_url": "https://api.github.com/users/slothbag/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/slothbag/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/slothbag/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/slothbag/subscriptions",
            "organizations_url": "https://api.github.com/users/slothbag/orgs",
            "repos_url": "https://api.github.com/users/slothbag/repos",
            "events_url": "https://api.github.com/users/slothbag/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/slothbag/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 64583,
              "node_id": "MDU6TGFiZWw2NDU4Mw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature",
              "name": "Feature",
              "color": "7cf575",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 326918230,
              "node_id": "MDU6TGFiZWwzMjY5MTgyMzA=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Resource%20usage",
              "name": "Resource usage",
              "color": "981023",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 113,
          "closed_at": "2022-10-28T14:25:18Z",
          "created_at": "2011-05-26T11:14:44Z",
          "updated_at": "2022-10-28T15:20:12Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-01T08:27:19Z",
      "updated_at": "2022-11-01T08:27:19Z",
      "source": {
        "issue": {
          "id": 1419806556,
          "node_id": "PR_kwDOABII585BXJB_",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26373",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26373/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26373/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26373/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26373",
          "number": 26373,
          "state": "closed",
          "state_reason": null,
          "title": "Update minisketch subtree to latest upstream",
          "body": "Contains:\r\n- https://github.com/sipa/minisketch/pull/68\r\n- https://github.com/sipa/minisketch/pull/69\r\n- https://github.com/sipa/minisketch/pull/70\r\n- https://github.com/sipa/minisketch/pull/72\r\n\r\nFixes bitcoin/bitcoin#26262.\r\n\r\nRequired for bitcoin/bitcoin#25797.\r\n\r\nGuix builds on `arm64`:\r\n```\r\n28af3bdd17924bb5279934add1fe34f5664181a1c99f33793725adc35f90d778  guix-build-45a0f4e01448/output/aarch64-linux-gnu/SHA256SUMS.part\r\nc9cdcb107de5b683221b0e2a3796814548414cdba27be198516a2b401ada90c3  guix-build-45a0f4e01448/output/aarch64-linux-gnu/bitcoin-45a0f4e01448-aarch64-linux-gnu-debug.tar.gz\r\nce1e916cc7574f555c04ed5fa9e9a47a1e4d2d9d1cb82a040269e8c32aca9194  guix-build-45a0f4e01448/output/aarch64-linux-gnu/bitcoin-45a0f4e01448-aarch64-linux-gnu.tar.gz\r\n26404d3479108bcb8ede4ae7f3d37dbb64a335f0cd5bce7ee901d171a1ef2b0b  guix-build-45a0f4e01448/output/arm-linux-gnueabihf/SHA256SUMS.part\r\n0fe32aee5836baed86ad25cbddb43c5a9d2ecbbe5cc954f3a76670aa52ff3c6f  guix-build-45a0f4e01448/output/arm-linux-gnueabihf/bitcoin-45a0f4e01448-arm-linux-gnueabihf-debug.tar.gz\r\n41f312cbf26a0e51e6867e644beb3d085ebd4221dc83ea84a97b708e6d230b6d  guix-build-45a0f4e01448/output/arm-linux-gnueabihf/bitcoin-45a0f4e01448-arm-linux-gnueabihf.tar.gz\r\nc05ba8235e05c171ecdbacba87dfc1db34d1971286b853c26e3de52a6b0ea1cc  guix-build-45a0f4e01448/output/arm64-apple-darwin/SHA256SUMS.part\r\n9d1dae2b73573d34950684269c41f2504761f2df19f24033513f6664b70b1aad  guix-build-45a0f4e01448/output/arm64-apple-darwin/bitcoin-45a0f4e01448-arm64-apple-darwin-unsigned.dmg\r\n1ff742346bd04b7edf27e096286f4863fcfec984b99caf265a64fe72b298b36a  guix-build-45a0f4e01448/output/arm64-apple-darwin/bitcoin-45a0f4e01448-arm64-apple-darwin-unsigned.tar.gz\r\n74a001f16ba382c22acb9979ee5d905af42f4ca3613fc6e8fa66fec994fb0850  guix-build-45a0f4e01448/output/arm64-apple-darwin/bitcoin-45a0f4e01448-arm64-apple-darwin.tar.gz\r\nec2f70a0b8a128d3ca69307150714c400620199b506a411b0a4c0a506cc3ed66  guix-build-45a0f4e01448/output/dist-archive/bitcoin-45a0f4e01448.tar.gz\r\n9a67ea74e1b5ef3d08b6a59217ecf8d193234c76f81157192fabe7a9b679af0c  guix-build-45a0f4e01448/output/powerpc64-linux-gnu/SHA256SUMS.part\r\n95b458427d73ed81f4a4f85be0dfe81a9a48dc254be65ef158de93d32f07a17a  guix-build-45a0f4e01448/output/powerpc64-linux-gnu/bitcoin-45a0f4e01448-powerpc64-linux-gnu-debug.tar.gz\r\n2b269c630f069cc42da5f361d13f5b684fbacb49641f44ed6687379a1e9281b0  guix-build-45a0f4e01448/output/powerpc64-linux-gnu/bitcoin-45a0f4e01448-powerpc64-linux-gnu.tar.gz\r\n33d576b9be022108db6d76c41c1f72c865b5bb38439c6da1cbceac757a1be47f  guix-build-45a0f4e01448/output/powerpc64le-linux-gnu/SHA256SUMS.part\r\n053dc9cecc978601701459109eec82f3bcce4042d794c520fd4bd8cd4e17eff3  guix-build-45a0f4e01448/output/powerpc64le-linux-gnu/bitcoin-45a0f4e01448-powerpc64le-linux-gnu-debug.tar.gz\r\n32946d589103c763c2fc67c0d8fa13a38b9194df76cd31755a761a7b9ad856a6  guix-build-45a0f4e01448/output/powerpc64le-linux-gnu/bitcoin-45a0f4e01448-powerpc64le-linux-gnu.tar.gz\r\n7d1be372c84f9403333462e82d7800dfb1812b14c1ed228dacf605dff9aab75c  guix-build-45a0f4e01448/output/riscv64-linux-gnu/SHA256SUMS.part\r\n3338bcaf6b8ffd9c155c055a0a18d039e1173212e128561fdea493c263d6ecb9  guix-build-45a0f4e01448/output/riscv64-linux-gnu/bitcoin-45a0f4e01448-riscv64-linux-gnu-debug.tar.gz\r\n7735eefa84630d16d8d37ea23c734578c6fb6540d4359b78d0d1508887e76042  guix-build-45a0f4e01448/output/riscv64-linux-gnu/bitcoin-45a0f4e01448-riscv64-linux-gnu.tar.gz\r\nc3a96d6758631b8e8b4f5bb8035e5442e1fc5b831c7a0ddedb26473b025b2503  guix-build-45a0f4e01448/output/x86_64-apple-darwin/SHA256SUMS.part\r\nb6c87738e6e561bfc4052464e93a6d03a87c51e8f27e4df8ae7458c9828e28cb  guix-build-45a0f4e01448/output/x86_64-apple-darwin/bitcoin-45a0f4e01448-x86_64-apple-darwin-unsigned.dmg\r\n0c16f9435c3d572970400ff4683705b297eda3dd37a682619371771da8efbb24  guix-build-45a0f4e01448/output/x86_64-apple-darwin/bitcoin-45a0f4e01448-x86_64-apple-darwin-unsigned.tar.gz\r\n22e06590afe07b992f6f4e46d5568499403937606d16540b121f23e133270560  guix-build-45a0f4e01448/output/x86_64-apple-darwin/bitcoin-45a0f4e01448-x86_64-apple-darwin.tar.gz\r\n56ddb44760f71fd1c1ea06c7174bf035b8b73c32569d69a1401d130551db43e5  guix-build-45a0f4e01448/output/x86_64-linux-gnu/SHA256SUMS.part\r\n1c8a27fab5d9d0f3a5449f04ae8a7e693c5f144948f6d0c2dbf397e04ce9ebfa  guix-build-45a0f4e01448/output/x86_64-linux-gnu/bitcoin-45a0f4e01448-x86_64-linux-gnu-debug.tar.gz\r\n66aca3767407f6c2e77b8b93edc58e71c00bed518a75362e3c2f5009739c666c  guix-build-45a0f4e01448/output/x86_64-linux-gnu/bitcoin-45a0f4e01448-x86_64-linux-gnu.tar.gz\r\n7ac04c1d5f2dbb6c2c392add9c4e2c5c838c718910b920fe6691a5e9881065b9  guix-build-45a0f4e01448/output/x86_64-w64-mingw32/SHA256SUMS.part\r\n2c51afbcf5645516d01d5f730e9883d9ed3cb90b9b9baf90792ecdb2b3eb21cf  guix-build-45a0f4e01448/output/x86_64-w64-mingw32/bitcoin-45a0f4e01448-win64-debug.zip\r\n81738a0690e954d6850f210fa3933ca5de8800078734f8b0810b5e7fe3e63e5d  guix-build-45a0f4e01448/output/x86_64-w64-mingw32/bitcoin-45a0f4e01448-win64-setup-unsigned.exe\r\necade9ee23ad156e057d466afe79943f008de316973738efdf5ae33d2a527631  guix-build-45a0f4e01448/output/x86_64-w64-mingw32/bitcoin-45a0f4e01448-win64-unsigned.tar.gz\r\n3b17762d01825a3f7d5aecf34cf038938d9ee467e63ea3f34efd1dfa2af5e284  guix-build-45a0f4e01448/output/x86_64-w64-mingw32/bitcoin-45a0f4e01448-win64.zip\r\n```",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 6,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26373",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26373",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26373.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26373.patch"
          },
          "closed_at": "2022-11-01T08:30:52Z",
          "created_at": "2022-10-23T14:07:14Z",
          "updated_at": "2022-11-01T08:49:43Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7821649714,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAHSNOcy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7821649714",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-16T09:10:04Z"
    },
    {
      "event": "unlabeled",
      "id": 7822291704,
      "node_id": "UNLE_lADOABII584yA-tHzwAAAAHSPrL4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7822291704",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-16T10:17:49Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-16T14:32:41Z",
      "updated_at": "2022-11-16T14:32:41Z",
      "source": {
        "issue": {
          "id": 1417936723,
          "node_id": "PR_kwDOABII585BQ_6D",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26359",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26359/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26359/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26359/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26359",
          "number": 26359,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: Erlay support signaling follow-ups",
          "body": "\r\n\r\nNon-trivial changes include:\r\n- Getting rid of roles in `sendtxrcncl` message (summarized in the [BIP PR](https://github.com/bitcoin/bips/pull/1376));\r\n- Disconnect the peer if it send `sendtxrcncl` although we are in `blocksonly` and notified the peer with `fRelay=0`;\r\n- Don't send `sendtxrcncl` to feeler connections.",
          "user": {
            "login": "naumenkogs",
            "id": 7975071,
            "node_id": "MDQ6VXNlcjc5NzUwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/naumenkogs",
            "html_url": "https://github.com/naumenkogs",
            "followers_url": "https://api.github.com/users/naumenkogs/followers",
            "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
            "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
            "repos_url": "https://api.github.com/users/naumenkogs/repos",
            "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26359",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26359",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26359.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26359.patch"
          },
          "closed_at": "2022-11-30T10:53:08Z",
          "created_at": "2022-10-21T08:08:43Z",
          "updated_at": "2022-11-30T10:53:09Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-16T16:15:24Z",
      "updated_at": "2022-11-16T16:15:24Z",
      "source": {
        "issue": {
          "id": 1379469601,
          "node_id": "PR_kwDOABII584_RzRJ",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26140",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26140/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26140/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26140/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26140",
          "number": 26140,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: Move CNodeState members guarded by g_msgproc_mutex to Peer",
          "body": "`nUnconnectingHeaders`, `m_headers_sync_timeout`, `fPreferHeaders` and  `m_recently_announced_headers` are currently all `CNodeState` members even though they are only ever accessed from the message processing thread (therefore sufficiently guarded exclusively by `g_msgproc_mutex`). `CNodeState` exists purely to hold validation-specific state guarded by `cs_main` that is accessed by multiple threads.\r\n\r\nThis PR adds thread-safety annotations for the above mentioned `CNodeState` members and moves them to `Peer`.",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 6,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26140",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26140",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26140.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26140.patch"
          },
          "closed_at": "2023-03-30T16:11:12Z",
          "created_at": "2022-09-20T13:56:43Z",
          "updated_at": "2023-03-31T11:10:00Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-16T20:44:24Z",
      "updated_at": "2022-11-16T20:44:24Z",
      "source": {
        "issue": {
          "id": 1167366626,
          "node_id": "PR_kwDOABII5840WLLa",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24545",
          "number": 24545,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Enable v2 P2P encrypted transport",
          "body": "This PR brings together all other BIP324 PRs and enables v2 encrypted P2P transport.\r\n\r\nBuilds on top of PRs: #25361, #23233, #23561, #23432. It looks like there's a lot of commits, but **only the last 12 commits belong in this PR**. The rest will be merged with upstream PRs.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).\r\n\r\nBIP324 is [here](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki).\r\n\r\n### Running a v2 node\r\n#### Get the code\r\n```\r\ngit remote add bip324 git@github.com:dhruv/bitcoin.git\r\ngit fetch bip324\r\ngit checkout bip324/bip324-enable\r\n```\r\n\r\n#### Build for your OS\r\n\r\nFollow the appropriate instructions [here](https://github.com/bitcoin/bitcoin/blob/master/doc/README.md)\r\n\r\n#### Run the node\r\n\r\n```\r\nsrc/bitcoind -conf=CONFIG_FILE -v2transport=1\r\n```\r\n\r\n#### Connect with a friend's v2 node\r\n```\r\nsrc/bitcoin-cli -conf=CONFIG_FILE addnode \"FRIEND_IP:FRIEND_PORT\" \"add\" true\r\n```\r\nThe last parameter(`p2p_v2:true`) signals to your node that the peer is running a v2 supportive client and we should attempt to make an encrypted P2P connection (you're simulating the `NODE_P2P_V2` service flag advertisement manually). Should that fail however (say because the peer told you mistakenly, lied, etc.), this code will downgrade the connection to unencrypted v1 transport.\r\n\r\n### Things you are helpful to test\r\n\r\n* If your friend's node is a v2 node, you can see with wireshark that the bytes are pseudorandom (the easiest way to confirm this is that with a v1 connection, wireshark will tell you it has detected a Bitcoin connection and it'll even parse out the metadata like message type, etc; with v2, wireshark has no idea -- of course that _could_ be because wireshark does simply not know v2, but it is because the bytestream is pseudorandom)\r\n* Compare the v2 encrypted session id exposed via `getpeerinfo` as `v2_session_id` with your friend.\r\n* Add another peer that is actually v1, but try `addnode` still indicating v2 support. You should see with wireshark that after a failed attempt at a v2 handshake, the connection is downgraded to unencrypted v1 and wireshark can parse it.\r\n\r\nI've been told there are v2 nodes running at (happy to update the list as more people run persistent v2 nodes; message me and I'll add it here):\r\n```\r\nbe.anyone.eu.org\r\nrp7k2go3s5lyj3fnj6zn62ktarlrsft2ohlsxkyd7v3e3idqyptvread.onion:8333\r\njdcoysubtxazi7dketpyb5rnjorvxad4onftveohash2pdwkgw4bvnqd.onion:8333\r\nxci6cphki2pdb5qe7axzrcxcxabkbm24z4zlv2hn4ziy6grquqco2kyd.onion:8333\r\nslvtesfgg3mkksqqzh67al4sq6dx3rhlzqepa4ny7jonzuckg6msf3id.onion:8333\r\ngifm4fnj3vua664xhgeanx5fnpco3txkqy4amr4txbfsciiyrkxpf2qd.onion:8333\r\n300:5ecb:6b8a:d837::3:8333\r\n300:5ecb:6b8a:d837::a6d6:8333\r\n2001:470:1f1a:365::2:8333\r\n2001:470:1f1b:365:aa20:66ff:fe3f:1909:8333\r\n184.74.240.157:8533\r\n95.179.145.232:8333\r\n```",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 47,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24545",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24545",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24545.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24545.patch"
          },
          "closed_at": "2023-05-06T11:14:46Z",
          "created_at": "2022-03-12T18:43:06Z",
          "updated_at": "2023-09-15T02:47:56Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-16T21:15:41Z",
      "updated_at": "2022-11-16T21:15:41Z",
      "source": {
        "issue": {
          "id": 1111166839,
          "node_id": "PR_kwDOABII584xa7v1",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24125",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24125/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24125/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24125/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24125",
          "number": 24125,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: Replace RecursiveMutex `m_tx_inventory_mutex` with Mutex and rename it",
          "body": "This PR is related to #19303 and gets rid of the `RecursiveMutex m_tx_inventory_mutex` and also adds `AssertLockNotHeld` macros combined with `LOCKS_EXCLUDED` thread safety annotations to avoid recursive locking.",
          "user": {
            "login": "w0xlt",
            "id": 94266259,
            "node_id": "U_kgDOBZ5jkw",
            "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/w0xlt",
            "html_url": "https://github.com/w0xlt",
            "followers_url": "https://api.github.com/users/w0xlt/followers",
            "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
            "organizations_url": "https://api.github.com/users/w0xlt/orgs",
            "repos_url": "https://api.github.com/users/w0xlt/repos",
            "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/w0xlt/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 749416508,
              "node_id": "MDU6TGFiZWw3NDk0MTY1MDg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Up%20for%20grabs",
              "name": "Up for grabs",
              "color": "99a810",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24125",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24125",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24125.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24125.patch"
          },
          "closed_at": "2023-04-25T15:19:25Z",
          "created_at": "2022-01-22T01:28:10Z",
          "updated_at": "2023-04-25T15:19:25Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-29T01:12:39Z",
      "updated_at": "2022-11-29T01:12:39Z",
      "source": {
        "issue": {
          "id": 1299238264,
          "node_id": "PR_kwDOABII5847Ho23",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25572",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25572/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25572/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25572/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25572",
          "number": 25572,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: Introduce EvictionManager and use it for the inbound eviction logic",
          "body": "This PR splits off the next couple commits from #25268 that introduce the `EvictionManager` and use it for  the inbound eviction logic.\r\n\r\nOne instance of the `EvictionManager` is created at start up and passed as a reference to the connection and peer managers. The connection and peer managers report all eviction relevant information (for inbound connections) to the eviction manager who ultimately suggests nodes to evict as the result of `EvictionManager::SelectNodeToEvict`.",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 11,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25572",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25572",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25572.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25572.patch"
          },
          "closed_at": "2023-09-28T20:06:18Z",
          "created_at": "2022-07-08T16:39:49Z",
          "updated_at": "2023-09-28T20:06:18Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T01:30:08Z",
      "updated_at": "2022-11-30T01:30:08Z",
      "source": {
        "issue": {
          "id": 1258121997,
          "node_id": "PR_kwDOABII5844-S2D",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25268",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25268/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25268/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25268/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25268",
          "number": 25268,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: Introduce EvictionManager",
          "body": "At the moment, the eviction logic is mangled across two different components (`CConnman`, `PeerManager`), so we can't really test it in isolation. This is not completely true for the inbound eviction logic as it exists as static functions in `net.{h.cpp}` for which tests already exist. However, the outbound eviction logic is not covered by any fuzz tests and is only testable by spinning up both a connman and peerman.\r\n\r\nThis PR splits out the eviction logic into its own component `EvictionManager`. In addition to isolating the eviction logic, we get rid of several layer violations (e.g. `CConnman::ForEachNode/ForNode` calls, `CNode::m_last_block_time`, etc.) between `net` and `net processing`.\r\n\r\nOne instance of the `EvictionManager` is created at start up and passed as a reference to the connection and peer managers. The connection and peer managers report all eviction relevant information to the eviction manager who ultimately suggests nodes to evict as the result of `EvictionManager::SelectInboundNodeToEvict` and `EvictionManager::SelectOutboundNodesToEvict`.",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25268",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25268",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25268.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25268.patch"
          },
          "closed_at": "2023-09-28T20:06:22Z",
          "created_at": "2022-06-02T12:34:15Z",
          "updated_at": "2023-09-28T20:06:22Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 7921437332,
      "node_id": "LE_lADOABII584yA-tHzwAAAAHYJ4qU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7921437332",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T12:08:32Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T15:57:53Z",
      "updated_at": "2023-05-31T15:57:53Z",
      "source": {
        "issue": {
          "id": 1734440569,
          "node_id": "PR_kwDOABII585RzUG4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27797",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27797/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27797/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27797/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27797",
          "number": 27797,
          "state": "closed",
          "state_reason": null,
          "title": "rpc, net: add erlay status in `getpeerinfo`",
          "body": "Fixes #26602\r\n\r\nAdds `m_tx_reconciliation` in `Peer` struct\r\nto know whether the peer supports Erlay and\r\nexposes it in `getpeerinfo` rpc.",
          "user": {
            "login": "brunoerg",
            "id": 19480819,
            "node_id": "MDQ6VXNlcjE5NDgwODE5",
            "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/brunoerg",
            "html_url": "https://github.com/brunoerg",
            "followers_url": "https://api.github.com/users/brunoerg/followers",
            "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
            "organizations_url": "https://api.github.com/users/brunoerg/orgs",
            "repos_url": "https://api.github.com/users/brunoerg/repos",
            "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/brunoerg/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27797",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27797",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27797.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27797.patch"
          },
          "closed_at": "2023-06-01T09:19:04Z",
          "created_at": "2023-05-31T15:03:25Z",
          "updated_at": "2023-06-01T09:19:05Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDEwMWVkMTVlZmFjN2M4N2RkMzhiOTcwNzNhYzYzMzM2ZjQzZWEzODQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/101ed15efac7c87dd38b97073ac63336f43ea384",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/101ed15efac7c87dd38b97073ac63336f43ea384",
      "tree": {
        "sha": "1ba40d50cd0eb9611243f9520c3d6c054604a668",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ba40d50cd0eb9611243f9520c3d6c054604a668"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/38db2bd4e144065c515a222e1ae3d4ca7677e428",
          "sha": "38db2bd4e144065c515a222e1ae3d4ca7677e428",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/38db2bd4e144065c515a222e1ae3d4ca7677e428"
        }
      ],
      "message": "refactor: Add a pre-mutexed version of IsPeerRegistered\n\nThe pre-mutexed version is useful for external calls, while\nthe regular version will be used internally.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-22T10:20:26Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-12-01T12:12:03Z"
      },
      "sha": "101ed15efac7c87dd38b97073ac63336f43ea384"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU3NDc5ZTliMDJmOWVjMWE5MGE4MGM4YjBhMjZiMGY0OTcwMDc2MTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e7479e9b02f9ec1a90a80c8b0a26b0f497007617",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e7479e9b02f9ec1a90a80c8b0a26b0f497007617",
      "tree": {
        "sha": "b7485dbc32fc0e62a7573497decb93484fe1b421",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7485dbc32fc0e62a7573497decb93484fe1b421"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/101ed15efac7c87dd38b97073ac63336f43ea384",
          "sha": "101ed15efac7c87dd38b97073ac63336f43ea384",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/101ed15efac7c87dd38b97073ac63336f43ea384"
        }
      ],
      "message": "p2p: Functions to add/remove wtxids to tx reconciliation sets\n\nThey will be used later on.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-22T10:20:26Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-10-08T06:25:01Z"
      },
      "sha": "e7479e9b02f9ec1a90a80c8b0a26b0f497007617"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDViODg2MzY3YzgwYTI5M2VmMmUxYzM3YjFlY2FiNDJiMDU3ZDg3M2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b886367c80a293ef2e1c37b1ecab42b057d873b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5b886367c80a293ef2e1c37b1ecab42b057d873b",
      "tree": {
        "sha": "ec5ee4b223c1b2090f3f57b4e2372b53de37d2c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ec5ee4b223c1b2090f3f57b4e2372b53de37d2c0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e7479e9b02f9ec1a90a80c8b0a26b0f497007617",
          "sha": "e7479e9b02f9ec1a90a80c8b0a26b0f497007617",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e7479e9b02f9ec1a90a80c8b0a26b0f497007617"
        }
      ],
      "message": "p2p: Add transactions to reconciliation sets\n\nTransactions eligible for reconciliation are added to the\nreconciliation sets. For the remaining txs, low-fanout is used.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-25T10:31:43Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-06-23T16:01:53Z"
      },
      "sha": "5b886367c80a293ef2e1c37b1ecab42b057d873b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg5ZGUwZjcxZGNlMTFlMjljNGMxMTVhMzAyMWU5N2RhNjJiYTNjZTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89de0f71dce11e29c4c115a3021e97da62ba3ce6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/89de0f71dce11e29c4c115a3021e97da62ba3ce6",
      "tree": {
        "sha": "8d0940503a96d1831a14b6b24ed7f089c111e7a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8d0940503a96d1831a14b6b24ed7f089c111e7a8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b886367c80a293ef2e1c37b1ecab42b057d873b",
          "sha": "5b886367c80a293ef2e1c37b1ecab42b057d873b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5b886367c80a293ef2e1c37b1ecab42b057d873b"
        }
      ],
      "message": "p2p: Introduce reconciliation-fanout tx broadcast interval\n\nFor a subset of reconciling peers we announce transactions\nvia low fanout. We need to set lower intervals for that to\nachieve lower relay latency.\n\nNote that for privacy reasons the ratio between inbound and outbound\ndelays matter much more than the actual delays. That ratio is preserved\nhere, so it is not a privacy degradation.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-25T10:31:44Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-16T19:33:05Z"
      },
      "sha": "89de0f71dce11e29c4c115a3021e97da62ba3ce6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBlYzFiNDI3ZWNlMDk1YmM5ZjQyYmVkZTgxNTJmYWI1MGEyMmUyYzk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ec1b427ece095bc9f42bede8152fab50a22e2c9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0ec1b427ece095bc9f42bede8152fab50a22e2c9",
      "tree": {
        "sha": "2b3dba00c51ea690361c51e3a850ae52397a3e80",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2b3dba00c51ea690361c51e3a850ae52397a3e80"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89de0f71dce11e29c4c115a3021e97da62ba3ce6",
          "sha": "89de0f71dce11e29c4c115a3021e97da62ba3ce6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/89de0f71dce11e29c4c115a3021e97da62ba3ce6"
        }
      ],
      "message": "p2p: Add peers to reconciliation queue on negotiation\n\nWhen we're finalizing negotiation, we should add the peers\nfor which we will initiate reconciliations to the queue.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-25T10:31:44Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T12:12:24Z"
      },
      "sha": "0ec1b427ece095bc9f42bede8152fab50a22e2c9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRiNTdhZWYyZjE0Zjk0YmM4NTk3Y2Q2MTAwYjMxOGQ1YTdiYzA3YzQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4b57aef2f14f94bc8597cd6100b318d5a7bc07c4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4b57aef2f14f94bc8597cd6100b318d5a7bc07c4",
      "tree": {
        "sha": "3bd0467940f5739d7d73e5949e4e28925e7d7d24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3bd0467940f5739d7d73e5949e4e28925e7d7d24"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ec1b427ece095bc9f42bede8152fab50a22e2c9",
          "sha": "0ec1b427ece095bc9f42bede8152fab50a22e2c9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0ec1b427ece095bc9f42bede8152fab50a22e2c9"
        }
      ],
      "message": "p2p: Track reconciliation requests schedule\n\nWe initiate reconciliation by looking at the queue periodically\nwith equal intervals between peers to achieve efficiency.\n\nThis will be later used to see whether it's time to initiate.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-25T10:31:44Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:26:17Z"
      },
      "sha": "4b57aef2f14f94bc8597cd6100b318d5a7bc07c4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI3MmYwZDVmYThkNDNmMzcwNzg0OGY3Y2M1MjIxMWFjZGIzY2RjZGI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/272f0d5fa8d43f3707848f7cc52211acdb3cdcdb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/272f0d5fa8d43f3707848f7cc52211acdb3cdcdb",
      "tree": {
        "sha": "f239b2b7191ed5423b589974d62389c454340a9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f239b2b7191ed5423b589974d62389c454340a9a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4b57aef2f14f94bc8597cd6100b318d5a7bc07c4",
          "sha": "4b57aef2f14f94bc8597cd6100b318d5a7bc07c4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4b57aef2f14f94bc8597cd6100b318d5a7bc07c4"
        }
      ],
      "message": "p2p: Initiate reconciliation round\n\nWhen the time comes for the peer, we send a\nreconciliation request with the parameters which\nwill help the peer to construct a (hopefully) sufficient\nreconciliation sketch for us. We will then use that\nsketch to find missing transactions.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-25T10:31:44Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:27:32Z"
      },
      "sha": "272f0d5fa8d43f3707848f7cc52211acdb3cdcdb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU3MTA0NTEwNTEyN2ZlNjQzZTVmMDQ5YTk4NmYzODk0YzU0NDlkNTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e71045105127fe643e5f049a986f3894c5449d57",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e71045105127fe643e5f049a986f3894c5449d57",
      "tree": {
        "sha": "8440d5c4e6f4411d15fada1040055df179d14c28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8440d5c4e6f4411d15fada1040055df179d14c28"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/272f0d5fa8d43f3707848f7cc52211acdb3cdcdb",
          "sha": "272f0d5fa8d43f3707848f7cc52211acdb3cdcdb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/272f0d5fa8d43f3707848f7cc52211acdb3cdcdb"
        }
      ],
      "message": "test: functional test for reqtxrcncl",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-25T10:31:44Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-11-10T10:18:45Z"
      },
      "sha": "e71045105127fe643e5f049a986f3894c5449d57"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDllMGM4Y2QwYTM1MWQyZmI3ODRjZDZjMjJmYWY5ZGU4ZWIzYjc0MGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e0c8cd0a351d2fb784cd6c22faf9de8eb3b740c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9e0c8cd0a351d2fb784cd6c22faf9de8eb3b740c",
      "tree": {
        "sha": "35002e4b8ebcbfaea332d457575f6edb4b2f6757",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/35002e4b8ebcbfaea332d457575f6edb4b2f6757"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e71045105127fe643e5f049a986f3894c5449d57",
          "sha": "e71045105127fe643e5f049a986f3894c5449d57",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e71045105127fe643e5f049a986f3894c5449d57"
        }
      ],
      "message": "p2p: Handle reconciliation request\n\nStore the parameters the peer sent us inside the\nreconciliation request.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-06T08:33:26Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T15:21:49Z"
      },
      "sha": "9e0c8cd0a351d2fb784cd6c22faf9de8eb3b740c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY5OWZhNDY5MTE1ODU2YWVmYTk3OTliM2ZjNjJiYTA5OTg1OTMzYWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f99fa469115856aefa9799b3fc62ba09985933ad",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f99fa469115856aefa9799b3fc62ba09985933ad",
      "tree": {
        "sha": "486d5498de84f6bc4c57a2e4a629de53ca2b0784",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/486d5498de84f6bc4c57a2e4a629de53ca2b0784"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e0c8cd0a351d2fb784cd6c22faf9de8eb3b740c",
          "sha": "9e0c8cd0a351d2fb784cd6c22faf9de8eb3b740c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9e0c8cd0a351d2fb784cd6c22faf9de8eb3b740c"
        }
      ],
      "message": "Add helper to see whether we should respond to recon request\n\nFor initial reconciliatin requests we track whether was the last time\nwe responded to them, and if it was too recent, we respond after\na small delay.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-06T08:36:38Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T13:33:22Z"
      },
      "sha": "f99fa469115856aefa9799b3fc62ba09985933ad"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI2OGNhZGE5ZGIyMWU3NjNlODdjNWFmZDgzNjI1MzNiNTE3ZjIyZTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b68cada9db21e763e87c5afd8362533b517f22e3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b68cada9db21e763e87c5afd8362533b517f22e3",
      "tree": {
        "sha": "26325db4e5086ea1f8aea150252e3ca23f051241",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/26325db4e5086ea1f8aea150252e3ca23f051241"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f99fa469115856aefa9799b3fc62ba09985933ad",
          "sha": "f99fa469115856aefa9799b3fc62ba09985933ad",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f99fa469115856aefa9799b3fc62ba09985933ad"
        }
      ],
      "message": "Add helper to compute reconciliation tx short id",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-06T08:41:21Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T12:32:57Z"
      },
      "sha": "b68cada9db21e763e87c5afd8362533b517f22e3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU1ZDhlNGE1YmU5NmRiOTk4Y2UxNmE2NmJjMDgxNTg5NTI5ZjAzN2Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e5d8e4a5be96db998ce16a66bc081589529f037f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e5d8e4a5be96db998ce16a66bc081589529f037f",
      "tree": {
        "sha": "b3a099ba06937c7075d31a11f7b3d9f13e4e8177",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b3a099ba06937c7075d31a11f7b3d9f13e4e8177"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b68cada9db21e763e87c5afd8362533b517f22e3",
          "sha": "b68cada9db21e763e87c5afd8362533b517f22e3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b68cada9db21e763e87c5afd8362533b517f22e3"
        }
      ],
      "message": "build: Link minisketch libraries",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-06T08:41:22Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-10-25T13:03:19Z"
      },
      "sha": "e5d8e4a5be96db998ce16a66bc081589529f037f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDlkMjdiNjM1NzU3MTdlMzkzMjIzODEzNGE3MTMzNGYzNTYwZDQzMjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d27b63575717e3932238134a71334f3560d4328",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9d27b63575717e3932238134a71334f3560d4328",
      "tree": {
        "sha": "2babf13abca2808e0a33b3823125efde3ed750ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2babf13abca2808e0a33b3823125efde3ed750ce"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e5d8e4a5be96db998ce16a66bc081589529f037f",
          "sha": "e5d8e4a5be96db998ce16a66bc081589529f037f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e5d8e4a5be96db998ce16a66bc081589529f037f"
        }
      ],
      "message": "Add helper to compute sketches for tx reconciliation",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-06T08:44:08Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T12:41:11Z"
      },
      "sha": "9d27b63575717e3932238134a71334f3560d4328"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10330899677,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAJnxQTd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10330899677",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:30:20Z"
    },
    {
      "event": "labeled",
      "id": 10331621254,
      "node_id": "LE_lADOABII584yA-tHzwAAAAJn0AeG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10331621254",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T09:30:26Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 10331639639,
      "node_id": "UNLE_lADOABII584yA-tHzwAAAAJn0E9X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10331639639",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T09:31:51Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T11:23:14Z",
      "updated_at": "2023-09-11T11:23:14Z",
      "source": {
        "issue": {
          "id": 1886408410,
          "node_id": "PR_kwDOABII585Zz1qR",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28429",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28429/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28429/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28429/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28429",
          "number": 28429,
          "state": "open",
          "state_reason": null,
          "title": "Do not log p2p bip61 reject messages, improve log, add tests",
          "body": "...per the IRC discussion around https://www.erisian.com.au/bitcoin-core-dev/log-2023-09-03.html#l-345.\r\n\r\nRationale for not logging the bip61 reject messages (as unknown commands):\r\n\r\n- they are not unknown and were valid before v20; see ##15437\r\n\r\n- peers have been observed that send a high number of these messages (I've seen 10k-20k messages per day from a single peer), thereby flooding the log when `-debug=net`\r\n\r\n- another option would be to continue logging bip61 reject messages, but with the `trace` log level instead\r\n\r\nRationale for improving the log output when receiving unknown commands:\r\n\r\n- logging only a peer id isn't of much help after the fact in understanding the source of the message and debugging what/why\r\n\r\n",
          "user": {
            "login": "jonatack",
            "id": 2415484,
            "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonatack",
            "html_url": "https://github.com/jonatack",
            "followers_url": "https://api.github.com/users/jonatack/followers",
            "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
            "organizations_url": "https://api.github.com/users/jonatack/orgs",
            "repos_url": "https://api.github.com/users/jonatack/repos",
            "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonatack/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28429",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28429",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28429.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28429.patch"
          },
          "created_at": "2023-09-07T18:46:55Z",
          "updated_at": "2023-09-13T16:00:09Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T12:27:48Z",
      "updated_at": "2023-09-11T12:27:48Z",
      "source": {
        "issue": {
          "id": 1741612382,
          "node_id": "PR_kwDOABII585SL5TZ",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27826",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27826/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27826/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27826/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27826",
          "number": 27826,
          "state": "open",
          "state_reason": null,
          "title": "validation: log which peer sent us a header",
          "body": "Fixes #27744\r\n\r\nSince #27278 we log received headers. For compact blocks we also log which peer sent it (e5ce8576349d404c466b2f4cab1ca7bf920904b2), but not for regular headers. That required an additional refactor, which this PR provides.\r\n\r\nMove the logging from validation to net_processing.\r\n\r\nThis also reduces the number of log entries (under default configuration) per compact block header from 3 to 2: one for the header and one for the connected tip.\r\n\r\nThe PR introduces a new helper method `LogBlockHeader`.\r\n\r\nWhen receiving a _compact block_ we call `LogBlockHeader` from the exact same place as where we previously logged. So that log message doesn't change. What does change is that we no longer _also_ log from `AcceptBlockHeader`.\r\n\r\nWhen receiving a regular header(s) message, _we only log the last one_. This is a change in behaviour because it was simpler to implement, but it's probably better anyway. It does mean that if a peer sends of a bunch of headers of which _any_ is invalid, we won't log it (here).\r\n\r\nLastly I expanded the code comment explaining why we log this. It initially only covered selfish mining, but we also care about peers sending us headers but not following up (see e.g. #27626).\r\n\r\nExample log:\r\n\r\n```\r\n2023-06-05T13:12:21Z Saw new header hash=000000000000000000045910263ef84b575ae3af151865238f1e5c619e69c330 height=792964 peer=0\r\n2023-06-05T13:12:23Z UpdateTip: new best=000000000000000000045910263ef84b575ae3af151865238f1e5c619e69c330 height=792964 version=0x20000000 log2_work=94.223098 tx=848176824 date='2023-06-05T13:11:49Z' progress=1.000000 cache=6.4MiB(54615txo)\r\n2023-06-05T13:14:05Z Saw new cmpctblock header hash=00000000000000000003c6fd4ef2e1246a3f9e1fffab7247344f94cadb9de979 height=792965 peer=0\r\n2023-06-05T13:14:05Z UpdateTip: new best=00000000000000000003c6fd4ef2e1246a3f9e1fffab7247344f94cadb9de979 height=792965 version=0x20000000 log2_work=94.223112 tx=848179461 date='2023-06-05T13:13:58Z' progress=1.000000 cache=7.2MiB(61275txo)\r\n2023-06-05T13:14:41Z Saw new header hash=000000000000000000048e6d69c8399992782d08cb57f5d6cbc81a9f996c3f43 height=792966 peer=8\r\n2023-06-05T13:14:42Z UpdateTip: new best=000000000000000000048e6d69c8399992782d08cb57f5d6cbc81a9f996c3f43 height=792966 version=0x2db3c000 log2_work=94.223126 tx=848182944 date='2023-06-05T13:14:35Z' progress=1.000000 cache=8.0MiB(69837txo)\r\n```",
          "user": {
            "login": "Sjors",
            "id": 10217,
            "node_id": "MDQ6VXNlcjEwMjE3",
            "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/Sjors",
            "html_url": "https://github.com/Sjors",
            "followers_url": "https://api.github.com/users/Sjors/followers",
            "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
            "organizations_url": "https://api.github.com/users/Sjors/orgs",
            "repos_url": "https://api.github.com/users/Sjors/repos",
            "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/Sjors/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27826",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27826",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27826.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27826.patch"
          },
          "created_at": "2023-06-05T11:53:28Z",
          "updated_at": "2023-10-09T09:09:24Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T18:09:56Z",
      "updated_at": "2023-09-11T18:09:56Z",
      "source": {
        "issue": {
          "id": 1471685707,
          "node_id": "PR_kwDOABII585EFGFt",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26621",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26621/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26621/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26621/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26621",
          "number": 26621,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: Continue moving application data from CNode to Peer",
          "body": "This PR picks up a subset of changes from #24970 and additionally moves `m_bip152_highbandwith{to,from}`, `nTimeOffset`, `nVersion`, `m_greates_common_version`.",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 17,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26621",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26621",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26621.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26621.patch"
          },
          "closed_at": "2023-09-28T20:06:13Z",
          "created_at": "2022-12-01T17:26:32Z",
          "updated_at": "2023-09-28T20:06:13Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10342895041,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAJofA3B",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10342895041",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T07:44:52Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T22:09:18Z",
      "updated_at": "2023-09-12T22:09:18Z",
      "source": {
        "issue": {
          "id": 1893223976,
          "node_id": "PR_kwDOABII585aKu0D",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28463",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28463/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28463/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28463/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28463",
          "number": 28463,
          "state": "open",
          "state_reason": null,
          "title": "p2p: Increase inbound capacity for block-relay only connections",
          "body": "This is joint work with amitiuttarwar.\r\n\r\n**Current PR: #28464** with the first few commits, I will keep this in draft for now.\r\n\r\nSee issue #28462 for a broader discussion on increasing the number of block-relay-only connections independent of this particular implementation proposal.\r\n\r\nWe suggest to increase the number of inbound slots allocated to block-relay-only peers by increasing the default maximum connections from 125 to 200, with 60% of inbound slots accessible for tx-relaying peers.\r\nThis is a prerequisite for being able to increase the default number of outgoing block-relay-only peers later, because the current inbound capacity of the network is not sufficient.\r\nIn order to account for incoming tx-relaying peers separately from incoming block-relay peers, changes to the inbound eviction logic are necessary.\r\n\r\nSee the next post in this thread for a more detailed explanation and motivation of the changes.\r\n\r\n### TODOs\r\n*  add test coverage for the new `-inboundrelaypercent` parameter\r\n",
          "user": {
            "login": "mzumsande",
            "id": 48763452,
            "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
            "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/mzumsande",
            "html_url": "https://github.com/mzumsande",
            "followers_url": "https://api.github.com/users/mzumsande/followers",
            "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
            "organizations_url": "https://api.github.com/users/mzumsande/orgs",
            "repos_url": "https://api.github.com/users/mzumsande/repos",
            "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/mzumsande/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 6,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28463",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28463",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28463.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28463.patch"
          },
          "created_at": "2023-09-12T20:36:39Z",
          "updated_at": "2023-10-18T18:04:24Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGUyZmJmMjAxOTNhNzliOGFjNzA2NDY4YzZmYjgwM2FhYzc1OGU3OTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e2fbf20193a79b8ac706468c6fb803aac758e798",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e2fbf20193a79b8ac706468c6fb803aac758e798",
      "tree": {
        "sha": "5861d4d451f045e74dbaf692ec175d7eb424a231",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5861d4d451f045e74dbaf692ec175d7eb424a231"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d27b63575717e3932238134a71334f3560d4328",
          "sha": "9d27b63575717e3932238134a71334f3560d4328",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9d27b63575717e3932238134a71334f3560d4328"
        }
      ],
      "message": "Respond to a reconciliation request\n\nWhen the time comes, we should send a sketch of our\nlocal reconciliation set to the reconciliation initiator.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:31:14Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T15:36:08Z"
      },
      "sha": "e2fbf20193a79b8ac706468c6fb803aac758e798"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg5MzEyYWI4MjRlMmU2NDNlMjAwNzg5MzYzMTY0YWIwNDA1ZjUxZGI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89312ab824e2e643e200789363164ab0405f51db",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/89312ab824e2e643e200789363164ab0405f51db",
      "tree": {
        "sha": "ddee95523abe4f84842f33ce1f83a2828580e4cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ddee95523abe4f84842f33ce1f83a2828580e4cc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e2fbf20193a79b8ac706468c6fb803aac758e798",
          "sha": "e2fbf20193a79b8ac706468c6fb803aac758e798",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e2fbf20193a79b8ac706468c6fb803aac758e798"
        }
      ],
      "message": "p2p: Add a function to identify local/remote missing txs\n\nWhen the sketches from both sides are combined successfully,\nthe diff is produced. Then this diff can (together with the local txs)\nbe used to identified which transactions are missing locally and remotely.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:31:15Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T13:09:06Z"
      },
      "sha": "89312ab824e2e643e200789363164ab0405f51db"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRhYjE2MDkwZWFkMTBlODRlNTM2M2RkZGU0MzM1ZGJhZThjN2I3ZGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dab16090ead10e84e5363ddde4335dbae8c7b7dc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/dab16090ead10e84e5363ddde4335dbae8c7b7dc",
      "tree": {
        "sha": "eb313ac88dd267166cf820b35fec65d5de3cd5a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eb313ac88dd267166cf820b35fec65d5de3cd5a8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89312ab824e2e643e200789363164ab0405f51db",
          "sha": "89312ab824e2e643e200789363164ab0405f51db",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/89312ab824e2e643e200789363164ab0405f51db"
        }
      ],
      "message": "Use txid/uint256 in CompareInvMempoolOrder\n\nThis will help to reuse the code later on in the function\nto announce transactions.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:31:15Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-06-24T06:23:59Z"
      },
      "sha": "dab16090ead10e84e5363ddde4335dbae8c7b7dc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJlZGMxNDFhMmFhYWY2NTIwMDMxOWJhOWVkNGRjMzlkMGY3OTQ1NmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2edc141a2aaaf65200319ba9ed4dc39d0f79456b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2edc141a2aaaf65200319ba9ed4dc39d0f79456b",
      "tree": {
        "sha": "6e076dc3d104bc4cf0c433e856cf19bf6987dd9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6e076dc3d104bc4cf0c433e856cf19bf6987dd9a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dab16090ead10e84e5363ddde4335dbae8c7b7dc",
          "sha": "dab16090ead10e84e5363ddde4335dbae8c7b7dc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/dab16090ead10e84e5363ddde4335dbae8c7b7dc"
        }
      ],
      "message": "p2p: Handle reconciliation sketch and successful decoding",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:33:46Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-11-11T09:23:11Z"
      },
      "sha": "2edc141a2aaaf65200319ba9ed4dc39d0f79456b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGMyMjdiYTIzZjc0YzRiODc2N2U5NDJkOTliMWUxZDZlYzg3MmJjYTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c227ba23f74c4b8767e942d99b1e1d6ec872bca8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c227ba23f74c4b8767e942d99b1e1d6ec872bca8",
      "tree": {
        "sha": "f01ba977925156e0e1d7b5b50473a07c97c90ea4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f01ba977925156e0e1d7b5b50473a07c97c90ea4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2edc141a2aaaf65200319ba9ed4dc39d0f79456b",
          "sha": "2edc141a2aaaf65200319ba9ed4dc39d0f79456b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2edc141a2aaaf65200319ba9ed4dc39d0f79456b"
        }
      ],
      "message": "p2p: Request extension if decoding failed\n\nIf after decoding a reconciliation sketch it turned out\nto be insufficient to find set difference, request extension.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:33:58Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T18:31:33Z"
      },
      "sha": "c227ba23f74c4b8767e942d99b1e1d6ec872bca8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhkYzRjZDIyMzg4ZDQzYjM3YjBlMzMwMGJhOGM3ZWRjZmEyM2NhNzQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8dc4cd22388d43b37b0e3300ba8c7edcfa23ca74",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8dc4cd22388d43b37b0e3300ba8c7edcfa23ca74",
      "tree": {
        "sha": "db6d1c020ecbcdb795ec47601f160cd41a94aeee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/db6d1c020ecbcdb795ec47601f160cd41a94aeee"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c227ba23f74c4b8767e942d99b1e1d6ec872bca8",
          "sha": "c227ba23f74c4b8767e942d99b1e1d6ec872bca8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c227ba23f74c4b8767e942d99b1e1d6ec872bca8"
        }
      ],
      "message": "Be ready to receive sketch extension\n\nStore the initial sketches so that we are able to process\nextension sketch while avoiding transmitting the same data.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:33:59Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T18:41:09Z"
      },
      "sha": "8dc4cd22388d43b37b0e3300ba8c7edcfa23ca74"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE2ZTRhMTMzNzI5Nzk3MWFkZjBhOWM4MDgzNDU3Y2I0ZmZmZDFjOTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6e4a1337297971adf0a9c8083457cb4fffd1c92",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a6e4a1337297971adf0a9c8083457cb4fffd1c92",
      "tree": {
        "sha": "1da258061eef4b986d2179604de15159fad8556e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1da258061eef4b986d2179604de15159fad8556e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8dc4cd22388d43b37b0e3300ba8c7edcfa23ca74",
          "sha": "8dc4cd22388d43b37b0e3300ba8c7edcfa23ca74",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8dc4cd22388d43b37b0e3300ba8c7edcfa23ca74"
        }
      ],
      "message": "p2p: Prepare for sketch extension request\n\nTo be ready to respond to a sketch extension request\nfrom our peer, we should store a snapshot of our state\nand capacity of the initial sketch, so that we compute\nextension of the same size and over the exact same\ntransactions.\n\nTransactions arriving during this reconciliation will\nbe instead stored in the regular set.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:33:59Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T20:35:45Z"
      },
      "sha": "a6e4a1337297971adf0a9c8083457cb4fffd1c92"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQxYjMzMjVkMTZlMzk3NGE0NTFlMWE1YjIxZDhkMWM0NjE5ZWMzY2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/41b3325d16e3974a451e1a5b21d8d1c4619ec3cb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/41b3325d16e3974a451e1a5b21d8d1c4619ec3cb",
      "tree": {
        "sha": "fd6ca6f9ff33d5a68180e87ac3bfb702bc8f9d5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fd6ca6f9ff33d5a68180e87ac3bfb702bc8f9d5c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6e4a1337297971adf0a9c8083457cb4fffd1c92",
          "sha": "a6e4a1337297971adf0a9c8083457cb4fffd1c92",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a6e4a1337297971adf0a9c8083457cb4fffd1c92"
        }
      ],
      "message": "p2p: Keep track of announcements during txrcncl extension",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:33:59Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-07-29T18:37:03Z"
      },
      "sha": "41b3325d16e3974a451e1a5b21d8d1c4619ec3cb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRiNjcxYzYzY2NhYjg5ZDM2YTYyODE5NmEwNTdmODk1MTRlMDI1ZmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db671c63ccab89d36a628196a057f89514e025fb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/db671c63ccab89d36a628196a057f89514e025fb",
      "tree": {
        "sha": "ebdb3367948a828cf103a6b0267aa44bcda48b69",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ebdb3367948a828cf103a6b0267aa44bcda48b69"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/41b3325d16e3974a451e1a5b21d8d1c4619ec3cb",
          "sha": "41b3325d16e3974a451e1a5b21d8d1c4619ec3cb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/41b3325d16e3974a451e1a5b21d8d1c4619ec3cb"
        }
      ],
      "message": "p2p: Handle reconciliation extension request\n\nIf peer failed to reconcile based on our initial response sketch,\nthey will ask us for a sketch extension. Store this request to respond later.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:36:40Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T20:36:54Z"
      },
      "sha": "db671c63ccab89d36a628196a057f89514e025fb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ0YjgzZGJiYzhlOWEzZGRlZGFiYzU0ZGFjODYyMjZlNzU5NWU1M2E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/44b83dbbc8e9a3ddedabc54dac86226e7595e53a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/44b83dbbc8e9a3ddedabc54dac86226e7595e53a",
      "tree": {
        "sha": "da165e43db98f8c09fa2274e6353fc26d23066a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/da165e43db98f8c09fa2274e6353fc26d23066a4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db671c63ccab89d36a628196a057f89514e025fb",
          "sha": "db671c63ccab89d36a628196a057f89514e025fb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/db671c63ccab89d36a628196a057f89514e025fb"
        }
      ],
      "message": "p2p: Respond to sketch extension request\n\nSending an extension may allow the peer to reconcile\ntransactions, because now the full sketch has twice\nas much capacity.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:36:41Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T20:41:40Z"
      },
      "sha": "44b83dbbc8e9a3ddedabc54dac86226e7595e53a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE0YjJlYWM5MzQ3ZmFhYWQ1OTQ4NzU2NTFiMDMwZmUxYWZhODQ3NDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/14b2eac9347faaad594875651b030fe1afa84743",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/14b2eac9347faaad594875651b030fe1afa84743",
      "tree": {
        "sha": "549368317fd3965618a6d2f583968f9dfd8ba611",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/549368317fd3965618a6d2f583968f9dfd8ba611"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/44b83dbbc8e9a3ddedabc54dac86226e7595e53a",
          "sha": "44b83dbbc8e9a3ddedabc54dac86226e7595e53a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/44b83dbbc8e9a3ddedabc54dac86226e7595e53a"
        }
      ],
      "message": "Handle sketch extension\n\nIf a peer sent us an extension sketch, we should\nreconstruct a full sketch from it with the snapshot\nwe stored initially, and attempt to decode the difference.\n\np2p: Handle sketch extension\n\nIf a peer sent us an extension sketch, we should\nreconstruct a full sketch from it with the snapshot\nwe stored initially, and attempt to decode the difference.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:36:41Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T20:47:16Z"
      },
      "sha": "14b2eac9347faaad594875651b030fe1afa84743"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIxMWEwNTIxOWE1ZDM5MzBhOGY0ODg2MjljODc0NThmZGMwMGVmMjU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b11a05219a5d3930a8f488629c87458fdc00ef25",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b11a05219a5d3930a8f488629c87458fdc00ef25",
      "tree": {
        "sha": "a5cd0d412d22f26aa14dada48e8f38f7c244265b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a5cd0d412d22f26aa14dada48e8f38f7c244265b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/14b2eac9347faaad594875651b030fe1afa84743",
          "sha": "14b2eac9347faaad594875651b030fe1afa84743",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/14b2eac9347faaad594875651b030fe1afa84743"
        }
      ],
      "message": "p2p: Add a finalize incoming reconciliation function\n\nThis currently unused function is supposed to be used once\na reconciliation round is done. It cleans the state corresponding\nto the passed reconciliation.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:58:29Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-25T13:07:43Z"
      },
      "sha": "b11a05219a5d3930a8f488629c87458fdc00ef25"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDYyNjQ3ZDlhM2MzN2IzNWEwMDk4ODVlNmJhZTA5NTdmNDNkYTdiMmY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/62647d9a3c37b35a009885e6bae0957f43da7b2f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/62647d9a3c37b35a009885e6bae0957f43da7b2f",
      "tree": {
        "sha": "7ffc09affb89df4ff92f0db52460488aa35b6d83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7ffc09affb89df4ff92f0db52460488aa35b6d83"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b11a05219a5d3930a8f488629c87458fdc00ef25",
          "sha": "b11a05219a5d3930a8f488629c87458fdc00ef25",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b11a05219a5d3930a8f488629c87458fdc00ef25"
        }
      ],
      "message": "Handle reconciliation finalization message\n\nOnce a peer tells us reconciliation is done, we should behave as follows:\n- if it was successful, just respond them with the transactions they asked\n  by short ID.\n- if it was a full failure, respond with all local transactions from the reconciliation\n  set snapshot\n- if it was a partial failure (only low or high part was failed after a bisection),\n  respond with all transactions which were asked for by short id,\n  and announce local txs which belong to the failed chunk.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-13T10:58:30Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-02-26T10:29:31Z"
      },
      "sha": "62647d9a3c37b35a009885e6bae0957f43da7b2f"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10358136437,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAJpZJ51",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10358136437",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T10:59:39Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T14:35:50Z",
      "updated_at": "2023-09-13T14:35:50Z",
      "source": {
        "issue": {
          "id": 1789806361,
          "node_id": "PR_kwDOABII585Ut7YI",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28031",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28031/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28031/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28031/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28031",
          "number": 28031,
          "state": "open",
          "state_reason": null,
          "title": "Package Relay 1/3: Introduce TxDownloadManager and improve orphan-handling",
          "body": "This is milestone 1 of package relay p2p changes. See #27463 for full project tracking.\r\n\r\nPlease see #27742 for how this PR fits into the big picture. I strongly suggest that reviewers look at that PR first to decide if they are comfortable with the overall approach.\r\n\r\nThis PR is mainly refactors, with a few behavior changes and improvements:\r\n- Introduces `TxDownloadManager`, which handles all transaction downloading. It contains the `TxRequestTracker`, `TxOrphanage`, and filters for `AlreadyHaveTx`.\r\n- Updates logs for tx {validation, relay, orphans} to include both txid and wtxid when possible.\r\n- Adds a new log category, `TXPACKAGES`. Logging in the orphanage is changed from `MEMPOOL` to `TXPACKAGES`.\r\n- Adds support for tracking when multiple peers provided the same tx in the orphanage.\r\n- Makes `TxDownloadManager` responsible for tracking the orphans we need to resolve and deciding how/when to resolve them.\r\n- Adds all announcers of an orphan as potential resolution candidates. This tracker is a `TxDownloadManager` which helps us schedule requests.\r\n   - In this PR, \"orphan resolution\" means requesting missing parents by `getdata(MSG_TX | MSG_WITNESS_FLAG, missing_txid)`.\r\n    - In a future PR, we'll add another resolution method, requesting ancestor wtxids using `getdata(MSG_ANCPKGINFO, orphan_wtxid)`.",
          "user": {
            "login": "glozow",
            "id": 25183001,
            "node_id": "MDQ6VXNlcjI1MTgzMDAx",
            "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/glozow",
            "html_url": "https://github.com/glozow",
            "followers_url": "https://api.github.com/users/glozow/followers",
            "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
            "organizations_url": "https://api.github.com/users/glozow/orgs",
            "repos_url": "https://api.github.com/users/glozow/repos",
            "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/glozow/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            },
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28031",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28031",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28031.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28031.patch"
          },
          "created_at": "2023-07-05T15:30:40Z",
          "updated_at": "2023-10-17T14:04:32Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI0ODI0ZWM2YzQ4N2I2YzFmZmM2NjNiY2NiNDU1ZWE3MDBlOTA1MDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4824ec6c487b6c1ffc663bccb455ea700e90508",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b4824ec6c487b6c1ffc663bccb455ea700e90508",
      "tree": {
        "sha": "598b5fda85e57af677f1dde544e8e1f403619d68",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/598b5fda85e57af677f1dde544e8e1f403619d68"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/62647d9a3c37b35a009885e6bae0957f43da7b2f",
          "sha": "62647d9a3c37b35a009885e6bae0957f43da7b2f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/62647d9a3c37b35a009885e6bae0957f43da7b2f"
        }
      ],
      "message": "p2p, test: Add tx reconciliation functional tests",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-14T07:04:52Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-07-06T07:09:30Z"
      },
      "sha": "b4824ec6c487b6c1ffc663bccb455ea700e90508"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNlMDhkYWI1NmIxMTFkNDg5NzBkYzE5YmQ3NzFiYTk2YzczNTA2YjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3e08dab56b111d48970dc19bd771ba96c73506b1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3e08dab56b111d48970dc19bd771ba96c73506b1",
      "tree": {
        "sha": "85d4b49db335dd4e039d9eca0fa6a12f3c010bad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/85d4b49db335dd4e039d9eca0fa6a12f3c010bad"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4824ec6c487b6c1ffc663bccb455ea700e90508",
          "sha": "b4824ec6c487b6c1ffc663bccb455ea700e90508",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b4824ec6c487b6c1ffc663bccb455ea700e90508"
        }
      ],
      "message": "test: Update mempool_packages.py test for reconciliation\n\nFirst, extend the timeout to facilitate reconciliation\nrelay which might take longer than previously.\n\nSecond, since reconciliation can't guarantee that\ndescendants of same-degree (from the parent) are\nrelayed in the same order they were received, loosen\nthe check for descendant limit.\nThis is the case because, if the parent is flooded,\nthe children might be both flooded and reconciled,\nand the decision is made independently. So even if\none arrived earlier, it can be relayed later because\nflooding.\nNote, it's possible to make txreconciliation.cpp be aware\nof the order of adding transactions to the set, but this\nwon't help to solve the above issue.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-09-14T07:04:53Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-08-07T09:08:49Z"
      },
      "sha": "3e08dab56b111d48970dc19bd771ba96c73506b1"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10368106879,
      "node_id": "HRFPE_lADOABII584yA-tHzwAAAAJp_MF_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10368106879",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-14T07:06:07Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-06T02:15:07Z",
      "updated_at": "2023-10-06T02:15:07Z",
      "source": {
        "issue": {
          "id": 1928485631,
          "node_id": "I_kwDOABII585y8lr_",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28599",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28599/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28599/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28599/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/28599",
          "number": 28599,
          "state": "closed",
          "state_reason": "completed",
          "title": "Gathering Priorities for 27.0",
          "body": "Please nominate projects that could become priorities for the next ~6 months (until the 27.0 release). We (frequent contributors) will vote on which projects will be priorities next week in a separate issue.\r\n\r\nProject priorities are those which the frequent contributors to this project have voted on to have more focused review on for the next ~6 months. This issue is to list what projects are ongoing that can be voted on. Voting will occur in a separate issue that will be opened next week.\r\n\r\nNominations will close at the start of the IRC meeting on October 12th at 14:00 UTC. The issue for voting will be opened at that time as well.\r\n\r\nNominations and voting is limited to those who are part of the bitcoin github organization. Comments in this issue from those outside of the organization will be ignored, and may be deleted. If you are not part of the organization and believe that you should be, please send me an email or message me on IRC.\r\n\r\nInitial list from recent CoreDev:\r\n\r\n* Multiprocess #10102 \r\n* Silent payments #28536\r\n* Package Relay #27463\r\n* Legacy wallet (BDB) removal #20160\r\n* Erlay #21515\r\n* Cmake #28607\r\n* Kernel #27587\r\n* Logging Migration #25203\r\n* Stratum V2 #27854\r\n* Cluster mempool #27677\r\n\r\nAssumeUTXO and BIP 324 were on this list originally, but they seem to be done now?",
          "user": {
            "login": "achow101",
            "id": 3782274,
            "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/achow101",
            "html_url": "https://github.com/achow101",
            "followers_url": "https://api.github.com/users/achow101/followers",
            "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
            "organizations_url": "https://api.github.com/users/achow101/orgs",
            "repos_url": "https://api.github.com/users/achow101/repos",
            "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/achow101/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 6,
          "closed_at": "2023-10-12T13:59:10Z",
          "created_at": "2023-10-05T14:49:25Z",
          "updated_at": "2023-10-12T13:59:11Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-12T13:58:35Z",
      "updated_at": "2023-10-12T13:58:35Z",
      "source": {
        "issue": {
          "id": 1940066390,
          "node_id": "I_kwDOABII585zoxBW",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28642",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28642/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28642/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28642/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/28642",
          "number": 28642,
          "state": "open",
          "state_reason": null,
          "title": "Voting on Priority Projects for 27.0",
          "body": "Please leave your votes for project priorities for the next ~6 months (until the 27.0 feature freeze).\r\n\r\nProject priorities are those which the frequent contributors to this project have voted on to have more focused review on until the next feature freeze (or until they are completed). They will become permanent topics in our weekly IRC meetings so that we can get updates on the progress of each project and determine the next step to move them forward.\r\n\r\nVoting will close at the start of the IRC meeting on October 19th at 14:00 UTC. To vote, please leave a comment containing the three projects from the list below that you would like to be the priority projects. The priority projects will be the three with the most votes.\r\n\r\nVoting is limited to those who are part of the bitcoin github organization. Comments in this issue from those outside of the organization will be ignored, and may be deleted. If you are not part of the organization and believe that you should be, please send me an email or message me on IRC.\r\n\r\nThe projects to vote on are:\r\n* Multiprocess #10102 \r\n* Silent payments #28536\r\n* Package Relay #27463\r\n* Legacy wallet (BDB) removal #20160\r\n* Erlay #28646\r\n* Cmake #28607\r\n* ~~Kernel #27587~~ (removed by request of the author)\r\n* ~~Logging Migration #25203~~ (removed by request of the author)\r\n* Stratum V2 #27854\r\n* ~~cluster mempool #27677~~ (removed by request of the author)",
          "user": {
            "login": "achow101",
            "id": 3782274,
            "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/achow101",
            "html_url": "https://github.com/achow101",
            "followers_url": "https://api.github.com/users/achow101/followers",
            "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
            "organizations_url": "https://api.github.com/users/achow101/orgs",
            "repos_url": "https://api.github.com/users/achow101/repos",
            "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/achow101/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 28,
          "created_at": "2023-10-12T13:58:35Z",
          "updated_at": "2023-10-18T13:48:29Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-13T08:55:31Z",
      "updated_at": "2023-10-13T08:55:31Z",
      "source": {
        "issue": {
          "id": 1941535143,
          "node_id": "I_kwDOABII585zuXmn",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28646",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28646/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28646/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28646/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/28646",
          "number": 28646,
          "state": "open",
          "state_reason": null,
          "title": "Erlay Project Tracking",
          "body": "This issue will be edited frequently to reflect the current status of the project.\r\n\r\n**What should I review now?**\r\n👇 👇 👇 👇 👇 👇 👇\r\n#26283 \r\n☝️ ☝️ ☝️ ☝️ ☝️ ☝️ ☝️\r\n\r\n- [x] Minisketch in Bitcoin Core\r\n    - [x] Main feature: #23114\r\n    - [x] #23670\r\n    - [x] #23496\r\n    - [x] #26272\r\n    - [x] Subtree updates: #24262, #25502, #26373\r\n- [ ] Peer-to-peer\r\nFull implementation: #21515 \r\n    - [x] Main feature: #23443 \r\n    - [x] Follow-up: #26359\r\n    - [x] #27797 \r\n    - [ ] Main feature: #26283\r\n    - [ ] Main feature: Tx reconciliation response (sending and handling)\r\n    - [ ] Main feature: Tx reconciliation extension request\r\n    - [ ] Main feature: Tx reconciliation extension response (sending and handling)\r\n    - [ ] Test: Full integration functional test \r\n\r\n**Performance research results**\r\n- [How to understand bandwidth savings](https://github.com/naumenkogs/txrelaysim/issues/7)\r\n- @kcalvinalvin [40% announcement-related bandwidth reduction](https://github.com/naumenkogs/txrelaysim/issues/8#issuecomment-1016075657)\r\n- @0xB10C [31.3% overall bandwidth reduction](https://github.com/naumenkogs/txrelaysim/issues/8#issuecomment-920852514)\r\n- @hebasto: [23.8% overall bandwidth reduction](https://github.com/naumenkogs/txrelaysim/issues/8#issuecomment-1016307869)\r\n- @hebasto: [0.9% overall bandwidth overhead for running 12 connections instead of 8](https://github.com/naumenkogs/txrelaysim/issues/8#issuecomment-1018834268)\r\n- my older experiments — note the current version is less efficient (needed for better security)\r\n    - 8 conns [overall 40% bandwidth savings](https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-599241490)\r\n    - 16 conns [1.8x erlay; 2.23x non-erlay — overall bandwidth increase compared to 8 conns](https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-600388543)\r\n\r\n**Supplementary materials**\r\n[BIP 330](https://github.com/bitcoin/bips/blob/master/bip-0330.mediawiki)\r\n[erlay paper](https://arxiv.org/pdf/1905.10518.pdf)\r\n[minisketch repo](https://github.com/sipa/minisketch)\r\nAncient PR: #18261\r\nNotes from the review club: [on the main PR](https://bitcoincore.reviews/18261), [on the support signaling PR](https://bitcoincore.reviews/23443).\r\n\r\n<details><summary><b>F.A.Q.</b></summary>\r\n<i>1. Are these bandwidth savings worth the added code complexity?</i>\r\n\r\nThe project has received Concept ACK from many contributors, and no NACKs. I am unlikely to invent a bulletproof argument, so I leave it up to each reviewer to compare the risks and review costs to the benefits.\r\n\r\nI personally think that the added code is pretty straightforward because it communicates with a legacy code through a thin interface (100 LOC in `net_processing.cpp` to collect transactions instead of relaying them immediately, although the reconciliation code is 500 LOC -- excluding comments and minisketch). Hence it is acceptable to pay for the given optimization.\r\n\r\nIf you suggest any experiment that will convince you, I will do my best to execute it.\r\n\r\n</details>",
          "user": {
            "login": "naumenkogs",
            "id": 7975071,
            "node_id": "MDQ6VXNlcjc5NzUwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/naumenkogs",
            "html_url": "https://github.com/naumenkogs",
            "followers_url": "https://api.github.com/users/naumenkogs/followers",
            "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
            "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
            "repos_url": "https://api.github.com/users/naumenkogs/repos",
            "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 0,
          "created_at": "2023-10-13T08:55:30Z",
          "updated_at": "2023-10-13T08:58:57Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-18T23:02:26Z",
      "updated_at": "2023-10-18T23:02:26Z",
      "source": {
        "issue": {
          "id": 1950437953,
          "node_id": "PR_kwDOABII585dLamZ",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28676",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28676/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28676/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28676/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28676",
          "number": 28676,
          "state": "open",
          "state_reason": null,
          "title": "[WIP] Cluster mempool implementation",
          "body": "This is a draft implementation of the cluster mempool design described in #27677.  I'm opening this as a draft PR now to share the branch I'm working on with others, so that we can start to think about in-progress projects (like package relay, package validation, and package rbf) in the context of this design.  Also, I can use some help from others for parts of this work, including the interaction between the mempool and the wallet, and also reworking some of our existing test cases to fit a cluster-mempool world.\r\n\r\nNote that the design of this implementation is subject to change as I continue to iterate on the code (to make the code more hygienic and robust, in particular). At this point though I think the performance is pretty reasonable and I'm not currently aware of any bugs.  There are some microbenchmarks added here, and some improved fuzz tests; it would be great if others ran both of those on their own hardware as well and reported back on any findings.\r\n\r\nThis branch implements the following observable behavior changes:\r\n\r\n- Maintains a partitioning of the mempool into connected clusters\r\n- Each cluster is sorted (\"linearized\") either using an optimal sort, or an ancestor-feerate-based one, depending on the size of the cluster (thanks to @sipa for this logic)\r\n- Transaction selection for mining is updated to use the cluster linearizations\r\n- Mempool eviction is updated to use the cluster linearizations\r\n- The RBF rules are updated to drop the requirement that no new inputs are introduced, and to change the feerate requirement to instead check that the mining score of a replacement transaction exceed the mining score of the conflicted transactions\r\n- The CPFP carveout rule is eliminated (it doesn't make sense in a cluster-limited mempool)\r\n- The ancestor and descendant limits are no longer enforced.\r\n- New cluster count/cluster vsize limits are now enforced instead.\r\n\r\nSome less observable behavior changes:\r\n- The cached ancestor and descendant data are dropped from the mempool, along with the multi_index indices that were maintained to sort the mempool by ancestor and descendant feerates. For compatibility (eg with wallet behavior or RPCs exposing this), this information is now calculated dynamically instead.\r\n- The ancestor and descendant walking algorithms are now implemented using `epoch`s (resulting in a significant performance improvement, according to the benchmarks I've looked at)\r\n\r\nStill to do:\r\n\r\n- [ ] More comparisons between this branch and master on historical data to compare validation speed (accepting loose transactions, processing RBF transactions, validating a block/postprocessing, updating the mempool for a reorg).\r\n- [ ] More historical data analysis to try to evaluate the likely impact of setting the cluster size limits to varying values (to motivate what values we should ultimately pick)\r\n- [ ] Updating wallet code to be cluster-aware (including mini_miner and coin selection)\r\n- [ ] Rework many of our functional tests to be cluster-aware\r\n- [ ] Figure out what package validation and package RBF rules should be in this design\r\n\r\nFor discussion/feedback:\r\n\r\n - How significant is it to be dropping the CPFP carveout rule?  Does that affect how we will ultimately want to stage new mempool deployment?\r\n - How well do the proposed RBF rules meet everyone's use cases?\r\n - What design improvements can we make to the cluster tracking implementation?",
          "user": {
            "login": "sdaftuar",
            "id": 7463573,
            "node_id": "MDQ6VXNlcjc0NjM1NzM=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sdaftuar",
            "html_url": "https://github.com/sdaftuar",
            "followers_url": "https://api.github.com/users/sdaftuar/followers",
            "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
            "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
            "repos_url": "https://api.github.com/users/sdaftuar/repos",
            "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 1,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28676",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28676",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28676.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28676.patch"
          },
          "created_at": "2023-10-18T18:59:37Z",
          "updated_at": "2023-10-18T23:02:25Z"
        },
        "type": "issue"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599969335",
      "pull_request_review_id": 619102655,
      "id": 599969335,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTk2OTMzNQ==",
      "diff_hunk": "@@ -0,0 +1,57 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <tuple>",
      "path": "src/txreconciliation.h",
      "position": null,
      "original_position": 11,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623\r\n\r\nnit `#include <memory>` for `std::unique_ptr`.",
      "created_at": "2021-03-23T21:34:00Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599969335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599969335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599974713",
      "pull_request_review_id": 619102655,
      "id": 599974713,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTk3NDcxMw==",
      "diff_hunk": "@@ -0,0 +1,57 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <tuple>\n+#include <unordered_map>",
      "path": "src/txreconciliation.h",
      "position": null,
      "original_position": 12,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623\r\n\r\nMove to txreconciliation.cpp",
      "created_at": "2021-03-23T21:39:09Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599974713",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599974713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599979335",
      "pull_request_review_id": 619102655,
      "id": 599979335,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTk3OTMzNQ==",
      "diff_hunk": "@@ -0,0 +1,59 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d\\n\", peer_id);\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        WITH_LOCK(m_mutex, m_local_salts.emplace(peer_id, m_local_recon_salt));",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623\r\n\r\nLooks like insertion should always happen? If so you could assert `.second` of `emplace()` result. If not, then `GetRand()` could be avoided in case it exists, and below it should return the existing salt.",
      "created_at": "2021-03-23T21:47:10Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599979335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599979335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602929047",
      "pull_request_review_id": 619157940,
      "id": 602929047,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkyOTA0Nw==",
      "diff_hunk": "@@ -52,6 +52,14 @@ class TxReconciliationTracker::Impl {\n \n         return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n     }\n+\n+    void RemovePeer(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        m_local_salts.erase(peer_id);\n+        LogPrint(BCLog::NET, \"Stop tracking reconciliation state for peer=%d.\\n\", peer_id);",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 9,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "3e4022a4a87c91b4b671ab4b71ccbd6d7136bade",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "3e4022a4a87c91b4b671ab4b71ccbd6d7136bade\r\n\r\nCould make this log conditional to whether `peer_id` was erased from `m_local_salts`.",
      "created_at": "2021-03-28T20:35:51Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602929047",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602929047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602930818",
      "pull_request_review_id": 619157940,
      "id": 602930818,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkzMDgxOA==",
      "diff_hunk": "@@ -68,10 +111,48 @@ class TxReconciliationTracker::Impl {\n         return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n     }\n \n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;\n+\n+        // Must match SuggestReconciliation logic.",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "8cdaf385aee34a9a10406eef73d6dcae74b5a2c4",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8cdaf385aee34a9a10406eef73d6dcae74b5a2c4\r\n\r\nShould be \"SuggestReconciling\"?",
      "created_at": "2021-03-28T20:50:59Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602930818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602930818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602941978",
      "pull_request_review_id": 619157940,
      "id": 602941978,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk0MTk3OA==",
      "diff_hunk": "@@ -161,6 +161,17 @@ class TxReconciliationTracker::Impl {\n         LOCK(m_mutex);\n         return m_states.find(peer_id) != m_states.end();\n     }\n+\n+    std::optional<bool> IsPeerChosenForFlooding(NodeId peer_id) const\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) {\n+            return std::nullopt;\n+        }\n+        return (*recon_state).second.m_flood_to;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "49108e38941f7136fafdbfc64a989aba0f1cc99f",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "49108e38941f7136fafdbfc64a989aba0f1cc99f\r\n\r\nnit, `->second`.",
      "created_at": "2021-03-28T22:26:29Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602941978",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602941978"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602943795",
      "pull_request_review_id": 619157940,
      "id": 602943795,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk0Mzc5NQ==",
      "diff_hunk": "@@ -2539,6 +2547,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 38,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "99906e0c3399225ee361ce85291074971d2025e1",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "99906e0c3399225ee361ce85291074971d2025e1\r\n\r\n`IsPeerRegistered` is not needed since `IsPeerChosenForFlooding` returns `nullopt`. Maybe:\r\n```cpp\r\nif (pfrom.MightSupportTransactionRelay()) {\r\n    we_may_flood_to = m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId()).value_or(true);\r\n}\r\n```",
      "created_at": "2021-03-28T22:39:57Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602943795",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602943795"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2665,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603143723",
      "pull_request_review_id": 623031306,
      "id": 603143723,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzE0MzcyMw==",
      "diff_hunk": "@@ -2539,6 +2547,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 38,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "99906e0c3399225ee361ce85291074971d2025e1",
      "in_reply_to_id": 602943795,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I agree this is way cleaner, but I think the current code is easier to understand, so I'm leaning towards my approach.",
      "created_at": "2021-03-29T09:27:57Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603143723",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603143723"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2665,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603144648",
      "pull_request_review_id": 623032451,
      "id": 603144648,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzE0NDY0OA==",
      "diff_hunk": "@@ -2539,6 +2547,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 38,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "99906e0c3399225ee361ce85291074971d2025e1",
      "in_reply_to_id": 602943795,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The problem is that you can hit undefined behavior with the current code - assuming peer can be disconnected between `IsPeerRegistered` and  `IsPeerChosenForFlooding`.\r\n\r\nEdit: Looks like the above is not possible.",
      "created_at": "2021-03-29T09:29:16Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603144648",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603144648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2665,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603200987",
      "pull_request_review_id": 623106592,
      "id": 603200987,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwMDk4Nw==",
      "diff_hunk": "@@ -4552,15 +4554,19 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             }\n             peer->m_blocks_for_inv_relay.clear();\n \n+            const bool supports_recon = m_reconciliation.IsPeerRegistered(pto->GetId());",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 15,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "3692db74f86186789c9dad4005f7b768721d5afe",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "3692db74f86186789c9dad4005f7b768721d5afe\r\n\r\nnit, could move to inner scope.",
      "created_at": "2021-03-29T11:01:03Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603200987",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603200987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4557,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603202580",
      "pull_request_review_id": 623106592,
      "id": 603202580,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwMjU4MA==",
      "diff_hunk": "@@ -154,6 +178,19 @@ class TxReconciliationTracker::Impl {\n             full_salt.GetUint64(1), we_initiate, flood_to));\n     }\n \n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        LOCK(m_mutex);",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 44,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "83a08c5ea07f7f7e3e67501ac8666521427ae9d3",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "83a08c5ea07f7f7e3e67501ac8666521427ae9d3\r\n\r\nnit, `assert(txs_to_reconcile.size() > 0)`",
      "created_at": "2021-03-29T11:04:13Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603202580",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603202580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 656,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603203867",
      "pull_request_review_id": 623106592,
      "id": 603203867,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwMzg2Nw==",
      "diff_hunk": "@@ -154,6 +178,19 @@ class TxReconciliationTracker::Impl {\n             full_salt.GetUint64(1), we_initiate, flood_to));\n     }\n \n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+        for (auto& wtxid: txs_to_reconcile) {\n+            recon_state->second.m_local_set.m_wtxids.insert(wtxid);\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i transactions to the reconciliation set for peer=%d.\\n\",",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 51,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "83a08c5ea07f7f7e3e67501ac8666521427ae9d3",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "83a08c5ea07f7f7e3e67501ac8666521427ae9d3\r\n\r\nCould `m_local_set already` have some of `txs_to_reconcile`? If so maybe we should count successful `.insert()` and log that?",
      "created_at": "2021-03-29T11:06:33Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603203867",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603203867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 190,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603206903",
      "pull_request_review_id": 623106592,
      "id": 603206903,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwNjkwMw==",
      "diff_hunk": "@@ -4622,6 +4629,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                         uint256 hash = vInvTx.back();\n+                        bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 44,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "3692db74f86186789c9dad4005f7b768721d5afe",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "3692db74f86186789c9dad4005f7b768721d5afe\r\n\r\nMove to inner scope, make const.",
      "created_at": "2021-03-29T11:12:08Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603206903",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603206903"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4632,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603207731",
      "pull_request_review_id": 623106592,
      "id": 603207731,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwNzczMQ==",
      "diff_hunk": "@@ -120,6 +120,13 @@ class TxReconciliationTracker::Impl {\n      */\n     std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n \n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set differene size.",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 7,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "05ac9dc21e5697a1e0261909b64de4f7d6e21eb1",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "05ac9dc21e5697a1e0261909b64de4f7d6e21eb1\r\n\r\ntypo \"differene\"",
      "created_at": "2021-03-29T11:13:40Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603207731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603207731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603210177",
      "pull_request_review_id": 623106592,
      "id": 603210177,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIxMDE3Nw==",
      "diff_hunk": "@@ -127,6 +135,16 @@ class TxReconciliationTracker::Impl {\n      */\n     std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n \n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request{0};",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 23,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "e854bcf5391d02a28690f7eedad8382cbb05f85b",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "e854bcf5391d02a28690f7eedad8382cbb05f85b\r\n\r\nAdd TSAN annotation?",
      "created_at": "2021-03-29T11:17:55Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603210177",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603210177"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603210815",
      "pull_request_review_id": 623106592,
      "id": 603210815,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIxMDgxNQ==",
      "diff_hunk": "@@ -127,6 +135,16 @@ class TxReconciliationTracker::Impl {\n      */\n     std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n \n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request{0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 26,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "e854bcf5391d02a28690f7eedad8382cbb05f85b",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "e854bcf5391d02a28690f7eedad8382cbb05f85b\r\n\r\nnit `assert(m_queue.size() > 0)`",
      "created_at": "2021-03-29T11:19:03Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603210815",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603210815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 443,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603214394",
      "pull_request_review_id": 623106592,
      "id": 603214394,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIxNDM5NA==",
      "diff_hunk": "@@ -27,6 +34,14 @@ constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n  */\n constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n \n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum ReconciliationPhase {",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 21,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "476ced6df27c13fd8d1dae46d09b91549977cac1",
      "in_reply_to_id": null,
      "user": {
        "login": "promag",
        "id": 3534524,
        "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/promag",
        "html_url": "https://github.com/promag",
        "followers_url": "https://api.github.com/users/promag/followers",
        "following_url": "https://api.github.com/users/promag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/promag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/promag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
        "organizations_url": "https://api.github.com/users/promag/orgs",
        "repos_url": "https://api.github.com/users/promag/repos",
        "events_url": "https://api.github.com/users/promag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/promag/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "476ced6df27c13fd8d1dae46d09b91549977cac1\r\n\r\nnit, enum class and use as `ReconciliationPhase::NONE`?",
      "created_at": "2021-03-29T11:25:31Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603214394",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603214394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603219571",
      "pull_request_review_id": 623130809,
      "id": 603219571,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIxOTU3MQ==",
      "diff_hunk": "@@ -47,8 +47,12 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;\n \n-    /** Relay transaction to all peers. */\n-    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid)\n+    /**\n+     * Relay transaction to every node.\n+     * The announcement protocol (flooding or reconciliation) will be chosen based on from which\n+     * peer the transaction came to us. For transactions originated locally, pass from=nullopt.\n+     */\n+    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from=std::nullopt)",
      "path": "src/net_processing.h",
      "position": null,
      "original_position": 11,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There's no need to update this public interface method. The only users of this method outside net_processing will _always_ call `RelayTransaction()` without a `from` parameter.\r\n\r\n(it's also unnecessary to wrap an optional parameter in a `std::optional` since the fact that it's an optional parameter already gives you a way to indicate no value)",
      "created_at": "2021-03-29T11:34:44Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603219571",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603219571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603221491",
      "pull_request_review_id": 623133260,
      "id": 603221491,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIyMTQ5MQ==",
      "diff_hunk": "@@ -365,6 +372,9 @@ class PeerManagerImpl final : public PeerManager\n     /** Number of peers with wtxid relay. */\n     int m_wtxid_relay_peers GUARDED_BY(cs_main) = 0;\n \n+    /** Number of outbound peers we may flood transactions to. */\n+    int m_out_flood_to GUARDED_BY(cs_main) = 0;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No need to protect this with `cs_main`. You can just make it atomic.",
      "created_at": "2021-03-29T11:38:10Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603221491",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603221491"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 376,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603221670",
      "pull_request_review_id": 623133260,
      "id": 603221670,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIyMTY3MA==",
      "diff_hunk": "@@ -597,6 +607,9 @@ struct CNodeState {\n     //! Whether this peer relays txs via wtxid\n     bool m_wtxid_relay{false};\n \n+    //! Whether this peer may be used by us for flooding txs.\n+    bool m_we_may_flood_to{false};",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 90,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Again, no need for this to be protected by main. I think it can easily live in `Peer`.",
      "created_at": "2021-03-29T11:38:34Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603221670",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603221670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 611,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603223119",
      "pull_request_review_id": 623133260,
      "id": 603223119,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIyMzExOQ==",
      "diff_hunk": "@@ -2017,8 +2063,9 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n  *                                  orphan will be reconsidered on each call of this function. This set\n  *                                  may be added to if accepting an orphan causes its children to be\n  *                                  reconsidered.\n+ * @param           from            The peer for which we are processing the orphan set.\n  */\n-void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n+void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set, NodeId from)",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 171,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "New `from` parameter is unused.",
      "created_at": "2021-03-29T11:41:12Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603223119",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603223119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2068,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/606384776",
      "pull_request_review_id": 627222659,
      "id": 606384776,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjM4NDc3Ng==",
      "diff_hunk": "@@ -4622,6 +4629,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                         uint256 hash = vInvTx.back();\n+                        bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 44,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "3692db74f86186789c9dad4005f7b768721d5afe",
      "in_reply_to_id": 603206903,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Making const. Can't move because it's erased in two lines after, so it won't be accessible in the inner scope.\r\nAnd I can't call `.second` on `.erase`, because it returns a number of erased elements.\r\n\r\nOne alternative could be to use `txid_to_ann_protocol` in `vInvTx` (instead of uint256). But then I won't be able to reuse `CompareInvMempoolOrder` in `AnnounceTxs`.",
      "created_at": "2021-04-02T19:26:16Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r606384776",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/606384776"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4632,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/606389480",
      "pull_request_review_id": 627228209,
      "id": 606389480,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjM4OTQ4MA==",
      "diff_hunk": "@@ -47,8 +47,12 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;\n \n-    /** Relay transaction to all peers. */\n-    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid)\n+    /**\n+     * Relay transaction to every node.\n+     * The announcement protocol (flooding or reconciliation) will be chosen based on from which\n+     * peer the transaction came to us. For transactions originated locally, pass from=nullopt.\n+     */\n+    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from=std::nullopt)",
      "path": "src/net_processing.h",
      "position": null,
      "original_position": 11,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "in_reply_to_id": 603219571,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sorry I don't understand this comment, despite your elaborate explanation. Probably my lack of C++ expertise.\r\n\r\nIf I remove just this change in the `virtual void` line, I get a compilation error.",
      "created_at": "2021-04-02T19:39:35Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r606389480",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/606389480"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613595312",
      "pull_request_review_id": 636090761,
      "id": 613595312,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzU5NTMxMg==",
      "diff_hunk": "@@ -0,0 +1,163 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all reconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0. Reconciliation protocol handshake.\n+ * 1. Once we receive a new transaction, add it to the set instead of announcing immediately\n+ * 2. When the time comes, a reconciliation initiator requests a sketch from the peer, where a sketch\n+ *    is a compressed representation of their set\n+ * 3. Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *    and combines the two skethes to find the difference in *sets*.\n+ * 4. Now the initiator knows full symmetrical difference and can request what the initiator is\n+ *    missing and announce to the peer what the peer is missing. For the former, an extra round is\n+ *    required because the initiator knows only short IDs of those transactions.\n+ * 5. Sometimes reconciliation fails if the difference is larger than the parties estimated,\n+ *    then there is one sketch extension round, in which the initiator requests for extra data.\n+ * 6. If extension succeeds, go to step 4.\n+ * 7. If extension fails, the initiator notifies the peer\n+ */",
      "path": "src/txreconciliation.h",
      "position": null,
      "original_position": 31,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for the clear write-up, may I suggest to insert a stable link to the paper ?",
      "created_at": "2021-04-14T21:21:06Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613595312",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613595312"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613599268",
      "pull_request_review_id": 636090761,
      "id": 613599268,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzU5OTI2OA==",
      "diff_hunk": "@@ -0,0 +1,163 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all reconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0. Reconciliation protocol handshake.\n+ * 1. Once we receive a new transaction, add it to the set instead of announcing immediately\n+ * 2. When the time comes, a reconciliation initiator requests a sketch from the peer, where a sketch\n+ *    is a compressed representation of their set\n+ * 3. Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *    and combines the two skethes to find the difference in *sets*.\n+ * 4. Now the initiator knows full symmetrical difference and can request what the initiator is\n+ *    missing and announce to the peer what the peer is missing. For the former, an extra round is\n+ *    required because the initiator knows only short IDs of those transactions.\n+ * 5. Sometimes reconciliation fails if the difference is larger than the parties estimated,\n+ *    then there is one sketch extension round, in which the initiator requests for extra data.\n+ * 6. If extension succeeds, go to step 4.\n+ * 7. If extension fails, the initiator notifies the peer\n+ */\n+class TxReconciliationTracker {",
      "path": "src/txreconciliation.h",
      "position": null,
      "original_position": 32,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think one obvious extension of the test coverage would be to join basic fuzz coverage of `TxReconciliationTracker` interface to assert its robustness. Have a look on `src/test/fuzz/addrman.cpp` or `src/test/fuzz/banman.cpp`.\r\n\r\nFuzz coverage might test further sanity of `TxReconciliationTracker` after each call or in function of `m_we_initiate` or `m_flood_to`. Still thinking about concrete suggestions there.",
      "created_at": "2021-04-14T21:28:34Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613599268",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613599268"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613926434",
      "pull_request_review_id": 636493106,
      "id": 613926434,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzkyNjQzNA==",
      "diff_hunk": "@@ -47,8 +47,12 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;\n \n-    /** Relay transaction to all peers. */\n-    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid)\n+    /**\n+     * Relay transaction to every node.\n+     * The announcement protocol (flooding or reconciliation) will be chosen based on from which\n+     * peer the transaction came to us. For transactions originated locally, pass from=nullopt.\n+     */\n+    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from=std::nullopt)",
      "path": "src/net_processing.h",
      "position": null,
      "original_position": 11,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "in_reply_to_id": 603219571,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, you'll need to change the function signature in `PeerManagerImpl()` as well. An `override` function must have the same signature as the function it's overriding.",
      "created_at": "2021-04-15T09:50:05Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613926434",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613926434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614166227",
      "pull_request_review_id": 636820159,
      "id": 614166227,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDE2NjIyNw==",
      "diff_hunk": "@@ -123,16 +126,16 @@ static constexpr auto AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL = 24h;\n static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL = 30s;\n /** Average delay between trickled inventory transmissions for inbound peers.\n  *  Blocks and peers with noban permission bypass this. */\n-static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL = 5s;\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL = 2s;\n /** Average delay between trickled inventory transmissions for outbound peers.\n  *  Use a smaller delay as there is less privacy concern for them.\n  *  Blocks and peers with noban permission bypass this. */\n-static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL = 2s;\n+static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL = 1s;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Surprised that modifying those 2 values doesn't lead to functional test changes. Apparently, they're not covered in p2p_tx_download.py. I can extend coverage there in another PR.",
      "created_at": "2021-04-15T15:21:39Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614166227",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614166227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614211171",
      "pull_request_review_id": 636820159,
      "id": 614211171,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDIxMTE3MQ==",
      "diff_hunk": "@@ -1507,17 +1526,44 @@ void PeerManagerImpl::SendPings()\n     for(auto& it : m_peer_map) it.second->m_ping_queued = true;\n }\n \n-void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid)\n+void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from)\n {\n-    m_connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+    bool flood;\n+    if (from) {\n+        // Flood those transactions which were received either from pre-reconciliation peers, or\n+        // inbound reconciliation but NOT via outbound reconciliation. Flooding then is mainly\n+        // used for initial propagation of new transactions across a network of reachable nodes\n+        // quickly, while most of the bandwidth is still conserved.\n+        if (m_reconciliation.IsPeerRegistered(*from)) {\n+            flood = !(*m_reconciliation.IsPeerResponder(*from));\n+        } else {\n+            flood = true;\n+        }\n+    }\n+    else {\n+        // Transactions originated locally should be always announced through reconciliation\n+        // for the privacy reasons.\n+        //\n+        // Consider a non-reachable node: the general policy is *flood transactions came from\n+        // inbounds* (see above), so non-reachable nodes would never flood any transactions.\n+        // Now, if they flood their local transactions, it will be obvious for their immediate peers\n+        // that those transactions belong to those non-reachable nodes.\n+        //\n+        // On the other hand, if non-reachable nodes reconcile those transactions, they would look\n+        // like any other transactions of non-reachable nodes.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 136,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we have privacy leaks for the following cases not mentioned in this comment ?\r\n\r\nA non-reachable node reconciliate with reconciliation-supporting _flooding_ outbound peers ? As it would be a deviation from the expected announcement policy.\r\n\r\nA reachable node reconciliate with reconciliation-supporting _flooding_ inbound/outbound peers ? Likewise, it would be a deviation from the expected announcement policy on those links.\r\n\r\nI think those cases are handled well at tx-announcement in SendMessages. Though I believe this comment would be better if it said that reconciliation is _downgraded_ to flooding if this the announcement previously selected for the to-be-announced-to peer.",
      "created_at": "2021-04-15T16:18:39Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614211171",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614211171"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1596,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614225402",
      "pull_request_review_id": 636820159,
      "id": 614225402,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDIyNTQwMg==",
      "diff_hunk": "@@ -2308,6 +2354,59 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n+namespace {\n+class CompareInvMempoolOrder\n+{\n+    CTxMemPool *mp;\n+    bool m_wtxid_relay;\n+public:\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    {\n+        mp = _mempool;\n+        m_wtxid_relay = use_wtxid;\n+    }\n+\n+    bool operator()(const uint256& a, const uint256& b)\n+    {\n+        /* As std::make_heap produces a max-heap, we want the entries with the\n+         * fewest ancestors/highest fee to sort later. */\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n+    }\n+};\n+}\n+\n+void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+    // A heap is used so that not all items need sorting if only a few are being sent.\n+    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, true);\n+    std::make_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    while (!remote_missing_wtxids.empty()) {\n+        // No need to add transactions to peer's filter or do checks\n+        // because it was already done when adding to the reconciliation set.",
      "path": "src/net_processing.cpp",
      "position": 92,
      "original_position": 204,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In theory, peer's feefilter might have increased between transaction selection for announcement at INV sending and receiving a SKETCH or RECONCILDIFF messages. Though AVG_FEEFILTER_BROADCAST_INTERVAL is 10min so it should be really okay.\r\n\r\nIs this gap could be exploited by an off-path attacker to interfere with tx-relay ? I don't think so, or at least without costly manipulation of victim's mempools.",
      "created_at": "2021-04-15T16:37:59Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614225402",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614225402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3312,
      "original_line": 3312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614231349",
      "pull_request_review_id": 636820159,
      "id": 614231349,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDIzMTM0OQ==",
      "diff_hunk": "@@ -2308,6 +2354,59 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n+namespace {\n+class CompareInvMempoolOrder\n+{\n+    CTxMemPool *mp;\n+    bool m_wtxid_relay;\n+public:\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    {\n+        mp = _mempool;\n+        m_wtxid_relay = use_wtxid;\n+    }\n+\n+    bool operator()(const uint256& a, const uint256& b)\n+    {\n+        /* As std::make_heap produces a max-heap, we want the entries with the\n+         * fewest ancestors/highest fee to sort later. */\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n+    }\n+};\n+}\n+\n+void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+    // A heap is used so that not all items need sorting if only a few are being sent.\n+    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, true);\n+    std::make_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    while (!remote_missing_wtxids.empty()) {\n+        // No need to add transactions to peer's filter or do checks\n+        // because it was already done when adding to the reconciliation set.\n+        std::pop_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+        uint256 wtxid = remote_missing_wtxids.back();\n+        remote_missing_wtxids.pop_back();\n+\n+        remote_missing_invs.push_back(CInv(MSG_WTX, wtxid));\n+        if (remote_missing_invs.size() == MAX_INV_SZ) {\n+            m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));\n+            remote_missing_invs.clear();\n+        }\n+    }\n+\n+    if (remote_missing_invs.size() != 0) {\n+        m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 217,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is logically equivalent ? \r\n\r\n```\r\n@@ -2386,15 +2390,11 @@ void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CN\r\n         remote_missing_wtxids.pop_back();\r\n \r\n         remote_missing_invs.push_back(CInv(MSG_WTX, wtxid));\r\n-        if (remote_missing_invs.size() == MAX_INV_SZ) {\r\n+        if (remote_missing_invs.size() == MAX_INV_SZ || remote_missing_wtxids.empty()) {\r\n             m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));\r\n             remote_missing_invs.clear();\r\n         }\r\n     }\r\n-\r\n-    if (remote_missing_invs.size() != 0) {\r\n-        m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));\r\n-    }\r\n }\r\n ```",
      "created_at": "2021-04-15T16:44:32Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614231349",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614231349"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2406,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614934750",
      "pull_request_review_id": 637839318,
      "id": 614934750,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkzNDc1MA==",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########",
      "path": "test/functional/p2p_erlay.py",
      "position": null,
      "original_position": 38,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "[The linter](https://cirrus-ci.com/task/6704150097428480) is not happy with this comment style.",
      "created_at": "2021-04-16T15:37:09Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614934750",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614934750"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614943424",
      "pull_request_review_id": 637847119,
      "id": 614943424,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk0MzQyNA==",
      "diff_hunk": "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        bool they_initiator, they_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> they_initiator >> they_responder >> recon_version >> remote_salt;\n+\n+        // Since this is called before VERACK, m_out_flooding_peers doesn't include this peer\n+        // being considered for reconciliation support, so no need for substraction.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 307,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/substraction/subtraction/",
      "created_at": "2021-04-16T15:45:48Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614943424",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614943424"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2797,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614944439",
      "pull_request_review_id": 637848006,
      "id": 614944439,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk0NDQzOQ==",
      "diff_hunk": "@@ -3806,6 +3976,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);\n+        return;\n+    }\n+\n+    if (msg_type == NetMsgType::SKETCH) {\n+        std::vector<uint8_t> skdata;\n+        vRecv >> skdata;\n+\n+        std::vector<uint32_t> txs_to_request;\n+        std::vector<uint256> txs_to_announce;\n+        std::optional<bool> recon_result;\n+        bool valid_sketch = m_reconciliation.HandleSketch(pfrom.GetId(), skdata, txs_to_request, txs_to_announce, recon_result);\n+\n+        if (valid_sketch) {\n+            if (recon_result) {\n+                // Handles both successful and failed reconciliation (but not the case per which\n+                // we want to request extension).\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                    *recon_result, txs_to_request));\n+            } else {\n+                // No final result means we should request sketch extension to make another\n+                // reconciliation attempt without loosing the initial data.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 362,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/loosing/losing/",
      "created_at": "2021-04-16T15:46:47Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614944439",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614944439"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4003,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615320860",
      "pull_request_review_id": 638283440,
      "id": 615320860,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMyMDg2MA==",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########\n+#################################\n+def mul2(x):\n+    \"\"\"Compute 2*x in GF(2^FIELD_BITS)\"\"\"\n+    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)\n+\n+def mul(x, y):\n+    \"\"\"Compute x*y in GF(2^FIELD_BITS)\"\"\"\n+    ret = 0\n+    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:\n+        ret, y = ret ^ bit * y, mul2(y)\n+    return ret\n+\n+def create_sketch(shortids, capacity):\n+    \"\"\"Compute the bytes of a sketch for given shortids and given capacity.\"\"\"\n+    odd_sums = [0 for _ in range(capacity)]\n+    for shortid in shortids:\n+        squared = mul(shortid, shortid)\n+        for i in range(capacity):\n+            odd_sums[i] ^= shortid\n+            shortid = mul(shortid, squared)\n+    sketch_bytes = []\n+    for odd_sum in odd_sums:\n+        for i in range(4):\n+            sketch_bytes.append((odd_sum >> (i * 8)) & 0xff)\n+    return sketch_bytes\n+\n+def GetShortID(tx, salt):\n+    (k0, k1) = salt\n+    wtxid = tx.calc_sha256(with_witness = True)\n+    s = siphash256(k0, k1, wtxid)\n+    return 1 + (s & 0xFFFFFFFF)\n+\n+def estimate_capacity(theirs, ours=1):\n+    return int(abs(theirs - ours) + DEFAULT_Q * min(theirs, ours)) + 1\n+\n+def generate_transaction(node, coinbase):\n+    amount = 0.001\n+    to_address = node.getnewaddress()\n+    from_txid = node.getblock(coinbase)['tx'][0]\n+    inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+    outputs = { to_address : amount }\n+    rawtx = node.createrawtransaction(inputs, outputs)\n+    signresult = node.signrawtransactionwithwallet(rawtx)\n+    tx = CTransaction()\n+    tx.deserialize(BytesIO(hex_str_to_bytes(signresult['hex'])))\n+    tx.rehash()\n+    return tx\n+\n+#################################\n+### General message handlers ####\n+#################################\n+\n+class TestP2PConn(P2PDataStore):\n+    def __init__(self, recon_version, mininode_salt, be_recon_requestor=False, be_recon_responder=False):\n+        super().__init__()\n+        self.recon_version = recon_version\n+        self.mininode_salt = mininode_salt\n+        self.be_recon_requestor = be_recon_requestor\n+        self.be_recon_responder= be_recon_responder\n+        self.node_salt = 0\n+        self.last_sendrecon = []\n+        self.last_sketch = []\n+        self.last_inv = []\n+        self.last_tx = []\n+        self.last_reqreconcil = []\n+        self.last_reconcildiff = []\n+        self.last_reqsketchext = []\n+        self.last_getdata = []\n+        self.node_q = DEFAULT_Q\n+        self.last_wtxidrelay = []\n+\n+    def on_version(self, message):\n+        if self.recon_version == 1:\n+            assert message.nVersion >= MIN_P2P_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_P2P_VERSION_SUPPORTED)\n+            if message.nVersion >= 70016 and self.wtxidrelay:\n+                self.send_message(msg_wtxidrelay())\n+                self.send_sendrecon(self.be_recon_requestor, self.be_recon_responder)\n+            self.send_message(msg_verack())\n+            self.nServices = message.nServices\n+        else:\n+            super().on_version(message)\n+\n+    def on_sendrecon(self, message):\n+        self.last_sendrecon.append(message)\n+        self.node_salt = message.salt\n+\n+    def on_wtxidrelay(self, message):\n+        self.last_wtxidrelay.append(message)\n+\n+    def on_sketch(self, message):\n+        self.last_sketch.append(message)\n+\n+    def on_inv(self, message):\n+        MSG_BLOCK = 2\n+        for inv in message.inv:\n+            if inv.type != MSG_BLOCK: # ignore block invs\n+                self.last_inv.append(inv.hash)\n+\n+    def on_tx(self, message):\n+        self.last_tx.append(message.tx.calc_sha256(True))\n+\n+    def on_reqrecon(self, message):\n+        self.last_reqreconcil.append(message)\n+\n+    def on_reqsketchext(self, message):\n+        self.last_reqsketchext.append(message)\n+\n+    def on_reconcildiff(self, message):\n+        self.last_reconcildiff.append(message)\n+\n+    def send_sendrecon(self, sender, responder):\n+        msg = msg_sendrecon()\n+        msg.salt = self.mininode_salt\n+        msg.version = self.recon_version\n+        msg.sender = sender\n+        msg.responder = responder\n+        self.send_message(msg)\n+\n+    def send_reqrecon(self, set_size, q):\n+        msg = msg_reqrecon()\n+        msg.set_size = set_size\n+        msg.q = q\n+        self.send_message(msg)\n+\n+    def send_sketch(self, skdata):\n+        msg = msg_sketch()\n+        msg.skdata = skdata\n+        self.send_message(msg)\n+\n+    def send_reqsketchext(self):\n+        msg = msg_reqsketchext()\n+        self.send_message(msg)\n+\n+    def send_reconcildiff(self, success, ask_shortids):\n+        msg = msg_reconcildiff()\n+        msg.success = success\n+        msg.ask_shortids = ask_shortids\n+        self.send_message(msg)\n+\n+    def send_inv(self, inv_wtxids):\n+        msg = msg_inv(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in inv_wtxids])\n+        self.send_message(msg)\n+\n+    def send_getdata(self, ask_wtxids):\n+        msg = msg_getdata(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in ask_wtxids])\n+        self.send_message(msg)\n+\n+#################################\n+##### High-level functions ######\n+#################################\n+\n+class ReconciliationTest(BitcoinTestFramework):\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.blocks_offset = 0\n+\n+    def proceed_in_time(self, jump_in_seconds):\n+        time.sleep(0.01) # We usually need the node to process some messages first.\n+        self.mocktime += jump_in_seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def generate_txs(self, n_mininode_unique, n_node_unique, n_shared, blocks, send=True):\n+        mininode_unique = []\n+        node_unique = []\n+        shared = []\n+\n+        for i in range(n_mininode_unique):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            mininode_unique.append(tx)\n+\n+        for i in range(n_mininode_unique, n_mininode_unique + n_node_unique):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            node_unique.append(tx)\n+\n+        for i in range(n_mininode_unique + n_node_unique, n_mininode_unique + n_node_unique + n_shared):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            shared.append(tx)\n+\n+        if send:\n+            self.nodes[0].p2ps[0].send_txs_and_test(node_unique + shared, self.nodes[0], success = True)\n+            self.blocks_offset += (n_mininode_unique + n_node_unique + n_shared)\n+\n+        return mininode_unique, node_unique, shared\n+\n+    def compute_salt(self):\n+        RECON_STATIC_SALT = \"Tx Relay Salting\"\n+        salt1, salt2 = self.test_node.node_salt, self.test_node.mininode_salt\n+        if salt1 > salt2:\n+            salt1, salt2 = salt2, salt1\n+        salt = struct.pack(\"<Q\", salt1) + struct.pack(\"<Q\", salt2)\n+        h = TaggedHash(RECON_STATIC_SALT, salt)\n+        k0 = int.from_bytes(h[0:8], \"little\")\n+        k1 = int.from_bytes(h[8:16], \"little\")\n+        return k0, k1\n+\n+    def request_reconciliation(self, test_node, mininode_set_size, expected_sketch):\n+        q_to_send = int(DEFAULT_Q * Q_PRECISION)\n+        test_node.send_reqrecon(mininode_set_size, q_to_send)\n+        self.proceed_in_time(3) # Hit sending sketches out\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) == 1)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(test_node.last_sketch[-1].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def transmit_sketch(self, test_node, txs_to_sketch, extension, capacity, expected_announced_txs):\n+        short_txids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_sketch]\n+        if extension:\n+            sketch = create_sketch(short_txids, capacity * 2)[int(capacity * BYTES_PER_SKETCH_CAPACITY):]\n+        else:\n+            test_node.last_full_mininode_size = len(txs_to_sketch)\n+            sketch = create_sketch(short_txids, capacity)\n+        test_node.send_sketch(sketch)\n+        expected_wtxds = [tx.calc_sha256(True) for tx in expected_announced_txs]\n+        if len(expected_wtxds) > 0:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(expected_wtxds))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxds))\n+            test_node.last_inv_size = len(test_node.last_inv) # Needed to recompute node q later\n+            test_node.last_inv = []\n+        else:\n+            assert_equal(test_node.last_inv, [])\n+\n+    def handle_reconciliation_finalization(self, test_node, expected_success, expected_requested_txs):\n+        expected_requested_shortids = [GetShortID(tx, self.compute_salt()) for tx in expected_requested_txs]\n+\n+        def received_reconcildiff():\n+            return (len(test_node.last_reconcildiff) == 1)\n+        self.wait_until(received_reconcildiff, timeout=30)\n+        success = test_node.last_reconcildiff[0].success\n+        assert_equal(success, int(expected_success))\n+        assert_equal(set(test_node.last_reconcildiff[0].ask_shortids), set(expected_requested_shortids))\n+        if success:\n+            mininode_missing = test_node.last_inv_size\n+            node_missing = len(test_node.last_reconcildiff[0].ask_shortids)\n+            total_missing = mininode_missing + node_missing\n+            mininode_size = test_node.last_full_mininode_size\n+            node_size = mininode_size + mininode_missing - node_missing\n+            min_size = min(mininode_size, node_size)\n+            if min_size != 0:\n+                test_node.node_q = (total_missing - abs(mininode_missing - node_missing)) / min_size\n+        else:\n+            test_node.node_q = DEFAULT_Q\n+        test_node.last_reconcildiff = []\n+\n+    def handle_extension_request(self, test_node):\n+        def received_reqsketchext():\n+            return (len(test_node.last_reqsketchext) == 1)\n+        self.wait_until(received_reqsketchext, timeout=30)\n+        test_node.last_reqsketchext = []\n+\n+    def request_sketchext(self, test_node, expected_sketch):\n+        test_node.send_reqsketchext()\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) > 0)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(len(test_node.last_sketch), 1)\n+        assert_equal(test_node.last_sketch[0].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def finalize_reconciliation(self, test_node, success, txs_to_request, txs_to_expect):\n+        ask_shortids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_request]\n+        expected_wtxids = [tx.calc_sha256(with_witness = True) for tx in txs_to_expect]\n+        test_node.send_reconcildiff(success, ask_shortids)\n+        if txs_to_expect != []:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(txs_to_expect))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxids))\n+            test_node.last_inv = []\n+\n+    def request_transactions(self, test_node, txs_to_request):\n+        assert_equal(test_node.last_tx, []) # Make sure there were no unexpected transactions received before\n+        wtxids_to_request = [tx.calc_sha256(with_witness = True) for tx in txs_to_request]\n+        test_node.send_getdata(wtxids_to_request)\n+\n+        def received_tx():\n+            return (len(test_node.last_tx) == len(txs_to_request))\n+        self.wait_until(received_tx, timeout=30)\n+        assert_equal(set([tx.calc_sha256(True) for tx in txs_to_request]), set(test_node.last_tx))\n+        test_node.last_tx = []\n+\n+    def receive_reqreconcil(self, test_node, expected_set_size):\n+        def received_reqreconcil():\n+            return (len(test_node.last_reqreconcil) == 1)\n+        self.wait_until(received_reqreconcil, timeout=30)\n+\n+        if test_node.last_reqreconcil[-1].set_size == 0 and expected_set_size != 0:\n+            # Sometimes transactions are added to the reconciliation sets after the reqrecon\n+            # message is sent out by the peer. In that case, we need to immediately terminate\n+            # this reconciliation by sending an empty sketch, and proceed to the expected\n+            # scenario.\n+            test_node.last_reqreconcil = []\n+            self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False,\n+                capacity=0, expected_announced_txs=[])\n+            self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                expected_requested_txs=[])\n+\n+            self.wait_until(received_reqreconcil, timeout=30)\n+\n+        assert_equal(test_node.last_reqreconcil[-1].set_size, expected_set_size)\n+        assert_equal(test_node.last_reqreconcil[-1].q, int(test_node.node_q * Q_PRECISION))\n+        test_node.last_reqreconcil = []\n+\n+#################################\n+####### Actual test cases #######\n+#################################\n+\n+    def reconciliation_responder_flow(self, n_mininode, n_node, extension, result):\n+        mininode_txs, node_txs, _ = self.generate_txs(n_mininode, n_node, 0, self.blocks)\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        more_node_txs = []\n+        node_short_ids = [GetShortID(tx, self.compute_salt()) for tx in node_txs]\n+        if n_mininode == 0 or n_node == 0:\n+            expected_sketch_capacity = 0\n+        else:\n+            expected_sketch_capacity = estimate_capacity(n_mininode, n_node)\n+        expected_sketch = create_sketch(node_short_ids, expected_sketch_capacity)\n+        self.request_reconciliation(self.test_node, len(mininode_txs), expected_sketch)\n+        more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks)[1])\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        if extension:\n+            expected_sketch = create_sketch(node_short_ids, expected_sketch_capacity * 2)[int(expected_sketch_capacity * BYTES_PER_SKETCH_CAPACITY):]\n+            self.request_sketchext(self.test_node, expected_sketch)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+        if result:\n+            txs_to_request = random.sample(node_txs, 3)\n+            self.finalize_reconciliation(self.test_node, True, txs_to_request, txs_to_expect=txs_to_request)\n+        else:\n+            self.finalize_reconciliation(self.test_node, True, [], txs_to_expect=[])\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+\n+        # Check those additional transactions are not lost.\n+        short_ids = [GetShortID(tx, self.compute_salt()) for tx in more_node_txs]\n+        capacity = estimate_capacity(len(more_node_txs), 1)\n+        if capacity < 3:\n+            capacity += 1\n+        expected_sketch = create_sketch(short_ids, capacity)\n+        self.request_reconciliation(self.test_node, 1, expected_sketch)\n+        self.finalize_reconciliation(self.test_node, success=True, txs_to_request=[], txs_to_expect=[])\n+\n+    # The mininode is a reconciliation initiator, the node being tested is responder.\n+    def test_recon_responder(self):\n+        mininode_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+\n+        # Needed to submit txs\n+        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=0, mininode_salt=mininode_SALT))\n+        self.test_node0.wait_for_verack()\n+\n+        self.mocktime = int(time.time())\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=mininode_SALT, be_recon_requestor=True, be_recon_responder=False))\n+        self.test_node.wait_for_verack()\n+        self.blocks = self.nodes[0].generate(nblocks=1024)\n+        self.sync_blocks()\n+\n+        # 0 at mininode, 20 at node, 0 shared, early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(0, 20, False, False)\n+        # 20 at mininode, 0 at node, 0 shared, early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(20, 0, False, False)\n+        # Initial reconciliation succeeds\n+        self.reconciliation_responder_flow(10, 20, False, False)\n+        # Initial reconciliation fails, extension succeeds\n+        self.reconciliation_responder_flow(1, 20, True, True)\n+        # Initial reconciliation fails, extension fails\n+        self.reconciliation_responder_flow(1, 20, True, False)\n+\n+    def reconciliation_initiator_flow(self, n_mininode, n_node, n_shared, capacity, terminate_after_initial, expected_success):\n+        mininode_unique_txs, node_unique_txs, shared_txs = self.generate_txs(n_mininode, n_node, n_shared, self.blocks, self)\n+        mininode_txs = mininode_unique_txs + shared_txs\n+        node_txs = node_unique_txs + shared_txs\n+        more_node_txs = []\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(node_txs))\n+\n+        if terminate_after_initial:\n+            self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=False,\n+                capacity=capacity, expected_announced_txs=node_unique_txs)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            if expected_success:\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+                    expected_requested_txs=mininode_unique_txs)\n+            else:\n+                # This happens only if one of the sets (or both) was empty.\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                    expected_requested_txs=[])\n+        else:\n+            self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=False,\n+                capacity=capacity, expected_announced_txs=[])\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            self.handle_extension_request(self.test_node)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            if expected_success:\n+                self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=True,\n+                    capacity=capacity, expected_announced_txs=node_unique_txs)\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+                    expected_requested_txs=mininode_unique_txs)\n+            else:\n+                self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=True,\n+                    capacity=capacity, expected_announced_txs=node_txs)\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                    expected_requested_txs=[])\n+\n+        self.request_transactions(self.test_node, node_unique_txs)\n+        # Check those additional transactions are not lost.\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(more_node_txs))\n+        self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False, capacity=0, expected_announced_txs=more_node_txs)\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+            expected_requested_txs=[])\n+\n+    # The node being tested is a reconciliation initiator, the mininode is responder.\n+    def test_recon_initiator(self):\n+        MININODE_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+\n+        # The first node is used to feed the node being tested with transactions.\n+        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=MININODE_SALT, be_recon_requestor=True, be_recon_responder=False))\n+        self.test_node0.wait_for_verack()\n+\n+        # These nodes will consume regular tx flood forwarding\n+        for i in range(MAX_OUTBOUND_FLOOD_TO):\n+            flooding_node = self.nodes[0].add_p2p_connection(TestP2PConn(\n+                recon_version=0, mininode_salt=MININODE_SALT), node_outgoing=True)\n+            flooding_node.wait_for_verack()\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=MININODE_SALT, be_recon_requestor=False, be_recon_responder=True), node_outgoing=True)\n+        self.test_node.wait_for_verack()\n+\n+        self.blocks = self.nodes[0].generate(nblocks=1024)",
      "path": "test/functional/p2p_erlay.py",
      "position": null,
      "original_position": 480,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why 1024? Is it an arbitrary number? I tested it using 500 blocks and it seems to work. Is there an explanation?",
      "created_at": "2021-04-18T00:26:05Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615320860",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615320860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 556,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615322950",
      "pull_request_review_id": 638284435,
      "id": 615322950,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMyMjk1MA==",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########",
      "path": "test/functional/p2p_erlay.py",
      "position": null,
      "original_position": 38,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 614934750,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not only with that.  I ran pycodestyle and got many warnings about it.\r\n\r\n![image](https://user-images.githubusercontent.com/19480819/115130588-3c113100-9fc7-11eb-8efd-77b0b406f732.png)\r\n",
      "created_at": "2021-04-18T00:52:59Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615322950",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615322950"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615594571",
      "pull_request_review_id": 638527852,
      "id": 615594571,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTU5NDU3MQ==",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########\n+#################################\n+def mul2(x):\n+    \"\"\"Compute 2*x in GF(2^FIELD_BITS)\"\"\"\n+    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)\n+\n+def mul(x, y):\n+    \"\"\"Compute x*y in GF(2^FIELD_BITS)\"\"\"\n+    ret = 0\n+    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:\n+        ret, y = ret ^ bit * y, mul2(y)\n+    return ret\n+\n+def create_sketch(shortids, capacity):\n+    \"\"\"Compute the bytes of a sketch for given shortids and given capacity.\"\"\"\n+    odd_sums = [0 for _ in range(capacity)]\n+    for shortid in shortids:\n+        squared = mul(shortid, shortid)\n+        for i in range(capacity):\n+            odd_sums[i] ^= shortid\n+            shortid = mul(shortid, squared)\n+    sketch_bytes = []\n+    for odd_sum in odd_sums:\n+        for i in range(4):\n+            sketch_bytes.append((odd_sum >> (i * 8)) & 0xff)\n+    return sketch_bytes\n+\n+def GetShortID(tx, salt):\n+    (k0, k1) = salt\n+    wtxid = tx.calc_sha256(with_witness = True)\n+    s = siphash256(k0, k1, wtxid)\n+    return 1 + (s & 0xFFFFFFFF)\n+\n+def estimate_capacity(theirs, ours=1):\n+    return int(abs(theirs - ours) + DEFAULT_Q * min(theirs, ours)) + 1\n+\n+def generate_transaction(node, coinbase):\n+    amount = 0.001\n+    to_address = node.getnewaddress()\n+    from_txid = node.getblock(coinbase)['tx'][0]\n+    inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+    outputs = { to_address : amount }\n+    rawtx = node.createrawtransaction(inputs, outputs)\n+    signresult = node.signrawtransactionwithwallet(rawtx)\n+    tx = CTransaction()\n+    tx.deserialize(BytesIO(hex_str_to_bytes(signresult['hex'])))\n+    tx.rehash()\n+    return tx\n+\n+#################################\n+### General message handlers ####\n+#################################\n+\n+class TestP2PConn(P2PDataStore):\n+    def __init__(self, recon_version, mininode_salt, be_recon_requestor=False, be_recon_responder=False):\n+        super().__init__()\n+        self.recon_version = recon_version\n+        self.mininode_salt = mininode_salt\n+        self.be_recon_requestor = be_recon_requestor\n+        self.be_recon_responder= be_recon_responder\n+        self.node_salt = 0\n+        self.last_sendrecon = []\n+        self.last_sketch = []\n+        self.last_inv = []\n+        self.last_tx = []\n+        self.last_reqreconcil = []\n+        self.last_reconcildiff = []\n+        self.last_reqsketchext = []\n+        self.last_getdata = []\n+        self.node_q = DEFAULT_Q\n+        self.last_wtxidrelay = []\n+\n+    def on_version(self, message):\n+        if self.recon_version == 1:\n+            assert message.nVersion >= MIN_P2P_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_P2P_VERSION_SUPPORTED)\n+            if message.nVersion >= 70016 and self.wtxidrelay:\n+                self.send_message(msg_wtxidrelay())\n+                self.send_sendrecon(self.be_recon_requestor, self.be_recon_responder)\n+            self.send_message(msg_verack())\n+            self.nServices = message.nServices\n+        else:\n+            super().on_version(message)\n+\n+    def on_sendrecon(self, message):\n+        self.last_sendrecon.append(message)\n+        self.node_salt = message.salt\n+\n+    def on_wtxidrelay(self, message):\n+        self.last_wtxidrelay.append(message)\n+\n+    def on_sketch(self, message):\n+        self.last_sketch.append(message)\n+\n+    def on_inv(self, message):\n+        MSG_BLOCK = 2\n+        for inv in message.inv:\n+            if inv.type != MSG_BLOCK: # ignore block invs\n+                self.last_inv.append(inv.hash)\n+\n+    def on_tx(self, message):\n+        self.last_tx.append(message.tx.calc_sha256(True))\n+\n+    def on_reqrecon(self, message):\n+        self.last_reqreconcil.append(message)\n+\n+    def on_reqsketchext(self, message):\n+        self.last_reqsketchext.append(message)\n+\n+    def on_reconcildiff(self, message):\n+        self.last_reconcildiff.append(message)\n+\n+    def send_sendrecon(self, sender, responder):\n+        msg = msg_sendrecon()\n+        msg.salt = self.mininode_salt\n+        msg.version = self.recon_version\n+        msg.sender = sender\n+        msg.responder = responder\n+        self.send_message(msg)\n+\n+    def send_reqrecon(self, set_size, q):\n+        msg = msg_reqrecon()\n+        msg.set_size = set_size\n+        msg.q = q\n+        self.send_message(msg)\n+\n+    def send_sketch(self, skdata):\n+        msg = msg_sketch()\n+        msg.skdata = skdata\n+        self.send_message(msg)\n+\n+    def send_reqsketchext(self):\n+        msg = msg_reqsketchext()\n+        self.send_message(msg)\n+\n+    def send_reconcildiff(self, success, ask_shortids):\n+        msg = msg_reconcildiff()\n+        msg.success = success\n+        msg.ask_shortids = ask_shortids\n+        self.send_message(msg)\n+\n+    def send_inv(self, inv_wtxids):\n+        msg = msg_inv(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in inv_wtxids])\n+        self.send_message(msg)\n+\n+    def send_getdata(self, ask_wtxids):\n+        msg = msg_getdata(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in ask_wtxids])\n+        self.send_message(msg)\n+\n+#################################\n+##### High-level functions ######\n+#################################\n+\n+class ReconciliationTest(BitcoinTestFramework):\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.blocks_offset = 0\n+\n+    def proceed_in_time(self, jump_in_seconds):\n+        time.sleep(0.01) # We usually need the node to process some messages first.\n+        self.mocktime += jump_in_seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def generate_txs(self, n_mininode_unique, n_node_unique, n_shared, blocks, send=True):\n+        mininode_unique = []\n+        node_unique = []\n+        shared = []\n+\n+        for i in range(n_mininode_unique):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            mininode_unique.append(tx)\n+\n+        for i in range(n_mininode_unique, n_mininode_unique + n_node_unique):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            node_unique.append(tx)\n+\n+        for i in range(n_mininode_unique + n_node_unique, n_mininode_unique + n_node_unique + n_shared):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            shared.append(tx)\n+\n+        if send:\n+            self.nodes[0].p2ps[0].send_txs_and_test(node_unique + shared, self.nodes[0], success = True)\n+            self.blocks_offset += (n_mininode_unique + n_node_unique + n_shared)\n+\n+        return mininode_unique, node_unique, shared\n+\n+    def compute_salt(self):\n+        RECON_STATIC_SALT = \"Tx Relay Salting\"\n+        salt1, salt2 = self.test_node.node_salt, self.test_node.mininode_salt\n+        if salt1 > salt2:\n+            salt1, salt2 = salt2, salt1\n+        salt = struct.pack(\"<Q\", salt1) + struct.pack(\"<Q\", salt2)\n+        h = TaggedHash(RECON_STATIC_SALT, salt)\n+        k0 = int.from_bytes(h[0:8], \"little\")\n+        k1 = int.from_bytes(h[8:16], \"little\")\n+        return k0, k1\n+\n+    def request_reconciliation(self, test_node, mininode_set_size, expected_sketch):\n+        q_to_send = int(DEFAULT_Q * Q_PRECISION)\n+        test_node.send_reqrecon(mininode_set_size, q_to_send)\n+        self.proceed_in_time(3) # Hit sending sketches out\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) == 1)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(test_node.last_sketch[-1].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def transmit_sketch(self, test_node, txs_to_sketch, extension, capacity, expected_announced_txs):\n+        short_txids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_sketch]\n+        if extension:\n+            sketch = create_sketch(short_txids, capacity * 2)[int(capacity * BYTES_PER_SKETCH_CAPACITY):]\n+        else:\n+            test_node.last_full_mininode_size = len(txs_to_sketch)\n+            sketch = create_sketch(short_txids, capacity)\n+        test_node.send_sketch(sketch)\n+        expected_wtxds = [tx.calc_sha256(True) for tx in expected_announced_txs]\n+        if len(expected_wtxds) > 0:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(expected_wtxds))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxds))\n+            test_node.last_inv_size = len(test_node.last_inv) # Needed to recompute node q later\n+            test_node.last_inv = []\n+        else:\n+            assert_equal(test_node.last_inv, [])\n+\n+    def handle_reconciliation_finalization(self, test_node, expected_success, expected_requested_txs):\n+        expected_requested_shortids = [GetShortID(tx, self.compute_salt()) for tx in expected_requested_txs]\n+\n+        def received_reconcildiff():\n+            return (len(test_node.last_reconcildiff) == 1)\n+        self.wait_until(received_reconcildiff, timeout=30)\n+        success = test_node.last_reconcildiff[0].success\n+        assert_equal(success, int(expected_success))\n+        assert_equal(set(test_node.last_reconcildiff[0].ask_shortids), set(expected_requested_shortids))\n+        if success:\n+            mininode_missing = test_node.last_inv_size\n+            node_missing = len(test_node.last_reconcildiff[0].ask_shortids)\n+            total_missing = mininode_missing + node_missing\n+            mininode_size = test_node.last_full_mininode_size\n+            node_size = mininode_size + mininode_missing - node_missing\n+            min_size = min(mininode_size, node_size)\n+            if min_size != 0:\n+                test_node.node_q = (total_missing - abs(mininode_missing - node_missing)) / min_size\n+        else:\n+            test_node.node_q = DEFAULT_Q\n+        test_node.last_reconcildiff = []\n+\n+    def handle_extension_request(self, test_node):\n+        def received_reqsketchext():\n+            return (len(test_node.last_reqsketchext) == 1)\n+        self.wait_until(received_reqsketchext, timeout=30)\n+        test_node.last_reqsketchext = []\n+\n+    def request_sketchext(self, test_node, expected_sketch):\n+        test_node.send_reqsketchext()\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) > 0)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(len(test_node.last_sketch), 1)\n+        assert_equal(test_node.last_sketch[0].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def finalize_reconciliation(self, test_node, success, txs_to_request, txs_to_expect):\n+        ask_shortids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_request]\n+        expected_wtxids = [tx.calc_sha256(with_witness = True) for tx in txs_to_expect]\n+        test_node.send_reconcildiff(success, ask_shortids)\n+        if txs_to_expect != []:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(txs_to_expect))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxids))\n+            test_node.last_inv = []\n+\n+    def request_transactions(self, test_node, txs_to_request):\n+        assert_equal(test_node.last_tx, []) # Make sure there were no unexpected transactions received before\n+        wtxids_to_request = [tx.calc_sha256(with_witness = True) for tx in txs_to_request]\n+        test_node.send_getdata(wtxids_to_request)\n+\n+        def received_tx():\n+            return (len(test_node.last_tx) == len(txs_to_request))\n+        self.wait_until(received_tx, timeout=30)\n+        assert_equal(set([tx.calc_sha256(True) for tx in txs_to_request]), set(test_node.last_tx))\n+        test_node.last_tx = []\n+\n+    def receive_reqreconcil(self, test_node, expected_set_size):\n+        def received_reqreconcil():\n+            return (len(test_node.last_reqreconcil) == 1)\n+        self.wait_until(received_reqreconcil, timeout=30)\n+\n+        if test_node.last_reqreconcil[-1].set_size == 0 and expected_set_size != 0:\n+            # Sometimes transactions are added to the reconciliation sets after the reqrecon\n+            # message is sent out by the peer. In that case, we need to immediately terminate\n+            # this reconciliation by sending an empty sketch, and proceed to the expected\n+            # scenario.\n+            test_node.last_reqreconcil = []\n+            self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False,\n+                capacity=0, expected_announced_txs=[])\n+            self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                expected_requested_txs=[])\n+\n+            self.wait_until(received_reqreconcil, timeout=30)\n+\n+        assert_equal(test_node.last_reqreconcil[-1].set_size, expected_set_size)\n+        assert_equal(test_node.last_reqreconcil[-1].q, int(test_node.node_q * Q_PRECISION))\n+        test_node.last_reqreconcil = []\n+\n+#################################\n+####### Actual test cases #######\n+#################################\n+\n+    def reconciliation_responder_flow(self, n_mininode, n_node, extension, result):\n+        mininode_txs, node_txs, _ = self.generate_txs(n_mininode, n_node, 0, self.blocks)\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        more_node_txs = []\n+        node_short_ids = [GetShortID(tx, self.compute_salt()) for tx in node_txs]\n+        if n_mininode == 0 or n_node == 0:\n+            expected_sketch_capacity = 0\n+        else:\n+            expected_sketch_capacity = estimate_capacity(n_mininode, n_node)\n+        expected_sketch = create_sketch(node_short_ids, expected_sketch_capacity)\n+        self.request_reconciliation(self.test_node, len(mininode_txs), expected_sketch)\n+        more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks)[1])\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        if extension:\n+            expected_sketch = create_sketch(node_short_ids, expected_sketch_capacity * 2)[int(expected_sketch_capacity * BYTES_PER_SKETCH_CAPACITY):]\n+            self.request_sketchext(self.test_node, expected_sketch)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+        if result:\n+            txs_to_request = random.sample(node_txs, 3)\n+            self.finalize_reconciliation(self.test_node, True, txs_to_request, txs_to_expect=txs_to_request)\n+        else:\n+            self.finalize_reconciliation(self.test_node, True, [], txs_to_expect=[])\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+\n+        # Check those additional transactions are not lost.\n+        short_ids = [GetShortID(tx, self.compute_salt()) for tx in more_node_txs]\n+        capacity = estimate_capacity(len(more_node_txs), 1)\n+        if capacity < 3:\n+            capacity += 1\n+        expected_sketch = create_sketch(short_ids, capacity)\n+        self.request_reconciliation(self.test_node, 1, expected_sketch)\n+        self.finalize_reconciliation(self.test_node, success=True, txs_to_request=[], txs_to_expect=[])\n+\n+    # The mininode is a reconciliation initiator, the node being tested is responder.\n+    def test_recon_responder(self):\n+        mininode_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+\n+        # Needed to submit txs\n+        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=0, mininode_salt=mininode_SALT))\n+        self.test_node0.wait_for_verack()\n+\n+        self.mocktime = int(time.time())\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=mininode_SALT, be_recon_requestor=True, be_recon_responder=False))\n+        self.test_node.wait_for_verack()\n+        self.blocks = self.nodes[0].generate(nblocks=1024)\n+        self.sync_blocks()\n+\n+        # 0 at mininode, 20 at node, 0 shared, early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(0, 20, False, False)\n+        # 20 at mininode, 0 at node, 0 shared, early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(20, 0, False, False)\n+        # Initial reconciliation succeeds\n+        self.reconciliation_responder_flow(10, 20, False, False)\n+        # Initial reconciliation fails, extension succeeds\n+        self.reconciliation_responder_flow(1, 20, True, True)\n+        # Initial reconciliation fails, extension fails\n+        self.reconciliation_responder_flow(1, 20, True, False)\n+\n+    def reconciliation_initiator_flow(self, n_mininode, n_node, n_shared, capacity, terminate_after_initial, expected_success):\n+        mininode_unique_txs, node_unique_txs, shared_txs = self.generate_txs(n_mininode, n_node, n_shared, self.blocks, self)\n+        mininode_txs = mininode_unique_txs + shared_txs\n+        node_txs = node_unique_txs + shared_txs\n+        more_node_txs = []\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(node_txs))\n+\n+        if terminate_after_initial:\n+            self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=False,\n+                capacity=capacity, expected_announced_txs=node_unique_txs)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            if expected_success:\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+                    expected_requested_txs=mininode_unique_txs)\n+            else:\n+                # This happens only if one of the sets (or both) was empty.\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                    expected_requested_txs=[])\n+        else:\n+            self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=False,\n+                capacity=capacity, expected_announced_txs=[])\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            self.handle_extension_request(self.test_node)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            if expected_success:\n+                self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=True,\n+                    capacity=capacity, expected_announced_txs=node_unique_txs)\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+                    expected_requested_txs=mininode_unique_txs)\n+            else:\n+                self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=True,\n+                    capacity=capacity, expected_announced_txs=node_txs)\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                    expected_requested_txs=[])\n+\n+        self.request_transactions(self.test_node, node_unique_txs)\n+        # Check those additional transactions are not lost.\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(more_node_txs))\n+        self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False, capacity=0, expected_announced_txs=more_node_txs)\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+            expected_requested_txs=[])\n+\n+    # The node being tested is a reconciliation initiator, the mininode is responder.\n+    def test_recon_initiator(self):\n+        MININODE_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+\n+        # The first node is used to feed the node being tested with transactions.\n+        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=MININODE_SALT, be_recon_requestor=True, be_recon_responder=False))\n+        self.test_node0.wait_for_verack()\n+\n+        # These nodes will consume regular tx flood forwarding\n+        for i in range(MAX_OUTBOUND_FLOOD_TO):\n+            flooding_node = self.nodes[0].add_p2p_connection(TestP2PConn(\n+                recon_version=0, mininode_salt=MININODE_SALT), node_outgoing=True)\n+            flooding_node.wait_for_verack()\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=MININODE_SALT, be_recon_requestor=False, be_recon_responder=True), node_outgoing=True)\n+        self.test_node.wait_for_verack()\n+\n+        self.blocks = self.nodes[0].generate(nblocks=1024)",
      "path": "test/functional/p2p_erlay.py",
      "position": null,
      "original_position": 480,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 615320860,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, pretty arbitrary. I could generate them in `generate_transactions` function, but then it would force block sync across nodes, which is not ideal to test that transactions are not lost between scenarios (block sync could hide this effect by forcing tx sync)",
      "created_at": "2021-04-19T07:14:13Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615594571",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615594571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 556,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616814867",
      "pull_request_review_id": 640132240,
      "id": 616814867,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjgxNDg2Nw==",
      "diff_hunk": "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 295,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we should update BIP330 to mark the dependency on BIP339. Also, should we bump the protocol version ? Otherwise a bip330 peer will send `SENDRECON` for nothing to bip339-only peer (core version 20+).",
      "created_at": "2021-04-20T15:45:54Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616814867",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616814867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2910,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616846325",
      "pull_request_review_id": 640132240,
      "id": 616846325,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjg0NjMyNQ==",
      "diff_hunk": "@@ -2535,6 +2643,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {\n+                        // We flood txs to only a subset of outbound reconciling peers.\n+                        we_may_flood_to = true;\n+                    }\n+                } else {\n+                    // All non-reconciling peers which pass the MightSupportTransactionRelay and\n+                    // !IsInboundConn checks are outbound flooding peers.\n+                    we_may_flood_to = true;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 256,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think what said in comment \"which pass... !IsInboundConn\" is enforced and actually inbound peers might take outbound flooding peers slots ?\r\n\r\nTurning this flag to false break `test_outgoing_recon` as all added peers L475-479 aren't occupying anymore flooding peers slots and as such the tested peers is flood to. IIRC `add_p2p_connection`'s peers are seen as inbound ?",
      "created_at": "2021-04-20T16:24:21Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616846325",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616846325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2672,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616855063",
      "pull_request_review_id": 640132240,
      "id": 616855063,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjg1NTA2Mw==",
      "diff_hunk": "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        bool they_initiator, they_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> they_initiator >> they_responder >> recon_version >> remote_salt;\n+\n+        // Since this is called before VERACK, m_out_flooding_peers doesn't include this peer\n+        // being considered for reconciliation support, so no need for substraction.\n+        m_reconciliation.EnableReconciliationSupport(pfrom.GetId(), pfrom.IsInboundConn(),\n+            they_initiator, they_responder, recon_version, remote_salt, m_out_flood_to);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 309,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is the following scenario possible ?\r\n* current outbound flooding peers=MAX_OUTBOUND_FLOOD_TO - 1\r\n* outbound peer 1 connects\r\n* outbound peer 2 connects\r\n* outbound peer 1 send a SENDRECON is marked as outbound flooding peers as a slot is still available\r\n* outbound peer 2 send a SENDRECON is marked as outbound flooding peers as a slot is still available\r\n* outbound peer 1 send a VERACK, current outbound flooding peers = MAX_OUTBOUND_FLOOD_TO\r\n* outbound peer 2 send a VERACK, current outbound flooding peers = MAX_OUTBOUND_FLOOD_TO +1 \r\n\r\nWhat do you think about moving outbound flooding peers accouting from VERACK to SENDRECON ? Independently of my scenario truthiness, I believe it would even avoid to reason on how message ordering is influencing accounting.",
      "created_at": "2021-04-20T16:35:59Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616855063",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616855063"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2818,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616861921",
      "pull_request_review_id": 640132240,
      "id": 616861921,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjg2MTkyMQ==",
      "diff_hunk": "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 47,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this variable belong more to our transaction relay policy rather than the reconciliation module in itself.  Its effect on the reconciliation module are function of the connection state, which is located outside this module. I'm leaning towards removing any \"flooding\" mention from this module, it should be agnostic about the existence of another transaction-announcement protocol.\r\n\r\nI guess \"flood\" could be a flag in `CNodeState`/`Peer` and allow to remove `IsPeerChosenForFlooding` here.\r\n\r\nWhat do you think ?",
      "created_at": "2021-04-20T16:43:49Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616861921",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616861921"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616897107",
      "pull_request_review_id": 640132240,
      "id": 616897107,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjg5NzEwNw==",
      "diff_hunk": "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 522,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think `MAX_PEER_TX_ANNOUNCEMENTS` is covered by `p2p_erlay.py` ? This diff doesn't yell an error.\r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex 689b899f1..0703fcea7 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -81,7 +81,7 @@ static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\r\n  *  the actual transaction (from any peer) in response to requests for them.\r\n  *  Also limits a maximum number of elements to store in the reconciliation set.\r\n  */\r\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\r\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 4999;\r\n /** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\r\n static constexpr auto TXID_RELAY_DELAY = std::chrono::seconds{2};\r\n /** How long to delay requesting transactions from non-preferred peers */\r\n```",
      "created_at": "2021-04-20T17:32:07Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616897107",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616897107"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4826,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616903681",
      "pull_request_review_id": 640132240,
      "id": 616903681,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjkwMzY4MQ==",
      "diff_hunk": "@@ -4525,12 +4741,12 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                        std::set<uint256>::iterator it = vInvTx.back();\n+                        uint256 hash = vInvTx.back();\n+                        const bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 491,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "IIUC, erlay is introducing an interdependency between transaction's source and selection of outgoing announcement-protocol (cf `RelayTransaction`), but I'm not if this is covered by `p2p_erlay.py` ? Following diff doesn't yell a failure. Same we turning to always true.\r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex 1818fc0f2..a4e847110 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -4732,7 +4732,8 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\r\n                         // Fetch the top element from the heap\r\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\r\n                         uint256 hash = vInvTx.back();\r\n-                        bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);\r\n+                        //bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);\r\n+                        bool flood_tx = false;\r\n                         vInvTx.pop_back();\r\n                         CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\r\n                         // Remove it from the to-be-sent set\r\n```",
      "created_at": "2021-04-20T17:40:31Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616903681",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616903681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616905161",
      "pull_request_review_id": 640132240,
      "id": 616905161,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjkwNTE2MQ==",
      "diff_hunk": "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 527,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it should be AND not an OR here. If `recon_peer_flood_to`= false, even if transaction is marked for flooding, it will be added to reconciliation set. Is it the semantic intended ?",
      "created_at": "2021-04-20T17:42:51Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616905161",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616905161"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616910754",
      "pull_request_review_id": 640132240,
      "id": 616910754,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjkxMDc1NA==",
      "diff_hunk": "@@ -4457,22 +4668,26 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             peer->m_blocks_for_inv_relay.clear();\n \n             if (pto->m_tx_relay != nullptr) {\n+                const bool supports_recon = m_reconciliation.IsPeerRegistered(pto->GetId());\n                 LOCK(pto->m_tx_relay->cs_tx_inventory);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n                 if (pto->m_tx_relay->nNextInvSend < current_time) {\n                     fSendTrickle = true;\n-                    if (pto->IsInboundConn()) {\n+                    if (!supports_recon && pto->IsInboundConn()) {\n                         pto->m_tx_relay->nNextInvSend = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n                     } else {\n+                        // Use half the delay for outbound peers, as there is less privacy concern for them.\n+                        // Also use half delay for inbound peers if they use reconciliations,\n+                        // because we have an additional delay for sending out requested sketches.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 447,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure if the following change on how reconciliation is influencing broadcast interval is covered by `p2p_erlay.py`\r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex 1818fc0f2..28641f576 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -4664,7 +4664,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\r\n                 bool fSendTrickle = pto->HasPermission(PF_NOBAN);\r\n                 if (pto->m_tx_relay->nNextInvSend < current_time) {\r\n                     fSendTrickle = true;\r\n-                    if (!supports_recon && pto->IsInboundConn()) {\r\n+                    if (pto->IsInboundConn()) {\r\n                         pto->m_tx_relay->nNextInvSend = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\r\n                     } else {\r\n                         // Use half the delay for outbound peers, as there is less privacy concern for them.\r\n```",
      "created_at": "2021-04-20T17:51:11Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616910754",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616910754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4724,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617332543",
      "pull_request_review_id": 640794804,
      "id": 617332543,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzMzMjU0Mw==",
      "diff_hunk": "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 527,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616905161,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">Is it the semantic intended?\r\n\r\nYes. Whether the transaction is marked for flooding *only* matters for reconciliation peers which are set for flooding.\r\nSo, if `flood_tx=true` but `recon_peer_flood_to= false`, we should reconcile.\r\n\r\nPerhaps this comment covers it already, no:\r\n```\r\n    /**\r\n     * Per BIP-330, we may want to flood certain transactions to a subset of peers with whom we\r\n     * reconcile.\r\n     * If the peer was not previously registered for reconciliations, returns nullopt.\r\n     */\r\n    std::optional<bool> IsPeerChosenForFlooding(NodeId peer_id) const;\r\n```\r\n\r\nShould I repeat it here?\r\n\r\n",
      "created_at": "2021-04-21T08:57:22Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617332543",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617332543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617336557",
      "pull_request_review_id": 640800102,
      "id": 617336557,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzMzNjU1Nw==",
      "diff_hunk": "@@ -2535,6 +2643,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {\n+                        // We flood txs to only a subset of outbound reconciling peers.\n+                        we_may_flood_to = true;\n+                    }\n+                } else {\n+                    // All non-reconciling peers which pass the MightSupportTransactionRelay and\n+                    // !IsInboundConn checks are outbound flooding peers.\n+                    we_may_flood_to = true;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 256,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616846325,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">I don't think what said in comment \"which pass... !IsInboundConn\" is enforced and actually inbound peers might take outbound flooding peers slots ?\r\n\r\nSee line above: `if (!pfrom.IsInboundConn()) {`, that's where it's enforced.\r\n\r\n>IIRC add_p2p_connection's peers are seen as inbound ?\r\n\r\nNope, I added a hack for that: 108b0233be7735b793e488ba5bda836d24b75d4e",
      "created_at": "2021-04-21T09:02:46Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617336557",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617336557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2672,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617353731",
      "pull_request_review_id": 640822764,
      "id": 617353731,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzM1MzczMQ==",
      "diff_hunk": "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 295,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616814867,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">I think we should update BIP330 to mark the dependency on BIP339.\r\n\r\nAgree.\r\n\r\n>Also, should we bump the protocol version ? Otherwise a bip330 peer will send SENDRECON for nothing to bip339-only peer (core version 20+).\r\n\r\nI don't understand what you mean here. \r\n",
      "created_at": "2021-04-21T09:25:55Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617353731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617353731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2910,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617367944",
      "pull_request_review_id": 640868059,
      "id": 617367944,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzM2Nzk0NA==",
      "diff_hunk": "@@ -2308,6 +2354,59 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n+namespace {\n+class CompareInvMempoolOrder\n+{\n+    CTxMemPool *mp;\n+    bool m_wtxid_relay;\n+public:\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    {\n+        mp = _mempool;\n+        m_wtxid_relay = use_wtxid;\n+    }\n+\n+    bool operator()(const uint256& a, const uint256& b)\n+    {\n+        /* As std::make_heap produces a max-heap, we want the entries with the\n+         * fewest ancestors/highest fee to sort later. */\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n+    }\n+};\n+}\n+\n+void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+    // A heap is used so that not all items need sorting if only a few are being sent.\n+    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, true);\n+    std::make_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    while (!remote_missing_wtxids.empty()) {\n+        // No need to add transactions to peer's filter or do checks\n+        // because it was already done when adding to the reconciliation set.",
      "path": "src/net_processing.cpp",
      "position": 92,
      "original_position": 204,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "in_reply_to_id": 614225402,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Accidentally some nodes might ignore fee filter, but we don't punish, so it's safe in that sense. Some useless transactions could be sent, but I think it's too hard to exploit in a real way.",
      "created_at": "2021-04-21T09:45:07Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617367944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617367944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3312,
      "original_line": 3312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617622941",
      "pull_request_review_id": 641193149,
      "id": 617622941,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzYyMjk0MQ==",
      "diff_hunk": "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continue */",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 493,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "eede5dc518502fd31c2b83ffc8a212f645f75cf8",
      "in_reply_to_id": null,
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "linter not happy with this line:\r\n\r\n`All calls to LogPrintf() and LogPrint() should be terminated with \\n`\r\n",
      "created_at": "2021-04-21T14:52:01Z",
      "updated_at": "2021-05-05T11:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617622941",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617622941"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 493,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617664798",
      "pull_request_review_id": 641248911,
      "id": 617664798,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY2NDc5OA==",
      "diff_hunk": "@@ -2308,6 +2354,59 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n+namespace {\n+class CompareInvMempoolOrder\n+{\n+    CTxMemPool *mp;\n+    bool m_wtxid_relay;\n+public:\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    {\n+        mp = _mempool;\n+        m_wtxid_relay = use_wtxid;\n+    }\n+\n+    bool operator()(const uint256& a, const uint256& b)\n+    {\n+        /* As std::make_heap produces a max-heap, we want the entries with the\n+         * fewest ancestors/highest fee to sort later. */\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n+    }\n+};\n+}\n+\n+void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+    // A heap is used so that not all items need sorting if only a few are being sent.\n+    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, true);\n+    std::make_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    while (!remote_missing_wtxids.empty()) {\n+        // No need to add transactions to peer's filter or do checks\n+        // because it was already done when adding to the reconciliation set.",
      "path": "src/net_processing.cpp",
      "position": 92,
      "original_position": 204,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "in_reply_to_id": 614225402,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes I recognize that's hard to exploit but even further any mempool manipulation comes up with a priced cost for the attacker as you need utxo value to fan out in victim(s) mempools.",
      "created_at": "2021-04-21T15:39:43Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617664798",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617664798"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3312,
      "original_line": 3312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617670809",
      "pull_request_review_id": 641256818,
      "id": 617670809,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY3MDgwOQ==",
      "diff_hunk": "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 295,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616814867,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A bip330 peer sends a SENDRECON message to a wtxid-relay peer but not supporting bip330. \r\nThe wtxid-relay peer doesn't understand SENDRECON and will ignore the message.\r\nThe bip330 wasted SENDRECON message bandwidth.\r\n\r\nIf the bip330 peer would have been aware that the wtxid-relay peer didn't support bip330 it could have avoid sending SENDRECON. Right now, I think your check implies that wtxid-relay peers also support bip330, I believe a protocol version bump would avoid this minor issue.",
      "created_at": "2021-04-21T15:46:48Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617670809",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617670809"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2910,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617686514",
      "pull_request_review_id": 641277457,
      "id": 617686514,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY4NjUxNA==",
      "diff_hunk": "@@ -2535,6 +2643,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {\n+                        // We flood txs to only a subset of outbound reconciling peers.\n+                        we_may_flood_to = true;\n+                    }\n+                } else {\n+                    // All non-reconciling peers which pass the MightSupportTransactionRelay and\n+                    // !IsInboundConn checks are outbound flooding peers.\n+                    we_may_flood_to = true;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 256,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616846325,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah sorry didn't see the patch was the reason of my confusion. So yes it's tested and the logic works as documented. \r\n\r\nMaybe add a friendly note L475 in `p2p_erlay.py` \"Contrary to default mininode setting, we mark those peers as node_outgoing=true to simulate them as outgoing connections and thus have them consume regular flood tx forwarding\" ?",
      "created_at": "2021-04-21T16:05:38Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617686514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617686514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2672,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617690684",
      "pull_request_review_id": 641282944,
      "id": 617690684,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY5MDY4NA==",
      "diff_hunk": "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########",
      "path": "test/functional/p2p_erlay.py",
      "position": null,
      "original_position": 38,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 614934750,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@brunoerg I think following best practices beyond what *our* linter does is not necessary, but still I tried to resolve most of those complaints from `pycodestyle` where it makes sense.",
      "created_at": "2021-04-21T16:11:02Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617690684",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617690684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617718341",
      "pull_request_review_id": 641318641,
      "id": 617718341,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzcxODM0MQ==",
      "diff_hunk": "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 527,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616905161,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">  So, if flood_tx=true but recon_peer_flood_to= false, we should reconcile.\r\n\r\nThis case I understand. The case I don't get the rational for is recon_peer_flood_to=true and flood_tx=false. \r\n\r\nAFAICT, it's motivated to preserve privacy of transactions originated locally as detailed in `RelayTransaction` ? I don't think it's achieving its goal as this announcement (i.e _reconciliation_) will diverge from the announcement-protocol expected on the link (i.e _flooding_) and this is observable by the peer on the other side of the link ?\r\n\r\nOverall, yes the comment could be better as it's describing code behavior but not it's rational (or pointing where the rational is laid out). Instead, what do you think of ?\r\n\r\n```\r\n\r\n// Unless sketch capacity has been reached, expected announcement policy should not diverge\r\n// for reconciling peers.\r\n// Outbound flooding peers may the expected announcement policy overridden in function of\r\n// the transaction source. Transactions originated locally should be always announced through\r\n// reconciliation, see RelayTransaction().\r\n\r\n``` ",
      "created_at": "2021-04-21T16:49:19Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617718341",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617718341"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617765235",
      "pull_request_review_id": 641380591,
      "id": 617765235,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzc2NTIzNQ==",
      "diff_hunk": "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;",
      "path": "src/net_processing.cpp",
      "position": 133,
      "original_position": 336,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If your peer has been marked as a responder but it sends you anyway a REQRECON, should we severe the connection ? I think it's qualify as a violation of protocol roles (sender, responder) as negotiated in SENDRECON.\r\n\r\nSame reasoning for other Erlay messages, should we enforce protocol flow ?",
      "created_at": "2021-04-21T17:58:28Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617765235",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617765235"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4946,
      "original_line": 4946,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617774781",
      "pull_request_review_id": 641380591,
      "id": 617774781,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzc3NDc4MQ==",
      "diff_hunk": "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);\n+        return;\n+    }\n+\n+    if (msg_type == NetMsgType::SKETCH) {\n+        std::vector<uint8_t> skdata;\n+        vRecv >> skdata;\n+\n+        std::vector<uint32_t> txs_to_request;\n+        std::vector<uint256> txs_to_announce;\n+        std::optional<bool> recon_result;\n+        bool valid_sketch = m_reconciliation.HandleSketch(pfrom.GetId(), skdata, txs_to_request, txs_to_announce, recon_result);\n+\n+        if (valid_sketch) {\n+            if (recon_result) {\n+                // Handles both successful and failed reconciliation (but not the case per which\n+                // we want to request extension).\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                    *recon_result, txs_to_request));\n+            } else {\n+                // No final result means we should request sketch extension to make another\n+                // reconciliation attempt without losing the initial data.\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::REQSKETCHEXT));\n+            }\n+            AnnounceTxs(txs_to_announce, pfrom);\n+        } else {\n+            // Disconnect peers that send reconciliation sketch violating the protocol.\n+            LogPrint(BCLog::NET, \"sketch from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;",
      "path": "src/net_processing.cpp",
      "position": 163,
      "original_position": 366,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Mutating this flag to false doesn't seem to break `p2p_erlay.py` ?\r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex bbab3f92c..1dfdc3017 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -3998,7 +3998,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\r\n         } else {\r\n             // Disconnect peers that send reconciliation sketch violating the protocol.\r\n             LogPrint(BCLog::NET, \"sketch from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\r\n-            pfrom.fDisconnect = true;\r\n+            pfrom.fDisconnect = false;\r\n             return;\r\n         }\r\n         return;\r\n```",
      "created_at": "2021-04-21T18:13:54Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617774781",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617774781"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4976,
      "original_line": 4976,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617784280",
      "pull_request_review_id": 641380591,
      "id": 617784280,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzc4NDI4MA==",
      "diff_hunk": "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 338,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we sanitize `peer_recon_set_size` ?\r\n\r\nWhat if a peer send you peer_recon_set_size=UINT16_MAX, may this provoke issues in `EstimateSketchCapacity` or `ComputeBaseSketch`, which are both consuming this value or product of it ?",
      "created_at": "2021-04-21T18:28:32Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617784280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617784280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617790228",
      "pull_request_review_id": 641380591,
      "id": 617790228,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzc5MDIyOA==",
      "diff_hunk": "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;\n+\n+        auto local_salt = m_local_salts.find(peer_id);\n+\n+        // This function should be called only after generating the local salt.\n+        if(local_salt == m_local_salts.end()) return;\n+\n+        // Must match SuggestReconciling logic.\n+        bool we_may_initiate = !inbound, we_may_respond = inbound;\n+\n+        bool they_initiate = they_may_initiate && we_may_respond;\n+        bool we_initiate = we_may_initiate && they_may_respond;\n+        // If we ever announce we_initiate && we_may_respond, this will need tie-breaking. For now,\n+        // this is mutually exclusive because both are based on the inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        if (!(they_initiate || we_initiate)) return;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        // To save bandwidth, we never flood to inbound peers we reconcile with. We may flood *some*\n+        // transactions to a limited number outbound peers we reconcile with.\n+        bool flood_to = !inbound && outbound_flooders < MAX_OUTBOUND_FLOOD_TO;\n+\n+        LogPrint(BCLog::NET, \"Register peer=%d for reconciliation with the following params: \" /* Continued */\n+            \"we_initiate=%i, they_initiate=%i, flood_to=%i.\\n\", peer_id, we_initiate, they_initiate, flood_to);\n+\n+        uint256 full_salt = ComputeSalt(local_salt->second, remote_salt);\n+\n+        m_states.emplace(peer_id, ReconciliationState(full_salt.GetUint64(0),\n+            full_salt.GetUint64(1), we_initiate, flood_to));\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        assert(txs_to_reconcile.size() > 0);\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state->second.m_local_set.m_wtxids.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, recon_state->second.m_local_set.GetSize(), peer_id);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return std::nullopt;\n+        if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order based on the queue,\n+            // and with a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request < current_time && m_queue.back() == peer_id) {\n+                recon_state->second.m_state_init_by_us.m_phase = Phase::INIT_REQUESTED;\n+                m_queue.pop_back();\n+                m_queue.push_front(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+                double local_q = recon_state->second.m_state_init_by_us.m_local_q;\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i, local_q=%i.\\n\", peer_id, local_set_size, local_q);\n+\n+                return std::make_pair(local_set_size, local_q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return;\n+        if (recon_state->second.m_state_init_by_them.m_phase != Phase::NONE) return;\n+        if (recon_state->second.m_we_initiate) return;\n+\n+        double peer_q_converted = peer_q * 1.0 / Q_PRECISION;\n+        recon_state->second.m_state_init_by_them.m_remote_q = peer_q_converted;\n+        recon_state->second.m_state_init_by_them.m_remote_set_size = peer_recon_set_size;\n+        recon_state->second.m_state_init_by_them.m_next_recon_respond = NextReconRespond();\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_REQUESTED;\n+\n+        LogPrint(BCLog::NET, \"Reconciliation initiated by peer=%d with the following params: \" /* Continued */\n+            \"remote_q=%d, remote_set_size=%i.\\n\", peer_id, peer_q_converted, peer_recon_set_size);\n+    }\n+\n+    bool RespondToReconciliationRequest(NodeId peer_id, std::vector<uint8_t>& skdata)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return false;\n+        if (recon_state->second.m_we_initiate) return false;\n+\n+        Phase incoming_phase = recon_state->second.m_state_init_by_them.m_phase;\n+\n+        // For initial requests, respond only periodically to a) limit CPU usage for sketch computation,\n+        // and, b) limit transaction possession privacy leak.\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        bool timely_initial_request = incoming_phase == Phase::INIT_REQUESTED &&\n+            current_time > recon_state->second.m_state_init_by_them.m_next_recon_respond;\n+        bool extension_request = incoming_phase == Phase::EXT_REQUESTED;\n+        if (!timely_initial_request && !extension_request) {\n+            return false;\n+        }\n+\n+        Minisketch sketch;\n+        if (timely_initial_request) {\n+            // Responding to an initial reconciliation request.\n+\n+            uint16_t sketch_capacity = 0;\n+            // We send an empty vector at initial request in the following 2 cases because\n+            // reconciliation can't help:\n+            // - if we have nothing on our side\n+            // - if they have nothing on their side\n+            // Then, they will terminate reconciliation early and force flooding-style announcement.\n+            if (recon_state->second.m_state_init_by_them.m_remote_set_size > 0 &&\n+                    recon_state->second.m_local_set.GetSize() > 0) {\n+\n+                sketch_capacity = recon_state->second.m_state_init_by_them.EstimateSketchCapacity(\n+                    recon_state->second.m_local_set.GetSize());\n+                Minisketch sketch = recon_state->second.ComputeBaseSketch(sketch_capacity);\n+                if (sketch) skdata = sketch.Serialize();\n+            }\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_RESPONDED;\n+            recon_state->second.PrepareForExtensionRequest(sketch_capacity);\n+\n+            LogPrint(BCLog::NET, \"Responding with a sketch to reconciliation initiated by peer=%d: \" /* Continued */\n+                \"sending sketch of capacity=%i.\\n\", peer_id, sketch_capacity);\n+        } else {\n+            // Responding to an extension request.\n+            if (recon_state->second.m_capacity_snapshot == 0) {\n+                // In this case, the peer is supposed to terminate the reconciliation and not\n+                // request extension.\n+                LogPrint(BCLog::NET, \"Peer=%d violated the protocol by requesting an extension \" /* Continued */\n+                    \"even though we initially provided an empty sketch.\\n\", peer_id);\n+                return false;\n+            }\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.m_state_init_by_them.m_phase = Phase::EXT_RESPONDED;\n+\n+            // Local extension sketch can be null only if initial sketch or initial capacity was 0,\n+            // in which case we would have terminated reconciliation already.\n+            uint16_t extended_capacity = std::min(uint16_t(recon_state->second.m_capacity_snapshot * 2), MAX_SKETCH_CAPACITY);\n+            sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+            assert(sketch);\n+            skdata = sketch.Serialize();\n+\n+            // For the sketch extension, send only the higher sketch elements.\n+            size_t lower_bytes_to_drop = extended_capacity / 2 * BYTES_PER_SKETCH_CAPACITY;\n+            // Extended sketch is twice the size of the initial sketch (which is m_capacity_snapshot).\n+            assert(lower_bytes_to_drop <= skdata.size());\n+            skdata.erase(skdata.begin(), skdata.begin() + lower_bytes_to_drop);\n+\n+            LogPrint(BCLog::NET, \"Responding with a sketch extension to reconciliation initiated by peer=%d.\\n\", peer_id);\n+        }\n+        return true;\n+    }\n+\n+    bool HandleSketch(NodeId peer_id, const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        // Protocol violation: our peer exceeded the sketch capacity, or sent a malformed sketch.\n+        if (remote_sketch_capacity > MAX_SKETCH_CAPACITY) {",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 811,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should `MAX_SKETCH_CAPACITY` be exposed in the BIP ?\r\n\r\nOtherwise I think other implementation can't verify when they're not in violation of your reconciliation bounds.\r\n\r\n",
      "created_at": "2021-04-21T18:38:18Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617790228",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617790228"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 805,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617800136",
      "pull_request_review_id": 641380591,
      "id": 617800136,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzgwMDEzNg==",
      "diff_hunk": "@@ -4577,12 +4822,43 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             pto->m_tx_relay->filterInventoryKnown.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_reconciliation.AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n             }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            auto reconciliation_request_data = m_reconciliation.MaybeRequestReconciliation(pto->GetId());\n+            if (reconciliation_request_data) {\n+                const auto [local_set_size, local_q_formatted] = (*reconciliation_request_data);\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::REQRECON, local_set_size, local_q_formatted));\n+            }\n+        }\n+\n+        //\n+        // Message: reconciliation response\n+        //\n+        {\n+            std::vector<uint8_t> skdata;\n+            bool respond = m_reconciliation.RespondToReconciliationRequest(pto->GetId(), skdata);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 570,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How do we handle failure if the responder never replies to our reconciliation request ?\r\n\r\nI don't think this is handled by `TxReconciliationTracker` for now. After RECON_REQUEST_INTERVAL expires again, is `MaybeRequestReconciliation` going to generate a new reconciliation request ?",
      "created_at": "2021-04-21T18:54:51Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617800136",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617800136"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617803685",
      "pull_request_review_id": 641380591,
      "id": 617803685,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzgwMzY4NQ==",
      "diff_hunk": "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);\n+        return;\n+    }\n+\n+    if (msg_type == NetMsgType::SKETCH) {\n+        std::vector<uint8_t> skdata;\n+        vRecv >> skdata;\n+\n+        std::vector<uint32_t> txs_to_request;\n+        std::vector<uint256> txs_to_announce;\n+        std::optional<bool> recon_result;\n+        bool valid_sketch = m_reconciliation.HandleSketch(pfrom.GetId(), skdata, txs_to_request, txs_to_announce, recon_result);\n+\n+        if (valid_sketch) {\n+            if (recon_result) {\n+                // Handles both successful and failed reconciliation (but not the case per which\n+                // we want to request extension).\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                    *recon_result, txs_to_request));\n+            } else {\n+                // No final result means we should request sketch extension to make another\n+                // reconciliation attempt without losing the initial data.\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::REQSKETCHEXT));\n+            }\n+            AnnounceTxs(txs_to_announce, pfrom);\n+        } else {\n+            // Disconnect peers that send reconciliation sketch violating the protocol.\n+            LogPrint(BCLog::NET, \"sketch from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+        return;\n+    }\n+\n+    if (msg_type == NetMsgType::REQSKETCHEXT) {\n+        m_reconciliation.HandleExtensionRequest(pfrom.GetId());\n+        return;\n+    }\n+\n+    // Among transactions requested by short ID here, we should send only those transactions\n+    // sketched (stored in local set snapshot), because otherwise we would leak privacy (mempool content).\n+    if (msg_type == NetMsgType::RECONCILDIFF) {\n+        bool recon_result;\n+        std::vector<uint32_t> ask_shortids;\n+        vRecv >> recon_result >> ask_shortids;\n+\n+        std::vector<uint256> remote_missing;\n+        bool valid_finalization = m_reconciliation.FinalizeInitByThem(pfrom.GetId(), recon_result, ask_shortids, remote_missing);\n+        if (valid_finalization) {\n+            AnnounceTxs(remote_missing, pfrom);\n+        } else {\n+            // Disconnect peers that send reconciliation finalization violating the protocol.\n+            LogPrint(BCLog::NET, \"reconcildiff from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;",
      "path": "src/net_processing.cpp",
      "position": 188,
      "original_position": 391,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Mutating this flag doesn't seem to break `p2p_erlay.py` \r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex bbab3f92c..62afc0eb3 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -4023,7 +4023,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\r\n         } else {\r\n             // Disconnect peers that send reconciliation finalization violating the protocol.\r\n             LogPrint(BCLog::NET, \"reconcildiff from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\r\n-            pfrom.fDisconnect = true;\r\n+            pfrom.fDisconnect = false;\r\n             return;\r\n         }\r\n         return;\r\n```",
      "created_at": "2021-04-21T19:00:24Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617803685",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617803685"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5001,
      "original_line": 5001,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618127934",
      "pull_request_review_id": 641835595,
      "id": 618127934,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODEyNzkzNA==",
      "diff_hunk": "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;",
      "path": "src/net_processing.cpp",
      "position": 133,
      "original_position": 336,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "in_reply_to_id": 617765235,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It is enforced in `txreconciliation.cpp`, but currently these requests are just ignored. I'm not sure if we should disconnect.",
      "created_at": "2021-04-22T06:55:00Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618127934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618127934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4946,
      "original_line": 4946,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618129008",
      "pull_request_review_id": 641836901,
      "id": 618129008,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODEyOTAwOA==",
      "diff_hunk": "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 338,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "in_reply_to_id": 617784280,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">What if a peer send you peer_recon_set_size=UINT16_MAX, may this provoke issues in EstimateSketchCapacity or ComputeBaseSketch, which are both consuming this value or product of it ?\r\n\r\nThis is taken care by `capacity = std::min(capacity, MAX_SKETCH_CAPACITY);` in `ComputeBaseSketch`, so this shouldn't cause any harm.",
      "created_at": "2021-04-22T06:56:43Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618129008",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618129008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618130349",
      "pull_request_review_id": 641838567,
      "id": 618130349,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODEzMDM0OQ==",
      "diff_hunk": "@@ -4577,12 +4822,43 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             pto->m_tx_relay->filterInventoryKnown.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_reconciliation.AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n             }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            auto reconciliation_request_data = m_reconciliation.MaybeRequestReconciliation(pto->GetId());\n+            if (reconciliation_request_data) {\n+                const auto [local_set_size, local_q_formatted] = (*reconciliation_request_data);\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::REQRECON, local_set_size, local_q_formatted));\n+            }\n+        }\n+\n+        //\n+        // Message: reconciliation response\n+        //\n+        {\n+            std::vector<uint8_t> skdata;\n+            bool respond = m_reconciliation.RespondToReconciliationRequest(pto->GetId(), skdata);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 570,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "in_reply_to_id": 617800136,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">is MaybeRequestReconciliation going to generate a new reconciliation request ?\r\n\r\nNo, because `if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;` takes care of that. Basically, an initiator will wait forever.",
      "created_at": "2021-04-22T06:58:55Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618130349",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618130349"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618457926",
      "pull_request_review_id": 642279533,
      "id": 618457926,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODQ1NzkyNg==",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED",
      "path": "test/functional/p2p_erlay.py",
      "position": null,
      "original_position": 20,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "linter turned up:\r\n`test/functional/p2p_erlay.py:20:1: F401 'test_framework.p2p.MIN_P2P_VERSION_SUPPORTED' imported but unused`",
      "created_at": "2021-04-22T14:32:47Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618457926",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618457926"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618689965",
      "pull_request_review_id": 642603060,
      "id": 618689965,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODY4OTk2NQ==",
      "diff_hunk": "@@ -0,0 +1,555 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED",
      "path": "test/functional/p2p_erlay.py",
      "position": null,
      "original_position": 20,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": 618457926,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oops, sorry I keep missing these issues. Linter broke on my machine for some reason, I better fix it before pushing again.",
      "created_at": "2021-04-22T19:42:48Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618689965",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618689965"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/620993937",
      "pull_request_review_id": 645594742,
      "id": 620993937,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDk5MzkzNw==",
      "diff_hunk": "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 527,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616905161,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">This case I understand. The case I don't get the rational for is recon_peer_flood_to=true and flood_tx=false.\r\n\r\nOk, what exactly are you suggesting? Always flood if `recon_peer_flood_to=true` and drop `flood_tx` at all?\r\n\r\n1. If this is applied, non-reachable nodes will flood transactions to 7 (erlay enabled) peers after receiving transactions from the 8th. No bandwidth savings because almost all transactions are flooded, bad.\r\n\r\n2. How erlay solves this? Adding a policy: \"flood only if a transaction is received from reconciliation initiator [or legacy peer]\". Now non-reachable nodes will never flood, because they have no recon initiator peers (because they have no inbounds). Assuming no legacy peers.\r\n\r\n3. Now, what to do with local transactions? If non-reachable nodes flood them, their reconciling peers will easily tell those are local transactions, because this is the only case non-reachable node floods.\r\nFor this special case, we also use reconciliation, to provide privacy.\r\n\r\n-------------------––––-------\r\n\r\nNow, I assume you can change step (2) or even step (1) here and have some different logic. Feel free to suggest, but this is my thinking for now, and Erlay is based on it. \r\n\r\nLet me know if it's clear.\r\n",
      "created_at": "2021-04-27T08:43:43Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r620993937",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/620993937"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/621060125",
      "pull_request_review_id": 645670857,
      "id": 621060125,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMTA2MDEyNQ==",
      "diff_hunk": "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        bool they_initiator, they_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> they_initiator >> they_responder >> recon_version >> remote_salt;\n+\n+        // Since this is called before VERACK, m_out_flooding_peers doesn't include this peer\n+        // being considered for reconciliation support, so no need for substraction.\n+        m_reconciliation.EnableReconciliationSupport(pfrom.GetId(), pfrom.IsInboundConn(),\n+            they_initiator, they_responder, recon_version, remote_salt, m_out_flood_to);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 309,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616855063,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, this scenario is possible.\r\n\r\n>What do you think about moving outbound flooding peers accouting from VERACK to SENDRECON ?\r\n\r\nThe problem with your suggestion is that we also need to account for peers which will never send SENDRECON (legacy flooding peers). There are 2 possible solutions:\r\n\r\n1. Handle legacy peers as a special case, so have this accounting twice (in VERACK for legacy, in SENDRECON for reconciliation).\r\n2. Always initialize ReconciliationState with `m_flood_to=false`, and update it to true on VERACK if there are still slots (along with tracking out peers in VERACK)",
      "created_at": "2021-04-27T10:01:07Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r621060125",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/621060125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2818,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/621156563",
      "pull_request_review_id": 645788901,
      "id": 621156563,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMTE1NjU2Mw==",
      "diff_hunk": "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        bool they_initiator, they_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> they_initiator >> they_responder >> recon_version >> remote_salt;\n+\n+        // Since this is called before VERACK, m_out_flooding_peers doesn't include this peer\n+        // being considered for reconciliation support, so no need for substraction.\n+        m_reconciliation.EnableReconciliationSupport(pfrom.GetId(), pfrom.IsInboundConn(),\n+            they_initiator, they_responder, recon_version, remote_salt, m_out_flood_to);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 309,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616855063,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I will implement the latter.",
      "created_at": "2021-04-27T12:24:37Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r621156563",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/621156563"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2818,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/622379909",
      "pull_request_review_id": 647321593,
      "id": 622379909,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjM3OTkwOQ==",
      "diff_hunk": "@@ -2645,6 +2774,51 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (pfrom.GetCommonVersion() < RECONCILIATION_RELAY_VERSION) {\n+            LogPrint(BCLog::NET, \"ignoring sendrecon due to old common version=%d from peer=%d\\n\", pfrom.GetCommonVersion(), pfrom.GetId());\n+            return;\n+        }",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 303,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for implementing the suggestion. \r\n\r\nFurther, should we disconnect sendrecon sender with a protocol version inferior to `RECONCILIATION_RELAY_VERSION` ? \r\n\r\nGood point to keep the check on `WTXID_RELAY_VERSION` support, I thought at first it should be removed but you might have sendrecon sender who don't signal wtxid-relay.",
      "created_at": "2021-04-28T17:10:54Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r622379909",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/622379909"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3611,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/622435781",
      "pull_request_review_id": 647321593,
      "id": 622435781,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjQzNTc4MQ==",
      "diff_hunk": "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 527,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616905161,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> If this is applied, non-reachable nodes will flood transactions to 7 (erlay enabled) peers after receiving transactions from the 8th. No bandwidth savings because almost all transactions are flooded, bad.\r\n\r\nCan you point me where as a _non-reachable node_ we necessary mark our peers as reconciling ones ? AFAICT, it's decided there without evaluating node reachability : https://github.com/naumenkogs/bitcoin/blob/5b8c65d32c142e7d91aef13772cf8c771020bee7/src/txreconciliation.cpp#L654\r\n\r\nThat said, I agree with your laid out reasoning on flooding-vs-reconciling peers selection for non-reachable nodes and how to protect their local transaction privacy. \r\n\r\nBut I don't think current code logic hinders well reachable nodes's local transactions as you will reconciliate (flood_tx=false) with your outbound flooding peers.\r\n\r\nLet me write a functional test to sustain (or not) my thinking :)",
      "created_at": "2021-04-28T18:28:18Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r622435781",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/622435781"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623211332",
      "pull_request_review_id": 648417961,
      "id": 623211332,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzIxMTMzMg==",
      "diff_hunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all reconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0. Reconciliation protocol handshake.\n+ * 1. Once we receive a new transaction, add it to the set instead of announcing immediately\n+ * 2. When the time comes, a reconciliation initiator requests a sketch from the peer, where a sketch\n+ *    is a compressed representation of their set\n+ * 3. Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *    and combines the two skethes to find the difference in *sets*.\n+ * 4. Now the initiator knows full symmetrical difference and can request what the initiator is\n+ *    missing and announce to the peer what the peer is missing. For the former, an extra round is\n+ *    required because the initiator knows only short IDs of those transactions.\n+ * 5. Sometimes reconciliation fails if the difference is larger than the parties estimated,\n+ *    then there is one sketch extension round, in which the initiator requests for extra data.\n+ * 6. If extension succeeds, go to step 4.\n+ * 7. If extension fails, the initiator notifies the peer and announces all transactions from the\n+ *    corresponding set. Once the peer received the failure notification, the peer announces all\n+ *    transactions from the corresponding set.\n+ *\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+    public:\n+\n+    explicit TxReconciliationTracker();\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generate and pass reconciliation parameters to be sent along with the suggestion\n+     * to announce transactions via reconciliations.\n+     * Generates (and stores) a peer-specific salt which will be used for reconciliations.\n+     * Reconciliation roles are based on inbound/outbound role in the connection.\n+     * Returns the following values which will be used to invite a peer to reconcile:\n+     * - whether we want to initiate reconciliation requests (ask for sketches)\n+     * - whether we agree to respond to reconciliation requests (send our sketches)\n+     * - reconciliation protocol version\n+     * - salt used for short ID computation required for reconciliation\n+     * A peer can't be registered for future reconciliations without this call.\n+     */\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound);",
      "path": "src/txreconciliation.h",
      "position": null,
      "original_position": 60,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should interface documentation say that peer must not be registered more than once ?\r\n\r\nI think that's a property enforced by the assert in the implementation.",
      "created_at": "2021-04-29T16:29:55Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623211332",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623211332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623213192",
      "pull_request_review_id": 648417961,
      "id": 623213192,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzIxMzE5Mg==",
      "diff_hunk": "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 134,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`assert(recon_version == RECON_VERSION)` ?",
      "created_at": "2021-04-29T16:32:22Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623213192",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623213192"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623219478",
      "pull_request_review_id": 648417961,
      "id": 623219478,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzIxOTQ3OA==",
      "diff_hunk": "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 143,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What's purpose serves the `TxReconciliationTrackerTest` wrapper given in that unit test you're using directly the reference implementation of `TxReconciliationTracker` ?",
      "created_at": "2021-04-29T16:40:52Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623219478",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623219478"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623238188",
      "pull_request_review_id": 648417961,
      "id": 623238188,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzIzODE4OA==",
      "diff_hunk": "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 630,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "W.r.t to future reconciliation upgrades, IIUC if peer support a lower version than us we downgrade to the lowest common version ? I think it's interesting to document in the `EnableReconciliationSupport` declaration how reconciliation version conflicts are negotiated. Further, why RECON_VERSION=1 and not just 0 ?\r\n\r\nReally likely we'll have to upgrade reconciliation if we introduce package_ids as tx-relay announcements in a near future.",
      "created_at": "2021-04-29T17:07:14Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623238188",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623238188"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 628,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623255076",
      "pull_request_review_id": 648417961,
      "id": 623255076,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzI1NTA3Ng==",
      "diff_hunk": "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    // Test inbound peers.\n+    bool inbound = true;\n+",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just test peer has been registered ?\r\n\r\n```\r\ndiff --git a/src/test/txreconciliation_tests.cpp b/src/test/txreconciliation_tests.cpp\r\nindex e7f20d7de..8dbad9461 100644\r\n--- a/src/test/txreconciliation_tests.cpp\r\n+++ b/src/test/txreconciliation_tests.cpp\r\n@@ -146,6 +146,10 @@ BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\r\n     // Test inbound peers.\r\n     bool inbound = true;\r\n \r\n+    NodeId non_registered_peer = 100;\r\n+    // Do nothing if peer is not registered\r\n+    tracker.EnableReconciliationSupport(non_registered_peer, inbound, false, false, 1, salt, 0);\r\n+\r\n     NodeId peer_id0 = 0;\r\n     tracker.SuggestReconciling(peer_id0, inbound);\r\n     // Both roles are false, don't register.\r\n```\r\n\r\nIt's maybe covered in other tests but otherwise asserting on \r\n\r\n```\r\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\r\nindex d4cfc8ee4..a325e0a2a 100644\r\n--- a/src/txreconciliation.cpp\r\n+++ b/src/txreconciliation.cpp\r\n@@ -632,7 +632,9 @@ class TxReconciliationTracker::Impl {\r\n         auto local_salt = m_local_salts.find(peer_id);\r\n \r\n         // This function should be called only after generating the local salt.\r\n-        if(local_salt == m_local_salts.end()) return;\r\n+        if(local_salt == m_local_salts.end()) {\r\n+            assert(false);\r\n+        }\r\n \r\n         // Must match SuggestReconciling logic.\r\n         bool we_may_initiate = !inbound, we_may_respond = inbound;\r\n```\r\n\r\nDoesn't break `EnableReconciliationSupportTest`.",
      "created_at": "2021-04-29T17:32:06Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623255076",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623255076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623260500",
      "pull_request_review_id": 648417961,
      "id": 623260500,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzI2MDUwMA==",
      "diff_hunk": "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;\n+\n+        auto local_salt = m_local_salts.find(peer_id);\n+\n+        // This function should be called only after generating the local salt.\n+        if(local_salt == m_local_salts.end()) return;\n+\n+        // Must match SuggestReconciling logic.\n+        bool we_may_initiate = !inbound, we_may_respond = inbound;\n+\n+        bool they_initiate = they_may_initiate && we_may_respond;\n+        bool we_initiate = we_may_initiate && they_may_respond;\n+        // If we ever announce we_initiate && we_may_respond, this will need tie-breaking. For now,\n+        // this is mutually exclusive because both are based on the inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        if (!(they_initiate || we_initiate)) return;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 646,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "IIUC, you can only hit this return if the peer is sending us both `they_may_initiate`=false and `they_may_respond`=false. This is def a pathological case and maybe we should disconnect such buggy peer ?",
      "created_at": "2021-04-29T17:40:06Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623260500",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623260500"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 644,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623308713",
      "pull_request_review_id": 648417961,
      "id": 623308713,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzMwODcxMw==",
      "diff_hunk": "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    // Test inbound peers.\n+    bool inbound = true;\n+\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    // Both roles are false, don't register.\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, false, false, 1, salt, 0);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Invalid roles for the given direction.\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, false, true, 1, salt, 0);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Invalid version.\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 0, salt, 0);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Valid peer.\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, salt, 0);\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+    // Don't flood to inbound reconciling peers.\n+    assert(!*tracker.IsPeerChosenForFlooding(peer_id0));\n+\n+    // Test outbound peers.\n+    inbound = false;\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, inbound);\n+    // Say we already have many flooding peers, don't flood to this one.\n+    tracker.EnableReconciliationSupport(peer_id1, inbound, false, true, 1, salt, 127);\n+    assert(!*tracker.IsPeerChosenForFlooding(peer_id1));\n+\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, inbound);\n+    // We choose this peer for flooding because we haven't reached MAX_OUTBOUND_FLOOD_TO.\n+    tracker.EnableReconciliationSupport(peer_id2, inbound, false, true, 1, salt, 1);\n+    assert(*tracker.IsPeerChosenForFlooding(peer_id2));\n+\n+    // We do not support updates.\n+    tracker.EnableReconciliationSupport(peer_id2, inbound, false, true, 1, salt, 127);\n+    assert(*tracker.IsPeerChosenForFlooding(peer_id2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0, 0);\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0, 0);\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0, 0);\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0, 0);\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+}",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 267,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe add some transactions to the set, to exercise that the correct `local_set_size` is returned \r\n\r\n```\r\n@@ -264,6 +270,25 @@ BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\r\n     assert(!tracker.MaybeRequestReconciliation(peer_id2));\r\n     tracker.RemovePeer(peer_id1);\r\n     assert(tracker.MaybeRequestReconciliation(peer_id2));\r\n+    tracker.RemovePeer(peer_id2);\r\n+\r\n+    NodeId peer_id3 = 3;\r\n+    tracker.SuggestReconciling(peer_id3, false);\r\n+    tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0, 0);\r\n+\r\n+    size_t count = 10;\r\n+    for (size_t i = 0; i < count; i++) {\r\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\r\n+    }\r\n+\r\n+    SetMockTime(start_time + 20000);\r\n+    // Make a request.\r\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\r\n+    if (request_data) {\r\n+        const auto [local_set_size, local_q_formatted] = (*request_data);\r\n+        assert(local_set_size == 10);\r\n+        assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\r\n+    }\r\n }\r\n```",
      "created_at": "2021-04-29T18:52:05Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623308713",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623308713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623312838",
      "pull_request_review_id": 648417961,
      "id": 623312838,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzMxMjgzOA==",
      "diff_hunk": "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;\n+\n+        auto local_salt = m_local_salts.find(peer_id);\n+\n+        // This function should be called only after generating the local salt.\n+        if(local_salt == m_local_salts.end()) return;\n+\n+        // Must match SuggestReconciling logic.\n+        bool we_may_initiate = !inbound, we_may_respond = inbound;\n+\n+        bool they_initiate = they_may_initiate && we_may_respond;\n+        bool we_initiate = we_may_initiate && they_may_respond;\n+        // If we ever announce we_initiate && we_may_respond, this will need tie-breaking. For now,\n+        // this is mutually exclusive because both are based on the inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        if (!(they_initiate || we_initiate)) return;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        // To save bandwidth, we never flood to inbound peers we reconcile with. We may flood *some*\n+        // transactions to a limited number outbound peers we reconcile with.\n+        bool flood_to = !inbound && outbound_flooders < MAX_OUTBOUND_FLOOD_TO;\n+\n+        LogPrint(BCLog::NET, \"Register peer=%d for reconciliation with the following params: \" /* Continued */\n+            \"we_initiate=%i, they_initiate=%i, flood_to=%i.\\n\", peer_id, we_initiate, they_initiate, flood_to);\n+\n+        uint256 full_salt = ComputeSalt(local_salt->second, remote_salt);\n+\n+        m_states.emplace(peer_id, ReconciliationState(full_salt.GetUint64(0),\n+            full_salt.GetUint64(1), we_initiate, flood_to));\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        assert(txs_to_reconcile.size() > 0);\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state->second.m_local_set.m_wtxids.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, recon_state->second.m_local_set.GetSize(), peer_id);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return std::nullopt;\n+        if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order based on the queue,\n+            // and with a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request < current_time && m_queue.back() == peer_id) {\n+                recon_state->second.m_state_init_by_us.m_phase = Phase::INIT_REQUESTED;\n+                m_queue.pop_back();\n+                m_queue.push_front(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+                double local_q = recon_state->second.m_state_init_by_us.m_local_q;\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i, local_q=%i.\\n\", peer_id, local_set_size, local_q);\n+\n+                return std::make_pair(local_set_size, local_q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return;\n+        if (recon_state->second.m_state_init_by_them.m_phase != Phase::NONE) return;\n+        if (recon_state->second.m_we_initiate) return;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 718,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This doesn't seem to break `HandleReconciliationRequestTest` ?\r\n\r\n```\r\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\r\nindex d4cfc8ee4..65dcc2675 100644\r\n--- a/src/txreconciliation.cpp\r\n+++ b/src/txreconciliation.cpp\r\n@@ -715,7 +715,9 @@ class TxReconciliationTracker::Impl {\r\n         auto recon_state = m_states.find(peer_id);\r\n         if (recon_state == m_states.end()) return;\r\n         if (recon_state->second.m_state_init_by_them.m_phase != Phase::NONE) return;\r\n-        if (recon_state->second.m_we_initiate) return;\r\n+        if (recon_state->second.m_we_initiate) {\r\n+            assert(false);\r\n+        }\r\n \r\n         double peer_q_converted = peer_q * 1.0 / Q_PRECISION;\r\n         recon_state->second.m_state_init_by_them.m_remote_q = peer_q_converted;\r\n```",
      "created_at": "2021-04-29T18:58:30Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623312838",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623312838"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 723,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623758208",
      "pull_request_review_id": 649062011,
      "id": 623758208,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzc1ODIwOA==",
      "diff_hunk": "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 630,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": 623238188,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">W.r.t to future reconciliation upgrades, IIUC if peer support a lower version than us we downgrade to the lowest common version ? I think it's interesting to document in the EnableReconciliationSupport declaration how reconciliation version conflicts are negotiated.?\r\n\r\nAgree.\r\n\r\n>Further, why RECON_VERSION=1 and not just 0 ?\r\n\r\nI think this is about personal taste, 0 might have special meaning or something. Gonna keep it 1.\r\n\r\n>Really likely we'll have to upgrade reconciliation if we introduce package_ids as tx-relay announcements in a near future.\r\n\r\nThen we have v2 :)",
      "created_at": "2021-04-30T09:54:48Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623758208",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623758208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 628,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623758952",
      "pull_request_review_id": 649062994,
      "id": 623758952,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzc1ODk1Mg==",
      "diff_hunk": "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 143,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": 623219478,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The purpose is to deduplicate the repeatable valid handshake (Suggest/Enable) by hiding it under the `TxReconciliationTrackerTest`",
      "created_at": "2021-04-30T09:56:00Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623758952",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623758952"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623759838",
      "pull_request_review_id": 649064217,
      "id": 623759838,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzc1OTgzOA==",
      "diff_hunk": "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 134,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": 623213192,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1. Not sure this is really useful.\r\n2. RECON_VERSION is currently hidden in the module, it it worth moving it out? ",
      "created_at": "2021-04-30T09:57:37Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623759838",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623759838"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623760722",
      "pull_request_review_id": 649065413,
      "id": 623760722,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzc2MDcyMg==",
      "diff_hunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all reconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0. Reconciliation protocol handshake.\n+ * 1. Once we receive a new transaction, add it to the set instead of announcing immediately\n+ * 2. When the time comes, a reconciliation initiator requests a sketch from the peer, where a sketch\n+ *    is a compressed representation of their set\n+ * 3. Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *    and combines the two skethes to find the difference in *sets*.\n+ * 4. Now the initiator knows full symmetrical difference and can request what the initiator is\n+ *    missing and announce to the peer what the peer is missing. For the former, an extra round is\n+ *    required because the initiator knows only short IDs of those transactions.\n+ * 5. Sometimes reconciliation fails if the difference is larger than the parties estimated,\n+ *    then there is one sketch extension round, in which the initiator requests for extra data.\n+ * 6. If extension succeeds, go to step 4.\n+ * 7. If extension fails, the initiator notifies the peer and announces all transactions from the\n+ *    corresponding set. Once the peer received the failure notification, the peer announces all\n+ *    transactions from the corresponding set.\n+ *\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+    public:\n+\n+    explicit TxReconciliationTracker();\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generate and pass reconciliation parameters to be sent along with the suggestion\n+     * to announce transactions via reconciliations.\n+     * Generates (and stores) a peer-specific salt which will be used for reconciliations.\n+     * Reconciliation roles are based on inbound/outbound role in the connection.\n+     * Returns the following values which will be used to invite a peer to reconcile:\n+     * - whether we want to initiate reconciliation requests (ask for sketches)\n+     * - whether we agree to respond to reconciliation requests (send our sketches)\n+     * - reconciliation protocol version\n+     * - salt used for short ID computation required for reconciliation\n+     * A peer can't be registered for future reconciliations without this call.\n+     */\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound);",
      "path": "src/txreconciliation.h",
      "position": null,
      "original_position": 60,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": 623211332,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1. I think there is a confusion about \"register\". Register for me is when Enable[...] is called and when ReconciliationState is created Here, we just generate the salt.\r\n2. Ok, adding the mention.",
      "created_at": "2021-04-30T09:59:10Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623760722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623760722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623977943",
      "pull_request_review_id": 649348312,
      "id": 623977943,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzk3Nzk0Mw==",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Invalid roles for the given direction.\n+    tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Invalid version.\n+    tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Valid peer.\n+    tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt);\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt);\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0);\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0);\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0);\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0);\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 315,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "96c261630cc42e3bad41a61ba2a589bf2ae22676",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Though embedding the peer in `TxReconciliationTrackerTest` doesn't let you test the no-registered peer or initiation direction for this method ?",
      "created_at": "2021-04-30T15:41:50Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623977943",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623977943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 442,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/624948905",
      "pull_request_review_id": 650173888,
      "id": 624948905,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDk0ODkwNQ==",
      "diff_hunk": "@@ -2645,6 +2774,51 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (pfrom.GetCommonVersion() < RECONCILIATION_RELAY_VERSION) {\n+            LogPrint(BCLog::NET, \"ignoring sendrecon due to old common version=%d from peer=%d\\n\", pfrom.GetCommonVersion(), pfrom.GetId());\n+            return;\n+        }",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 303,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "in_reply_to_id": 622379909,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">Further, should we disconnect sendrecon sender with a protocol version inferior to RECONCILIATION_RELAY_VERSION ?\r\n\r\nYeah seems right.",
      "created_at": "2021-05-03T08:32:35Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624948905",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/624948905"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3611,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/624952992",
      "pull_request_review_id": 650179011,
      "id": 624952992,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDk1Mjk5Mg==",
      "diff_hunk": "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 527,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616905161,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">Can you point me where as a non-reachable node we necessary mark our peers as reconciling ones ? AFAICT, it's decided there without evaluating node reachability : https://github.com/naumenkogs/bitcoin/blob/5b8c65d32c142e7d91aef13772cf8c771020bee7/src/txreconciliation.cpp#L654\r\n\r\nYes, that exact line: `bool flood_to = !inbound && outbound_flooders < MAX_OUTBOUND_FLOOD_TO;`\r\n\r\nFor a non-reachable node, all the peers are `inbound=false`.... and I just realized that my logic only works if connectivity=MAX_OUTBOUND_FLOOD_TO. Is that understandable?\r\n\r\nNow, we should think what to do when we bump the connectivity... Non-reachable nodes will have both `flood_to` false AND true peers.",
      "created_at": "2021-05-03T08:41:43Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624952992",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/624952992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625010038",
      "pull_request_review_id": 650251297,
      "id": 625010038,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTAxMDAzOA==",
      "diff_hunk": "@@ -1507,17 +1526,44 @@ void PeerManagerImpl::SendPings()\n     for(auto& it : m_peer_map) it.second->m_ping_queued = true;\n }\n \n-void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid)\n+void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from)\n {\n-    m_connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+    bool flood;\n+    if (from) {\n+        // Flood those transactions which were received either from pre-reconciliation peers, or\n+        // inbound reconciliation but NOT via outbound reconciliation. Flooding then is mainly\n+        // used for initial propagation of new transactions across a network of reachable nodes\n+        // quickly, while most of the bandwidth is still conserved.\n+        if (m_reconciliation.IsPeerRegistered(*from)) {\n+            flood = !(*m_reconciliation.IsPeerResponder(*from));\n+        } else {\n+            flood = true;\n+        }\n+    }\n+    else {\n+        // Transactions originated locally should be always announced through reconciliation\n+        // for the privacy reasons.\n+        //\n+        // Consider a non-reachable node: the general policy is *flood transactions came from\n+        // inbounds* (see above), so non-reachable nodes would never flood any transactions.\n+        // Now, if they flood their local transactions, it will be obvious for their immediate peers\n+        // that those transactions belong to those non-reachable nodes.\n+        //\n+        // On the other hand, if non-reachable nodes reconcile those transactions, they would look\n+        // like any other transactions of non-reachable nodes.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 136,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "in_reply_to_id": 614211171,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Let's continue this same discussion in one place: https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624952992",
      "created_at": "2021-05-03T10:52:36Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r625010038",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625010038"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1596,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/626118561",
      "pull_request_review_id": 651682258,
      "id": 626118561,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNjExODU2MQ==",
      "diff_hunk": "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 527,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616905161,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">Now, we should think what to do when we bump the connectivity... Non-reachable nodes will have both flood_to false AND true peers.\r\n\r\nOk, so this is fine, because again, local transactions and transactions from outbounds are always reconciled, so it doesn't matter if a non-reachable node has some peers with `flood_to=true`.\r\n\r\nI will improve the docs.\r\n\r\nKeeping this open, it's likely gonna change a bit after I do some experiments.",
      "created_at": "2021-05-04T21:26:27Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r626118561",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/626118561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4787,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/626311725",
      "pull_request_review_id": 651988670,
      "id": 626311725,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNjMxMTcyNQ==",
      "diff_hunk": "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 522,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "in_reply_to_id": 616897107,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I tried to make this test, but signing 5000 transactions takes minutes (that's expected, right?), and that's the only way to test this.\r\n\r\nInstead, I'm adding tests for `MAX_SKETCH_CAPACITY = 2 << 12`",
      "created_at": "2021-05-05T07:14:07Z",
      "updated_at": "2021-05-05T11:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r626311725",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/626311725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4826,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628258132",
      "pull_request_review_id": 654524878,
      "id": 628258132,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODI1ODEzMg==",
      "diff_hunk": "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 283,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What's the unit of the mocktime bump here, seconds or microseconds ? If it's second I would recommend to replace the bumping value by RECON_RESPOND_INTERVAL, I think it can be taken verbatim from txreconciliation.cpp like you're already doing for few values.\r\n\r\nThat way you can assert that's the module is binding to the interval expectation. Otherwise, slightly increasing RECON_RESPOND_INTERVAL doesn't break the test.",
      "created_at": "2021-05-07T14:33:06Z",
      "updated_at": "2021-05-07T17:35:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628258132",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628258132"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 283,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628262633",
      "pull_request_review_id": 654524878,
      "id": 628262633,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODI2MjYzMw==",
      "diff_hunk": "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 315,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it's missing a small case coverage if node is the initiator. It should be ignored.\r\n\r\n```\r\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\r\nindex 0218d21ad..9cac2eba5 100644\r\n--- a/src/txreconciliation.cpp\r\n+++ b/src/txreconciliation.cpp\r\n@@ -786,7 +786,7 @@ class TxReconciliationTracker::Impl {\r\n         LOCK(m_mutex);\r\n         auto recon_state = m_states.find(peer_id);\r\n         if (recon_state == m_states.end()) return false;\r\n-        if (recon_state->second.m_we_initiate) return false;\r\n+        //if (recon_state->second.m_we_initiate) return false;\r\n \r\n         Phase incoming_phase = recon_state->second.m_state_init_by_them.m_phase;\r\n```",
      "created_at": "2021-05-07T14:39:10Z",
      "updated_at": "2021-05-07T17:35:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628262633",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628262633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 425,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628313826",
      "pull_request_review_id": 654524878,
      "id": 628313826,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMxMzgyNg==",
      "diff_hunk": "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 324,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this comment should be reverse with the test case above ?\r\n\r\nLocal set is increased by `AddTransaction(5)` though initiator set is empty `HandleReconciliationRequest`",
      "created_at": "2021-05-07T15:31:28Z",
      "updated_at": "2021-05-07T17:35:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628313826",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628313826"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628315271",
      "pull_request_review_id": 654524878,
      "id": 628315271,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMxNTI3MQ==",
      "diff_hunk": "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 329,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also I don't understand why you bump mocktime by +1000 at each new test case ? You're renewing `tracker_test` everytime so it shouldn't matter",
      "created_at": "2021-05-07T15:33:15Z",
      "updated_at": "2021-05-07T17:35:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628315271",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628315271"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 329,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628325062",
      "pull_request_review_id": 654524878,
      "id": 628325062,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMyNTA2Mg==",
      "diff_hunk": "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint32_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint32_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    bool m_flood_to{false};\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint32_t& capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 320,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If this helper is called in `RespondToInitialRequest` I believe the check on local set size is duplicated. \r\n\r\nTo avoid this, what do you think about uplifting this check to `HandleInitialSketch` and returning true and empty `skdata` there ?",
      "created_at": "2021-05-07T15:45:03Z",
      "updated_at": "2021-05-07T17:35:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628325062",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628325062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628332247",
      "pull_request_review_id": 654524878,
      "id": 628332247,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMzMjI0Nw==",
      "diff_hunk": "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 345,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You can verify that `PrepareForExtensionRequest` did clear up `local_set` for `local_snapshot`.\r\n\r\n```\r\ndiff --git a/src/test/txreconciliation_tests.cpp b/src/test/txreconciliation_tests.cpp\r\nindex 2e12d55dc..35e3db5e5 100644\r\n--- a/src/test/txreconciliation_tests.cpp\r\n+++ b/src/test/txreconciliation_tests.cpp\r\n@@ -343,344 +343,345 @@ BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\r\n     // Then respond with an extension sketch.\r\n     tracker_test3.HandleExtensionRequest();\r\n     assert(tracker_test3.RespondToReconciliationRequest(skdata));\r\n+    assert(tracker_test3.GetPeerSetSize() == 0);\r\n     std::vector<uint8_t> extended_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity * 2).Serialize();\r\n     std::vector<uint8_t> sketch_extension(extended_sketch.begin() + extended_sketch.size() / 2, extended_sketch.end());\r\n     assert(skdata == sketch_extension);\r\n ```",
      "created_at": "2021-05-07T15:53:26Z",
      "updated_at": "2021-05-07T17:35:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628332247",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628332247"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 469,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628339736",
      "pull_request_review_id": 654524878,
      "id": 628339736,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMzOTczNg==",
      "diff_hunk": "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint32_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint32_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    bool m_flood_to{false};\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint32_t& capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint32_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    bool HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint32_t remote_sketch_capacity = uint32_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        // Protocol violation: our peer exceeded the sketch capacity, or sent a malformed sketch.\n+        if (remote_sketch_capacity > MAX_SKETCH_CAPACITY) {\n+            return false;\n+        }\n+\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch. \" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return true;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+        return true;\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits. The limits are MAX_SKETCH_CAPACITY * 2, so that\n+        // they can extend even the largest (originally) sketch.\n+        uint16_t extended_capacity = uint32_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY * 2) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    bool EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt)\n+    {\n+        // We do not support reconciliation salt/version updates. We treat an attempt to update\n+        // after a successful registration as a protocol violation.\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return false;\n+\n+        // If the peer supports the version which is lower than our, we downgrade to the version\n+        // they support. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return false;\n+\n+        auto local_salt = m_local_salts.find(peer_id);\n+\n+        // This function should be called only after generating the local salt.\n+        if (local_salt == m_local_salts.end()) return false;\n+\n+        // Must match SuggestReconciling logic.\n+        bool we_may_initiate = !inbound, we_may_respond = inbound;\n+\n+        bool they_initiate = they_may_initiate && we_may_respond;\n+        bool we_initiate = we_may_initiate && they_may_respond;\n+        // If we ever announce we_initiate && we_may_respond, this will need tie-breaking. For now,\n+        // this is mutually exclusive because both are based on the inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return false;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrint(BCLog::NET, \"Register peer=%d for reconciliation with the following params: \" /* Continued */\n+            \"we_initiate=%i, they_initiate=%i.\\n\", peer_id, we_initiate, they_initiate);\n+\n+        uint256 full_salt = ComputeSalt(local_salt->second, remote_salt);\n+\n+        assert(m_states.emplace(peer_id, ReconciliationState(full_salt.GetUint64(0),\n+            full_salt.GetUint64(1), we_initiate)).second);\n+        return true;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        assert(txs_to_reconcile.size() > 0);\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state->second.m_local_set.m_wtxids.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, recon_state->second.m_local_set.GetSize(), peer_id);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return std::nullopt;\n+        if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order based on the queue,\n+            // and with a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request < current_time && m_queue.back() == peer_id) {\n+                recon_state->second.m_state_init_by_us.m_phase = Phase::INIT_REQUESTED;\n+                m_queue.pop_back();\n+                m_queue.push_front(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+                double local_q = recon_state->second.m_state_init_by_us.m_local_q;\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i, local_q=%i.\\n\", peer_id, local_set_size, local_q);\n+\n+                return std::make_pair(local_set_size, local_q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return;\n+        if (recon_state->second.m_state_init_by_them.m_phase != Phase::NONE) return;\n+        if (recon_state->second.m_we_initiate) return;\n+\n+        double peer_q_converted = peer_q * 1.0 / Q_PRECISION;\n+        recon_state->second.m_state_init_by_them.m_remote_q = peer_q_converted;\n+        recon_state->second.m_state_init_by_them.m_remote_set_size = peer_recon_set_size;\n+        recon_state->second.m_state_init_by_them.m_next_recon_respond = NextReconRespond();\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_REQUESTED;\n+\n+        LogPrint(BCLog::NET, \"Reconciliation initiated by peer=%d with the following params: \" /* Continued */\n+            \"remote_q=%d, remote_set_size=%i.\\n\", peer_id, peer_q_converted, peer_recon_set_size);\n+    }\n+\n+    void RespondToInitialRequest(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state, std::vector<uint8_t>& skdata)\n+    {\n+        uint32_t sketch_capacity = 0;\n+        // We send an empty vector at initial request in the following 2 cases because\n+        // reconciliation can't help:\n+        // - if we have nothing on our side\n+        // - if they have nothing on their side\n+        // Then, they will terminate reconciliation early and force flooding-style announcement.\n+        if (recon_state->second.m_state_init_by_them.m_remote_set_size > 0 &&\n+                recon_state->second.m_local_set.GetSize() > 0) {\n+\n+            sketch_capacity = recon_state->second.m_state_init_by_them.EstimateSketchCapacity(\n+                recon_state->second.m_local_set.GetSize());\n+            Minisketch sketch = recon_state->second.ComputeBaseSketch(sketch_capacity);\n+            if (sketch) skdata = sketch.Serialize();\n+        }\n+\n+        // Update local reconciliation state for the peer.\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_RESPONDED;\n+        recon_state->second.PrepareForExtensionRequest(sketch_capacity);\n+\n+        LogPrint(BCLog::NET, \"Responding with a sketch to reconciliation initiated by peer=%d: \" /* Continued */\n+            \"sending sketch of capacity=%i.\\n\", recon_state->first, sketch_capacity);\n+    }\n+\n+    void RespondToExtensionRequest(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state, std::vector<uint8_t>& skdata)\n+    {\n+        assert(recon_state->second.m_capacity_snapshot > 0);\n+        // Update local reconciliation state for the peer.\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::EXT_RESPONDED;\n+\n+        // Local extension sketch can be null only if initial sketch or initial capacity was 0,\n+        // in which case we would have terminated reconciliation already.\n+        uint32_t extended_capacity = std::min(uint32_t(recon_state->second.m_capacity_snapshot * 2), MAX_SKETCH_CAPACITY * 2);",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 770,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Verify but I believe that module's previous steps guarantee that `m_capacity_snapshot` can't be superior to `MAX_SKETCH_CAPCITY`.\r\n\r\nAt least following diff seems to pass unit tests:\r\n```\r\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\r\nindex 0218d21ad..d035569af 100644\r\n--- a/src/txreconciliation.cpp\r\n+++ b/src/txreconciliation.cpp\r\n@@ -762,12 +762,13 @@ class TxReconciliationTracker::Impl {\r\n     void RespondToExtensionRequest(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state, std::vector<uint8_t>& skdata)\r\n     {\r\n         assert(recon_state->second.m_capacity_snapshot > 0);\r\n+        assert(MAX_SKETCH_CAPACITY * 2 > recon_state->second.m_capacity_snapshot * 2);\r\n         // Update local reconciliation state for the peer.\r\n         recon_state->second.m_state_init_by_them.m_phase = Phase::EXT_RESPONDED;\r\n \r\n         // Local extension sketch can be null only if initial sketch or initial capacity was 0,\r\n         // in which case we would have terminated reconciliation already.\r\n-        uint32_t extended_capacity = std::min(uint32_t(recon_state->second.m_capacity_snapshot * 2), MAX_SKETCH_CAPACITY * 2);\r\n+        uint32_t extended_capacity = uint32_t(recon_state->second.m_capacity_snapshot * 2);\r\n         Minisketch sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\r\n         assert(sketch);\r\n         skdata = sketch.Serialize();\r\n```",
      "created_at": "2021-05-07T16:04:47Z",
      "updated_at": "2021-05-07T17:35:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628339736",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628339736"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 747,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628343839",
      "pull_request_review_id": 654524878,
      "id": 628343839,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM0MzgzOQ==",
      "diff_hunk": "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    std::vector<uint8_t> extended_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity * 2).Serialize();\n+    std::vector<uint8_t> sketch_extension(extended_sketch.begin() + extended_sketch.size() / 2, extended_sketch.end());\n+    assert(skdata == sketch_extension);\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleExtensionRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.AddTransactions(5);\n+\n+    // Extension request without initial request does nothing.\n+    std::vector<uint8_t> skdata;\n+    tracker_test.HandleExtensionRequest();\n+    assert(!tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    tracker_test.HandleReconciliationRequest();\n+    SetMockTime(start_time + 1000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() != 0);\n+    // Then respond with an extension sketch.\n+    tracker_test.HandleExtensionRequest();\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    TxReconciliationTrackerTest tracker_test2(true);\n+\n+    tracker_test2.HandleReconciliationRequest();\n+    SetMockTime(start_time + 2000);\n+    std::vector<uint8_t> skdata2;\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata2));\n+    assert(skdata2.size() == 0);\n+    // Do not respond if the initial sketch we sent out was empty.\n+    tracker_test2.HandleExtensionRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleInitialSketchTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    TxReconciliationTrackerTest tracker_test(false);\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+\n+    // Protocol violation: unknown peer.\n+    assert(!tracker_test.HandleSketch(std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result, true));",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 394,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: verify if we're reconciliation responder and not initiator.",
      "created_at": "2021-05-07T16:11:24Z",
      "updated_at": "2021-05-07T17:35:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628343839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628343839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 519,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628345073",
      "pull_request_review_id": 654524878,
      "id": 628345073,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM0NTA3Mw==",
      "diff_hunk": "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    std::vector<uint8_t> extended_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity * 2).Serialize();\n+    std::vector<uint8_t> sketch_extension(extended_sketch.begin() + extended_sketch.size() / 2, extended_sketch.end());\n+    assert(skdata == sketch_extension);\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleExtensionRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.AddTransactions(5);\n+\n+    // Extension request without initial request does nothing.\n+    std::vector<uint8_t> skdata;\n+    tracker_test.HandleExtensionRequest();\n+    assert(!tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    tracker_test.HandleReconciliationRequest();\n+    SetMockTime(start_time + 1000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() != 0);\n+    // Then respond with an extension sketch.\n+    tracker_test.HandleExtensionRequest();\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    TxReconciliationTrackerTest tracker_test2(true);\n+\n+    tracker_test2.HandleReconciliationRequest();\n+    SetMockTime(start_time + 2000);\n+    std::vector<uint8_t> skdata2;\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata2));\n+    assert(skdata2.size() == 0);\n+    // Do not respond if the initial sketch we sent out was empty.\n+    tracker_test2.HandleExtensionRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleInitialSketchTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    TxReconciliationTrackerTest tracker_test(false);\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+\n+    // Protocol violation: unknown peer.\n+    assert(!tracker_test.HandleSketch(std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result, true));\n+",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 395,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also I don't think this unit test is covering sketch reception during wrong reconciliation phase, the final branch of `HandleSketch` ?",
      "created_at": "2021-05-07T16:13:28Z",
      "updated_at": "2021-05-07T17:35:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628345073",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628345073"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 520,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628372727",
      "pull_request_review_id": 654524878,
      "id": 628372727,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM3MjcyNw==",
      "diff_hunk": "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint32_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint32_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    bool m_flood_to{false};\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint32_t& capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint32_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    bool HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint32_t remote_sketch_capacity = uint32_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        // Protocol violation: our peer exceeded the sketch capacity, or sent a malformed sketch.\n+        if (remote_sketch_capacity > MAX_SKETCH_CAPACITY) {\n+            return false;\n+        }\n+\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 477,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I would verify returned pointer before to try `Deserialize()`. Beyond capacity == 0, minisketch API will also return a nullptr in case of memory allocation failure inside library. I don't know how to tread it, but definitively not crashing on it :/",
      "created_at": "2021-05-07T16:58:53Z",
      "updated_at": "2021-05-07T17:35:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628372727",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628372727"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 459,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628381177",
      "pull_request_review_id": 654524878,
      "id": 628381177,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM4MTE3Nw==",
      "diff_hunk": "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy can’t monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint32_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint32_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    bool m_flood_to{false};\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint32_t& capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint32_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    bool HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint32_t remote_sketch_capacity = uint32_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        // Protocol violation: our peer exceeded the sketch capacity, or sent a malformed sketch.\n+        if (remote_sketch_capacity > MAX_SKETCH_CAPACITY) {\n+            return false;\n+        }\n+\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch. \" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return true;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 515,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note, coefficient recomputation doesn't seem covered by unit tests but sounds to be by functional tests. I would favor covering it unit tests too. An unrelated change in `p2p_erlay.py` in the future might remove coverage, up to you.",
      "created_at": "2021-05-07T17:12:55Z",
      "updated_at": "2021-05-07T17:35:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628381177",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628381177"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 515,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628389326",
      "pull_request_review_id": 654524878,
      "id": 628389326,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM4OTMyNg==",
      "diff_hunk": "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 39,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting, default value sounds to diverge from Erlay paper recommendation : \r\n\r\n\"The coefficient q characterizes earlier reconciliation, so before the very first reconciliation round it is set to zero.\"\r\n\r\nYou find empirically that a small coefficient was better to start with?",
      "created_at": "2021-05-07T17:27:10Z",
      "updated_at": "2021-05-07T17:35:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628389326",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628389326"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660490867",
      "pull_request_review_id": 694865394,
      "id": 660490867,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDQ5MDg2Nw==",
      "diff_hunk": "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 39,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": 628389326,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For future conversations, I will refer to my findings [here](https://github.com/naumenkogs/txrelaysim/tree/master/results/flood-erlay).",
      "created_at": "2021-06-29T10:34:41Z",
      "updated_at": "2021-06-29T10:34:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660490867",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660490867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660668925",
      "pull_request_review_id": 695105491,
      "id": 660668925,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY2ODkyNQ==",
      "diff_hunk": "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    std::vector<uint8_t> extended_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity * 2).Serialize();\n+    std::vector<uint8_t> sketch_extension(extended_sketch.begin() + extended_sketch.size() / 2, extended_sketch.end());\n+    assert(skdata == sketch_extension);\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleExtensionRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.AddTransactions(5);\n+\n+    // Extension request without initial request does nothing.\n+    std::vector<uint8_t> skdata;\n+    tracker_test.HandleExtensionRequest();\n+    assert(!tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    tracker_test.HandleReconciliationRequest();\n+    SetMockTime(start_time + 1000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() != 0);\n+    // Then respond with an extension sketch.\n+    tracker_test.HandleExtensionRequest();\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    TxReconciliationTrackerTest tracker_test2(true);\n+\n+    tracker_test2.HandleReconciliationRequest();\n+    SetMockTime(start_time + 2000);\n+    std::vector<uint8_t> skdata2;\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata2));\n+    assert(skdata2.size() == 0);\n+    // Do not respond if the initial sketch we sent out was empty.\n+    tracker_test2.HandleExtensionRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleInitialSketchTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    TxReconciliationTrackerTest tracker_test(false);\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+\n+    // Protocol violation: unknown peer.\n+    assert(!tracker_test.HandleSketch(std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result, true));",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 394,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": 628343839,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No way to test this. HandleSketch() can be legally called only after MaybeRequestSketch (`m_state_init_by_us.m_phase = Phase::INIT_REQUESTED`) , which is not possible for responders in the first place.",
      "created_at": "2021-06-29T14:22:36Z",
      "updated_at": "2021-06-29T14:22:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660668925",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660668925"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 519,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660671746",
      "pull_request_review_id": 695109261,
      "id": 660671746,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY3MTc0Ng==",
      "diff_hunk": "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));",
      "path": "src/test/txreconciliation_tests.cpp",
      "position": null,
      "original_position": 345,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "in_reply_to_id": 628332247,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Adding a check for `local_set`, but it's hard to get into `local_set_snapshot` because it's a private variable with no getter method. I could possibly check it implicitly, but that's more of a functional test thing.",
      "created_at": "2021-06-29T14:25:25Z",
      "updated_at": "2021-06-29T14:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660671746",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660671746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 469,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663755989",
      "pull_request_review_id": 698947525,
      "id": 663755989,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc1NTk4OQ==",
      "diff_hunk": "@@ -30,8 +30,8 @@ Drag Bitcoin Core to your applications folder, and then run Bitcoin Core.\n \n * See the documentation at the [Bitcoin Wiki](https://en.bitcoin.it/wiki/Main_Page)\n for help and more information.\n-* Ask for help on the [Bitcoin StackExchange](https://bitcoin.stackexchange.com)\n-* Ask for help on [#bitcoin](https://webchat.freenode.net/#bitcoin) on Freenode. If you don't have an IRC client, use [webchat here](https://webchat.freenode.net/#bitcoin).\n+* Ask for help on [Bitcoin StackExchange](https://bitcoin.stackexchange.com).",
      "path": "doc/README.md",
      "position": null,
      "original_position": 6,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "in_reply_to_id": null,
      "user": {
        "login": "kiminuo",
        "id": 58662979,
        "node_id": "MDQ6VXNlcjU4NjYyOTc5",
        "avatar_url": "https://avatars.githubusercontent.com/u/58662979?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kiminuo",
        "html_url": "https://github.com/kiminuo",
        "followers_url": "https://api.github.com/users/kiminuo/followers",
        "following_url": "https://api.github.com/users/kiminuo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kiminuo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kiminuo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kiminuo/subscriptions",
        "organizations_url": "https://api.github.com/users/kiminuo/orgs",
        "repos_url": "https://api.github.com/users/kiminuo/repos",
        "events_url": "https://api.github.com/users/kiminuo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kiminuo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Why is this change here? ",
      "created_at": "2021-07-05T08:53:06Z",
      "updated_at": "2021-07-05T08:53:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663755989",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663755989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663759139",
      "pull_request_review_id": 698951767,
      "id": 663759139,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc1OTEzOQ==",
      "diff_hunk": "@@ -322,19 +327,32 @@ def main():\n                                      epilog='''\n     Help text and arguments for individual test script:''',\n                                      formatter_class=argparse.RawTextHelpFormatter)\n-    parser.add_argument('--ansi', action='store_true', default=sys.stdout.isatty(), help=\"Use ANSI colors and dots in output (enabled by default when standard output is a TTY)\")\n-    parser.add_argument('--combinedlogslen', '-c', type=int, default=0, metavar='n', help='On failure, print a log (of length n lines) to the console, combined from the test framework and all test nodes.')\n-    parser.add_argument('--coverage', action='store_true', help='generate a basic coverage report for the RPC interface')\n-    parser.add_argument('--ci', action='store_true', help='Run checks and code that are usually only enabled in a continuous integration environment')\n-    parser.add_argument('--exclude', '-x', help='specify a comma-separated-list of scripts to exclude.')\n-    parser.add_argument('--extended', action='store_true', help='run the extended test suite in addition to the basic tests')\n-    parser.add_argument('--help', '-h', '-?', action='store_true', help='print help text and exit')\n-    parser.add_argument('--jobs', '-j', type=int, default=4, help='how many test scripts to run in parallel. Default=4.')\n-    parser.add_argument('--keepcache', '-k', action='store_true', help='the default behavior is to flush the cache directory on startup. --keepcache retains the cache from the previous testrun.')\n-    parser.add_argument('--quiet', '-q', action='store_true', help='only print dots, results summary and failure logs')\n-    parser.add_argument('--tmpdirprefix', '-t', default=tempfile.gettempdir(), help=\"Root directory for datadirs\")\n-    parser.add_argument('--failfast', action='store_true', help='stop execution after the first test failure')\n-    parser.add_argument('--filter', help='filter scripts to run by regular expression')\n+    parser.add_argument('--ansi', action='store_true', default=sys.stdout.isatty(),",
      "path": "test/functional/test_runner.py",
      "position": null,
      "original_position": 51,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "in_reply_to_id": null,
      "user": {
        "login": "kiminuo",
        "id": 58662979,
        "node_id": "MDQ6VXNlcjU4NjYyOTc5",
        "avatar_url": "https://avatars.githubusercontent.com/u/58662979?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kiminuo",
        "html_url": "https://github.com/kiminuo",
        "followers_url": "https://api.github.com/users/kiminuo/followers",
        "following_url": "https://api.github.com/users/kiminuo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kiminuo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kiminuo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kiminuo/subscriptions",
        "organizations_url": "https://api.github.com/users/kiminuo/orgs",
        "repos_url": "https://api.github.com/users/kiminuo/repos",
        "events_url": "https://api.github.com/users/kiminuo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kiminuo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: Is it a good idea to reformat this file? Maybe that can be done in a separate PR.",
      "created_at": "2021-07-05T08:57:25Z",
      "updated_at": "2021-07-05T08:57:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663759139",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663759139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988352",
      "pull_request_review_id": 699254360,
      "id": 663988352,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzk4ODM1Mg==",
      "diff_hunk": "@@ -322,19 +327,32 @@ def main():\n                                      epilog='''\n     Help text and arguments for individual test script:''',\n                                      formatter_class=argparse.RawTextHelpFormatter)\n-    parser.add_argument('--ansi', action='store_true', default=sys.stdout.isatty(), help=\"Use ANSI colors and dots in output (enabled by default when standard output is a TTY)\")\n-    parser.add_argument('--combinedlogslen', '-c', type=int, default=0, metavar='n', help='On failure, print a log (of length n lines) to the console, combined from the test framework and all test nodes.')\n-    parser.add_argument('--coverage', action='store_true', help='generate a basic coverage report for the RPC interface')\n-    parser.add_argument('--ci', action='store_true', help='Run checks and code that are usually only enabled in a continuous integration environment')\n-    parser.add_argument('--exclude', '-x', help='specify a comma-separated-list of scripts to exclude.')\n-    parser.add_argument('--extended', action='store_true', help='run the extended test suite in addition to the basic tests')\n-    parser.add_argument('--help', '-h', '-?', action='store_true', help='print help text and exit')\n-    parser.add_argument('--jobs', '-j', type=int, default=4, help='how many test scripts to run in parallel. Default=4.')\n-    parser.add_argument('--keepcache', '-k', action='store_true', help='the default behavior is to flush the cache directory on startup. --keepcache retains the cache from the previous testrun.')\n-    parser.add_argument('--quiet', '-q', action='store_true', help='only print dots, results summary and failure logs')\n-    parser.add_argument('--tmpdirprefix', '-t', default=tempfile.gettempdir(), help=\"Root directory for datadirs\")\n-    parser.add_argument('--failfast', action='store_true', help='stop execution after the first test failure')\n-    parser.add_argument('--filter', help='filter scripts to run by regular expression')\n+    parser.add_argument('--ansi', action='store_true', default=sys.stdout.isatty(),",
      "path": "test/functional/test_runner.py",
      "position": null,
      "original_position": 51,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "in_reply_to_id": 663759139,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oops, definitely not indented. Probably a rebasing mistake.",
      "created_at": "2021-07-05T14:51:39Z",
      "updated_at": "2021-07-05T14:51:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663988352",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988384",
      "pull_request_review_id": 699254400,
      "id": 663988384,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzk4ODM4NA==",
      "diff_hunk": "@@ -30,8 +30,8 @@ Drag Bitcoin Core to your applications folder, and then run Bitcoin Core.\n \n * See the documentation at the [Bitcoin Wiki](https://en.bitcoin.it/wiki/Main_Page)\n for help and more information.\n-* Ask for help on the [Bitcoin StackExchange](https://bitcoin.stackexchange.com)\n-* Ask for help on [#bitcoin](https://webchat.freenode.net/#bitcoin) on Freenode. If you don't have an IRC client, use [webchat here](https://webchat.freenode.net/#bitcoin).\n+* Ask for help on [Bitcoin StackExchange](https://bitcoin.stackexchange.com).",
      "path": "doc/README.md",
      "position": null,
      "original_position": 6,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "in_reply_to_id": 663755989,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oops, definitely not indented. Probably a rebasing mistake.",
      "created_at": "2021-07-05T14:51:41Z",
      "updated_at": "2021-07-05T14:51:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663988384",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/805335106",
      "pull_request_review_id": 880981819,
      "id": 805335106,
      "node_id": "PRRC_kwDOABII584wAHBC",
      "diff_hunk": "@@ -0,0 +1,1048 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <node/minisketchwrapper.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 32,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The value chosen here seems too large based on some tests that i did.\r\n\r\nOn my laptop (with a decent CPU) a sketch with a capacity of  `2 << 13` and `2 << 13` differences (possible if an extension is requested) took ~20 seconds to decode. On lower end devices this will likely be worse. This is not super bad since sketches are only requested on outbound connections but having the `msghand` thread block like this is undesirable in any case.\r\n\r\nI am not entirely sure what an appropriate value would be but given the expected average set difference of 7 i would assume that 256 - 1024 as the max. sketch capacity would suffice.",
      "created_at": "2022-02-13T13:27:20Z",
      "updated_at": "2022-02-13T13:27:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r805335106",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/805335106"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806556529",
      "pull_request_review_id": 882603544,
      "id": 806556529,
      "node_id": "PRRC_kwDOABII584wExNx",
      "diff_hunk": "@@ -0,0 +1,1048 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <node/minisketchwrapper.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;",
      "path": "src/txreconciliation.cpp",
      "position": null,
      "original_position": 32,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "in_reply_to_id": 805335106,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Excellent point. I will address this once I have to rebase these changes.",
      "created_at": "2022-02-15T08:11:59Z",
      "updated_at": "2022-02-15T08:12:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r806556529",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806556529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/867364288",
      "pull_request_review_id": 965341350,
      "id": 867364288,
      "node_id": "PRRC_kwDOABII584zsu3A",
      "diff_hunk": "@@ -140,6 +140,7 @@ BITCOIN_TESTS =\\\n   test/transaction_tests.cpp \\\n   test/txindex_tests.cpp \\\n   test/txpackage_tests.cpp \\\n+  test/txreconciliation_tests.cpp \\",
      "path": "src/Makefile.test.include",
      "position": null,
      "original_position": 4,
      "commit_id": "3e08dab56b111d48970dc19bd771ba96c73506b1",
      "original_commit_id": "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This line should be in the earlier commit, \"test: Add unit tests for reconciliation negotiation\" (with it, the tests do pass).\r\n\r\n```\r\n$ ./src/test/test_bitcoin -t txreconciliation_tests\r\nTest setup error: no test cases matching filter or all test cases were disabled\r\n```\r\n\r\n```diff\r\n--- a/src/Makefile.test.include\r\n+++ b/src/Makefile.test.include\r\n@@ -144,6 +144,7 @@ BITCOIN_TESTS =\\\r\n   test/transaction_tests.cpp \\\r\n   test/txindex_tests.cpp \\\r\n   test/txpackage_tests.cpp \\\r\n+  test/txreconciliation_tests.cpp \\\r\n   test/txrequest_tests.cpp \\\r\n```\r\n```\r\n$ ./src/test/test_bitcoin -t txreconciliation_tests\r\nRunning 4 test cases...\r\n\r\n*** No errors detected\r\n```\r\n",
      "created_at": "2022-05-07T15:28:28Z",
      "updated_at": "2022-05-07T16:00:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r867364288",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/867364288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 156,
      "side": "RIGHT"
    }
  ]
}