{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
    "id": 1080948690,
    "node_id": "PR_kwDOABII585AbffS",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/26283",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/26283.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/26283.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/65025d1935b082e98d7d347c629c1739abaa5f67",
    "number": 26283,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "p2p: Fill reconciliation sets and request reconciliation (Erlay)",
    "user": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is a part of the Erlay project:\r\n- [parent PR](https://github.com/bitcoin/bitcoin/pull/21515)\r\n- [associated BIP-330](https://github.com/bitcoin/bips/pull/1376). **Note this is not what's in the bitcoin/bips repo, but an updated version.**\r\n- [previous PR](https://github.com/bitcoin/bitcoin/pull/23443)\r\n\r\n-------\r\n\r\nFirst, this PR enables keeping track of per-peer reconciliation sets, containing those transactions which we intend to exchange efficiently. The remaining transactions are announced via flooding, as usual. \r\nSecond, this PR enables periodically initiating a reconciliation round via a new p2p message.",
    "labels": [
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      },
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2022-10-08T07:29:52Z",
    "updated_at": "2023-08-17T11:43:17Z",
    "mergeable_state": "unknown",
    "merge_commit_sha": "bbb1f4a1ff288c17182811b6452185c79fa8284b",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "naumenkogs:2022-10-erlay2",
      "ref": "2022-10-erlay2",
      "sha": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 115054139,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTUwNTQxMzk=",
        "name": "bitcoin",
        "full_name": "naumenkogs/bitcoin",
        "owner": {
          "login": "naumenkogs",
          "id": 7975071,
          "node_id": "MDQ6VXNlcjc5NzUwNzE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/naumenkogs",
          "html_url": "https://github.com/naumenkogs",
          "followers_url": "https://api.github.com/users/naumenkogs/followers",
          "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
          "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
          "repos_url": "https://api.github.com/users/naumenkogs/repos",
          "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/naumenkogs/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/naumenkogs/bitcoin",
        "archive_url": "https://api.github.com/repos/naumenkogs/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/naumenkogs/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/naumenkogs/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/naumenkogs/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/naumenkogs/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/naumenkogs/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/naumenkogs/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/naumenkogs/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/naumenkogs/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/naumenkogs/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/naumenkogs/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/naumenkogs/bitcoin/events",
        "forks_url": "https://api.github.com/repos/naumenkogs/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/naumenkogs/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/naumenkogs/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/naumenkogs/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/naumenkogs/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/naumenkogs/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/naumenkogs/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/naumenkogs/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/naumenkogs/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/naumenkogs/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/naumenkogs/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/naumenkogs/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/naumenkogs/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:naumenkogs/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/naumenkogs/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/naumenkogs/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/naumenkogs/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/naumenkogs/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/naumenkogs/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/naumenkogs/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/naumenkogs/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/naumenkogs/bitcoin/hooks",
        "svn_url": "https://github.com/naumenkogs/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 2,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 226405,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-17T11:43:11Z",
        "created_at": "2017-12-21T22:52:17Z",
        "updated_at": "2021-03-02T13:21:27Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "d78ff380a2cde80c264e36e046b1cfc054bd9253",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35548,
        "stargazers_count": 70959,
        "watchers_count": 70959,
        "size": 236531,
        "default_branch": "master",
        "open_issues_count": 676,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-17T11:55:34Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-08-17T11:00:18Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 747,
    "deletions": 13,
    "changed_files": 10,
    "commits": 8,
    "review_comments": 112,
    "comments": 4
  },
  "events": [
    {
      "event": "convert_to_draft",
      "id": 7547617514,
      "node_id": "CTDE_lADOABII585TjqCFzwAAAAHB34Dq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7547617514",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T07:30:00Z"
    },
    {
      "event": "commented",
      "id": 1272254249,
      "node_id": "IC_kwDOABII585L1Q8p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272254249",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T07:33:48Z",
      "updated_at": "2022-10-28T09:07:02Z",
      "author_association": "MEMBER",
      "body": "Marking this draft until:\r\n1. ~~[Previous PR is merged](https://github.com/bitcoin/bitcoin/pull/23443)~~ [Follow-up is merged](https://github.com/bitcoin/bitcoin/pull/26359)\r\n2. There is one in-code TODO I have to resolve (it is minor, but it has to be improved)\r\n3. I add unit and functional tests for these features.\r\n\r\nAnother task is to sync [parent PR](https://github.com/bitcoin/bitcoin/pull/21515) with this version. I have a local branch that compiles, but tests of the full Erlay there needs a little care. If you want to see how this PR works in the broader context, the parent should be good enough to get it. Otherwise, I intend to update it soon.",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1272254249",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283"
    },
    {
      "event": "labeled",
      "id": 7547807873,
      "node_id": "LE_lADOABII585TjqCFzwAAAAHB4miB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7547807873",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T10:16:28Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "commented",
      "id": 1272351013,
      "node_id": "IC_kwDOABII585L1okl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272351013",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T16:15:15Z",
      "updated_at": "2023-08-16T22:16:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#27675](https://github.com/bitcoin/bitcoin/pull/27675) (p2p: Drop m_recently_announced_invs bloom filter by ajtowns)\n* [#26621](https://github.com/bitcoin/bitcoin/pull/26621) (refactor: Continue moving application data from CNode to Peer by dergoegge)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1272351013",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T23:37:40Z",
      "updated_at": "2022-10-08T23:37:40Z",
      "source": {
        "issue": {
          "id": 1381442729,
          "node_id": "PR_kwDOABII584_YLq7",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26151",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26151/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26151/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26151/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26151",
          "number": 26151,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: Guard TxRequestTracker by its own lock instead of cs_main",
          "body": "I don't see the need to have the `TxRequestTracker` guarded by `cs_main` which would also be more in line with our developer docs.\r\n\r\nFrom `developer-notes.md`:\r\n\r\n```\r\nRe-architecting the core code so there are better-defined interfaces between\r\nthe various components is a goal, with any necessary locking done by the\r\ncomponents (e.g. see the self-contained FillableSigningProvider class and its\r\ncs_KeyStore lock for example).\r\n```\r\n\r\nThis PR gives `TxRequestTracker` its own mutex, thereby removing the need to guard `PeerManagerImpl::m_txrequest` using `cs_main`.\r\n",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 749416508,
              "node_id": "MDU6TGFiZWw3NDk0MTY1MDg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Up%20for%20grabs",
              "name": "Up for grabs",
              "color": "99a810",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 14,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26151",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26151",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26151.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26151.patch"
          },
          "closed_at": "2023-05-30T14:56:26Z",
          "created_at": "2022-09-21T20:15:15Z",
          "updated_at": "2023-05-30T15:22:49Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T23:42:23Z",
      "updated_at": "2022-10-08T23:42:23Z",
      "source": {
        "issue": {
          "id": 1379469601,
          "node_id": "PR_kwDOABII584_RzRJ",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26140",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26140/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26140/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26140/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26140",
          "number": 26140,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: Move CNodeState members guarded by g_msgproc_mutex to Peer",
          "body": "`nUnconnectingHeaders`, `m_headers_sync_timeout`, `fPreferHeaders` and  `m_recently_announced_headers` are currently all `CNodeState` members even though they are only ever accessed from the message processing thread (therefore sufficiently guarded exclusively by `g_msgproc_mutex`). `CNodeState` exists purely to hold validation-specific state guarded by `cs_main` that is accessed by multiple threads.\r\n\r\nThis PR adds thread-safety annotations for the above mentioned `CNodeState` members and moves them to `Peer`.",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 6,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26140",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26140",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26140.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26140.patch"
          },
          "closed_at": "2023-03-30T16:11:12Z",
          "created_at": "2022-09-20T13:56:43Z",
          "updated_at": "2023-03-31T11:10:00Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-09T01:12:22Z",
      "updated_at": "2022-10-09T01:12:22Z",
      "source": {
        "issue": {
          "id": 1354921936,
          "node_id": "PR_kwDOABII584-AN5m",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25957",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25957/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25957/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25957/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25957",
          "number": 25957,
          "state": "closed",
          "state_reason": null,
          "title": "wallet: fast rescan with BIP157 block filters for descriptor wallets",
          "body": "## Description\r\n\r\nThis PR is another take of using BIP 157 block filters (enabled by `-blockfilterindex=1`) for faster wallet rescans and is a modern revival of #15845. For reviewers new to this topic I can highly recommend to read the corresponding PR review club (https://bitcoincore.reviews/15845). \r\n\r\nThe basic idea is to skip blocks for deeper inspection (i.e. looking at every single tx for matches) if our block filter doesn't match any of the block's spent or created UTXOs are relevant for our wallet. Note that there can be false-positives (see https://bitcoincore.reviews/15845#l-199 for a PR review club discussion about false-positive rates), but no false-negatives, i.e. it is safe to skip blocks if the filter doesn't match; if the filter *does* match even though there are no wallet-relevant txs in the block, no harm is done, only a little more time is spent extra.\r\n\r\nIn contrast to #15845, this solution only supports descriptor wallets, which are way more widespread now than back in the time >3 years ago. With that approach, we don't have to ever derive the relevant scriptPubKeys ourselves from keys before populating the filter, and can instead shift the full responsibility to that to the `DescriptorScriptPubKeyMan` which already takes care of that automatically. Compared to legacy wallets, the `IsMine` logic for descriptor wallets is as trivial as checking if a scriptPubKey is included in the ScriptPubKeyMan's set of scriptPubKeys (`m_map_script_pub_keys`): https://github.com/bitcoin/bitcoin/blob/e191fac4f3c37820f0618f72f0a8e8b524531ab8/src/wallet/scriptpubkeyman.cpp#L1703-L1710\r\n\r\nOne of the unaddressed issues of #15845 was that [the filter was only created once outside the loop](https://github.com/bitcoin/bitcoin/pull/15845#discussion_r343265997) and as such didn't take into account possible top-ups that have happened. This is solved here by keeping a state of ranged `DescriptorScriptPubKeyMan`'s descriptor end ranges and check at each iteration whether that range has increased since last time. If yes, we update the filter with all scriptPubKeys that have been added since the last filter update with a range index equal or higher than the last end range. Note that finding new scriptPubKeys could be made more efficient than linearly iterating through the whole `m_script_pub_keys` map (e.g. by introducing a bidirectional map), but this would mean introducing additional complexity and state and it's probably not worth it at this time, considering that the performance gain is already significant.\r\n\r\nOutput scripts from non-ranged `DescriptorScriptPubKeyMan`s (i.e. ones with a fixed set of output scripts that is never extended) are added only once when the filter is created first.\r\n\r\n## Benchmark results\r\n\r\nObviously, the speed-up indirectly correlates with the wallet tx frequency in the scanned range: the more blocks contain wallet-related transactions, the less blocks can be skipped due to block filter detection.\r\n\r\nIn a [simple benchmark](https://github.com/theStack/bitcoin/blob/fast_rescan_functional_test_benchmark/test/functional/pr25957_benchmark.py), a regtest chain with 1008 blocks (corresponding to 1 week) is mined with 20000 scriptPubKeys contained (25 txs * 800 outputs) each. The blocks each have a weight of ~2500000 WUs and hence are about 62.5% full. A global constant `WALLET_TX_BLOCK_FREQUENCY` defines how often wallet-related txs are included in a block. The created descriptor wallet (default setting of `keypool=1000`, we have 8*1000 = 8000 scriptPubKeys at the start) is backuped via the `backupwallet` RPC before the mining starts and imported via `restorewallet` RPC after. The measured time for taking this import process (which involves a rescan) once with block filters (`-blockfilterindex=1`) and once without block filters (`-blockfilterindex=0`) yield the relevant result numbers for the benchmark.\r\n\r\nThe following table lists the results, sorted from worst-case (all blocks contain wallte-relevant txs, 0% can be skipped) to best-case (no blocks contain walltet-relevant txs, 100% can be skipped) where the frequencies have been picked arbitrarily:\r\n\r\nwallet-related tx frequency; 1 tx per...    | ratio of irrelevant blocks  | w/o filters | with filters | speed gain\r\n--------------------------------------------|-----------------------------|-------------|--------------|-------------\r\n~ 10 minutes (every block)                  |              0%             |   56.806s   |   63.554s    |  ~0.9x\r\n~ 20 minutes (every 2nd block)              |           50% (1/2)         |   58.896s   |   36.076s    |  ~1.6x\r\n~ 30 minutes (every 3rd block)              |          66.67% (2/3)       |   56.781s   |   25.430s    |  ~2.2x\r\n~ 1 hour (every 6th block)                  |          83.33% (5/6)       |   58.193s   |   15.786s    |  ~3.7x\r\n~ 6 hours (every 36th block)                |          97.22% (35/36)     |   57.500s   |    6.935s    |  ~8.3x\r\n~ 1 day (every 144th block)                 |         99.31% (143/144)    |   68.881s   |    6.107s    | ~11.3x\r\n  (no txs)                                  |              100%           |   58.529s   |    5.630s    | ~10.4x\r\n\r\n\r\nSince even the (rather unrealistic) worst-case scenario of having wallet-related txs in _every_ block of the rescan range obviously doesn't take significantly longer, I'd argue it's reasonable to always take advantage of block filters if they are available and there's no need to provide an option for the user.\r\n\r\nFeedback about the general approach (but also about details like naming, where I struggled a lot) would be greatly appreciated. Thanks fly out to furszy for discussing this subject and patiently answering basic question about descriptor wallets!",
          "user": {
            "login": "theStack",
            "id": 91535,
            "node_id": "MDQ6VXNlcjkxNTM1",
            "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/theStack",
            "html_url": "https://github.com/theStack",
            "followers_url": "https://api.github.com/users/theStack/followers",
            "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
            "organizations_url": "https://api.github.com/users/theStack/orgs",
            "repos_url": "https://api.github.com/users/theStack/repos",
            "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/theStack/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 149424,
              "node_id": "MDU6TGFiZWwxNDk0MjQ=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Wallet",
              "name": "Wallet",
              "color": "08a781",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 28,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25957",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25957",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25957.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25957.patch"
          },
          "closed_at": "2022-10-26T15:19:51Z",
          "created_at": "2022-08-29T22:04:41Z",
          "updated_at": "2022-11-12T17:42:39Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-09T02:32:45Z",
      "updated_at": "2022-10-09T02:32:45Z",
      "source": {
        "issue": {
          "id": 1322350026,
          "node_id": "PR_kwDOABII5848Uuju",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25740",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25740/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25740/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25740/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25740",
          "number": 25740,
          "state": "closed",
          "state_reason": null,
          "title": "assumeutxo: background validation completion",
          "body": "This is part of the [assumeutxo project](https://github.com/bitcoin/bitcoin/projects/11) (parent PR: https://github.com/bitcoin/bitcoin/pull/15606)\r\n\r\nPart two of replacing https://github.com/bitcoin/bitcoin/pull/24232.\r\n\r\n---\r\n\r\nWhen a user activates a snapshot, the serialized UTXO set data is used to create an \"assumed-valid\" chainstate, which becomes active in an attempt to get the node to network tip as quickly as possible. Simultaneously in the background, the already-existing chainstate continues \"conventional\" IBD to both accumulate full block data and serve as a belt-and-suspenders to validate the assumed-valid chainstate.\r\n\r\nOnce the background chainstate's tip reaches the base block of the snapshot used, we set `m_stop_use` on that chainstate and immediately take the hash of its UTXO set; we verify that this matches the assumeutxo value in the source code. Note that while we ultimately want to remove this background chainstate, we don't do so until the following initialization process, when we again check the UTXO set hash of the background chainstate, and if it continues to match, we remove the (now unnecessary) background chainstate, and move the (previously) assumed-valid chainstate into its place. We then reinitialize the chainstate in the normal way.\r\n\r\nAs noted in previous comments, we could do the filesystem operations \"inline\" immediately when the background validation completes, but that's basically just an optimization that saves disk space until the next restart. It didn't strike me as worth the risk of moving chainstate data around on disk during runtime of the node, though maybe my concerns are overblown.\r\n\r\nThe final result of this completion process is a fully-validated chain, where the only evidence that the user synced using assumeutxo is the existence of a `base_blockhash` file in the `chainstate` directory.\r\n",
          "user": {
            "login": "jamesob",
            "id": 73197,
            "node_id": "MDQ6VXNlcjczMTk3",
            "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jamesob",
            "html_url": "https://github.com/jamesob",
            "followers_url": "https://api.github.com/users/jamesob/followers",
            "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
            "organizations_url": "https://api.github.com/users/jamesob/orgs",
            "repos_url": "https://api.github.com/users/jamesob/repos",
            "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jamesob/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 20,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25740",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25740",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25740.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25740.patch"
          },
          "closed_at": "2023-03-07T23:55:38Z",
          "created_at": "2022-07-29T14:52:11Z",
          "updated_at": "2023-03-13T15:20:52Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-11T21:25:57Z",
      "updated_at": "2022-10-11T21:25:57Z",
      "source": {
        "issue": {
          "id": 1313570087,
          "node_id": "PR_kwDOABII58473xLO",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25667",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25667/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25667/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25667/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25667",
          "number": 25667,
          "state": "closed",
          "state_reason": null,
          "title": "assumeutxo: snapshot initialization",
          "body": "This is part of the [assumeutxo project](https://github.com/bitcoin/bitcoin/projects/11) (parent PR: https://github.com/bitcoin/bitcoin/pull/15606)\r\n\r\n---\r\n\r\nHalf of the replacement for #24232. The original PR grew larger than expected throughout the review process.\r\n\r\nThis change adds the ability to initialize a snapshot-based chainstate during init if one is detected on disk. This is of course unused as of now (aside from in unittests) given that we haven't yet enabled actually loading snapshots. \r\n\r\nDon't be scared! There are some big move-only commits in here.\r\n\r\nAccompanying changes include: \r\n\r\n- moving the snapshot coinsdb directory from being called `chainstate_[base blockhash]` to `chainstate_snapshot`, since we only support one snapshot in use at a time. This simplifies some logic, but it necessitates writing that base blockhash out to a file within the coinsdb dir. See [discussion here](https://github.com/bitcoin/bitcoin/pull/24232#discussion_r832762880).\r\n- adding a simple fix in `FlushBlockFile()` that avoids a crash when attemping to flush to disk before `LoadBlockIndexDB()` is called, which happens when calling `MaybeRebalanceCaches()` during multiple chainstate init.\r\n- improving the unittest to allow testing with on-disk chainstates - necessary to test a simulated restart and re-initialization.",
          "user": {
            "login": "jamesob",
            "id": 73197,
            "node_id": "MDQ6VXNlcjczMTk3",
            "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jamesob",
            "html_url": "https://github.com/jamesob",
            "followers_url": "https://api.github.com/users/jamesob/followers",
            "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
            "organizations_url": "https://api.github.com/users/jamesob/orgs",
            "repos_url": "https://api.github.com/users/jamesob/repos",
            "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jamesob/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 97470796,
              "node_id": "MDU6TGFiZWw5NzQ3MDc5Ng==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/UTXO%20Db%20and%20Indexes",
              "name": "UTXO Db and Indexes",
              "color": "fbca04",
              "default": false
            },
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 10,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25667",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25667",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25667.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25667.patch"
          },
          "closed_at": "2022-10-13T14:20:57Z",
          "created_at": "2022-07-21T17:18:54Z",
          "updated_at": "2022-12-23T20:50:07Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-11T21:51:50Z",
      "updated_at": "2022-10-11T21:51:50Z",
      "source": {
        "issue": {
          "id": 1299238264,
          "node_id": "PR_kwDOABII5847Ho23",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25572",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25572/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25572/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25572/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25572",
          "number": 25572,
          "state": "open",
          "state_reason": null,
          "title": "refactor: Introduce EvictionManager and use it for the inbound eviction logic",
          "body": "This PR splits off the next couple commits from #25268 that introduce the `EvictionManager` and use it for  the inbound eviction logic.\r\n\r\nOne instance of the `EvictionManager` is created at start up and passed as a reference to the connection and peer managers. The connection and peer managers report all eviction relevant information (for inbound connections) to the eviction manager who ultimately suggests nodes to evict as the result of `EvictionManager::SelectNodeToEvict`.",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 10,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25572",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25572",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25572.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25572.patch"
          },
          "created_at": "2022-07-08T16:39:49Z",
          "updated_at": "2023-08-06T17:48:41Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-11T23:33:27Z",
      "updated_at": "2022-10-11T23:33:27Z",
      "source": {
        "issue": {
          "id": 1167366626,
          "node_id": "PR_kwDOABII5840WLLa",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24545",
          "number": 24545,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Enable v2 P2P encrypted transport",
          "body": "This PR brings together all other BIP324 PRs and enables v2 encrypted P2P transport.\r\n\r\nBuilds on top of PRs: #25361, #23233, #23561, #23432. It looks like there's a lot of commits, but **only the last 12 commits belong in this PR**. The rest will be merged with upstream PRs.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).\r\n\r\nBIP324 is [here](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki).\r\n\r\n### Running a v2 node\r\n#### Get the code\r\n```\r\ngit remote add bip324 git@github.com:dhruv/bitcoin.git\r\ngit fetch bip324\r\ngit checkout bip324/bip324-enable\r\n```\r\n\r\n#### Build for your OS\r\n\r\nFollow the appropriate instructions [here](https://github.com/bitcoin/bitcoin/blob/master/doc/README.md)\r\n\r\n#### Run the node\r\n\r\n```\r\nsrc/bitcoind -conf=CONFIG_FILE -v2transport=1\r\n```\r\n\r\n#### Connect with a friend's v2 node\r\n```\r\nsrc/bitcoin-cli -conf=CONFIG_FILE addnode \"FRIEND_IP:FRIEND_PORT\" \"add\" true\r\n```\r\nThe last parameter(`p2p_v2:true`) signals to your node that the peer is running a v2 supportive client and we should attempt to make an encrypted P2P connection (you're simulating the `NODE_P2P_V2` service flag advertisement manually). Should that fail however (say because the peer told you mistakenly, lied, etc.), this code will downgrade the connection to unencrypted v1 transport.\r\n\r\n### Things you are helpful to test\r\n\r\n* If your friend's node is a v2 node, you can see with wireshark that the bytes are pseudorandom (the easiest way to confirm this is that with a v1 connection, wireshark will tell you it has detected a Bitcoin connection and it'll even parse out the metadata like message type, etc; with v2, wireshark has no idea -- of course that _could_ be because wireshark does simply not know v2, but it is because the bytestream is pseudorandom)\r\n* Compare the v2 encrypted session id exposed via `getpeerinfo` as `v2_session_id` with your friend.\r\n* Add another peer that is actually v1, but try `addnode` still indicating v2 support. You should see with wireshark that after a failed attempt at a v2 handshake, the connection is downgraded to unencrypted v1 and wireshark can parse it.\r\n\r\nI've been told there are v2 nodes running at (happy to update the list as more people run persistent v2 nodes; message me and I'll add it here):\r\n```\r\nbe.anyone.eu.org\r\nrp7k2go3s5lyj3fnj6zn62ktarlrsft2ohlsxkyd7v3e3idqyptvread.onion:8333\r\njdcoysubtxazi7dketpyb5rnjorvxad4onftveohash2pdwkgw4bvnqd.onion:8333\r\nxci6cphki2pdb5qe7axzrcxcxabkbm24z4zlv2hn4ziy6grquqco2kyd.onion:8333\r\nslvtesfgg3mkksqqzh67al4sq6dx3rhlzqepa4ny7jonzuckg6msf3id.onion:8333\r\ngifm4fnj3vua664xhgeanx5fnpco3txkqy4amr4txbfsciiyrkxpf2qd.onion:8333\r\n300:5ecb:6b8a:d837::3:8333\r\n300:5ecb:6b8a:d837::a6d6:8333\r\n2001:470:1f1a:365::2:8333\r\n2001:470:1f1b:365:aa20:66ff:fe3f:1909:8333\r\n184.74.240.157:8533\r\n95.179.145.232:8333\r\n```",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 47,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24545",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24545",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24545.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24545.patch"
          },
          "closed_at": "2023-05-06T11:14:46Z",
          "created_at": "2022-03-12T18:43:06Z",
          "updated_at": "2023-05-06T11:14:46Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-12T00:10:04Z",
      "updated_at": "2022-10-12T00:10:04Z",
      "source": {
        "issue": {
          "id": 1111166839,
          "node_id": "PR_kwDOABII584xa7v1",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24125",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24125/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24125/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24125/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24125",
          "number": 24125,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: Replace RecursiveMutex `m_tx_inventory_mutex` with Mutex and rename it",
          "body": "This PR is related to #19303 and gets rid of the `RecursiveMutex m_tx_inventory_mutex` and also adds `AssertLockNotHeld` macros combined with `LOCKS_EXCLUDED` thread safety annotations to avoid recursive locking.",
          "user": {
            "login": "w0xlt",
            "id": 94266259,
            "node_id": "U_kgDOBZ5jkw",
            "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/w0xlt",
            "html_url": "https://github.com/w0xlt",
            "followers_url": "https://api.github.com/users/w0xlt/followers",
            "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
            "organizations_url": "https://api.github.com/users/w0xlt/orgs",
            "repos_url": "https://api.github.com/users/w0xlt/repos",
            "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/w0xlt/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 749416508,
              "node_id": "MDU6TGFiZWw3NDk0MTY1MDg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Up%20for%20grabs",
              "name": "Up for grabs",
              "color": "99a810",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24125",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24125",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24125.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24125.patch"
          },
          "closed_at": "2023-04-25T15:19:25Z",
          "created_at": "2022-01-22T01:28:10Z",
          "updated_at": "2023-04-25T15:19:25Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-12T00:49:10Z",
      "updated_at": "2022-10-12T00:49:10Z",
      "source": {
        "issue": {
          "id": 1057850480,
          "node_id": "PR_kwDOABII584uvS9g",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23549",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23549/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23549/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23549/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23549",
          "number": 23549,
          "state": "closed",
          "state_reason": null,
          "title": "Add scanblocks RPC call (attempt 2)",
          "body": "Revives #20664. All feedback from the previous PR has either been responded to inline or incorporated here.\r\n\r\n---\r\n\r\nMajor changes from Jonas' PR:\r\n- consolidated arguments for scantxoutset/scanblocks\r\n- substantial cleanup of the functional test\r\n\r\nHere's the range-diff (`git range-diff master jonasschnelli/2020/12/filterblocks_rpc jamesob/2021-11-scanblocks`): https://gist.github.com/jamesob/aa4a975344209f0316444b8de2ec1d18\r\n\r\n### Original PR description\r\n\r\n> The `scanblocks` RPC call allows one to get relevant blockhashes from a set of descriptors by scanning all blockfilters in a given range.\r\n> \r\n> **Example:**\r\n> \r\n> `scanblocks start '[\"addr(<bitcoin_address>)\"]' 661000` (returns relevant blockhashes for `<bitcoin_address>` from blockrange 661000->tip)\r\n> \r\n> ## Why is this useful?\r\n> **Fast wallet rescans**: get the relevant blocks and only rescan those via `rescanblockchain getblockheader(<hash>)[height] getblockheader(<hash>)[height])`. A future PR may add an option to allow to provide an array of blockhashes to `rescanblockchain`.\r\n> \r\n> **prune wallet rescans**: (_needs additional changes_): together with a call to fetch blocks from the p2p network if they have been pruned, it would allow to rescan wallets back to the genesis block in pruned mode (relevant #15946).\r\n> \r\n> **SPV mode** (_needs additional changes_): it would be possible to build the blockfilterindex from the p2p network (rather then deriving them from the blocks) and thus allow some sort of hybrid-SPV mode with moderate bandwidth consumption (related #9483)\r\n\r\n\r\n",
          "user": {
            "login": "jamesob",
            "id": 73197,
            "node_id": "MDQ6VXNlcjczMTk3",
            "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jamesob",
            "html_url": "https://github.com/jamesob",
            "followers_url": "https://api.github.com/users/jamesob/followers",
            "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
            "organizations_url": "https://api.github.com/users/jamesob/orgs",
            "repos_url": "https://api.github.com/users/jamesob/repos",
            "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jamesob/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98279177,
              "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
              "name": "RPC/REST/ZMQ",
              "color": "0052cc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 21,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23549",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23549",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23549.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23549.patch"
          },
          "closed_at": "2022-10-13T14:49:29Z",
          "created_at": "2021-11-18T21:56:52Z",
          "updated_at": "2022-10-13T18:20:39Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-12T01:12:21Z",
      "updated_at": "2022-10-12T01:12:21Z",
      "source": {
        "issue": {
          "id": 1021384855,
          "node_id": "PR_kwDOABII584s9UYg",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23233",
          "number": 23233,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Add encrypted p2p transport {de}serializer",
          "body": "Revives #18242. Depends on #25361 (please review that first, the last 4 commits are to be reviewed here).\r\n\r\nThis PR adds a p2p message transport {de}serializer for encrypted packets leveraging the BIP324 specification.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 34,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23233",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23233",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23233.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23233.patch"
          },
          "closed_at": "2023-05-06T11:11:30Z",
          "created_at": "2021-10-08T19:01:33Z",
          "updated_at": "2023-05-06T11:11:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 7582950069,
      "node_id": "LE_lADOABII585TjqCFzwAAAAHD-qK1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7582950069",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-13T16:06:09Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1146311466,
      "node_id": "PRR_kwDOABII585EU1Mq",
      "url": null,
      "actor": null,
      "commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Just few comments as a first parse on the post-#23443 commits.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1146311466",
      "submitted_at": "2022-10-18T20:01:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-21T05:20:03Z",
      "updated_at": "2022-10-21T05:20:03Z",
      "source": {
        "issue": {
          "id": 839117639,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTk5MTgyNzQ5",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21515/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21515",
          "number": 21515,
          "state": "open",
          "state_reason": null,
          "title": "Erlay: bandwidth-efficient transaction relay protocol",
          "body": "I started forking off parts of this big PR so that we can review and merge in chunks with better efficiency.\r\n1. [p2p: Erlay support signaling](https://github.com/bitcoin/bitcoin/pull/23443) — done\r\n2. [Follow-up](https://github.com/bitcoin/bitcoin/pull/26359) — done\r\n3. [p2p: Fill reconciliation sets and request reconciliation (Erlay)](https://github.com/bitcoin/bitcoin/pull/26283) — pending\r\n\r\n-----------\r\n\r\nPlease use this discussion for high-level topics and keep the nitpics for the sub-PRs. The state of this branch might be not the cleanest and the freshest, although last time I rebased in on 2022/05/12 to be in sync {with master, with the latest child PR} and pass CI (modulo one race condition issue).\r\n\r\n-----------\r\n\r\nThis is an implementation of  [Erlay](https://arxiv.org/abs/1905.10518) , using primitives in the BIP-330 (see the updated spec  [here](https://github.com/naumenkogs/bips/blob/bip_0330_updates/bip-0330.mediawiki) ). Please refer to these two to understand the design. My talk is [here](https://youtu.be/YxsjdIl0034?t=670) .\r\n\r\nThis PR supersedes the previous [one](https://github.com/bitcoin/bitcoin/pull/18261), because that one got too much review comments (I tried to resolve all of them for this version), and also it was much refactored since then.\r\n\r\n### Abstract\r\n\r\nErlay uses both flooding (announcing using INV messages to all peers) and reconciliation to announce transactions. Flooding is expensive, so Erlay seeks to use it sparingly and in strategic locations - only well-connected publicly reachable nodes flood transactions to other publicly reachable nodes via outbound connections. Since every unreachable node is directly connected to several reachable nodes, this policy ensures that a transaction is quickly propagated to be within one hop from most of the nodes in the network.\r\n\r\nAll transactions not propagated through flooding are propagated through efficient set reconciliation. To do this, every node keeps a reconciliation set for each peer, in which transactions are placed which would have been announced using INV messages absent this protocol. Every 2 seconds every node chooses a peer from its outbound connections in a predetermined order to reconcile with, resulting in both sides learning the transactions known to the other side. After every reconciliation round, the corresponding reconciliation set is cleared.\r\n\r\nI think both paper and the BIP motives the changes, but I’ll mention them briefly once again here:\r\n* save 40% of the bandwidth consumed by a node\r\n* increase network connectivity for almost no bandwidth or latency cost\r\n* improves privacy as a side-effect\r\n\r\n### How to review\r\n\r\nI suggest doing `make clean && autogen.sh && configure` before you try building it locally.\r\n\r\n-----------\r\n\r\nI created 2 discussion boards, please discuss not-code-related topics there:\r\n1. [Understanding bandwidth savings](https://github.com/naumenkogs/txrelaysim/issues/7)\r\n2. [Joining mainnet testing](https://github.com/naumenkogs/txrelaysim/issues/8)",
          "user": {
            "login": "naumenkogs",
            "id": 7975071,
            "node_id": "MDQ6VXNlcjc5NzUwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/naumenkogs",
            "html_url": "https://github.com/naumenkogs",
            "followers_url": "https://api.github.com/users/naumenkogs/followers",
            "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
            "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
            "repos_url": "https://api.github.com/users/naumenkogs/repos",
            "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 27,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21515",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21515.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21515.patch"
          },
          "created_at": "2021-03-23T20:58:32Z",
          "updated_at": "2023-05-31T20:37:48Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1156088702,
      "node_id": "PRR_kwDOABII585E6IN-",
      "url": null,
      "actor": null,
      "commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "First code-review parse, left some minor comments.",
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1156088702",
      "submitted_at": "2022-10-26T09:24:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7740408825,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHNXUP5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7740408825",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T12:44:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7740556003,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHNX4Lj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7740556003",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T13:05:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7740684079,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHNYXcv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7740684079",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T13:21:48Z"
    },
    {
      "event": "unlabeled",
      "id": 7741143892,
      "node_id": "UNLE_lADOABII585TjqCFzwAAAAHNaHtU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7741143892",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T14:17:25Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 7742287057,
      "node_id": "LE_lADOABII585TjqCFzwAAAAHNeezR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7742287057",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T16:29:57Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7762678458,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHOsRK6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7762678458",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-08T13:16:16Z"
    },
    {
      "event": "unlabeled",
      "id": 7763186057,
      "node_id": "UNLE_lADOABII585TjqCFzwAAAAHOuNGJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7763186057",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-08T14:09:11Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-09T17:11:39Z",
      "updated_at": "2022-11-09T17:11:39Z",
      "source": {
        "issue": {
          "id": 1417936723,
          "node_id": "PR_kwDOABII585BQ_6D",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26359",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26359/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26359/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26359/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26359",
          "number": 26359,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: Erlay support signaling follow-ups",
          "body": "\r\n\r\nNon-trivial changes include:\r\n- Getting rid of roles in `sendtxrcncl` message (summarized in the [BIP PR](https://github.com/bitcoin/bips/pull/1376));\r\n- Disconnect the peer if it send `sendtxrcncl` although we are in `blocksonly` and notified the peer with `fRelay=0`;\r\n- Don't send `sendtxrcncl` to feeler connections.",
          "user": {
            "login": "naumenkogs",
            "id": 7975071,
            "node_id": "MDQ6VXNlcjc5NzUwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/naumenkogs",
            "html_url": "https://github.com/naumenkogs",
            "followers_url": "https://api.github.com/users/naumenkogs/followers",
            "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
            "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
            "repos_url": "https://api.github.com/users/naumenkogs/repos",
            "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 4,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26359",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26359",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26359.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26359.patch"
          },
          "closed_at": "2022-11-30T10:53:08Z",
          "created_at": "2022-10-21T08:08:43Z",
          "updated_at": "2022-11-30T10:53:09Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7781724122,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHP06_a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7781724122",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T10:19:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7781872176,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHP1fIw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7781872176",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T10:37:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7782660720,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHP4fpw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7782660720",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T12:14:18Z"
    },
    {
      "event": "reviewed",
      "id": 1177296531,
      "node_id": "PRR_kwDOABII585GLB6T",
      "url": null,
      "actor": null,
      "commit_id": "913c2cbcea58696237760c51f55acee9d91eb186",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1177296531",
      "submitted_at": "2022-11-11T12:51:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T01:30:07Z",
      "updated_at": "2022-11-30T01:30:07Z",
      "source": {
        "issue": {
          "id": 1258121997,
          "node_id": "PR_kwDOABII5844-S2D",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25268",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25268/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25268/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25268/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25268",
          "number": 25268,
          "state": "open",
          "state_reason": null,
          "title": "refactor: Introduce EvictionManager",
          "body": "At the moment, the eviction logic is mangled across two different components (`CConnman`, `PeerManager`), so we can't really test it in isolation. This is not completely true for the inbound eviction logic as it exists as static functions in `net.{h.cpp}` for which tests already exist. However, the outbound eviction logic is not covered by any fuzz tests and is only testable by spinning up both a connman and peerman.\r\n\r\nThis PR splits out the eviction logic into its own component `EvictionManager`. In addition to isolating the eviction logic, we get rid of several layer violations (e.g. `CConnman::ForEachNode/ForNode` calls, `CNode::m_last_block_time`, etc.) between `net` and `net processing`.\r\n\r\nOne instance of the `EvictionManager` is created at start up and passed as a reference to the connection and peer managers. The connection and peer managers report all eviction relevant information to the eviction manager who ultimately suggests nodes to evict as the result of `EvictionManager::SelectInboundNodeToEvict` and `EvictionManager::SelectOutboundNodesToEvict`.",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25268",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25268",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25268.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25268.patch"
          },
          "created_at": "2022-06-02T12:34:15Z",
          "updated_at": "2023-08-06T17:48:48Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 7921414509,
      "node_id": "LE_lADOABII585TjqCFzwAAAAHYJzFt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7921414509",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T12:05:54Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7921654308,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHYKtok",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7921654308",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T12:36:12Z"
    },
    {
      "event": "ready_for_review",
      "id": 7921848447,
      "node_id": "RFRE_lADOABII585TjqCFzwAAAAHYLdB_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7921848447",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T13:00:36Z"
    },
    {
      "event": "unlabeled",
      "id": 7922468578,
      "node_id": "UNLE_lADOABII585TjqCFzwAAAAHYN0bi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7922468578",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T14:11:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1199573032,
      "node_id": "PRR_kwDOABII585HgAgo",
      "url": null,
      "actor": null,
      "commit_id": "63d103dcb4defeb7192179f2f5867fe964d28cb9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Some comments on the first commits.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1199573032",
      "submitted_at": "2022-11-30T15:56:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7931380629,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHYv0OV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7931380629",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-01T12:28:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7931388755,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHYv2NT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7931388755",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-01T12:29:31Z"
    },
    {
      "event": "reviewed",
      "id": 1202785461,
      "node_id": "PRR_kwDOABII585HsQy1",
      "url": null,
      "actor": null,
      "commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1202785461",
      "submitted_at": "2022-12-02T18:54:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1202979648,
      "node_id": "PRR_kwDOABII585HtANA",
      "url": null,
      "actor": null,
      "commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Some comments on the first 3 commits.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1202979648",
      "submitted_at": "2022-12-02T23:48:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7952654996,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHaA-KU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7952654996",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-05T09:16:23Z"
    },
    {
      "event": "reviewed",
      "id": 1206848088,
      "node_id": "PRR_kwDOABII585H7wpY",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1206848088",
      "submitted_at": "2022-12-06T16:17:37Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1207285454,
      "node_id": "PRR_kwDOABII585H9bbO",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1207285454",
      "submitted_at": "2022-12-06T23:44:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1208726536,
      "node_id": "PRR_kwDOABII585IC7QI",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I've drafted up a fuzz target for the `TxReconciliationTracker` here: https://github.com/dergoegge/bitcoin/commits/2022-10-erlay2\r\n\r\nI think having a fuzz target is worth while, now that there is quite a bit more going on besides registering/forgetting peers. I am happy to PR that separately after this is merged.\r\n\r\nSome suggestions inline after working on that target:",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1208726536",
      "submitted_at": "2022-12-07T16:28:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1208638733,
      "node_id": "PRR_kwDOABII585ICl0N",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1208638733",
      "submitted_at": "2022-12-07T16:31:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1208800680,
      "node_id": "PRR_kwDOABII585IDNWo",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1208800680",
      "submitted_at": "2022-12-07T17:02:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-17T13:33:34Z",
      "updated_at": "2022-12-17T13:33:34Z",
      "source": {
        "issue": {
          "id": 1191033673,
          "node_id": "PR_kwDOABII5841jAnn",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24748",
          "number": 24748,
          "state": "open",
          "state_reason": null,
          "title": "test/BIP324: functional tests for v2 P2P encryption",
          "body": "This PR introduces support for v2 P2P encryption(BIP 324) in the existing functional test framework and adds functional tests for the same.\r\n\r\nIt's built on top of:\r\n* #24545 \r\n* #24005\r\n\r\nThe first 2 commits help the CI pass since the secp256k1 subtree directory is touched by the parent PR 24545.\r\nThe next 2 commits bring in the mentioned parent PRs. They'll all be removed when the parent PRs get merged.\r\n\r\n### commits overview\r\n1. Introducing cryptographic constructs(HKDF, ECDH, ChaCha20, Poly1305, FSChaCha20 and FSChaCha20Poly1305) in the test framework to help with P2P encryption.\r\n2. Performing v2 P2P encryption in a v2 connection.\r\n    * introduces a new class `EncryptedP2PState` to store the keys, functions for performing the initial v2 handshake and encryption/decryption.\r\n    * this class is used by `P2PConnection` in inbound/outbound connections to perform the initial v2 handshake before the v1 version handshake. Only after the initial v2 handshake is performed do application layer P2P messages(version, verack etc..) get exchanged. (in a v2 connection)\r\n    * the encrypted P2P messages follow a different format - 3 byte length + 1-13 byte message_type + payload + 16 byte MAC\r\n    * includes support for testing decoy messages and v2 connection downgrade(using false advertisement - when a v2 node makes an outbound connection to a node which doesn't support v2 but is advertised as v2 by some malicious\r\nintermediary)\r\n\r\n### run the tests\r\n* functional test - `test/functional/p2p_v2_encrypted.py` `test/functional/p2p_v2_earlykeyresponse.py`\r\n\r\nI'm also super grateful to @ dhruv for his really valuable feedback on this branch.",
          "user": {
            "login": "stratospher",
            "id": 44024636,
            "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
            "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/stratospher",
            "html_url": "https://github.com/stratospher",
            "followers_url": "https://api.github.com/users/stratospher/followers",
            "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
            "organizations_url": "https://api.github.com/users/stratospher/orgs",
            "repos_url": "https://api.github.com/users/stratospher/repos",
            "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/stratospher/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24748",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24748.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24748.patch"
          },
          "created_at": "2022-04-03T20:14:51Z",
          "updated_at": "2023-08-01T18:12:18Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8068655484,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHg7el8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8068655484",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-19T11:42:39Z"
    },
    {
      "event": "reviewed",
      "id": 1223170187,
      "node_id": "PRR_kwDOABII585I6BiL",
      "url": null,
      "actor": null,
      "commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Left some comments. Is it possible to add some unit tests for the `ShouldFloodTo` function?",
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1223170187",
      "submitted_at": "2022-12-19T18:36:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-19T21:06:32Z",
      "updated_at": "2022-12-19T21:06:32Z",
      "source": {
        "issue": {
          "id": 1471685707,
          "node_id": "PR_kwDOABII585EFGFt",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26621",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26621/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26621/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26621/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26621",
          "number": 26621,
          "state": "open",
          "state_reason": null,
          "title": "refactor: Continue moving application data from CNode to Peer",
          "body": "This PR picks up a subset of changes from #24970 and additionally moves `m_bip152_highbandwith{to,from}`, `nTimeOffset`, `nVersion`, `m_greates_common_version`.",
          "user": {
            "login": "dergoegge",
            "id": 8077169,
            "node_id": "MDQ6VXNlcjgwNzcxNjk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dergoegge",
            "html_url": "https://github.com/dergoegge",
            "followers_url": "https://api.github.com/users/dergoegge/followers",
            "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
            "organizations_url": "https://api.github.com/users/dergoegge/orgs",
            "repos_url": "https://api.github.com/users/dergoegge/repos",
            "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dergoegge/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 16,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26621",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26621",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26621.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26621.patch"
          },
          "created_at": "2022-12-01T17:26:32Z",
          "updated_at": "2023-08-16T21:14:02Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1359001649,
      "node_id": "IC_kwDOABII585RALgx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1359001649",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-20T08:32:30Z",
      "updated_at": "2022-12-20T08:32:30Z",
      "author_association": "MEMBER",
      "body": "@aureleoules fixed all you pointed out. Note that the last two commits are WIP, as I'm looking for a confirmation that those two are indeed an improvement. If yes, then I will squash them with the earlier commits, add tests, etc.\r\nYou could state your opinion about them too (each commit separately) :).",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1359001649",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283"
    },
    {
      "event": "mentioned",
      "id": 8076134704,
      "node_id": "MEE_lADOABII585TjqCFzwAAAAHhYAkw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8076134704",
      "actor": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-20T08:32:31Z"
    },
    {
      "event": "subscribed",
      "id": 8076134710,
      "node_id": "SE_lADOABII585TjqCFzwAAAAHhYAk2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8076134710",
      "actor": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-20T08:32:31Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8076142642,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHhYCgy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8076142642",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-20T08:33:33Z"
    },
    {
      "event": "reviewed",
      "id": 1302212068,
      "node_id": "PRR_kwDOABII585Nni3k",
      "url": null,
      "actor": null,
      "commit_id": "986b02ce31cc22ec6f92ec190687afe6725711b8",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "> Curious, what we care about a low transaction relay latency ? Like I would say lower latency > makes it a) harder to observe original transaction broadcast by deanonymization attacker\r\n> b) disincentive transaction issuers front-running the standard tx-relay rules to place their\r\n> transactions first in the mempools in case of congestion and c) for instant/0confs flows\r\n> improve UX, do we have more properties ?\r\n\r\nYeah low-transaction relay latency is still to reconsider in light of all the timevalue DoS that you might have as a Lightning node running on top of Bitcoin Core. Implications with things like https://github.com/bitcoin/bitcoin/pull/21224.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1302212068",
      "submitted_at": "2023-02-16T20:13:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8562593448,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-Xs6o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8562593448",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-20T14:57:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8568371560,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-tvlo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8568371560",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:52:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8568840098,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-vh-i",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8568840098",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T09:36:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8569430617,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-xyJZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8569430617",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T10:33:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8569653246,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-yof-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8569653246",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T10:58:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8569846011,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-zXj7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8569846011",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T11:18:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8570141448,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-0fsI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8570141448",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T11:56:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8579856066,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH_ZjbC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8579856066",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-22T11:09:42Z"
    },
    {
      "event": "reviewed",
      "id": 1309970444,
      "node_id": "PRR_kwDOABII585OFJAM",
      "url": null,
      "actor": null,
      "commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1309970444",
      "submitted_at": "2023-02-22T19:55:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8590289302,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAIABWmW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8590289302",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-23T10:58:19Z"
    },
    {
      "event": "reviewed",
      "id": 1339558296,
      "node_id": "PRR_kwDOABII585P2AmY",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1339558296",
      "submitted_at": "2023-03-14T15:31:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1342448815,
      "node_id": "PRR_kwDOABII585QBCSv",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I found the algorithm to pick fanout peers in commit \"p2p: Initiate reconciliation round\" rather hard to understand.\r\nIt would be helpful to have more documentation in this part of the code and the function descriptions of (`ShouldFanoutTo()` and `GetFanoutTargets()`), especially since this is not covered in the BIP.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1342448815",
      "submitted_at": "2023-03-16T15:49:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1344306348,
      "node_id": "PRR_kwDOABII585QIHys",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1344306348",
      "submitted_at": "2023-03-16T17:34:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1363161761,
      "node_id": "PRR_kwDOABII585RQDKh",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1363161761",
      "submitted_at": "2023-03-29T13:59:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "labeled",
      "id": 8889740944,
      "node_id": "LE_lADOABII585TjqCFzwAAAAIR3q6Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8889740944",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T16:43:16Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1451435060,
      "node_id": "PRR_kwDOABII585WgyQ0",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1451435060",
      "submitted_at": "2023-05-30T17:12:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1451623963,
      "node_id": "PRR_kwDOABII585WhgYb",
      "url": null,
      "actor": null,
      "commit_id": "30c39c1316a7b5c1914654f2a1487309b6e550ac",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1451623963",
      "submitted_at": "2023-05-30T18:55:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T15:33:11Z",
      "updated_at": "2023-05-31T15:33:11Z",
      "source": {
        "issue": {
          "id": 1734440569,
          "node_id": "PR_kwDOABII585RzUG4",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27797",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27797/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27797/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27797/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27797",
          "number": 27797,
          "state": "closed",
          "state_reason": null,
          "title": "rpc, net: add erlay status in `getpeerinfo`",
          "body": "Fixes #26602\r\n\r\nAdds `m_tx_reconciliation` in `Peer` struct\r\nto know whether the peer supports Erlay and\r\nexposes it in `getpeerinfo` rpc.",
          "user": {
            "login": "brunoerg",
            "id": 19480819,
            "node_id": "MDQ6VXNlcjE5NDgwODE5",
            "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/brunoerg",
            "html_url": "https://github.com/brunoerg",
            "followers_url": "https://api.github.com/users/brunoerg/followers",
            "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
            "organizations_url": "https://api.github.com/users/brunoerg/orgs",
            "repos_url": "https://api.github.com/users/brunoerg/repos",
            "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/brunoerg/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27797",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27797",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27797.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27797.patch"
          },
          "closed_at": "2023-06-01T09:19:04Z",
          "created_at": "2023-05-31T15:03:25Z",
          "updated_at": "2023-06-01T09:19:05Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1566303719,
      "node_id": "PRR_kwDOABII585dW-Xn",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1566303719",
      "submitted_at": "2023-08-08T00:27:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10105921717,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAJaXCC1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10105921717",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T09:06:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10105982320,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAJaXQ1w",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10105982320",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T09:12:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10106058985,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAJaXjjp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10106058985",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T09:19:53Z"
    },
    {
      "event": "unlabeled",
      "id": 10106959903,
      "node_id": "UNLE_lADOABII585TjqCFzwAAAAJaa_gf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10106959903",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T10:53:26Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 10107489542,
      "node_id": "LE_lADOABII585TjqCFzwAAAAJadA0G",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10107489542",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T11:52:59Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10108827764,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAJaiHh0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10108827764",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T13:53:20Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-16T17:49:49Z",
      "updated_at": "2023-08-16T17:49:49Z",
      "source": {
        "issue": {
          "id": 1712063643,
          "node_id": "PR_kwDOABII585QnjDj",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27675",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27675/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27675/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27675/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27675",
          "number": 27675,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: Drop m_recently_announced_invs bloom filter",
          "body": "This PR replaces the `m_recently_announced_invs` bloom filter with a simple sequence number tracking the mempool state when we last considered sending an INV message to a node. This saves 33kB per peer (or more if we raise the rate at which we relay transactions over the network, in which case we would need to increase the size of the bloom filter proportionally).\r\n\r\nThe philosophy here (compare with #18861 and #19109) is that we consider the rate limiting on INV messages to only be about saving bandwidth and not protecting privacy, and therefore after you receive an INV message, it's immediately fair game to request any transaction that was in the mempool at the time the INV message was sent. We likewise consider the BIP 133 feefilter and BIP 37 bloom filters to be bandwidth optimisations here, and treat transactions as requestable if they would have been announced without those filters. Given that philosophy, tracking the timestamp of the last INV message and comparing that against the mempool entry time allows removal of each of `m_recently_announced_invs`, `m_last_mempool_req` and `UNCONDITIONAL_RELAY_DELAY` and associated logic.",
          "user": {
            "login": "ajtowns",
            "id": 127186,
            "node_id": "MDQ6VXNlcjEyNzE4Ng==",
            "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ajtowns",
            "html_url": "https://github.com/ajtowns",
            "followers_url": "https://api.github.com/users/ajtowns/followers",
            "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
            "organizations_url": "https://api.github.com/users/ajtowns/orgs",
            "repos_url": "https://api.github.com/users/ajtowns/repos",
            "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ajtowns/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 29,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27675",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27675",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27675.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27675.patch"
          },
          "closed_at": "2023-08-17T09:52:21Z",
          "created_at": "2023-05-16T13:45:18Z",
          "updated_at": "2023-08-17T11:09:46Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1681931026,
      "node_id": "IC_kwDOABII585kQDsS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1681931026",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T09:19:17Z",
      "updated_at": "2023-08-17T09:19:17Z",
      "author_association": "MEMBER",
      "body": "Looks like the functional test times out in CI?",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1681931026",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDlkOGUyZDVjNTVkMTE4NDY1YmNjYjRmYzdiM2RkMzJiNzk1NmE5YmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d8e2d5c55d118465bccb4fc7b3dd32b7956a9ba",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9d8e2d5c55d118465bccb4fc7b3dd32b7956a9ba",
      "tree": {
        "sha": "6cfdbcf7b930cc7f288bb7e693e962b34767b29c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6cfdbcf7b930cc7f288bb7e693e962b34767b29c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d78ff380a2cde80c264e36e046b1cfc054bd9253",
          "sha": "d78ff380a2cde80c264e36e046b1cfc054bd9253",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d78ff380a2cde80c264e36e046b1cfc054bd9253"
        }
      ],
      "message": "refactor: Add a pre-mutexed version of IsPeerRegistered\n\nThe pre-mutexed version is useful for external calls, while\nthe regular version will be used internally.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-17T11:26:28Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-12-01T12:12:03Z"
      },
      "sha": "9d8e2d5c55d118465bccb4fc7b3dd32b7956a9ba"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE5NGUyNTU5ZmM3MDFkOGM4OWI3ZjNiMDUyODYyZjZmMWI4ZjA5Yjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/194e2559fc701d8c89b7f3b052862f6f1b8f09b8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/194e2559fc701d8c89b7f3b052862f6f1b8f09b8",
      "tree": {
        "sha": "38be03669117accb06441693cde42d9c5afbce5b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/38be03669117accb06441693cde42d9c5afbce5b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d8e2d5c55d118465bccb4fc7b3dd32b7956a9ba",
          "sha": "9d8e2d5c55d118465bccb4fc7b3dd32b7956a9ba",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9d8e2d5c55d118465bccb4fc7b3dd32b7956a9ba"
        }
      ],
      "message": "p2p: Functions to add/remove wtxids to tx reconciliation sets\n\nThey will be used later on.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-17T11:26:28Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-10-08T06:25:01Z"
      },
      "sha": "194e2559fc701d8c89b7f3b052862f6f1b8f09b8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA1MWE5MzRhOGEyMjk5Y2MyNjM2NWUwYWMyMGU5MjU5MjM4N2RlNTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/051a934a8a2299cc26365e0ac20e92592387de58",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/051a934a8a2299cc26365e0ac20e92592387de58",
      "tree": {
        "sha": "cb1a4b25c6b5dac352a0c90c4c96dd9d144921d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cb1a4b25c6b5dac352a0c90c4c96dd9d144921d0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/194e2559fc701d8c89b7f3b052862f6f1b8f09b8",
          "sha": "194e2559fc701d8c89b7f3b052862f6f1b8f09b8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/194e2559fc701d8c89b7f3b052862f6f1b8f09b8"
        }
      ],
      "message": "p2p: Add transactions to reconciliation sets\n\nTransactions eligible for reconciliation are added to the\nreconciliation sets. For the remaining txs, low-fanout is used.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-17T11:43:05Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-06-23T16:01:53Z"
      },
      "sha": "051a934a8a2299cc26365e0ac20e92592387de58"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDIzODRjNjViNGFlNTM2YTJlMDRkYWUyYjBkMTY4ODAyMGZkNzgxZjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2384c65b4ae536a2e04dae2b0d1688020fd781f9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2384c65b4ae536a2e04dae2b0d1688020fd781f9",
      "tree": {
        "sha": "8413cba31ed9b3068edd1af5b74a7213e4e3fa51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8413cba31ed9b3068edd1af5b74a7213e4e3fa51"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/051a934a8a2299cc26365e0ac20e92592387de58",
          "sha": "051a934a8a2299cc26365e0ac20e92592387de58",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/051a934a8a2299cc26365e0ac20e92592387de58"
        }
      ],
      "message": "p2p: Introduce reconciliation-fanout tx broadcast interval\n\nFor a subset of reconciling peers we announce transactions\nvia low fanout. We need to set lower intervals for that to\nachieve lower relay latency.\n\nNote that for privacy reasons the ratio between inbound and outbound\ndelays matter much more than the actual delays. That ratio is preserved\nhere, so it is not a privacy degradation.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-17T11:43:06Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-16T19:33:05Z"
      },
      "sha": "2384c65b4ae536a2e04dae2b0d1688020fd781f9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM1ODA3MWFjYmY5NjE5NmFmNzc3NDQ0N2QzZmRmN2E3NmU0MGJjY2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/358071acbf96196af7774447d3fdf7a76e40bccb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/358071acbf96196af7774447d3fdf7a76e40bccb",
      "tree": {
        "sha": "44fbaa29dbd687a6527a6744730226f5fc55ee1f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/44fbaa29dbd687a6527a6744730226f5fc55ee1f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2384c65b4ae536a2e04dae2b0d1688020fd781f9",
          "sha": "2384c65b4ae536a2e04dae2b0d1688020fd781f9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2384c65b4ae536a2e04dae2b0d1688020fd781f9"
        }
      ],
      "message": "p2p: Add peers to reconciliation queue on negotiation\n\nWhen we're finalizing negotiation, we should add the peers\nfor which we will initiate reconciliations to the queue.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-17T11:43:06Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T12:12:24Z"
      },
      "sha": "358071acbf96196af7774447d3fdf7a76e40bccb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI1NDA0OGZlYmJmYTFlODRiMWMzZDc1ODQyNDU0ZTZkOTA5OGIwNzg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/254048febbfa1e84b1c3d75842454e6d9098b078",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/254048febbfa1e84b1c3d75842454e6d9098b078",
      "tree": {
        "sha": "14767da3888144c3ae36d8edadfe2e94ddef9d90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/14767da3888144c3ae36d8edadfe2e94ddef9d90"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/358071acbf96196af7774447d3fdf7a76e40bccb",
          "sha": "358071acbf96196af7774447d3fdf7a76e40bccb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/358071acbf96196af7774447d3fdf7a76e40bccb"
        }
      ],
      "message": "p2p: Track reconciliation requests schedule\n\nWe initiate reconciliation by looking at the queue periodically\nwith equal intervals between peers to achieve efficiency.\n\nThis will be later used to see whether it's time to initiate.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-17T11:43:06Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:26:17Z"
      },
      "sha": "254048febbfa1e84b1c3d75842454e6d9098b078"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE1YjQ2NDU2N2M0ZjRjZTFmMTljMzM5ODc5MzU3YWFjZjIyN2ZkYWM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/15b464567c4f4ce1f19c339879357aacf227fdac",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/15b464567c4f4ce1f19c339879357aacf227fdac",
      "tree": {
        "sha": "89a1d5a5801378eb0d722830c1080e3b5dc7152d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/89a1d5a5801378eb0d722830c1080e3b5dc7152d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/254048febbfa1e84b1c3d75842454e6d9098b078",
          "sha": "254048febbfa1e84b1c3d75842454e6d9098b078",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/254048febbfa1e84b1c3d75842454e6d9098b078"
        }
      ],
      "message": "p2p: Initiate reconciliation round\n\nWhen the time comes for the peer, we send a\nreconciliation request with the parameters which\nwill help the peer to construct a (hopefully) sufficient\nreconciliation sketch for us. We will then use that\nsketch to find missing transactions.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-17T11:43:06Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:27:32Z"
      },
      "sha": "15b464567c4f4ce1f19c339879357aacf227fdac"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY1MDI1ZDE5MzViMDgyZTk4ZDdkMzQ3YzYyOWMxNzM5YWJhYTVmNjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/65025d1935b082e98d7d347c629c1739abaa5f67",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/65025d1935b082e98d7d347c629c1739abaa5f67",
      "tree": {
        "sha": "5218aa431273935b5efae8b751121566fc51030f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5218aa431273935b5efae8b751121566fc51030f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/15b464567c4f4ce1f19c339879357aacf227fdac",
          "sha": "15b464567c4f4ce1f19c339879357aacf227fdac",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/15b464567c4f4ce1f19c339879357aacf227fdac"
        }
      ],
      "message": "test: functional test for reqtxrcncl",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-08-17T11:43:06Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-11-10T10:18:45Z"
      },
      "sha": "65025d1935b082e98d7d347c629c1739abaa5f67"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10118451607,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAJbG1GX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10118451607",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-17T11:43:17Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613",
      "pull_request_review_id": 1146311466,
      "id": 998568613,
      "node_id": "PRRC_kwDOABII5847hPKl",
      "diff_hunk": "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 297,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/reocnciliation set/reconciliation set/g",
      "created_at": "2022-10-18T18:17:12Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998568613",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5756,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937",
      "pull_request_review_id": 1146311466,
      "id": 998588937,
      "node_id": "PRRC_kwDOABII5847hUIJ",
      "diff_hunk": "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 334,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could be `<=` as `MAX_PEER_TX_ANNOUNCEMENTS` should be the maximum number of elements/transactions we announce to our peers. Note, while only strictly inferior transaction requests are considered L1409 in `net_processing.cpp`, this is different for the processing of `NOTFOUND`, L4793, still in `net_processing.cpp`.",
      "created_at": "2022-10-18T18:41:23Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998588937",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182",
      "pull_request_review_id": 1146311466,
      "id": 998598182,
      "node_id": "PRRC_kwDOABII5847hWYm",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXRECONCILIATION_H\n+#define BITCOIN_NODE_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/** Whether transaction reconciliation protocol should be enabled by default. */\n+static constexpr bool DEFAULT_TXRECONCILIATION_ENABLE{false};\n+/** Supported transaction reconciliation protocol version */\n+static constexpr uint32_t TXRECONCILIATION_VERSION{1};\n+\n+enum ReconciliationRegisterResult {\n+    NOT_FOUND = 0,\n+    SUCCESS = 1,\n+    PROTOCOL_VIOLATION = 2,\n+};\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all txreconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0.  Txreconciliation protocol handshake.\n+ * 1.  Once we receive a new transaction, add it to the set instead of announcing immediately.\n+ * 2.  At regular intervals, a txreconciliation initiator requests a sketch from a peer, where a\n+ *     sketch is a compressed representation of short form IDs of the transactions in their set.\n+ * 3.  Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *     and combines the two sketches to attempt finding the difference in *sets*.\n+ * 4a. If the difference was not larger than estimated, see SUCCESS below.\n+ * 4b. If the difference was larger than estimated, initial txreconciliation fails. The initiator\n+ *     requests a larger sketch via an extension round (allowed only once).\n+ *     - If extension succeeds (a larger sketch is sufficient), see SUCCESS below.\n+ *     - If extension fails (a larger sketch is insufficient), see FAILURE below.\n+ *\n+ * SUCCESS. The initiator knows full symmetrical difference and can request what the initiator is\n+ *          missing and announce to the peer what the peer is missing.\n+ *\n+ * FAILURE. The initiator notifies the peer about the failure and announces all transactions from\n+ *          the corresponding set. Once the peer received the failure notification, the peer\n+ *          announces all transactions from their set.\n+\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker\n+{\n+private:\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    explicit TxReconciliationTracker(uint32_t recon_version);\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generates initial part of the state (salt) required to reconcile txs with the peer.\n+     * The salt is used for short ID computation required for txreconciliation.\n+     * The function returns the salt.\n+     * A peer can't participate in future txreconciliations without this call.\n+     * This function must be called only once per peer.\n+     */\n+    uint64_t PreRegisterPeer(NodeId peer_id);\n+\n+    /**\n+     * Step 0. Once the peer agreed to reconcile txs with us, generate the state required to track\n+     * ongoing reconciliations. Must be called only after pre-registering the peer and only once.\n+     */\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version, uint64_t remote_salt);\n+\n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     */\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     */\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If a it's time to request a reconciliation from the peer, this function will return\n+     * the details of our local state, which should be communicated to the peer so that they better\n+     * know what we need:\n+     * - size of our reconciliation set for the peer\n+     * - our q-coefficient with the peer, formatted to be transmitted as integer value\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id);\n+\n+    /**\n+     * Returns the size of the reconciliation set we have locally for the given peer.\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    size_t GetPeerSetSize(NodeId peer_id) const;\n+\n+    /**\n+     * Attempts to forget txreconciliation-related state of the peer (if we previously stored any).\n+     * After this, we won't be able to reconcile transactions with the peer.\n+     */\n+    void ForgetPeer(NodeId peer_id);\n+\n+    /**\n+     * Check if a peer is registered to reconcile transactions with us.\n+     */\n+    bool IsPeerRegistered(NodeId peer_id) const;\n+\n+    /**\n+     * Returns whether for the given call the peer is chosen as a low-fanout destination.\n+     */\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const;\n+\n+    /**\n+     * Check whether a particular transaction is being currently reconciled with a given peer.\n+     */\n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const;",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 125,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could be called `IsAlreadyInPeerSet` or something more speaking than transaction is already in peer local set but not announced yet. ",
      "created_at": "2022-10-18T18:52:19Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998598182",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903",
      "pull_request_review_id": 1146311466,
      "id": 998610903,
      "node_id": "PRRC_kwDOABII5847hZfX",
      "diff_hunk": "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_txreconciliation->AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {",
      "path": "src/net_processing.cpp",
      "position": 194,
      "original_position": 366,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note, current inv-based transaction announcement (L5812) isn't gated on IBD being over though I agree it makes sense to save bandwidth as the node is unlikely to be able to validate most of the transactions received for inaccuracy of its local UTXO set. ",
      "created_at": "2022-10-18T19:07:34Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998610903",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5861,
      "original_line": 5861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472",
      "pull_request_review_id": 1146311466,
      "id": 998613472,
      "node_id": "PRRC_kwDOABII5847haHg",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXRECONCILIATION_H\n+#define BITCOIN_NODE_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/** Whether transaction reconciliation protocol should be enabled by default. */\n+static constexpr bool DEFAULT_TXRECONCILIATION_ENABLE{false};\n+/** Supported transaction reconciliation protocol version */\n+static constexpr uint32_t TXRECONCILIATION_VERSION{1};\n+\n+enum ReconciliationRegisterResult {\n+    NOT_FOUND = 0,\n+    SUCCESS = 1,\n+    PROTOCOL_VIOLATION = 2,\n+};\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all txreconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0.  Txreconciliation protocol handshake.\n+ * 1.  Once we receive a new transaction, add it to the set instead of announcing immediately.\n+ * 2.  At regular intervals, a txreconciliation initiator requests a sketch from a peer, where a\n+ *     sketch is a compressed representation of short form IDs of the transactions in their set.\n+ * 3.  Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *     and combines the two sketches to attempt finding the difference in *sets*.\n+ * 4a. If the difference was not larger than estimated, see SUCCESS below.\n+ * 4b. If the difference was larger than estimated, initial txreconciliation fails. The initiator\n+ *     requests a larger sketch via an extension round (allowed only once).\n+ *     - If extension succeeds (a larger sketch is sufficient), see SUCCESS below.\n+ *     - If extension fails (a larger sketch is insufficient), see FAILURE below.\n+ *\n+ * SUCCESS. The initiator knows full symmetrical difference and can request what the initiator is\n+ *          missing and announce to the peer what the peer is missing.\n+ *\n+ * FAILURE. The initiator notifies the peer about the failure and announces all transactions from\n+ *          the corresponding set. Once the peer received the failure notification, the peer\n+ *          announces all transactions from their set.\n+\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker\n+{\n+private:\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    explicit TxReconciliationTracker(uint32_t recon_version);\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generates initial part of the state (salt) required to reconcile txs with the peer.\n+     * The salt is used for short ID computation required for txreconciliation.\n+     * The function returns the salt.\n+     * A peer can't participate in future txreconciliations without this call.\n+     * This function must be called only once per peer.\n+     */\n+    uint64_t PreRegisterPeer(NodeId peer_id);\n+\n+    /**\n+     * Step 0. Once the peer agreed to reconcile txs with us, generate the state required to track\n+     * ongoing reconciliations. Must be called only after pre-registering the peer and only once.\n+     */\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version, uint64_t remote_salt);\n+\n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     */\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     */\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If a it's time to request a reconciliation from the peer, this function will return",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 91,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/if a it's time/if it's time/g",
      "created_at": "2022-10-18T19:10:45Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998613472",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645",
      "pull_request_review_id": 1146311466,
      "id": 998619645,
      "node_id": "PRRC_kwDOABII5847hbn9",
      "diff_hunk": "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_txreconciliation->AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n+                if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pto->GetId())) {\n+                    auto reconciliation_request_data = m_txreconciliation->MaybeRequestReconciliation(pto->GetId());",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 368,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`reconciliation_request_data` could be called `reconciliation_request_parameters` to dissociate clearly we're sending reconciliation config info and not the set itself.",
      "created_at": "2022-10-18T19:18:32Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998619645",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5853,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718",
      "pull_request_review_id": 1146311466,
      "id": 998628718,
      "node_id": "PRRC_kwDOABII5847hd1u",
      "diff_hunk": "@@ -143,17 +146,22 @@ static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL{30s};\n /** Delay between rotating the peers we relay a particular address to */\n static constexpr auto ROTATE_ADDR_RELAY_DEST_INTERVAL{24h};\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL{5s};\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{2s};\n /** Average delay between trickled inventory transmissions for outbound peers.\n  *  Use a smaller delay as there is less privacy concern for them.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL{2s};\n+static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{1s};\n /** Maximum rate of inventory items to send per second.\n  *  Limits the impact of low-fee transaction floods. */\n static constexpr unsigned int INVENTORY_BROADCAST_PER_SECOND = 7;\n /** Maximum number of inventory items to send per transmission. */\n-static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND * count_seconds(INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND *\n+    count_seconds(std::max(INBOUND_INVENTORY_BROADCAST_INTERVAL, INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON));",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure what you aimed to achieve here with the `std::max` between `INBOUND_INVENTORY_BROADCAST_INTERVAL` and `INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON` as the former is always superior to the latter. Maybe could be rather a `static_assert` to enforce the order at compilation time in case of future changes.  ",
      "created_at": "2022-10-18T19:29:51Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998628718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668",
      "pull_request_review_id": 1146311466,
      "id": 998629668,
      "node_id": "PRRC_kwDOABII5847heEk",
      "diff_hunk": "@@ -5488,12 +5589,35 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 LOCK(tx_relay->m_tx_inventory_mutex);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(NetPermissionFlags::NoBan);\n+                const bool supports_recon = m_txreconciliation && m_txreconciliation->IsPeerRegistered(pto->GetId());\n+\n                 if (tx_relay->m_next_inv_send_time < current_time) {\n                     fSendTrickle = true;\n                     if (pto->IsInboundConn()) {\n-                        tx_relay->m_next_inv_send_time = NextInvToInbounds(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        if (supports_recon) {\n+                            // Use shorter intervals for reconciliation peers because we use\n+                            // low-fanout, and 1) we need to make faster; 2) we won't get much",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 217,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you can develop the comment here why \"we need to make faster\" or point towards another code comment or BIP section where it's explained.",
      "created_at": "2022-10-18T19:31:04Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998629668",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5611,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914",
      "pull_request_review_id": 1146311466,
      "id": 998633914,
      "node_id": "PRRC_kwDOABII5847hfG6",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could add comment if the rational behind those values selection is specified in the BIP, paper or other research.",
      "created_at": "2022-10-18T19:36:25Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998633914",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600",
      "pull_request_review_id": 1146311466,
      "id": 998640600,
      "node_id": "PRRC_kwDOABII5847hgvY",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "path": "src/node/txreconciliation.cpp",
      "position": 32,
      "original_position": 36,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Curious, what we care about a low transaction relay latency ? Like I would say lower latency makes it a) harder to observe original transaction broadcast by deanonymization attacker b) disincentive transaction issuers front-running the standard tx-relay rules to place their transactions first in the mempools in case of congestion and c) for instant/0confs flows improve UX, do we have more properties ?",
      "created_at": "2022-10-18T19:44:50Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998640600",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 40,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688",
      "pull_request_review_id": 1146311466,
      "id": 998653688,
      "node_id": "PRRC_kwDOABII5847hj74",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "path": "src/node/txreconciliation.cpp",
      "position": 94,
      "original_position": 136,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"which are unlikely to game this timer in a serious way\", though is there a timeout in the rest of the patchset to evict lazy/buggy outbound peers which would stuck the reconciliation, making us stale on `Phase::INIT_REQUESTED` and which would prevent `MaybeRequestReconciliation()` to move forward due to the check L258 ?",
      "created_at": "2022-10-18T20:00:37Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998653688",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 140,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672",
      "pull_request_review_id": 1156088702,
      "id": 1005384672,
      "node_id": "PRRC_kwDOABII58477PPg",
      "diff_hunk": "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 354,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1d9b1f7d4bbf5ca5a8f43180b994b7b2fc03447f\r\n```suggestion\r\n                    if (!txs_to_reconcile.empty()) {\r\n```",
      "created_at": "2022-10-26T08:36:31Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005384672",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5839,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195",
      "pull_request_review_id": 1156088702,
      "id": 1005385195,
      "node_id": "PRRC_kwDOABII58477PXr",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "5070c97459282346cdcff7af08914c702462fe0d\r\n```suggestion\r\nenum class Phase {\r\n```",
      "created_at": "2022-10-26T08:36:58Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005385195",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331",
      "pull_request_review_id": 1156088702,
      "id": 1005386331,
      "node_id": "PRRC_kwDOABII58477Ppb",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 139,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "7cffb4cc0211b0494a7563d9a80a67633fa61255\r\n```suggestion\r\n                const auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\r\n```",
      "created_at": "2022-10-26T08:38:01Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005386331",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197",
      "pull_request_review_id": 1156088702,
      "id": 1005387197,
      "node_id": "PRRC_kwDOABII58477P29",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 249,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        if (!m_queue.empty()) {\r\n```",
      "created_at": "2022-10-26T08:38:49Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005387197",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347",
      "pull_request_review_id": 1156088702,
      "id": 1005388347,
      "node_id": "PRRC_kwDOABII58477QI7",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n    bool ShouldFloodTo(const uint256& wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\r\n```",
      "created_at": "2022-10-26T08:39:49Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005388347",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 305,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029",
      "pull_request_review_id": 1156088702,
      "id": 1005389029,
      "node_id": "PRRC_kwDOABII58477QTl",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                const auto cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 320,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n                const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\r\n```",
      "created_at": "2022-10-26T08:40:23Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389029",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 305,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951",
      "pull_request_review_id": 1156088702,
      "id": 1005389951,
      "node_id": "PRRC_kwDOABII58477Qh_",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 319,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n            [&eligible_peers, we_initiate](auto indexed_state) {\r\n```",
      "created_at": "2022-10-26T08:41:20Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389951",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 304,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504",
      "pull_request_review_id": 1156088702,
      "id": 1005390504,
      "node_id": "PRRC_kwDOABII58477Qqo",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                const auto cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+            }\n+        );\n+\n+        // TODO: there should be a cleaner way to do this.\n+        size_t flood_index_modulo;\n+        if (we_initiate) {\n+            flood_index_modulo = 1.0 / OUTBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        } else {\n+            flood_index_modulo = 1.0 / INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        assert(it != eligible_peers.end());\n+\n+        const size_t peer_index = it - eligible_peers.begin();\n+        return txidHasher(wtxid) % flood_index_modulo == peer_index % flood_index_modulo;\n+    }\n+\n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 340,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1d9b1f7d4bbf5ca5a8f43180b994b7b2fc03447f: there are other instances where wtxid is not passed by ref\r\n```suggestion\r\n    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\r\n```",
      "created_at": "2022-10-26T08:41:50Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005390504",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595",
      "pull_request_review_id": 1156088702,
      "id": 1005414595,
      "node_id": "PRRC_kwDOABII58477WjD",
      "diff_hunk": "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 100,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b\r\nnit but I think it's easier to read\r\n```suggestion\r\n        assert(!they_initiate || !we_initiate));\r\n```",
      "created_at": "2022-10-26T09:02:41Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005414595",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156",
      "pull_request_review_id": 1156088702,
      "id": 1005415156,
      "node_id": "PRRC_kwDOABII58477Wr0",
      "diff_hunk": "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 103,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b\r\nnit but I think it's easier to read\r\n```suggestion\r\n        if (!they_initiate && !we_initiate) return PROTOCOL_VIOLATION;\r\n```",
      "created_at": "2022-10-26T09:03:01Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005415156",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316",
      "pull_request_review_id": 1168195546,
      "id": 1013791316,
      "node_id": "PRRC_kwDOABII5848bTpU",
      "diff_hunk": "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 334,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998588937,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Applied `<=`, but I don't get the second sentence :(",
      "created_at": "2022-11-04T09:26:34Z",
      "updated_at": "2022-11-04T09:26:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013791316",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477",
      "pull_request_review_id": 1168276941,
      "id": 1013848477,
      "node_id": "PRRC_kwDOABII5848bhmd",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "path": "src/node/txreconciliation.cpp",
      "position": 32,
      "original_position": 36,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998640600,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I thought it's kinda obvious for 0conf experience, yes. Not even accepting payment, but at least seeing it in the network... Not sure what to include in the codebase.",
      "created_at": "2022-11-04T10:26:35Z",
      "updated_at": "2022-11-04T10:26:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013848477",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 40,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793",
      "pull_request_review_id": 1168280370,
      "id": 1013850793,
      "node_id": "PRRC_kwDOABII5848biKp",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "path": "src/node/txreconciliation.cpp",
      "position": 94,
      "original_position": 136,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998653688,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think `Phase::INIT_REQUESTED` is somehow related to being stuck... if one peer stays in that state, it doesn't prevent us from requesting recon from other peers. Only will delay by `m_next_recon_request` once?",
      "created_at": "2022-11-04T10:29:12Z",
      "updated_at": "2022-11-04T10:29:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013850793",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 140,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776",
      "pull_request_review_id": 1168466518,
      "id": 1013981776,
      "node_id": "PRRC_kwDOABII5848cCJQ",
      "diff_hunk": "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 100,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "in_reply_to_id": 1005414595,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure it's any better",
      "created_at": "2022-11-04T12:46:02Z",
      "updated_at": "2022-11-04T12:46:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013981776",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507",
      "pull_request_review_id": 1177296531,
      "id": 1020190507,
      "node_id": "PRRC_kwDOABII5848zt8r",
      "diff_hunk": "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 341,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "913c2cbcea58696237760c51f55acee9d91eb186",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Using PRNGs is usually discouraged, is this safe here?",
      "created_at": "2022-11-11T12:48:21Z",
      "updated_at": "2022-11-11T12:51:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020190507",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771",
      "pull_request_review_id": 1177318100,
      "id": 1020204771,
      "node_id": "PRRC_kwDOABII5848zxbj",
      "diff_hunk": "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 341,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "913c2cbcea58696237760c51f55acee9d91eb186",
      "in_reply_to_id": 1020190507,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think so — since txidHasher is salted, the peer would have no control of it, and thus can't exploit this rand. But I'll keep this comment in case someone has an objection, just in case.",
      "created_at": "2022-11-11T13:08:41Z",
      "updated_at": "2022-11-11T13:08:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020204771",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036137603",
      "pull_request_review_id": 1199573032,
      "id": 1036137603,
      "node_id": "PRRC_kwDOABII5849wjSD",
      "diff_hunk": "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 23,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This will lock `m_txreconciliation_mutex` inside `IsPeerRegistered()`, check the state, and unlock again. On the next line we will then lock it again, and get a reference to the actual state. I don't think that's what we want:\r\n\r\n* It doesn't guarantee that the state didn't change in between the unlocking in `IsPeerRegistered` and getting the state two lines below, so the assertion doesn't actually prevent race conditions.\r\n* It's inefficient to lock and unlock twice.\r\n\r\nYou should check the `TxReconciliationState` within the same critical section as using it (perhaps by making `IsPeerRegistered` require `m_txreconciliation_mutex` being held?).",
      "created_at": "2022-11-30T15:45:13Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036137603",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036137603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036138757",
      "pull_request_review_id": 1199573032,
      "id": 1036138757,
      "node_id": "PRRC_kwDOABII5849wjkF",
      "diff_hunk": "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same thing here: check the state within the same critical section as using it.",
      "created_at": "2022-11-30T15:46:15Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036138757",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036138757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036140210",
      "pull_request_review_id": 1199573032,
      "id": 1036140210,
      "node_id": "PRRC_kwDOABII5849wj6y",
      "diff_hunk": "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Shorter: `added += recon_state.m_local_set.insert(wtxid).second;`.",
      "created_at": "2022-11-30T15:47:27Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036140210",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036140210"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036141026",
      "pull_request_review_id": 1199573032,
      "id": 1036141026,
      "node_id": "PRRC_kwDOABII5849wkHi",
      "diff_hunk": "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Style nit (feel free to ignore, it's not in the style guide, but I don't think we use anything like this anywhere): space before `:`.",
      "created_at": "2022-11-30T15:48:05Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036141026",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036141026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036143555",
      "pull_request_review_id": 1199573032,
      "id": 1036143555,
      "node_id": "PRRC_kwDOABII5849wkvD",
      "diff_hunk": "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 341,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "913c2cbcea58696237760c51f55acee9d91eb186",
      "in_reply_to_id": 1020190507,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You should really use our own PRNG (`FastRandomContext`), not the standard library built-in one which has no guarantees about its quality or performance. If you really can't use FastRandomContext for some reason, use C++ RNG functions, not C ones (`rand()` is not thread-safe, in addition to possibly being poor quality).",
      "created_at": "2022-11-30T15:50:07Z",
      "updated_at": "2022-11-30T15:58:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036143555",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036143555"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 347,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036145460",
      "pull_request_review_id": 1199573032,
      "id": 1036145460,
      "node_id": "PRRC_kwDOABII5849wlM0",
      "diff_hunk": "@@ -178,6 +198,69 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "51f1c190762e9283d91297a82704e0d90fe0a8fb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This creates a copy of the `TxReconciliationState`. Sure you don't want to get a reference here?",
      "created_at": "2022-11-30T15:51:40Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036145460",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036145460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036146412",
      "pull_request_review_id": 1199573032,
      "id": 1036146412,
      "node_id": "PRRC_kwDOABII5849wlbs",
      "diff_hunk": "@@ -72,6 +86,12 @@ class TxReconciliationTracker::Impl\n private:\n     mutable Mutex m_txreconciliation_mutex;\n \n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 38,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "51f1c190762e9283d91297a82704e0d90fe0a8fb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Style: `m_txid_hasher`.",
      "created_at": "2022-11-30T15:52:15Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036146412",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036146412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036149162",
      "pull_request_review_id": 1199573032,
      "id": 1036149162,
      "node_id": "PRRC_kwDOABII5849wmGq",
      "diff_hunk": "@@ -178,6 +198,69 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "51f1c190762e9283d91297a82704e0d90fe0a8fb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No need for `floor()` here. Casting a floating-point type to integer type will automatically round down.",
      "created_at": "2022-11-30T15:54:20Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036149162",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036149162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038334384",
      "pull_request_review_id": 1202785461,
      "id": 1038334384,
      "node_id": "PRRC_kwDOABII584947mw",
      "diff_hunk": "@@ -264,6 +264,11 @@ extern const char* WTXIDRELAY;\n  * txreconciliation, as described by BIP 330.\n  */\n extern const char* SENDTXRCNCL;\n+/**\n+ * Contains a 4-byte local reconciliation set size and 4-byte q-coefficient.",
      "path": "src/protocol.h",
      "position": null,
      "original_position": 5,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The comment could be descriptive of actually what is contains and which protocol phase it's triggering (as other p2p messages coments). From the BIP:  \"The reqrecon message initiates a reconciliation round\" ",
      "created_at": "2022-12-02T16:49:28Z",
      "updated_at": "2022-12-02T18:54:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038334384",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038334384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 268,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038404614",
      "pull_request_review_id": 1202785461,
      "id": 1038404614,
      "node_id": "PRRC_kwDOABII58495MwG",
      "diff_hunk": "@@ -121,26 +201,181 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                     \"local_set_size=%i\\n\",\n+                         peer_id, local_set_size);\n+\n+                // In future, Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 234,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you can use the same wording than the BIP here \"The initiator of the P2P connection assumes the role of reconciliation initiator\" otherwise it's obscure how the initiator/responder overlaps with connection direction.",
      "created_at": "2022-12-02T18:17:56Z",
      "updated_at": "2022-12-02T18:54:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038404614",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038404614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038421101",
      "pull_request_review_id": 1202785461,
      "id": 1038421101,
      "node_id": "PRRC_kwDOABII58495Qxt",
      "diff_hunk": "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "path": "src/node/txreconciliation.cpp",
      "position": 51,
      "original_position": 58,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Have you considered to enforce policy checks like feefilter at `REQTXRCNCL` sending instead of at reconciliation set fulfilling in INV sending ?\r\n\r\nDue to `RECON_REQUEST_INTERVAL`, I think some transactions could become stalled, wasting bandwidth in case of fast-paced mempool congestion change (not to exclude when we see few transactions issuers on the network provoking spikes by themselves). Though if correct, more likely a marginal performance improvement better left for follow-up. ",
      "created_at": "2022-12-02T18:33:42Z",
      "updated_at": "2022-12-02T18:54:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038421101",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038421101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 89,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038424477",
      "pull_request_review_id": 1202785461,
      "id": 1038424477,
      "node_id": "PRRC_kwDOABII58495Rmd",
      "diff_hunk": "@@ -121,26 +201,181 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 138,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can update this logger and few other to `BCLog::TXRECONCILIATION`",
      "created_at": "2022-12-02T18:38:27Z",
      "updated_at": "2022-12-02T18:54:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038424477",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038424477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 213,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038465392",
      "pull_request_review_id": 1202979648,
      "id": 1038465392,
      "node_id": "PRRC_kwDOABII58495blw",
      "diff_hunk": "@@ -124,6 +132,33 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "99acf14cf4aa66167f826de6b1d6044c5cc3dc85",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If adding is logged, maybe also log removal similarly?",
      "created_at": "2022-12-02T19:34:22Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038465392",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038465392"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038564473",
      "pull_request_review_id": 1202979648,
      "id": 1038564473,
      "node_id": "PRRC_kwDOABII58495zx5",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Using `==` to compare floating-point numbers seems not ideal due to precision issues, but it seems like we can never hit the return here anyway since we assert that `eligible_peers.size() > 0` above, so maybe the entire line could be deleted or be an assert?",
      "created_at": "2022-12-02T21:42:31Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038564473",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038564473"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 321,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038589117",
      "pull_request_review_id": 1202979648,
      "id": 1038589117,
      "node_id": "PRRC_kwDOABII584955y9",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "since you later use `insecure_rand.randrange`, \"no randomness\" seems a bit misleading.",
      "created_at": "2022-12-02T22:05:42Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038589117",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038589117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038591870",
      "pull_request_review_id": 1202979648,
      "id": 1038591870,
      "node_id": "PRRC_kwDOABII584956d-",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 90,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: wtxid",
      "created_at": "2022-12-02T22:09:57Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038591870",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038591870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038600759",
      "pull_request_review_id": 1202979648,
      "id": 1038600759,
      "node_id": "PRRC_kwDOABII584958o3",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 86,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think I understand this algorithm yet. Say we have 20 inbound peers (0...19), as in the example. What if the starting point is 19 because of the hash of the wtxid? Then we'd only flood the tx to peer 19, but not to peer 0 (because the algorithm doesn't wrap around) - so we'd flood it to 1 target out of 20, not meeting the goal of flooding to 2.4 targets even ignoring the fraction - is that intended?",
      "created_at": "2022-12-02T22:29:22Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038600759",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038600759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 329,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039262264",
      "pull_request_review_id": 1204047515,
      "id": 1039262264,
      "node_id": "PRRC_kwDOABII58498eI4",
      "diff_hunk": "@@ -121,26 +201,181 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                     \"local_set_size=%i\\n\",\n+                         peer_id, local_set_size);\n+\n+                // In future, Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 234,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": 1038404614,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This comment was outdated, i think it's not needed here at all... deleting for now.",
      "created_at": "2022-12-05T07:55:53Z",
      "updated_at": "2022-12-05T07:55:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039262264",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039262264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039265857",
      "pull_request_review_id": 1204052484,
      "id": 1039265857,
      "node_id": "PRRC_kwDOABII58498fBB",
      "diff_hunk": "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "path": "src/node/txreconciliation.cpp",
      "position": 51,
      "original_position": 58,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": 1038421101,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This would largely complicate the code I think.... Policy check stuff should be moved out of `net_processing.cpp`.\r\nYeah, I see your concern (although I tested Erlay in mainnet and it was ok), let's see if other reviewers think it's needed now.",
      "created_at": "2022-12-05T08:00:28Z",
      "updated_at": "2022-12-05T08:00:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039265857",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039265857"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 89,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039272601",
      "pull_request_review_id": 1204063482,
      "id": 1039272601,
      "node_id": "PRRC_kwDOABII58498gqZ",
      "diff_hunk": "@@ -124,6 +132,33 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "99acf14cf4aa66167f826de6b1d6044c5cc3dc85",
      "in_reply_to_id": 1038465392,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The removal is currently per-tx (not batched), so it would make the logs really annoying... Which raises another question: should I refactor it to make it batched where possible (on hearing INV batch from the given peer)?",
      "created_at": "2022-12-05T08:09:50Z",
      "updated_at": "2022-12-05T08:09:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039272601",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039272601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039308165",
      "pull_request_review_id": 1204115844,
      "id": 1039308165,
      "node_id": "PRRC_kwDOABII58498pWF",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 86,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": 1038600759,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You are right, it is broken. At least it was documented well enough you found the issue :)\r\n",
      "created_at": "2022-12-05T08:47:43Z",
      "updated_at": "2022-12-05T08:47:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039308165",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039308165"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 329,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041146278",
      "pull_request_review_id": 1206848088,
      "id": 1041146278,
      "node_id": "PRRC_kwDOABII584-DqGm",
      "diff_hunk": "@@ -121,26 +201,184 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 147,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I would suggest not to have an assert here. Generally (imo) we should only add asserts when crashing the node is better than continuing. In this case simply adding a `if(!IsPeerRegistered()) return;` is better than crashing if the user of the API makes a mistake. You would be treating non-existence of the peer the same as the peer having an empty set (i.e. nothing is removed as it didn't exist in the first place).\r\n\r\nAdditionally, the way you are using this API right now is not generally safe.\r\n```c++\r\nif (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pfrom.GetId())) {\r\n    m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), wtxid);\r\n}\r\n```\r\n\r\nThe peer could be de-registered from the tracker in between the `IsPeerRegistered` and `TryRemovingFromSet` calls causing the node to crash for no good reason. This is only safe right now because `cs_main` is held here as well as when a peer is forgotten from the tracker. Since the tracker has its own mutex it should not rely on another mutex such as `cs_main`.",
      "created_at": "2022-12-06T15:48:37Z",
      "updated_at": "2022-12-06T16:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041146278",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041146278"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041165539",
      "pull_request_review_id": 1206848088,
      "id": 1041165539,
      "node_id": "PRRC_kwDOABII584-Duzj",
      "diff_hunk": "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it would make sense to move this block to its own function. This entire block for the tx announcement logic in SendMessages is already quite big.\r\n\r\nMaybe this can even move to the tracker?",
      "created_at": "2022-12-06T16:04:46Z",
      "updated_at": "2022-12-06T16:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041165539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041165539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5724,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041171241",
      "pull_request_review_id": 1206848088,
      "id": 1041171241,
      "node_id": "PRRC_kwDOABII584-DwMp",
      "diff_hunk": "@@ -121,26 +201,184 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 130,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same thing here about the assert.",
      "created_at": "2022-12-06T16:09:35Z",
      "updated_at": "2022-12-06T16:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041171241",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041171241"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041434849",
      "pull_request_review_id": 1207285454,
      "id": 1041434849,
      "node_id": "PRRC_kwDOABII584-Ewjh",
      "diff_hunk": "@@ -183,6 +203,72 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ffbb2b814e82284c7c77c5a5b23058cbc7c0149c",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "One more conceptual question for the flooding algorithm:\r\nDoesn't this still leak internal order by flooding preferentially to adjacent nodes in `eligible_peers` if `flood_targets > 1`?\r\n\r\nWould it be a simpler alternative to have a deterministic randomizer that takes the wtxid, and then pick `flood_targets` random peers (and pick a last one only with an appropiate probability if `flood_targets` is not an integer), in the same way that way `PeerManagerImpl::RelayAddress()` picks 2 peers for addr relay? (but without the 24h reset happening there)",
      "created_at": "2022-12-06T20:38:07Z",
      "updated_at": "2022-12-06T23:44:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041434849",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041434849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 332,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041516794",
      "pull_request_review_id": 1207285454,
      "id": 1041516794,
      "node_id": "PRRC_kwDOABII584-FEj6",
      "diff_hunk": "@@ -5678,7 +5678,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "869c6824235ff2af09d24b13cfab9a6cabd52b00",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Trying to understand commit 869c6824235ff2af09d24b13cfab9a6cabd52b00: \"It's possible that a parent will be scheduled to relay same time as child, but a child arrives earlier. \"\r\nIs this only possible with reconciliation? The previous commit tries to make sure that the child is also scheduled for recon, if the parent was - so can it only happen in the case where the recon set is at max capacity?\r\n\r\nAlso, since now twice as many entries will be saved in `m_recently_announced_invs`, does it need a larger capacity?",
      "created_at": "2022-12-06T22:16:45Z",
      "updated_at": "2022-12-06T23:44:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041516794",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041516794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5719,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041544419",
      "pull_request_review_id": 1207285454,
      "id": 1041544419,
      "node_id": "PRRC_kwDOABII584-FLTj",
      "diff_hunk": "@@ -147,12 +147,29 @@ static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL{30s};\n /** Delay between rotating the peers we relay a particular address to */\n static constexpr auto ROTATE_ADDR_RELAY_DEST_INTERVAL{24h};\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is chosen according the following\n+ *  considerations:\n+ *  1. Reconciliation. When the transaction is reconciled, this delay is applied to adding to\n+ *     reconciliation sets, not actual reconciliation (less frequent). That should happen rather\n+ *     fast, so that sets are in sync and reconciliation is efficient. At the same time, not too\n+ *     fast to avoid privacy leaks (e.g., infer connections via set probing).\n+ *  2. Low-fanout. In rare cases when the reconciling peer is chosen for low-fanout\n+ *     flooding, it will apply to the actual broadcast. Then, regular trickle considerations apply,\n+ *     but since this is a rare occasion, the following risks are much lower:\n+ *     2a) announcing both ways simultaneously (inefficiency);\n+ *     2b) inference based on the announced transactions (privacy leak).\n+ *     That's why it's ok to make this delay low as well, and lower delay is generally good to\n+ *     facilitate good transaction relay speed when slow reconciliations prevail. */\n static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL{5s};\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{2s};",
      "path": "src/net_processing.cpp",
      "position": 20,
      "original_position": 20,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "9f64cfe63e3b833e0f9faf17004cf51c4c925aec",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Commit 9f64cfe63e3b833e0f9faf17004cf51c4c925aec:\r\n\"Note that for privacy reasons the ratio between inbound and outbound\r\ndelays matter much more than the actual delays. That ratio is preserved\r\nhere, so it is not a privacy degradation.\"\r\nThe ratio is not exactly preserved, the old one was 5s/2s, now it's 2s/1s.",
      "created_at": "2022-12-06T22:45:45Z",
      "updated_at": "2022-12-06T23:44:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041544419",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041544419"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 156,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041586275",
      "pull_request_review_id": 1207285454,
      "id": 1041586275,
      "node_id": "PRRC_kwDOABII584-FVhj",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it might be possible for a peer to abuse this logic and prevent us from reconciling with other peers: If an attacker sends a `SENDTXRCNCL` but stalls the `VERACK`, they would be registered and added to `m_queue` - but `SendMessages()` will never get to the part where `REQTXRCNCL` is sent for this peer because we abort early [here](https://github.com/bitcoin/bitcoin/blob/0596aa40f77a630d8a21035856fa5fd6838b292e/src/net_processing.cpp#L5367) before hanshake completion. Therefore, once that peer is in the front of the queue, it won't get cleared and prevents us from reconciling with other peers while connected (up to `DEFAULT_PEER_CONNECT_TIMEOUT = 60` seconds).",
      "created_at": "2022-12-06T23:40:07Z",
      "updated_at": "2022-12-06T23:44:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041586275",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041586275"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042310934",
      "pull_request_review_id": 1208575387,
      "id": 1042310934,
      "node_id": "PRRC_kwDOABII584-IGcW",
      "diff_hunk": "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "path": "src/node/txreconciliation.cpp",
      "position": 51,
      "original_position": 58,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": 1038421101,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To clarify, we're considering the scenario in which our peer's fee filter changes between adding tx to `txs_to_reconcile` and sending the `inv` after reconciliation? Given that `RECON_REQUEST_INTERVAL` is 8sec and `AVG_FEEFILTER_BROADCAST_INTERVAL` is 10min, I don't think this is too much of a concern (at least for this PR)?",
      "created_at": "2022-12-07T14:58:09Z",
      "updated_at": "2022-12-07T14:58:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042310934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042310934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 89,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042366525",
      "pull_request_review_id": 1208638733,
      "id": 1042366525,
      "node_id": "PRRC_kwDOABII584-IUA9",
      "diff_hunk": "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1041165539,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree, though it wouldn't make sense to have txreconciliation module depend on mempool. Would probably recommend grabbing the txiter ahead of time and passing in the parent wtxids.",
      "created_at": "2022-12-07T15:39:47Z",
      "updated_at": "2022-12-07T16:31:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042366525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042366525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5724,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042385456",
      "pull_request_review_id": 1208638733,
      "id": 1042385456,
      "node_id": "PRRC_kwDOABII584-IYow",
      "diff_hunk": "@@ -17,6 +19,41 @@ namespace {\n const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n \n+/**\n+ * Announce transactions via full wtxid to a limited number of inbound and outbound peers.\n+ * Justification for these values are provided here:\n+ * https://github.com/naumenkogs/txrelaysim/issues/7#issuecomment-902165806 */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS = 1;\n+/**\n+ * If there's a chance a transaction is not streamlined along the first couple hops, it would take\n+ *  very long to relay.\n+ */\n+static_assert(OUTBOUND_FANOUT_DESTINATIONS >= 1);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in ffbb2b814e82284c7c77c5a5b23058cbc7c0149c:\r\n\r\nBased on this, is the \"The requirements to this algorithm is the following: 1. Every transaction should be assigned to *some* peer.\" a hard requirement? If so, it seems the logic in f0685a1781 net_processing if recon parent -> recon child seems to break this, since you might have chosen just 1 peer to flood the child to, but then switch to recon because you're reconing the parent with that peer. It doesn't seem like `ShouldFloodTo` uses any state about whether we've chosen other peers for flooding, so we might end up not flooding the tx to anybody? Am I missing something / is this okay?",
      "created_at": "2022-12-07T15:54:24Z",
      "updated_at": "2022-12-07T16:31:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042385456",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042385456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042412529",
      "pull_request_review_id": 1208638733,
      "id": 1042412529,
      "node_id": "PRRC_kwDOABII584-IfPx",
      "diff_hunk": "@@ -5703,11 +5835,28 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    if (!txs_to_reconcile.empty()) {\n+                        m_txreconciliation->AddToSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload() && m_txreconciliation) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 220,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "IIUC with this PR we'll request reconciliation with each other but since no `NetMsgType::REQTXRCNCL` handling is added, we ignore the request. That's fine, but should we also have the logic for falling back to flooding the wtxids in the reconciliation set when it gets full / after a timeout?",
      "created_at": "2022-12-07T16:16:45Z",
      "updated_at": "2022-12-07T16:31:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042412529",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042412529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5851,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413082",
      "pull_request_review_id": 1208726536,
      "id": 1042413082,
      "node_id": "PRRC_kwDOABII584-IfYa",
      "diff_hunk": "@@ -76,6 +76,35 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 9,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be useful if this returned the number of added wtxids.",
      "created_at": "2022-12-07T16:17:17Z",
      "updated_at": "2022-12-07T16:28:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042413082",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413751",
      "pull_request_review_id": 1208726536,
      "id": 1042413751,
      "node_id": "PRRC_kwDOABII584-Ifi3",
      "diff_hunk": "@@ -76,6 +76,35 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove);",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 16,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be useful if this returned whether or not the wtxid was removed.",
      "created_at": "2022-12-07T16:17:50Z",
      "updated_at": "2022-12-07T16:28:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042413751",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042417507",
      "pull_request_review_id": 1208726536,
      "id": 1042417507,
      "node_id": "PRRC_kwDOABII584-Igdj",
      "diff_hunk": "@@ -76,6 +76,35 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If it's time to request a reconciliation from the peer, this function will return\n+     * the details of our local state, which should be communicated to the peer so that they better\n+     * know what we need:\n+     * - size of our reconciliation set for the peer\n+     * - our q-coefficient with the peer, formatted to be transmitted as integer value\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id);",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 26,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\r\n```suggestion\r\n    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id, std::chrono::microsecond now);\r\n```\r\n\r\nPassing in the time here would be nice for testing. \r\n* We only have one global mock time currently (globals are always a bit annoying when writing unit/fuzz tests, as you have to reset state after each test)\r\n* The current global mock time is only accurate in intervals of seconds",
      "created_at": "2022-12-07T16:21:06Z",
      "updated_at": "2022-12-07T16:28:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042417507",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042417507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 100,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042420561",
      "pull_request_review_id": 1208726536,
      "id": 1042420561,
      "node_id": "PRRC_kwDOABII584-IhNR",
      "diff_hunk": "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1041165539,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Adding to this:\r\n\r\nAfaict it's impossible for our fuzzers to exercise this code at the moment. Encapsulating this logic within the TxReconciliationTracker would make that possible.",
      "created_at": "2022-12-07T16:23:45Z",
      "updated_at": "2022-12-07T16:28:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042420561",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042420561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5724,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042464406",
      "pull_request_review_id": 1208800680,
      "id": 1042464406,
      "node_id": "PRRC_kwDOABII584-Ir6W",
      "diff_hunk": "@@ -121,26 +201,184 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::TXRECONCILIATION, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                                  \"local_set_size=%i\\n\",\n+                         peer_id, local_set_size);\n+\n+                // In future, Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 240,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This throws a `std::bad_variant_access` for peers that aren't fully registered yet (found by the fuzzer).\r\n\r\nMaybe create an internal helper method that only iterates through all fully registered peers/states to avoid this entirely?",
      "created_at": "2022-12-07T17:02:17Z",
      "updated_at": "2022-12-07T17:02:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042464406",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042464406"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044199932",
      "pull_request_review_id": 1211290010,
      "id": 1044199932,
      "node_id": "PRRC_kwDOABII584-PTn8",
      "diff_hunk": "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "path": "src/node/txreconciliation.cpp",
      "position": 51,
      "original_position": 58,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": 1038421101,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I thought this could happen even without explicit fee filter changes, but rather the following:\r\n1. A transaction marginally passed the given fee filter.\r\n2. In 8 seconds when it's time to send, it doesn't pass the filter, but is sent anyway.",
      "created_at": "2022-12-09T08:26:21Z",
      "updated_at": "2022-12-09T08:26:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1044199932",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044199932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 89,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044229932",
      "pull_request_review_id": 1211334700,
      "id": 1044229932,
      "node_id": "PRRC_kwDOABII584-Pa8s",
      "diff_hunk": "@@ -183,6 +203,72 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ffbb2b814e82284c7c77c5a5b23058cbc7c0149c",
      "in_reply_to_id": 1041434849,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Doesn't this still leak internal order by flooding preferentially to adjacent nodes in eligible_peers if flood_targets > 1?\r\n\r\nGood point. Yes. I should think about the fix.\r\n\r\n>Would it be a simpler alternative to have a deterministic randomizer that takes the wtxid, and then pick flood_targets random peers (and pick a last one only with an appropiate probability if flood_targets is not an integer), in the same way that way PeerManagerImpl::RelayAddress() picks 2 peers for addr relay? (but without the 24h reset happening there)\r\n\r\nI'll try.",
      "created_at": "2022-12-09T09:04:17Z",
      "updated_at": "2022-12-09T09:04:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1044229932",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044229932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 332,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045740922",
      "pull_request_review_id": 1213394979,
      "id": 1045740922,
      "node_id": "PRRC_kwDOABII584-VL16",
      "diff_hunk": "@@ -5703,11 +5835,28 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    if (!txs_to_reconcile.empty()) {\n+                        m_txreconciliation->AddToSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload() && m_txreconciliation) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 220,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1042412529,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We're talking about someone enabling the `-txreconciliation=1` CLI flag... Why do you think this would be useful for such tester?",
      "created_at": "2022-12-12T12:04:33Z",
      "updated_at": "2022-12-12T12:04:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1045740922",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045740922"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5851,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045802684",
      "pull_request_review_id": 1213502717,
      "id": 1045802684,
      "node_id": "PRRC_kwDOABII584-Va68",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't see that yet. No matter what happens to this peer, it will be moved to the end of the queue, and the next peer will be requested in couple seconds.",
      "created_at": "2022-12-12T13:02:55Z",
      "updated_at": "2022-12-12T13:02:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1045802684",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045802684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045978253",
      "pull_request_review_id": 1213803271,
      "id": 1045978253,
      "node_id": "PRRC_kwDOABII584-WFyN",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I don't see that yet. No matter what happens to this peer, it will be moved to the end of the queue, and the next peer will be requested in couple seconds.\r\n\r\nI was thinking of the following:\r\n1.) Peer X gets connected, sends `SENDTXRCNCL`, RegisterPeer puts it into the back of the queue.\r\n2.) X doesn't send `VERACK`\r\n3.) We do regular reconciliation requests with all other peers of the queue, so now X is in the front of it\r\n4.) Since X is not succesfully connected, `SendMessages` aborts early and we don't reach the code where `REQTXRCNCL` is processed\r\n5.) X won't be removed from the front of the queue,  and we don't request reconciliations from any other peer because of that.\r\n\r\n\r\n",
      "created_at": "2022-12-12T15:32:01Z",
      "updated_at": "2022-12-12T15:32:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1045978253",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045978253"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045980252",
      "pull_request_review_id": 1213806803,
      "id": 1045980252,
      "node_id": "PRRC_kwDOABII584-WGRc",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ahhh good point, should be addressed indeed.",
      "created_at": "2022-12-12T15:33:43Z",
      "updated_at": "2022-12-12T15:33:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1045980252",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045980252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1046946611",
      "pull_request_review_id": 1215173615,
      "id": 1046946611,
      "node_id": "PRRC_kwDOABII584-ZyMz",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is a dangerous piece of code... This could also happen if the peer enters IBD again or something.",
      "created_at": "2022-12-13T10:24:05Z",
      "updated_at": "2022-12-13T10:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1046946611",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1046946611"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1047291134",
      "pull_request_review_id": 1215685753,
      "id": 1047291134,
      "node_id": "PRRC_kwDOABII584-bGT-",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah - just to bring this alternative up, if we uncoupled peers and had every peer on its separate timer (instead of a queue), would that lead to major efficiency losses?",
      "created_at": "2022-12-13T15:13:17Z",
      "updated_at": "2022-12-13T15:13:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1047291134",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1047291134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1047538690",
      "pull_request_review_id": 1216141754,
      "id": 1047538690,
      "node_id": "PRRC_kwDOABII584-cCwC",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I started with having two separate calls — one for queue management, the other for sending REQTXRCNCL.\r\nI'll submit that shortly. Then I'll think about your idea.",
      "created_at": "2022-12-13T18:04:24Z",
      "updated_at": "2022-12-13T18:04:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1047538690",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1047538690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1051969326",
      "pull_request_review_id": 1222540790,
      "id": 1051969326,
      "node_id": "PRRC_kwDOABII584-s8cu",
      "diff_hunk": "@@ -5678,7 +5678,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "869c6824235ff2af09d24b13cfab9a6cabd52b00",
      "in_reply_to_id": 1041516794,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">Is this only possible with reconciliation? \r\n\r\nYes I think so\r\n\r\n>so can it only happen in the case where the recon set is at max capacity?\r\n\r\nNot only that. The order is lost when set difference is decoded. The decoding party only knows wtxids and will request them in random order, via a regular INV. The ordering could be handled on the responder side, but I'm afraid it would be hard and messy. I can try though.\r\n\r\nThe logic in the last commit is not super-reliable either, so I think it's better to have belt-and-suspenders like this.\r\n\r\nUnless they break something else of course.\r\n\r\n>Also, since now twice as many entries will be saved in m_recently_announced_invs, does it need a larger capacity?\r\n\r\ngood point.\r\n",
      "created_at": "2022-12-19T09:18:01Z",
      "updated_at": "2022-12-19T09:18:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1051969326",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1051969326"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5719,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052002193",
      "pull_request_review_id": 1222589735,
      "id": 1052002193,
      "node_id": "PRRC_kwDOABII584-tEeR",
      "diff_hunk": "@@ -17,6 +19,41 @@ namespace {\n const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n \n+/**\n+ * Announce transactions via full wtxid to a limited number of inbound and outbound peers.\n+ * Justification for these values are provided here:\n+ * https://github.com/naumenkogs/txrelaysim/issues/7#issuecomment-902165806 */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS = 1;\n+/**\n+ * If there's a chance a transaction is not streamlined along the first couple hops, it would take\n+ *  very long to relay.\n+ */\n+static_assert(OUTBOUND_FANOUT_DESTINATIONS >= 1);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1042385456,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">Every transaction should be assigned to some peer.\" a hard requirement?\r\n\r\nI meant to relay in *some way* (either flooded or reconciled), so that the transaction doesn't get stuck. That's it.\r\nThat resolves your question right? Fixing code comment for now.",
      "created_at": "2022-12-19T09:49:43Z",
      "updated_at": "2022-12-19T09:49:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052002193",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052002193"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052114025",
      "pull_request_review_id": 1222752080,
      "id": 1052114025,
      "node_id": "PRRC_kwDOABII584-tfxp",
      "diff_hunk": "@@ -183,6 +203,72 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "ffbb2b814e82284c7c77c5a5b23058cbc7c0149c",
      "in_reply_to_id": 1041434849,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could you review if 02e480d174e4edb1ffedb643fc454ad9b77e9001 is any better? Looking at the following commit may add some useful context 15006207099882aa73c18738e5013bf0c313be93",
      "created_at": "2022-12-19T11:46:54Z",
      "updated_at": "2022-12-19T11:46:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052114025",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052114025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 332,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052114496",
      "pull_request_review_id": 1222752746,
      "id": 1052114496,
      "node_id": "PRRC_kwDOABII584-tf5A",
      "diff_hunk": "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1041165539,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could your review 15006207099882aa73c18738e5013bf0c313be93 separately? If that's roughly what you're asked for and you are satisfied, I will squash into the original commit.",
      "created_at": "2022-12-19T11:47:29Z",
      "updated_at": "2022-12-19T11:47:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052114496",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052114496"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5724,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052392630",
      "pull_request_review_id": 1223170187,
      "id": 1052392630,
      "node_id": "PRRC_kwDOABII584-ujy2",
      "diff_hunk": "@@ -5336,6 +5365,16 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     if (!peer) return false;\n     const Consensus::Params& consensusParams = m_chainparams.GetConsensus();\n \n+    const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+    // We must look into the reconciliation queue first. Since the queue applies to all peers,\n+    // this peer might block other reconciliation if we don't make this call regularly and\n+    // unconditionally.\n+    bool reconcile = false;\n+    if (m_txreconciliation) {\n+        // reconcile = m_txreconciliation->IsPeerNextToReconcileWith(pto->GetId(), current_time);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 103,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "e894824cea7bbb835c762fc57b9523f76c51339f\r\ncommented code here",
      "created_at": "2022-12-19T16:16:07Z",
      "updated_at": "2022-12-19T18:36:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052392630",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052392630"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052393745",
      "pull_request_review_id": 1223170187,
      "id": 1052393745,
      "node_id": "PRRC_kwDOABII584-ukER",
      "diff_hunk": "@@ -5703,11 +5788,30 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    if (!txs_to_reconcile.empty()) {\n+                        m_txreconciliation->AddToSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n+                if (reconcile) {\n+                    const auto reconciliation_request_params = m_txreconciliation->InitiateReconciliationRequest(pto->GetId());\n+                    if (reconciliation_request_params) {\n+                        const auto [local_set_size, local_q_formatted] = (*reconciliation_request_params);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 220,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "e894824cea7bbb835c762fc57b9523f76c51339f no need for parentheses",
      "created_at": "2022-12-19T16:17:14Z",
      "updated_at": "2022-12-19T18:36:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052393745",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052393745"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5808,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052395138",
      "pull_request_review_id": 1223170187,
      "id": 1052395138,
      "node_id": "PRRC_kwDOABII584-ukaC",
      "diff_hunk": "@@ -124,23 +204,273 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddPeerToQueue(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        auto recon_state = m_states.find(peer_id);\n+\n+        if (recon_state == m_states.end()) return;\n+\n+        if (!std::holds_alternative<TxReconciliationState>(recon_state->second)) {\n+            return;\n+        }\n+\n+        m_queue.push_back(peer_id);\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Added peer=%d to the queue\\n\",\n+                      peer_id);\n+    }\n+\n+    size_t AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return 0;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+        return added;\n+    }\n+\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.erase(wtxid_to_remove) > 0;\n+    }\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        if (m_queue.empty()) return false;\n+\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_next_recon_request <= now && m_queue.front() == peer_id) {\n+            Assume(recon_state.m_we_initiate);\n+            m_queue.pop_front();\n+            m_queue.push_back(peer_id);\n+\n+            // If the phase is not NONE, the peer hasn't responded to the previous reconciliation.\n+            // A laggy peer should not affect other peers.\n+            //\n+            // This doesn't prevent from a malicious peer gaming this by staying in this state\n+            // all the time somehow.\n+            if (recon_state.m_phase_init_by_us == Phase::NONE) UpdateNextReconRequest(now);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> InitiateReconciliationRequest(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+        recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+        size_t local_set_size = recon_state.m_local_set.size();\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                          \"local_set_size=%i\\n\",\n+                 peer_id, local_set_size);\n+\n+        // In future, Q could be recomputed after every reconciliation based on the\n+        // set differences. For now, it provides good enough results without recompute\n+        // complexity, but we communicate it here to allow backward compatibility if\n+        // the value is changed or made dynamic.\n+        return std::make_pair(local_set_size, Q * Q_PRECISION);\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool IsAlreadyInPeerSet(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        return recon_state.m_local_set.count(wtxid) > 0;\n+    }\n+\n+    std::vector<NodeId> GetFloodTargets(const uint256& wtxid, CSipHasher deterministic_randomizer,\n+                                        size_t all_inbound_peers, size_t already_flooded_to_outbound) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        auto try_flood_candidate = [](CSipHasher deterministic_randomizer, std::vector<std::pair<uint64_t, NodeId>> best_peers,\n+                                      const size_t limit, const std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> candidate) {\n+            const auto& cur_state = std::get<TxReconciliationState>(candidate.second);\n+            uint64_t hash_key = std::min<uint64_t>(deterministic_randomizer.Write(cur_state.m_k0).Finalize(), 1);\n+\n+            for (size_t i = 0; i < limit; ++i) {\n+                if (hash_key > best_peers[i].first) {\n+                    std::copy(best_peers.begin() + i, best_peers.begin() + limit - 1, best_peers.begin() + i + 1);\n+                    best_peers[i] = std::make_pair(hash_key, candidate.first);\n+                    break;\n+                }\n+            }\n+        };\n+\n+        const double inbound_destinations = all_inbound_peers * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        const size_t outbound_destinations = std::min<int>(0, OUTBOUND_FANOUT_DESTINATIONS - already_flooded_to_outbound);\n+\n+        std::vector<std::pair<uint64_t, NodeId>> best_inbound_peers(size_t(inbound_destinations) + 1, std::make_pair(0, 0));\n+        std::vector<std::pair<uint64_t, NodeId>> best_outbound_peers(outbound_destinations, std::make_pair(0, 0));\n+        ;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 292,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "02e480d174e4edb1ffedb643fc454ad9b77e9001\r\n```suggestion\r\n```",
      "created_at": "2022-12-19T16:18:42Z",
      "updated_at": "2022-12-19T18:36:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052395138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052395138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052397812",
      "pull_request_review_id": 1223170187,
      "id": 1052397812,
      "node_id": "PRRC_kwDOABII584-ulD0",
      "diff_hunk": "@@ -76,6 +76,44 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /** TODO */",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 4,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "e894824cea7bbb835c762fc57b9523f76c51339f Forgotten todo?",
      "created_at": "2022-12-19T16:21:13Z",
      "updated_at": "2022-12-19T18:36:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052397812",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052397812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052398233",
      "pull_request_review_id": 1223170187,
      "id": 1052398233,
      "node_id": "PRRC_kwDOABII584-ulKZ",
      "diff_hunk": "@@ -124,23 +204,273 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddPeerToQueue(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        auto recon_state = m_states.find(peer_id);\n+\n+        if (recon_state == m_states.end()) return;\n+\n+        if (!std::holds_alternative<TxReconciliationState>(recon_state->second)) {\n+            return;\n+        }\n+\n+        m_queue.push_back(peer_id);\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Added peer=%d to the queue\\n\",\n+                      peer_id);\n+    }\n+\n+    size_t AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return 0;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+        return added;\n+    }\n+\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.erase(wtxid_to_remove) > 0;\n+    }\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        if (m_queue.empty()) return false;\n+\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_next_recon_request <= now && m_queue.front() == peer_id) {\n+            Assume(recon_state.m_we_initiate);\n+            m_queue.pop_front();\n+            m_queue.push_back(peer_id);\n+\n+            // If the phase is not NONE, the peer hasn't responded to the previous reconciliation.\n+            // A laggy peer should not affect other peers.\n+            //\n+            // This doesn't prevent from a malicious peer gaming this by staying in this state\n+            // all the time somehow.\n+            if (recon_state.m_phase_init_by_us == Phase::NONE) UpdateNextReconRequest(now);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> InitiateReconciliationRequest(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+        recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+        size_t local_set_size = recon_state.m_local_set.size();\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                          \"local_set_size=%i\\n\",\n+                 peer_id, local_set_size);\n+\n+        // In future, Q could be recomputed after every reconciliation based on the\n+        // set differences. For now, it provides good enough results without recompute\n+        // complexity, but we communicate it here to allow backward compatibility if\n+        // the value is changed or made dynamic.\n+        return std::make_pair(local_set_size, Q * Q_PRECISION);\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool IsAlreadyInPeerSet(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        return recon_state.m_local_set.count(wtxid) > 0;\n+    }\n+\n+    std::vector<NodeId> GetFloodTargets(const uint256& wtxid, CSipHasher deterministic_randomizer,\n+                                        size_t all_inbound_peers, size_t already_flooded_to_outbound) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        auto try_flood_candidate = [](CSipHasher deterministic_randomizer, std::vector<std::pair<uint64_t, NodeId>> best_peers,\n+                                      const size_t limit, const std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> candidate) {\n+            const auto& cur_state = std::get<TxReconciliationState>(candidate.second);\n+            uint64_t hash_key = std::min<uint64_t>(deterministic_randomizer.Write(cur_state.m_k0).Finalize(), 1);\n+\n+            for (size_t i = 0; i < limit; ++i) {\n+                if (hash_key > best_peers[i].first) {\n+                    std::copy(best_peers.begin() + i, best_peers.begin() + limit - 1, best_peers.begin() + i + 1);\n+                    best_peers[i] = std::make_pair(hash_key, candidate.first);\n+                    break;\n+                }\n+            }\n+        };\n+\n+        const double inbound_destinations = all_inbound_peers * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        const size_t outbound_destinations = std::min<int>(0, OUTBOUND_FANOUT_DESTINATIONS - already_flooded_to_outbound);\n+\n+        std::vector<std::pair<uint64_t, NodeId>> best_inbound_peers(size_t(inbound_destinations) + 1, std::make_pair(0, 0));\n+        std::vector<std::pair<uint64_t, NodeId>> best_outbound_peers(outbound_destinations, std::make_pair(0, 0));\n+        ;\n+\n+        for (auto indexed_state : m_states) {\n+            const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+            if (cur_state.m_we_initiate == true) { // corresponds to connection direction.\n+                try_flood_candidate(deterministic_randomizer, best_outbound_peers, outbound_destinations, indexed_state);\n+            } else {\n+                try_flood_candidate(deterministic_randomizer, best_inbound_peers, inbound_destinations, indexed_state);\n+            }\n+        }\n+\n+        // For inbound peers, it's possible that the last peer was added optimistically,\n+        // so we have to roll the dice now.\n+        FastRandomContext insecure_rand;\n+        if (insecure_rand.randrange(100) > (inbound_destinations - size_t(inbound_destinations)) * 100) {\n+            best_inbound_peers.pop_back();\n+        }\n+\n+\n+        best_inbound_peers.insert(best_inbound_peers.end(), best_outbound_peers.begin(), best_outbound_peers.end());\n+        std::vector<NodeId> result;\n+        std::for_each(best_inbound_peers.begin(), best_inbound_peers.end(),\n+                      [&result](auto best_peer) {\n+                          if (best_peer.first != 0) result.push_back(best_peer.second);\n+                      });\n+        return result;\n+    }\n+\n+    // For a given peer, see whether the transaction should be flooded\n+    bool ShouldFloodTo(const uint256& wtxid, const std::vector<uint256> parents_wtxids,\n+                       const std::vector<uint256> wtxids_to_reconcile, CSipHasher deterministic_randomizer, NodeId peer_id,",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 322,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "15006207099882aa73c18738e5013bf0c313be93\r\nShould maybe pass by const ref for `parents_wtxids` and `wtxids_to_reconcile`, same for `TxReconciliationTracker::ShouldFloodTo`.",
      "created_at": "2022-12-19T16:21:40Z",
      "updated_at": "2022-12-19T18:36:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052398233",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052398233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": 404,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 405,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114818128",
      "pull_request_review_id": 1309970444,
      "id": 1114818128,
      "node_id": "PRRC_kwDOABII585CcsZQ",
      "diff_hunk": "@@ -3699,6 +3720,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 if (!fAlreadyHave && !m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                     AddTxAnnouncement(pfrom, gtxid, current_time);\n                 }\n+                if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pfrom.GetId()) && gtxid.IsWtxid()) {\n+                    m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), gtxid.GetHash());",
      "path": "src/net_processing.cpp",
      "position": 46,
      "original_position": 57,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Don't know if transaction received through BIP152's `BLOCKTXN` should be `TryRemovingFromSet()`.",
      "created_at": "2023-02-22T18:53:50Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114818128",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114818128"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3834,
      "original_line": 3834,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114821225",
      "pull_request_review_id": 1309970444,
      "id": 1114821225,
      "node_id": "PRRC_kwDOABII585CctJp",
      "diff_hunk": "@@ -145,12 +147,29 @@ static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL{30s};\n /** Delay between rotating the peers we relay a particular address to */\n static constexpr auto ROTATE_ADDR_RELAY_DEST_INTERVAL{24h};\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is chosen according the following\n+ *  considerations:\n+ *  1. Reconciliation. When the transaction is reconciled, this delay is applied to adding to\n+ *     reconciliation sets, not actual reconciliation (less frequent). That should happen rather\n+ *     fast, so that sets are in sync and reconciliation is efficient. At the same time, not too\n+ *     fast to avoid privacy leaks (e.g., infer connections via set probing).",
      "path": "src/net_processing.cpp",
      "position": 11,
      "original_position": 22,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the \"fast\" (i.e 2s)  has been reasoned out in the bip or the paper, the section can be referenced too, I think. ",
      "created_at": "2023-02-22T18:55:52Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114821225",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114821225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114835166",
      "pull_request_review_id": 1309970444,
      "id": 1114835166,
      "node_id": "PRRC_kwDOABII585Ccwje",
      "diff_hunk": "@@ -76,6 +76,36 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * Returns the number of added transactions (already present transactions won't be added).\n+     *\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    size_t AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     * Returns whether the wtxid was removed.\n+     *\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove);\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now);",
      "path": "src/node/txreconciliation.h",
      "position": 26,
      "original_position": 22,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can add a comment about what `TxReconciliationTracker::IsPeerNextToReconcileWith()` does, like assumptions on peers queue and phase we're in.",
      "created_at": "2023-02-22T19:04:02Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114835166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114835166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 99,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114866248",
      "pull_request_review_id": 1309970444,
      "id": 1114866248,
      "node_id": "PRRC_kwDOABII585Cc4JI",
      "diff_hunk": "@@ -99,7 +99,9 @@ static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n /** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n  *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n  *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n- *  the actual transaction (from any peer) in response to requests for them. */\n+ *  the actual transaction (from any peer) in response to requests for them.\n+ *  Also limits a maximum number of elements to store in the reconciliation set.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 6,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure this new comment still holds with the introduction of `MAX_SET_SIZE=3000`. ",
      "created_at": "2023-02-22T19:35:20Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114866248",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114866248"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114877866",
      "pull_request_review_id": 1309970444,
      "id": 1114877866,
      "node_id": "PRRC_kwDOABII585Cc6-q",
      "diff_hunk": "@@ -121,26 +194,233 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        if (!is_peer_inbound) m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    size_t AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return 0;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 128,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Correct the max set size (`MAX_SET_SIZE`) is enforced by `ShouldFanoutTo()` which happens before the call to `AddToSet()`, don't know if it could be more conservative with another check here. ",
      "created_at": "2023-02-22T19:47:25Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114877866",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114877866"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114886751",
      "pull_request_review_id": 1310071886,
      "id": 1114886751,
      "node_id": "PRRC_kwDOABII585Cc9Jf",
      "diff_hunk": "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 334,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998588937,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Well we might have some small discrepancy in old code, doesn't seem to matter here.",
      "created_at": "2023-02-22T19:56:19Z",
      "updated_at": "2023-02-22T19:56:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114886751",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114886751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114888417",
      "pull_request_review_id": 1310074223,
      "id": 1114888417,
      "node_id": "PRRC_kwDOABII585Cc9jh",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "path": "src/node/txreconciliation.cpp",
      "position": 32,
      "original_position": 36,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998640600,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it's accurate with the current comment of warning about less frequent reconciliations introducing high transaction relay latency. Like some trade-off between bandwidth and 0confs UX to be aware, I would say.",
      "created_at": "2023-02-22T19:58:03Z",
      "updated_at": "2023-02-22T19:58:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114888417",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114888417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 40,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114890070",
      "pull_request_review_id": 1310077069,
      "id": 1114890070,
      "node_id": "PRRC_kwDOABII585Cc99W",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "path": "src/node/txreconciliation.cpp",
      "position": 94,
      "original_position": 136,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998653688,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Gotcha, just means the malicious outbound peer will never move forward its own reconciliation. ",
      "created_at": "2023-02-22T19:59:29Z",
      "updated_at": "2023-02-22T19:59:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114890070",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114890070"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 140,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1115299326",
      "pull_request_review_id": 1310699173,
      "id": 1115299326,
      "node_id": "PRRC_kwDOABII585Ceh3-",
      "diff_hunk": "@@ -3699,6 +3720,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 if (!fAlreadyHave && !m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                     AddTxAnnouncement(pfrom, gtxid, current_time);\n                 }\n+                if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pfrom.GetId()) && gtxid.IsWtxid()) {\n+                    m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), gtxid.GetHash());",
      "path": "src/net_processing.cpp",
      "position": 46,
      "original_position": 57,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": 1114818128,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What you described means that the peer clearly has the transaction, thus it can safely be removed from the corresponding set (\"try\" means it's ok if the tx is not there). What's the problem with that?",
      "created_at": "2023-02-23T07:04:14Z",
      "updated_at": "2023-02-23T07:04:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1115299326",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1115299326"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3834,
      "original_line": 3834,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135725988",
      "pull_request_review_id": 1339558296,
      "id": 1135725988,
      "node_id": "PRRC_kwDOABII585Dsc2k",
      "diff_hunk": "@@ -121,26 +194,204 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        if (!is_peer_inbound) m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    bool AddToSet(NodeId peer_id, const uint256& wtxid) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // Check if reconciliation set is not at capacity for two reasons:\n+        // - limit sizes of reconciliation sets and short id mappings;\n+        // - limit CPU use for sketch computations.\n+        //\n+        // Since we reconcile frequently, reaching capacity either means:\n+        // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+        // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+        // We don't care about a laggy peer (1) because we probably can't help them even if we fanout transactions.\n+        // However, exploiting (2) should not prevent us from relaying certain transactions.\n+        //\n+        // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+        if (recon_state.m_local_set.size() >= MAX_SET_SIZE) return false;\n+\n+        Assume(recon_state.m_local_set.insert(wtxid).second);\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Added a transaction to the reconciliation set for peer=%d. \" /* Continued */\n+                                                                    \"Now the set contains %i transactions.\\n\",\n+                      peer_id, recon_state.m_local_set.size());\n+        return true;\n+    }\n+\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.erase(wtxid_to_remove) > 0;\n+    }\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        if (m_queue.empty()) return false;\n+\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_next_recon_request <= now && m_queue.front() == peer_id) {\n+            Assume(recon_state.m_we_initiate);\n+            m_queue.pop_front();\n+            m_queue.push_back(peer_id);\n+\n+            // If the phase is not NONE, the peer hasn't responded to the previous reconciliation.\n+            // A laggy peer should not affect other peers.\n+            //\n+            // This doesn't prevent from a malicious peer gaming this by staying in this state\n+            // all the time somehow.\n+            if (recon_state.m_phase_init_by_us == Phase::NONE) UpdateNextReconRequest(now);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> InitiateReconciliationRequest(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+        recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+        size_t local_set_size = recon_state.m_local_set.size();\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                                                    \"local_set_size=%i\\n\",\n+                      peer_id, local_set_size);\n+\n+        // In future, Q could be recomputed after every reconciliation based on the\n+        // set differences. For now, it provides good enough results without recompute\n+        // complexity, but we communicate it here to allow backward compatibility if\n+        // the value is changed or made dynamic.\n+        return std::make_pair(local_set_size, Q * Q_PRECISION);\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    std::vector<NodeId> GetFanoutTargets(const uint256& wtxid, CSipHasher& deterministic_randomizer,\n+                                         bool we_initiate, float limit) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // To handle fractional values, we add one peer optimistically and then probabilistically\n+        // drop it later.\n+        // Initiate the randomness here so that it's not influenced by the following code.\n+        double fractional_peer;\n+        const size_t targets = size_t(std::modf(limit, &fractional_peer)) + 1;\n+        const bool drop_peer_if_extra = deterministic_randomizer.Finalize() > fractional_peer * float(UINT64_MAX);\n+\n+        std::vector<std::pair<uint64_t, NodeId>> best_peers(targets, std::make_pair(0, 0));\n+\n+        auto try_fanout_candidate = [&best_peers, &deterministic_randomizer, targets](\n+                                        const std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> candidate) {\n+            const auto& cur_state = std::get<TxReconciliationState>(candidate.second);\n+            uint64_t hash_key = std::max<uint64_t>(deterministic_randomizer.Write(cur_state.m_k0).Finalize(), 1);\n+\n+            for (size_t i = 0; i < targets; ++i) {\n+                if (hash_key > best_peers[i].first) {\n+                    std::copy(best_peers.begin() + i, best_peers.begin() + targets - 1, best_peers.begin() + i + 1);\n+                    best_peers[i] = std::make_pair(hash_key, candidate.first);\n+                    break;\n+                }\n+            }\n+        };\n+\n+        for (auto indexed_state : m_states) {\n+            const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 262,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same as https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042464406",
      "created_at": "2023-03-14T15:20:01Z",
      "updated_at": "2023-03-14T15:31:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1135725988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135725988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135765960",
      "pull_request_review_id": 1339614248,
      "id": 1135765960,
      "node_id": "PRRC_kwDOABII585DsmnI",
      "diff_hunk": "@@ -121,26 +194,204 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        if (!is_peer_inbound) m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    bool AddToSet(NodeId peer_id, const uint256& wtxid) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // Check if reconciliation set is not at capacity for two reasons:\n+        // - limit sizes of reconciliation sets and short id mappings;\n+        // - limit CPU use for sketch computations.\n+        //\n+        // Since we reconcile frequently, reaching capacity either means:\n+        // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+        // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+        // We don't care about a laggy peer (1) because we probably can't help them even if we fanout transactions.\n+        // However, exploiting (2) should not prevent us from relaying certain transactions.\n+        //\n+        // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+        if (recon_state.m_local_set.size() >= MAX_SET_SIZE) return false;\n+\n+        Assume(recon_state.m_local_set.insert(wtxid).second);\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Added a transaction to the reconciliation set for peer=%d. \" /* Continued */\n+                                                                    \"Now the set contains %i transactions.\\n\",\n+                      peer_id, recon_state.m_local_set.size());\n+        return true;\n+    }\n+\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.erase(wtxid_to_remove) > 0;\n+    }\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        if (m_queue.empty()) return false;\n+\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_next_recon_request <= now && m_queue.front() == peer_id) {\n+            Assume(recon_state.m_we_initiate);\n+            m_queue.pop_front();\n+            m_queue.push_back(peer_id);\n+\n+            // If the phase is not NONE, the peer hasn't responded to the previous reconciliation.\n+            // A laggy peer should not affect other peers.\n+            //\n+            // This doesn't prevent from a malicious peer gaming this by staying in this state\n+            // all the time somehow.\n+            if (recon_state.m_phase_init_by_us == Phase::NONE) UpdateNextReconRequest(now);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> InitiateReconciliationRequest(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+        recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+        size_t local_set_size = recon_state.m_local_set.size();\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                                                    \"local_set_size=%i\\n\",\n+                      peer_id, local_set_size);\n+\n+        // In future, Q could be recomputed after every reconciliation based on the\n+        // set differences. For now, it provides good enough results without recompute\n+        // complexity, but we communicate it here to allow backward compatibility if\n+        // the value is changed or made dynamic.\n+        return std::make_pair(local_set_size, Q * Q_PRECISION);\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    std::vector<NodeId> GetFanoutTargets(const uint256& wtxid, CSipHasher& deterministic_randomizer,\n+                                         bool we_initiate, float limit) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // To handle fractional values, we add one peer optimistically and then probabilistically\n+        // drop it later.\n+        // Initiate the randomness here so that it's not influenced by the following code.\n+        double fractional_peer;\n+        const size_t targets = size_t(std::modf(limit, &fractional_peer)) + 1;\n+        const bool drop_peer_if_extra = deterministic_randomizer.Finalize() > fractional_peer * float(UINT64_MAX);\n+\n+        std::vector<std::pair<uint64_t, NodeId>> best_peers(targets, std::make_pair(0, 0));\n+\n+        auto try_fanout_candidate = [&best_peers, &deterministic_randomizer, targets](\n+                                        const std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> candidate) {\n+            const auto& cur_state = std::get<TxReconciliationState>(candidate.second);\n+            uint64_t hash_key = std::max<uint64_t>(deterministic_randomizer.Write(cur_state.m_k0).Finalize(), 1);\n+\n+            for (size_t i = 0; i < targets; ++i) {\n+                if (hash_key > best_peers[i].first) {\n+                    std::copy(best_peers.begin() + i, best_peers.begin() + targets - 1, best_peers.begin() + i + 1);\n+                    best_peers[i] = std::make_pair(hash_key, candidate.first);\n+                    break;\n+                }\n+            }\n+        };\n+\n+        for (auto indexed_state : m_states) {\n+            const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 262,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": 1135725988,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could use [`std::visit`](https://en.cppreference.com/w/cpp/utility/variant/visit).",
      "created_at": "2023-03-14T15:44:09Z",
      "updated_at": "2023-03-14T15:44:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1135765960",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135765960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137786018",
      "pull_request_review_id": 1342448815,
      "id": 1137786018,
      "node_id": "PRRC_kwDOABII585D0Tyi",
      "diff_hunk": "@@ -5669,7 +5679,42 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool fanout = true;\n+                        if (reconciles_txs) {\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "dcde537b5bc0e2dd272528e3a770a768ca804955",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it might be possible that in between the spot where `txinfo` is queried, and the time we call `m_mempool.GetIter()` some other thread could remove the tx from the mempool (because no lock is held), so that this assert would be hit.",
      "created_at": "2023-03-15T21:20:43Z",
      "updated_at": "2023-03-16T15:49:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1137786018",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137786018"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5731,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138793203",
      "pull_request_review_id": 1342448815,
      "id": 1138793203,
      "node_id": "PRRC_kwDOABII585D4Jrz",
      "diff_hunk": "@@ -192,6 +205,87 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    std::vector<NodeId> GetFanoutTargets(const uint256& wtxid, CSipHasher& deterministic_randomizer,\n+                                         bool we_initiate, float limit) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // To handle fractional values, we add one peer optimistically and then probabilistically\n+        // drop it later.\n+        // Initiate the randomness here so that it's not influenced by the following code.\n+        double fractional_peer;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 47,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "dcde537b5bc0e2dd272528e3a770a768ca804955",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Having a mix of float (`limit`) and double (`fractional_peer`) is probably not ideal.",
      "created_at": "2023-03-16T14:40:48Z",
      "updated_at": "2023-03-16T15:49:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1138793203",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138793203"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138809864",
      "pull_request_review_id": 1342448815,
      "id": 1138809864,
      "node_id": "PRRC_kwDOABII585D4NwI",
      "diff_hunk": "@@ -192,6 +205,87 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    std::vector<NodeId> GetFanoutTargets(const uint256& wtxid, CSipHasher& deterministic_randomizer,",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "dcde537b5bc0e2dd272528e3a770a768ca804955",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`wtxid` is unused",
      "created_at": "2023-03-16T14:48:46Z",
      "updated_at": "2023-03-16T15:49:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1138809864",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138809864"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1139046536",
      "pull_request_review_id": 1344306348,
      "id": 1139046536,
      "node_id": "PRRC_kwDOABII585D5HiI",
      "diff_hunk": "@@ -4021,6 +4043,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n+        if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pfrom.GetId())) {\n+            m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), wtxid);\n+        }",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 57,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        if (m_txreconciliation) m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), wtxid);\r\n```\r\n\r\nYou are already checking internally that the peer is registered.",
      "created_at": "2023-03-16T16:49:30Z",
      "updated_at": "2023-03-16T17:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1139046536",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1139046536"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": 4046,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4039,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1139078818",
      "pull_request_review_id": 1344306348,
      "id": 1139078818,
      "node_id": "PRRC_kwDOABII585D5Pai",
      "diff_hunk": "@@ -5669,7 +5721,42 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool fanout = true;\n+                        if (reconciles_txs) {\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            if ((*txiter)->GetCountWithDescendants() > 1) {\n+                                // If a transaction has in-mempool children, always fanout it.\n+                                // Until package relay is implemented, this is needed to avoid\n+                                // breaking parent+child relay expectations in some cases.\n+                                //\n+                                // Potentially reconciling parent+child would mean that for every\n+                                // child we need to to check if any of the parents is currently\n+                                // reconciled so that the child isn't fanouted ahead. But then\n+                                // it gets tricky when reconciliation sets are full: a) the child\n+                                // can't just be added; b) removing parents from reconciliation\n+                                // sets for this one child is not good either.\n+                                fanout = true;\n+                            } else {\n+                                size_t inbounds_fanouted = 0, outbounds_fanouted = 0;\n+                                m_connman.ForEachNode([&inbounds_fanouted, &outbounds_fanouted, this](CNode* pnode) {\n+                                    inbounds_fanouted += pnode->IsInboundConn() && pnode->m_relays_txs;\n+                                    outbounds_fanouted += pnode->IsFullOutboundConn() && pnode->m_relays_txs && !m_txreconciliation->IsPeerRegistered(pnode->GetId());\n+                                });",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 149,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n                                {\r\n                                    LOCK(m_peer_mutex);\r\n                                    for (auto [id, peer] : m_peer_map) {\r\n                                        const auto state{State(id)};\r\n                                        if (!state) continue;\r\n\r\n                                        if (auto tx_relay = peer->GetTxRelay()) {\r\n                                            LOCK(tx_relay->m_bloom_filter_mutex);\r\n                                            inbounds_fanouted += state->m_is_inbound && tx_relay->m_relay_txs;\r\n                                            outbounds_fanouted += !state->m_is_inbound && tx_relay->m_relay_txs && !m_txreconciliation->IsPeerRegistered(id);\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n```\r\n\r\nSee https://github.com/bitcoin/bitcoin/pull/27270",
      "created_at": "2023-03-16T17:08:36Z",
      "updated_at": "2023-03-16T17:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1139078818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1139078818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": 5744,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 5747,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151979732",
      "pull_request_review_id": 1363161761,
      "id": 1151979732,
      "node_id": "PRRC_kwDOABII585EqdDU",
      "diff_hunk": "@@ -5669,7 +5721,42 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool fanout = true;\n+                        if (reconciles_txs) {\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            if ((*txiter)->GetCountWithDescendants() > 1) {\n+                                // If a transaction has in-mempool children, always fanout it.\n+                                // Until package relay is implemented, this is needed to avoid\n+                                // breaking parent+child relay expectations in some cases.\n+                                //\n+                                // Potentially reconciling parent+child would mean that for every\n+                                // child we need to to check if any of the parents is currently\n+                                // reconciled so that the child isn't fanouted ahead. But then\n+                                // it gets tricky when reconciliation sets are full: a) the child\n+                                // can't just be added; b) removing parents from reconciliation\n+                                // sets for this one child is not good either.\n+                                fanout = true;\n+                            } else {\n+                                size_t inbounds_fanouted = 0, outbounds_fanouted = 0;\n+                                m_connman.ForEachNode([&inbounds_fanouted, &outbounds_fanouted, this](CNode* pnode) {\n+                                    inbounds_fanouted += pnode->IsInboundConn() && pnode->m_relays_txs;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 147,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n                                    inbounds_fanouted += pnode->IsInboundConn() && pnode->m_relays_txs && !m_txreconciliation->IsPeerRegistered(pnode->GetId());\r\n```\r\nRight? because otherwise this includes erlay peers which we are not flooding to by default.",
      "created_at": "2023-03-29T13:51:53Z",
      "updated_at": "2023-03-29T13:59:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1151979732",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151979732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5745,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151986544",
      "pull_request_review_id": 1363161761,
      "id": 1151986544,
      "node_id": "PRRC_kwDOABII585Eqetw",
      "diff_hunk": "@@ -5669,7 +5721,42 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool fanout = true;\n+                        if (reconciles_txs) {\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            if ((*txiter)->GetCountWithDescendants() > 1) {\n+                                // If a transaction has in-mempool children, always fanout it.\n+                                // Until package relay is implemented, this is needed to avoid\n+                                // breaking parent+child relay expectations in some cases.\n+                                //\n+                                // Potentially reconciling parent+child would mean that for every\n+                                // child we need to to check if any of the parents is currently\n+                                // reconciled so that the child isn't fanouted ahead. But then\n+                                // it gets tricky when reconciliation sets are full: a) the child\n+                                // can't just be added; b) removing parents from reconciliation\n+                                // sets for this one child is not good either.\n+                                fanout = true;\n+                            } else {\n+                                size_t inbounds_fanouted = 0, outbounds_fanouted = 0;\n+                                m_connman.ForEachNode([&inbounds_fanouted, &outbounds_fanouted, this](CNode* pnode) {\n+                                    inbounds_fanouted += pnode->IsInboundConn() && pnode->m_relays_txs;\n+                                    outbounds_fanouted += pnode->IsFullOutboundConn() && pnode->m_relays_txs && !m_txreconciliation->IsPeerRegistered(pnode->GetId());\n+                                });\n+\n+                                auto fanout_randomizer = m_connman.GetDeterministicRandomizer(RANDOMIZER_ID_FANOUTTARGET);\n+                                fanout = m_txreconciliation->ShouldFanoutTo(wtxid, fanout_randomizer, pto->GetId(),\n+                                                                            std::make_pair(m_connman.GetNodeCount(ConnectionDirection::In), inbounds_fanouted),",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 153,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`m_connman.GetNodeCount(ConnectionDirection::In)` includes all inbound connections, even ones that do want transactions relayed to them. IIUC, you want this to be \"number of all inbound peers that sent fRelay=true\" and the second member of the pair should be \"number of all non-erlay inbound peers that sent fRelay=true\"",
      "created_at": "2023-03-29T13:56:22Z",
      "updated_at": "2023-03-29T13:59:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1151986544",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151986544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5751,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210580514",
      "pull_request_review_id": 1451435060,
      "id": 1210580514,
      "node_id": "PRRC_kwDOABII585IJ_4i",
      "diff_hunk": "@@ -0,0 +1,84 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test REQTXRCNCL message\n+\"\"\"\n+\n+import time\n+\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n+from test_framework.wallet import MiniWallet\n+\n+class ReqTxrcnclReceiver(P2PInterface):\n+    def __init__(self):\n+        super().__init__(support_txrcncl = True)\n+        self.reqtxrcncl_msg_received = None\n+        self.received_inv_items = 0\n+\n+    def on_inv(self, message):\n+        self.received_inv_items += len(message.inv)\n+        super().on_inv(message)\n+\n+    def on_reqtxrcncl(self, message):\n+        self.reqtxrcncl_msg_received = message\n+\n+class ReqTxRcnclTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [['-txreconciliation']]\n+\n+    def run_test(self):\n+        t = int(time.time())\n+        self.nodes[0].setmocktime(t)\n+        self.generate(self.nodes[0], 200) # mature coinbase UTXO used later",
      "path": "test/functional/p2p_reqtxrcncl.py",
      "position": null,
      "original_position": 36,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 00df0aefff938e849bdab5278d6658d5c9d5d064, If the purpose is maturing them, I think we could do:\r\n```suggestion\r\n        self.generate(self.nodes[0], COINBASE_MATURITY) # mature coinbase UTXO used later\r\n```",
      "created_at": "2023-05-30T17:12:06Z",
      "updated_at": "2023-05-30T17:15:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1210580514",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210580514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 36,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210698732",
      "pull_request_review_id": 1451623963,
      "id": 1210698732,
      "node_id": "PRRC_kwDOABII585IKcvs",
      "diff_hunk": "@@ -5787,6 +5795,21 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {",
      "path": "src/net_processing.cpp",
      "position": 194,
      "original_position": 34,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "30c39c1316a7b5c1914654f2a1487309b6e550ac",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 30c39c1316a7b5c1914654f2a1487309b6e550ac: If we're in IBD, wouldn't we put that peer in the end of the queue with no need (I mean, without doing a rec request in fact)? ",
      "created_at": "2023-05-30T18:55:21Z",
      "updated_at": "2023-05-30T18:55:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1210698732",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210698732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5861,
      "original_line": 5861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1286486164",
      "pull_request_review_id": 1566303719,
      "id": 1286486164,
      "node_id": "PRRC_kwDOABII585MrjiU",
      "diff_hunk": "@@ -184,6 +201,8 @@ static constexpr double MAX_ADDR_RATE_PER_SECOND{0.1};\n static constexpr size_t MAX_ADDR_PROCESSING_TOKEN_BUCKET{MAX_ADDR_TO_SEND};\n /** The compactblocks version we support. See BIP 152. */\n static constexpr uint64_t CMPCTBLOCKS_VERSION{2};\n+/** Used to determine whether to fanout or to reconcile a transaction with a given peer */",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 36,
      "commit_id": "65025d1935b082e98d7d347c629c1739abaa5f67",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could say “low-fanout flooding” as it’s the term used above to describe the two transaction announcement strategy",
      "created_at": "2023-08-08T00:27:03Z",
      "updated_at": "2023-08-08T00:27:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1286486164",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1286486164"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    }
  ]
}