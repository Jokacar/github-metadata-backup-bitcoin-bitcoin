{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328",
    "id": 1935933587,
    "node_id": "PR_kwDOABII585zZACT",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30328",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30328.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30328.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/e09407c2924935b456cbbbe141bab0b4686f03ba",
    "number": 30328,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "wallet: Remove IsMine from migration code",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "The legacy wallet `IsMine` code will be removed with the legacy wallet, but is still partially needed for migration. Instead of using `IsMine` directly in migration, equivalent checks are performed by migration.\r\n\r\nBuilds on #26596 ",
    "labels": [
      {
        "id": 149424,
        "node_id": "MDU6TGFiZWwxNDk0MjQ=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Wallet",
        "name": "Wallet",
        "color": "08a781",
        "default": false
      },
      {
        "id": 955867938,
        "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
        "name": "Needs rebase",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2024-06-24T16:40:47Z",
    "updated_at": "2024-12-09T20:48:25Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "achow101:migrate-inline-ismine",
      "ref": "migrate-inline-ismine",
      "sha": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 45006379,
        "node_id": "MDEwOlJlcG9zaXRvcnk0NTAwNjM3OQ==",
        "name": "bitcoin",
        "full_name": "achow101/bitcoin",
        "owner": {
          "login": "achow101",
          "id": 3782274,
          "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
          "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/achow101",
          "html_url": "https://github.com/achow101",
          "followers_url": "https://api.github.com/users/achow101/followers",
          "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
          "organizations_url": "https://api.github.com/users/achow101/orgs",
          "repos_url": "https://api.github.com/users/achow101/repos",
          "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/achow101/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/achow101/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/achow101/bitcoin",
        "archive_url": "https://api.github.com/repos/achow101/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/achow101/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/achow101/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/achow101/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/achow101/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/achow101/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/achow101/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/achow101/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/achow101/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/achow101/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/achow101/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/achow101/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/achow101/bitcoin/events",
        "forks_url": "https://api.github.com/repos/achow101/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/achow101/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/achow101/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/achow101/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/achow101/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/achow101/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/achow101/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/achow101/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/achow101/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/achow101/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/achow101/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/achow101/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/achow101/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/achow101/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/achow101/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/achow101/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:achow101/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/achow101/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/achow101/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/achow101/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/achow101/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/achow101/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/achow101/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/achow101/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/achow101/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/achow101/bitcoin/hooks",
        "svn_url": "https://github.com/achow101/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 8,
        "stargazers_count": 39,
        "watchers_count": 39,
        "size": 287206,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-12-09T20:31:04Z",
        "created_at": "2015-10-27T00:20:28Z",
        "updated_at": "2024-10-04T23:43:44Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "22723c809a8abce415195693546e2a7c03e516c4",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36525,
        "stargazers_count": 80343,
        "watchers_count": 80343,
        "size": 273388,
        "default_branch": "master",
        "open_issues_count": 661,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-12-09T20:12:52Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-12-09T20:55:25Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 340,
    "deletions": 44,
    "changed_files": 3,
    "commits": 4,
    "review_comments": 92,
    "comments": 9
  },
  "events": [
    {
      "event": "commented",
      "id": 2186987135,
      "node_id": "IC_kwDOABII586CWsZ_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2186987135",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-24T16:40:50Z",
      "updated_at": "2024-12-05T17:36:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/30328.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2196286870) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#31423](https://github.com/bitcoin/bitcoin/pull/31423) (wallet: migration, don't create spendable wallet from a watch-only legacy wallet by furszy)\n* [#31374](https://github.com/bitcoin/bitcoin/pull/31374) (wallet: fix crash during watch-only wallet migration by furszy)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#issuecomment-2186987135",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328"
    },
    {
      "event": "labeled",
      "id": 13269106942,
      "node_id": "LE_lADOABII586NTY_uzwAAAAMW5oD-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13269106942",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-24T16:40:52Z",
      "label": {
        "name": "Wallet",
        "color": "08a781"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13355282170,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAAMcCW76",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13355282170",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "574b840c42d7ad5e53fe5c400581561912d1504f",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/574b840c42d7ad5e53fe5c400581561912d1504f",
      "created_at": "2024-07-01T18:48:15Z"
    },
    {
      "event": "convert_to_draft",
      "id": 13427412885,
      "node_id": "CTDE_lADOABII586NTY_uzwAAAAMgVg-V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13427412885",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T17:29:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13476549068,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAAMjQ9HM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13476549068",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d5d994c02bb54db395da457724ec45539f1c10a8",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/d5d994c02bb54db395da457724ec45539f1c10a8",
      "created_at": "2024-07-11T19:29:41Z"
    },
    {
      "event": "ready_for_review",
      "id": 13476550066,
      "node_id": "RFRE_lADOABII586NTY_uzwAAAAMjQ9Wy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13476550066",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T19:29:48Z"
    },
    {
      "event": "commented",
      "id": 2223723973,
      "node_id": "IC_kwDOABII586Ei1XF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2223723973",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T19:30:23Z",
      "updated_at": "2024-07-11T19:30:23Z",
      "author_association": "MEMBER",
      "body": "Ready for review now that #26596 has been merged.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#issuecomment-2223723973",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328"
    },
    {
      "event": "reviewed",
      "id": 2186531990,
      "node_id": "PRR_kwDOABII586CU9SW",
      "url": null,
      "actor": null,
      "commit_id": "d5d994c02bb54db395da457724ec45539f1c10a8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2186531990",
      "submitted_at": "2024-07-18T18:01:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "reviewed",
      "id": 2186871308,
      "node_id": "PRR_kwDOABII586CWQIM",
      "url": null,
      "actor": null,
      "commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2186871308",
      "submitted_at": "2024-07-18T20:41:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "reviewed",
      "id": 2186919023,
      "node_id": "PRR_kwDOABII586CWbxv",
      "url": null,
      "actor": null,
      "commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2186919023",
      "submitted_at": "2024-07-18T21:09:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "labeled",
      "id": 13599857620,
      "node_id": "LE_lADOABII586NTY_uzwAAAAMqnVvU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13599857620",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-22T11:32:49Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2242736995,
      "node_id": "IC_kwDOABII586FrXNj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2242736995",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-22T11:32:50Z",
      "updated_at": "2024-07-22T11:32:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/27341718423</sub>\n\n<details><summary>Hints</summary>\n\nMake sure to run all tests locally, according to the documentation.\n\nThe failure may happen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#issuecomment-2242736995",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328"
    },
    {
      "event": "unlabeled",
      "id": 13601954814,
      "node_id": "UNLE_lADOABII586NTY_uzwAAAAMqvVv-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13601954814",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-22T14:07:32Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2196286870,
      "node_id": "PRR_kwDOABII586C6K2W",
      "url": null,
      "actor": null,
      "commit_id": "d5d994c02bb54db395da457724ec45539f1c10a8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK, left two code-deduplication nits below",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2196286870",
      "submitted_at": "2024-07-24T10:42:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "reviewed",
      "id": 2201704324,
      "node_id": "PRR_kwDOABII586DO1eE",
      "url": null,
      "actor": null,
      "commit_id": "d5d994c02bb54db395da457724ec45539f1c10a8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Commit message in d5d994c02bb54db395da457724ec45539f1c10a8 incorrectly states:\r\n\"This reverts commit bbb1d51e1240da61db2ca1036f9ec91fd2f36f2d.\"\r\n\r\nI believe that commit ended up being merged as b231f4d556876ae70305e8710e31d53525ded8ae.",
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2201704324",
      "submitted_at": "2024-07-26T12:21:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "labeled",
      "id": 13750338894,
      "node_id": "LE_lADOABII586NTY_uzwAAAAMzlYVO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13750338894",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-03T15:00:07Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2266756401,
      "node_id": "IC_kwDOABII586HG_Ux",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2266756401",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-03T15:00:08Z",
      "updated_at": "2024-08-03T15:00:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/27341718760</sub>\n\n<details><summary>Hints</summary>\n\nMake sure to run all tests locally, according to the documentation.\n\nThe failure may happen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#issuecomment-2266756401",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14118147380,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAANJgdU0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14118147380",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b6c2aad1a89c0ff1c414e3fca9c1b511f241ca9f",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/b6c2aad1a89c0ff1c414e3fca9c1b511f241ca9f",
      "created_at": "2024-09-03T16:30:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14205135002,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAANOsSia",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14205135002",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "705d9eb0aef8831891e1cce80c33615440547e90",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/705d9eb0aef8831891e1cce80c33615440547e90",
      "created_at": "2024-09-10T20:09:53Z"
    },
    {
      "event": "unlabeled",
      "id": 14214342113,
      "node_id": "UNLE_lADOABII586NTY_uzwAAAANPPaXh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14214342113",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-11T11:18:46Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2345733518,
      "node_id": "IC_kwDOABII586L0Q2O",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2345733518",
      "actor": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-12T09:22:37Z",
      "updated_at": "2024-09-12T09:22:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2201704324 still applies to 705d9eb0aef8831891e1cce80c33615440547e90 instead of d5d994c02bb54db395da457724ec45539f1c10a8.\r\n\r\n(Clarified linked comment a bit).",
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#issuecomment-2345733518",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14674767400,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAANqry4o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14674767400",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "34751aeb733dd239d69e6e7dc743c292620bb632",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/34751aeb733dd239d69e6e7dc743c292620bb632",
      "created_at": "2024-10-16T11:17:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14676206798,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAANqxSTO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14676206798",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ed5608a5fd2ee7984afb32dd331b9665c1de1fcb",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/ed5608a5fd2ee7984afb32dd331b9665c1de1fcb",
      "created_at": "2024-10-16T11:33:38Z"
    },
    {
      "event": "review_requested",
      "id": 14852588461,
      "node_id": "RRE_lADOABII586NTY_uzwAAAAN1SIOt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14852588461",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-24T14:20:29Z",
      "requested_reviewer": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15304500193,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAAOQOCPh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15304500193",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f01e56aaf42e0b06f634b799d5eff8599f71df2f",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/f01e56aaf42e0b06f634b799d5eff8599f71df2f",
      "created_at": "2024-11-14T21:16:30Z"
    },
    {
      "event": "commented",
      "id": 2477425377,
      "node_id": "IC_kwDOABII586TqoLh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2477425377",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-14T21:16:38Z",
      "updated_at": "2024-11-14T21:16:38Z",
      "author_association": "MEMBER",
      "body": "> Commit message in [d5d994c](https://github.com/bitcoin/bitcoin/commit/d5d994c02bb54db395da457724ec45539f1c10a8) incorrectly states: \"This reverts commit [bbb1d51](https://github.com/bitcoin/bitcoin/commit/bbb1d51e1240da61db2ca1036f9ec91fd2f36f2d).\"\r\n> \r\n> I believe that commit ended up being merged as [b231f4d](https://github.com/bitcoin/bitcoin/commit/b231f4d556876ae70305e8710e31d53525ded8ae).\r\n\r\nIndeed, fixed.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#issuecomment-2477425377",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328"
    },
    {
      "event": "reviewed",
      "id": 2434167216,
      "node_id": "PRR_kwDOABII586RFnGw",
      "url": null,
      "actor": null,
      "commit_id": "f01e56aaf42e0b06f634b799d5eff8599f71df2f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Half way through it. Small comments so far.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2434167216",
      "submitted_at": "2024-11-15T17:47:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "reviewed",
      "id": 2439329600,
      "node_id": "PRR_kwDOABII586RZTdA",
      "url": null,
      "actor": null,
      "commit_id": "f01e56aaf42e0b06f634b799d5eff8599f71df2f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2439329600",
      "submitted_at": "2024-11-15T18:13:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "reviewed",
      "id": 2421497661,
      "node_id": "PRR_kwDOABII586QVR89",
      "url": null,
      "actor": null,
      "commit_id": "f01e56aaf42e0b06f634b799d5eff8599f71df2f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "This section of the code is fairly arcane and hard to read. It would help me (and probably other reviewers) if there were more commentary on why things are being done and what is actually happening, especially because a lot of the involved variables are never explicitly denominated.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2421497661",
      "submitted_at": "2024-11-15T19:15:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "reviewed",
      "id": 2439445784,
      "node_id": "PRR_kwDOABII586RZv0Y",
      "url": null,
      "actor": null,
      "commit_id": "f01e56aaf42e0b06f634b799d5eff8599f71df2f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "There is a bug in the second loop. Before adding the P2WSH program to the spks set, it is necessary to verify that the underlying witness script does not contain any uncompressed keys, as these are prohibited under segwit rules.\r\nCrafted a test exercising the behavior https://github.com/furszy/bitcoin-core/commit/3a0d127343320cc00f13cef96fad7f3b1bd3335a.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2439445784",
      "submitted_at": "2024-11-15T19:24:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15320084483,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAAORJfAD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15320084483",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "401f439cc50e4d55502247dfc98eb430e6c19f98",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/401f439cc50e4d55502247dfc98eb430e6c19f98",
      "created_at": "2024-11-16T02:11:18Z"
    },
    {
      "event": "commented",
      "id": 2480325630,
      "node_id": "IC_kwDOABII586T1sP-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2480325630",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-16T02:19:11Z",
      "updated_at": "2024-11-16T02:19:11Z",
      "author_association": "MEMBER",
      "body": "> There is a bug in the second loop. Before adding the P2WSH program to the spks set, it is necessary to verify that the underlying witness script does not contain any uncompressed keys, as these are prohibited under segwit rules.\r\n\r\nI've added a test to `wallet_migration.py` so that it will persist once legacy wallets are removed.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#issuecomment-2480325630",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328"
    },
    {
      "event": "reviewed",
      "id": 2441226741,
      "node_id": "PRR_kwDOABII586Rgin1",
      "url": null,
      "actor": null,
      "commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2441226741",
      "submitted_at": "2024-11-17T21:12:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "reviewed",
      "id": 2442077210,
      "node_id": "PRR_kwDOABII586RjyQa",
      "url": null,
      "actor": null,
      "commit_id": "401f439cc50e4d55502247dfc98eb430e6c19f98",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "Preliminary review fa155991ff30bc001229e1d71bf44e8782f02d17\r\n\r\n~I feel e6342ffdf0030f6350a07f325ce603fddfff1bd8 commit could be a separate PR, these functional tests are not dependent on the changes in the next two commits and don't need to be tied to these changes.~ I see the comment history now.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2442077210",
      "submitted_at": "2024-11-18T12:05:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15353087571,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAAOTHYZT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15353087571",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7fdbb19edbdd9e09a40d7726b859484c111a697e",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/7fdbb19edbdd9e09a40d7726b859484c111a697e",
      "created_at": "2024-11-19T17:31:41Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15373917931,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAAOUW17r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15373917931",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "97893b124a072f9111942f3e572c9637c51dd481",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/97893b124a072f9111942f3e572c9637c51dd481",
      "created_at": "2024-11-20T23:25:51Z"
    },
    {
      "event": "reviewed",
      "id": 2451750295,
      "node_id": "PRR_kwDOABII586SIr2X",
      "url": null,
      "actor": null,
      "commit_id": "97893b124a072f9111942f3e572c9637c51dd481",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Must admit that i'm not versed enough in the subtle specifics with regard to validity and spendability of scripts, to be sure all of this is correct. But where i've checked, the behavior matches the IsMine-based implementation. Overall changes LGTM.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2451750295",
      "submitted_at": "2024-11-22T11:18:37Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "reviewed",
      "id": 2458976059,
      "node_id": "PRR_kwDOABII586SkP87",
      "url": null,
      "actor": null,
      "commit_id": "a5a81cf7bc380273a4678bcb843319b2fdaa9f1b",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2458976059",
      "submitted_at": "2024-11-25T16:44:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "commented",
      "id": 2504519664,
      "node_id": "IC_kwDOABII586VR-_w",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2504519664",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-27T18:08:07Z",
      "updated_at": "2024-11-27T18:08:07Z",
      "author_association": "MEMBER",
      "body": "Found a few ways to crash migration while reviewing these PR that also occur in master: #31374, #31378. I think we should focus on those before moving forward with this final `IsMine` killing refactoring. They also include further test coverage that would be nice to have here.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#issuecomment-2504519664",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15549065127,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAAOey-en",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15549065127",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fea89250452fd153e0c4e25b02e26789c8218400",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/fea89250452fd153e0c4e25b02e26789c8218400",
      "created_at": "2024-12-05T19:13:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15549074121,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAAOezArJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15549074121",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "348e5aadb156bfa94d5b810f152fef8fbc0d8485",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/348e5aadb156bfa94d5b810f152fef8fbc0d8485",
      "created_at": "2024-12-05T19:13:59Z"
    },
    {
      "event": "reviewed",
      "id": 2485761578,
      "node_id": "PRR_kwDOABII586UKbYq",
      "url": null,
      "actor": null,
      "commit_id": "348e5aadb156bfa94d5b810f152fef8fbc0d8485",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#pullrequestreview-2485761578",
      "submitted_at": "2024-12-06T22:55:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM4MjBjZjFiMzFiNDA0NmYwMTFjYWQ2OWQ2YTJjNjcxYzU4NTljMmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c820cf1b31b4046f011cad69d6a2c671c5859c2c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c820cf1b31b4046f011cad69d6a2c671c5859c2c",
      "tree": {
        "sha": "285e1161a4651b3adc90b58a8dbe65fde0023691",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/285e1161a4651b3adc90b58a8dbe65fde0023691"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/22723c809a8abce415195693546e2a7c03e516c4",
          "sha": "22723c809a8abce415195693546e2a7c03e516c4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/22723c809a8abce415195693546e2a7c03e516c4"
        }
      ],
      "message": "test: Extra verification that migratewallet migrates",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-12-07T17:39:42Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-12-07T16:34:26Z"
      },
      "sha": "c820cf1b31b4046f011cad69d6a2c671c5859c2c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM1ZTc3NWVhMTdlZDEyNmRmM2VmN2JmZGZmZWY0OTA3NmI5MDg5ZDI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/35e775ea17ed126df3ef7bfdffef49076b9089d2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/35e775ea17ed126df3ef7bfdffef49076b9089d2",
      "tree": {
        "sha": "21869dbf84dfefbe7faa94806c9444abe8e315bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/21869dbf84dfefbe7faa94806c9444abe8e315bf"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c820cf1b31b4046f011cad69d6a2c671c5859c2c",
          "sha": "c820cf1b31b4046f011cad69d6a2c671c5859c2c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c820cf1b31b4046f011cad69d6a2c671c5859c2c"
        }
      ],
      "message": "tests: Test migration of additional P2WSH scripts",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-12-07T17:39:42Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-11-16T01:22:18Z"
      },
      "sha": "35e775ea17ed126df3ef7bfdffef49076b9089d2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIxYWUwMGIyOGIwOGFmMTczNzQ2NTQ1YTkzZDk0YTBmY2I5ODkzMGE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1ae00b28b08af173746545a93d94a0fcb98930a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b1ae00b28b08af173746545a93d94a0fcb98930a",
      "tree": {
        "sha": "66d8eef91022121955b75b1a87c815ac04e5af92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/66d8eef91022121955b75b1a87c815ac04e5af92"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/35e775ea17ed126df3ef7bfdffef49076b9089d2",
          "sha": "35e775ea17ed126df3ef7bfdffef49076b9089d2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/35e775ea17ed126df3ef7bfdffef49076b9089d2"
        }
      ],
      "message": "wallet: Remove IsMine from migration\n\nAs IsMine will be removed, the relevant components of IsMine are inlined\ninto the migration functions.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-12-07T17:39:42Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-01-05T23:36:24Z"
      },
      "sha": "b1ae00b28b08af173746545a93d94a0fcb98930a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGUwOTQwN2MyOTI0OTM1YjQ1NmNiYmJlMTQxYmFiMGI0Njg2ZjAzYmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e09407c2924935b456cbbbe141bab0b4686f03ba",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e09407c2924935b456cbbbe141bab0b4686f03ba",
      "tree": {
        "sha": "7f50890d2f5007ff813d85923863a4521e5d7c8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f50890d2f5007ff813d85923863a4521e5d7c8d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1ae00b28b08af173746545a93d94a0fcb98930a",
          "sha": "b1ae00b28b08af173746545a93d94a0fcb98930a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b1ae00b28b08af173746545a93d94a0fcb98930a"
        }
      ],
      "message": "Revert \"wallet: Move LegacyScriptPubKeyMan::IsMine to LegacyDataSPKM\"\n\nThis reverts commit b231f4d556876ae70305e8710e31d53525ded8ae.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-12-07T17:39:42Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-11-14T21:16:10Z"
      },
      "sha": "e09407c2924935b456cbbbe141bab0b4686f03ba"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15570357242,
      "node_id": "HRFPE_lADOABII586NTY_uzwAAAAOgEMv6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15570357242",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/e09407c2924935b456cbbbe141bab0b4686f03ba",
      "created_at": "2024-12-07T17:39:51Z"
    },
    {
      "event": "commented",
      "id": 2529415352,
      "node_id": "IC_kwDOABII586Ww9C4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2529415352",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-09T20:48:23Z",
      "updated_at": "2024-12-09T20:48:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--cf906140f33d8803c4a75a2196329ecb-->\n🐙 This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#issuecomment-2529415352",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30328"
    },
    {
      "event": "labeled",
      "id": 15590357277,
      "node_id": "LE_lADOABII586NTY_uzwAAAAOhQfkd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15590357277",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-09T20:48:23Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683274753",
      "pull_request_review_id": 2186531990,
      "id": 1683274753,
      "node_id": "PRRC_kwDOABII585kVLwB",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care aboue these types because they are not spendable",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "d5d994c02bb54db395da457724ec45539f1c10a8",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n        // We don't care about these types because they are not spendable\r\n```",
      "created_at": "2024-07-18T18:01:35Z",
      "updated_at": "2024-07-18T18:01:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1683274753",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683274753"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1728,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683481047",
      "pull_request_review_id": 2186871308,
      "id": 1683481047,
      "node_id": "PRRC_kwDOABII585kV-HX",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care aboue these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                bool allowed = true;\n+                for (const auto& key : keys) {\n+                    if (key.size() != 33) {\n+                        allowed = false;\n+                        break;\n+                    }\n+                }\n+                if (allowed) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash;\n+            CRIPEMD160().Write(sols[0].data(), sols[0].size()).Finalize(hash.begin());\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+            return ctx == ScriptContext::TOP;\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && sols[0].size() != 33) return false;\n+            return true;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(sols[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(sols[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            CScriptID script_id{RIPEMD160(sols[0])};\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2WSH);\n+            }\n+            return true;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            if (ctx == ScriptContext::P2WSH) {\n+                std::vector<valtype> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 153,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 905e22b469a1e09df9ff0e98bf989a55642f301e \"wallet: Remove IsMine from migration\": Just a question, but could it be a vector of `CPubKey` then use `IsCompressed`?",
      "created_at": "2024-07-18T20:41:25Z",
      "updated_at": "2024-07-18T20:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1683481047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683481047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683511942",
      "pull_request_review_id": 2186919023,
      "id": 1683511942,
      "node_id": "PRRC_kwDOABII585kWFqG",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": 66,
      "original_position": 4,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 905e22b469a1e09df9ff0e98bf989a55642f301e \"wallet: Remove IsMine from migration\": Maybe it's worth updating the documentation?\r\n\r\n```\r\n// For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\r\n```",
      "created_at": "2024-07-18T21:09:38Z",
      "updated_at": "2024-07-18T21:09:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1683511942",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1683511942"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1725,
      "original_line": 1725,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1689547396",
      "pull_request_review_id": 2196286870,
      "id": 1689547396,
      "node_id": "PRRC_kwDOABII585ktHKE",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care aboue these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                bool allowed = true;\n+                for (const auto& key : keys) {\n+                    if (key.size() != 33) {\n+                        allowed = false;\n+                        break;\n+                    }\n+                }\n+                if (allowed) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash;\n+            CRIPEMD160().Write(sols[0].data(), sols[0].size()).Finalize(hash.begin());",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: can use the `RIPEMD160` helper here\r\n```suggestion\r\n            uint160 hash{RIPEMD160(sols[0])};\r\n```",
      "created_at": "2024-07-24T10:37:34Z",
      "updated_at": "2024-07-24T10:42:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1689547396",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1689547396"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1790,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1794,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1689550504",
      "pull_request_review_id": 2196286870,
      "id": 1689550504,
      "node_id": "PRRC_kwDOABII585ktH6o",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care aboue these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                bool allowed = true;\n+                for (const auto& key : keys) {\n+                    if (key.size() != 33) {\n+                        allowed = false;\n+                        break;\n+                    }\n+                }\n+                if (allowed) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 71,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: to deduplicate code, could introduce an `all_keys_compressed` helper that is used here and below in the `is_valid_script` lambda, e.g. something like:\r\n\r\n```\r\n    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\r\n        return std::all_of(keys.cbegin(), keys.cend(),\r\n               [](const auto& key) { return key.size() == 33; });\r\n    };\r\n```",
      "created_at": "2024-07-24T10:40:19Z",
      "updated_at": "2024-07-24T10:42:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1689550504",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1689550504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1768,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1778,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802902566",
      "pull_request_review_id": 2372107763,
      "id": 1802902566,
      "node_id": "PRRC_kwDOABII585rdhwm",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care aboue these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                bool allowed = true;\n+                for (const auto& key : keys) {\n+                    if (key.size() != 33) {\n+                        allowed = false;\n+                        break;\n+                    }\n+                }\n+                if (allowed) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash;\n+            CRIPEMD160().Write(sols[0].data(), sols[0].size()).Finalize(hash.begin());\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+            return ctx == ScriptContext::TOP;\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && sols[0].size() != 33) return false;\n+            return true;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(sols[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(sols[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            CScriptID script_id{RIPEMD160(sols[0])};\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2WSH);\n+            }\n+            return true;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            if (ctx == ScriptContext::P2WSH) {\n+                std::vector<valtype> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 153,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "in_reply_to_id": 1683481047,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`HaveKeys` uses `std::vector<valtype>`",
      "created_at": "2024-10-16T11:16:59Z",
      "updated_at": "2024-10-16T11:16:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1802902566",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802902566"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802902988",
      "pull_request_review_id": 2372108454,
      "id": 1802902988,
      "node_id": "PRRC_kwDOABII585rdh3M",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care aboue these types because they are not spendable",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "d5d994c02bb54db395da457724ec45539f1c10a8",
      "in_reply_to_id": 1683274753,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-10-16T11:17:20Z",
      "updated_at": "2024-10-16T11:17:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1802902988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802902988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1728,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802903174",
      "pull_request_review_id": 2372108723,
      "id": 1802903174,
      "node_id": "PRRC_kwDOABII585rdh6G",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": 66,
      "original_position": 4,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "in_reply_to_id": 1683511942,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated the comment.",
      "created_at": "2024-10-16T11:17:29Z",
      "updated_at": "2024-10-16T11:17:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1802903174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802903174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1725,
      "original_line": 1725,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802908802",
      "pull_request_review_id": 2372118601,
      "id": 1802908802,
      "node_id": "PRRC_kwDOABII585rdjSC",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care aboue these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                bool allowed = true;\n+                for (const auto& key : keys) {\n+                    if (key.size() != 33) {\n+                        allowed = false;\n+                        break;\n+                    }\n+                }\n+                if (allowed) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash;\n+            CRIPEMD160().Write(sols[0].data(), sols[0].size()).Finalize(hash.begin());",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "in_reply_to_id": 1689547396,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-10-16T11:22:12Z",
      "updated_at": "2024-10-16T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1802908802",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802908802"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1790,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1794,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802908907",
      "pull_request_review_id": 2372118795,
      "id": 1802908907,
      "node_id": "PRRC_kwDOABII585rdjTr",
      "diff_hunk": "@@ -1721,37 +1721,157 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care aboue these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                bool allowed = true;\n+                for (const auto& key : keys) {\n+                    if (key.size() != 33) {\n+                        allowed = false;\n+                        break;\n+                    }\n+                }\n+                if (allowed) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 71,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "905e22b469a1e09df9ff0e98bf989a55642f301e",
      "in_reply_to_id": 1689550504,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-10-16T11:22:17Z",
      "updated_at": "2024-10-16T11:22:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1802908907",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802908907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1768,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1778,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1832978940",
      "pull_request_review_id": 2421497661,
      "id": 1832978940,
      "node_id": "PRRC_kwDOABII585tQQn8",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What does \"sols\" stand for beside solar days on Mars? Is this intended to refer to \"solvers\"? If so, abbreviating that just seems unnecessarily confusing.\r\n\r\n```suggestion\r\n        std::vector<std::vector<unsigned char>> solvers;\r\n```",
      "created_at": "2024-11-07T16:23:28Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1832978940",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1832978940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1841007320",
      "pull_request_review_id": 2434167216,
      "id": 1841007320,
      "node_id": "PRRC_kwDOABII585tu4rY",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 15,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\nif you move this to use an structured binding, could use the script id directly instead of calculating it on every ´ScriptHash(script)´ call.\r\n\r\ne.g.\r\n\r\n```c++\r\nfor (const auto& [id, script] : mapScripts) {\r\n   // ... stuff ...\r\n   spks.insert(GetScriptForDestination(ScriptHash(id))); \r\n  // ^^ this does not perform the extra Hash160(script) call.\r\n}\r\n```",
      "created_at": "2024-11-13T18:55:51Z",
      "updated_at": "2024-11-15T17:47:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1841007320",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1841007320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1729,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1734,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1841132532",
      "pull_request_review_id": 2421497661,
      "id": 1841132532,
      "node_id": "PRRC_kwDOABII585tvXP0",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n        // These are only spendable if the witness script is also spendable as a scriptPubKey\r\n```",
      "created_at": "2024-11-13T20:40:56Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1841132532",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1841132532"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1741,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1841207696",
      "pull_request_review_id": 2421497661,
      "id": 1841207696,
      "node_id": "PRRC_kwDOABII585tvpmQ",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 51,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could we maybe give a few pointers what’s going on here?\r\n```suggestion\r\n            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\r\n                // Insert the output script for a P2WPKH output\r\n                spks.insert(script);\r\n                // Insert the output script for a P2SH-P2WPKH output\r\n                spks.insert(GetScriptForDestination(ScriptHash(script)));\r\n```\r\n\r\nAgain, mostly guessing. :shrug:",
      "created_at": "2024-11-13T21:40:33Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1841207696",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1841207696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1757,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1769,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1841210613",
      "pull_request_review_id": 2421497661,
      "id": 1841210613,
      "node_id": "PRRC_kwDOABII585tvqT1",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Are we talking about private keys here? Or public keys? E.g. clearly we would need all three public keys, but only two private keys to spend a 2-of-3 bare multisig.\r\n\r\nThis is talking about bare multisig, right? Would something like this make sense?\r\n\r\n```suggestion\r\n            // Bare multisig outputs are only spendable if we have [public|private|public and private] keys that appear in the output script\r\n```",
      "created_at": "2024-11-13T21:43:17Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1841210613",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1841210613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1765,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844166304",
      "pull_request_review_id": 2434167216,
      "id": 1844166304,
      "node_id": "PRRC_kwDOABII585t676g",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Note for reviewers:\r\nThis is because we store scripts (witness programs, witness scripts and redeem scripts) in a map whose key is a `CScriptID` -> which is a Hash160 of the script -> which is a `RIPEMD160(SHA256(script))`.\r\nAs P2WSH are in the form of `OP_0 <SHA256(witness_script)>`, the SHA256 part is already there and we only need to perform the RIPEMD160 calculation to obtain the `CScriptID`.",
      "created_at": "2024-11-15T16:48:09Z",
      "updated_at": "2024-11-15T17:47:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844166304",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844166304"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1790,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1791,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844244829",
      "pull_request_review_id": 2434167216,
      "id": 1844244829,
      "node_id": "PRRC_kwDOABII585t7PFd",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is this being tested? It seems we have P2WSH(multisig) tests inside `ismine_tests.cpp` and `wallet_migration.py` but these type of script should be covered inside the first loop already. Because if the wallet owns the P2WSH, it will also contain the inner multisig script, which will be handled by the first loop.",
      "created_at": "2024-11-15T17:47:20Z",
      "updated_at": "2024-11-15T17:48:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844244829",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844244829"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1785,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1801,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844279607",
      "pull_request_review_id": 2439329600,
      "id": 1844279607,
      "node_id": "PRRC_kwDOABII585t7Xk3",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 116,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "f01e56aaf42e0b06f634b799d5eff8599f71df2f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "How can we end up with a P2SH or a witness program inside the witness script?",
      "created_at": "2024-11-15T18:13:54Z",
      "updated_at": "2024-11-15T18:13:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844279607",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844279607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1795,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1797,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844300642",
      "pull_request_review_id": 2421497661,
      "id": 1844300642,
      "node_id": "PRRC_kwDOABII585t7cti",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was first confused by the snake_case apparently being used as a function below. A comment would have helped me figure this out a bit faster. Maybe something in the vein of:\r\n\r\n```suggestion\r\n    // Assigns an unnamed lambda function which checks that all keys are compressed\r\n    const auto& func_all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\r\n        return std::all_of(keys.cbegin(), keys.cend(),\r\n               [](const auto& key) { return key.size() == 33; });\r\n    };\r\n```",
      "created_at": "2024-11-15T18:31:07Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844300642",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844300642"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1720,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1741,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844302843",
      "pull_request_review_id": 2421497661,
      "id": 1844302843,
      "node_id": "PRRC_kwDOABII585t7dP7",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could this comment please be more specific? What sorts of scripts are being stored in this map? Input scripts, output scripts, redeemscripts, witness programs, witness scripts, all of the above, a subset of the above, etc.?",
      "created_at": "2024-11-15T18:33:31Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844302843",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844302843"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1725,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844305339",
      "pull_request_review_id": 2421497661,
      "id": 1844305339,
      "node_id": "PRRC_kwDOABII585t7d27",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 26,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n        // The legacy wallet never had support for P2TR, therefore it’s among the unspendable scripts here\r\n        case TxoutType::WITNESS_V1_TAPROOT:\r\n```",
      "created_at": "2024-11-15T18:36:15Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844305339",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844305339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1738,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844306218",
      "pull_request_review_id": 2421497661,
      "id": 1844306218,
      "node_id": "PRRC_kwDOABII585t7eEq",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This comment is confusing, because once `spks` refers to the variable, and once \"spks\" seems to refer to output scripts. If I understand this right:\r\n\r\n```suggestion\r\n        // We will check these later after `spks` has been updated with scriptPubKeys from the processed scripts.\r\n```",
      "created_at": "2024-11-15T18:37:12Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844306218",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844306218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1742,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844317743",
      "pull_request_review_id": 2421497661,
      "id": 1844317743,
      "node_id": "PRRC_kwDOABII585t7g4v",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "These two lines of comments are hard to understand. What is a \"P2SH nested spk\"? It would make it easier to understand if references to variables and references to abstract concepts were clearly differentiated.\r\n\r\nAfter staring at this for a while, is the following roughly what is meant here?\r\n\r\n```suggestion\r\n        // P2PK and P2PKH output scripts can already be handled after the the wallet’s keys have been processed above.\r\n        // If we encounter any output scripts that match the P2PKH output script pattern, these are here to handle P2SH-P2WPKH output scripts\r\n```\r\n\r\nOtherwise, please consider my comment evidence that it was hard to understand what is going on here.",
      "created_at": "2024-11-15T18:49:24Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844317743",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844317743"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1745,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1746,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844326937",
      "pull_request_review_id": 2421497661,
      "id": 1844326937,
      "node_id": "PRRC_kwDOABII585t7jIZ",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Did you mean?\r\n\r\n```suggestion\r\n            // We need to have the witness script to consider the P2WSH output script to be spendable.\r\n```\r\n",
      "created_at": "2024-11-15T18:56:46Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844326937",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844326937"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1772,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844333982",
      "pull_request_review_id": 2421497661,
      "id": 1844333982,
      "node_id": "PRRC_kwDOABII585t7k2e",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844166304,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could this please be documented in the code?",
      "created_at": "2024-11-15T19:04:02Z",
      "updated_at": "2024-11-15T19:15:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844333982",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844333982"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1790,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1791,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844334957",
      "pull_request_review_id": 2421497661,
      "id": 1844334957,
      "node_id": "PRRC_kwDOABII585t7lFt",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 107,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What is a \"TOP\" ScriptContext?",
      "created_at": "2024-11-15T19:05:07Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844334957",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844334957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1801,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844338459",
      "pull_request_review_id": 2421497661,
      "id": 1844338459,
      "node_id": "PRRC_kwDOABII585t7l8b",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::ANCHOR:\n+            return ctx == ScriptContext::TOP;\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && sols[0].size() != 33) return false;\n+            return true;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(sols[0])), pubkey) && !pubkey.IsCompressed()) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 131,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What is our expectation to be happening when `uint160(sols[0])` is called here? Could we maybe pull apart these three conversations in a conditional statement into two lines where the first line provides some insight on what we are converting here?\r\n\r\nWould I be right in guessing that a `CKeyID` is the hash of a public key?",
      "created_at": "2024-11-15T19:08:35Z",
      "updated_at": "2024-11-15T19:15:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844338459",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844338459"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1829,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1826,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844342958",
      "pull_request_review_id": 2421497661,
      "id": 1844342958,
      "node_id": "PRRC_kwDOABII585t7nCu",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::ANCHOR:\n+            return ctx == ScriptContext::TOP;\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && sols[0].size() != 33) return false;\n+            return true;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(sols[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(sols[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            CScriptID script_id{RIPEMD160(sols[0])};",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 149,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wouldn’t all of this be way easier and more readable, if we had explicit types for our various output script components instead of treating them as if they were just numbers and strings?",
      "created_at": "2024-11-15T19:13:08Z",
      "updated_at": "2024-11-15T19:15:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844342958",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844342958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1852,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844630125",
      "pull_request_review_id": 2439881600,
      "id": 1844630125,
      "node_id": "PRRC_kwDOABII585t8tJt",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 116,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "f01e56aaf42e0b06f634b799d5eff8599f71df2f",
      "in_reply_to_id": 1844279607,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Using `importaddress`, you can import arbitrary scripts that can appear as output scripts. It is thus possible to import a P2WSH script which contains the hash of a P2SH script or a witness program. The user can then use `importaddress` again to import those particular scripts.\r\n\r\nMost of the edge cases revolve around the user doing something insane, but because they were allowed, we have to handle them.",
      "created_at": "2024-11-15T22:46:23Z",
      "updated_at": "2024-11-15T23:01:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844630125",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844630125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1795,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1797,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844642514",
      "pull_request_review_id": 2439898869,
      "id": 1844642514,
      "node_id": "PRRC_kwDOABII585t8wLS",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1832978940,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "**sol**ution**s**",
      "created_at": "2024-11-15T22:52:22Z",
      "updated_at": "2024-11-15T22:52:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844642514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844642514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844644393",
      "pull_request_review_id": 2439901507,
      "id": 1844644393,
      "node_id": "PRRC_kwDOABII585t8wop",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1841210613,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Generally \"keys\" refers to private keys and public keys are typically specified as such or as \"pubkey\".\r\n\r\nIn this instance, multisigs are only spendable if we have all of their private keys, regardless of the context the multisig appears in.",
      "created_at": "2024-11-15T22:55:39Z",
      "updated_at": "2024-11-15T22:55:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844644393",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844644393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1765,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844645672",
      "pull_request_review_id": 2439903121,
      "id": 1844645672,
      "node_id": "PRRC_kwDOABII585t8w8o",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844302843,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "All of the above. All types of scripts are stored in mapScripts, without contexts. Thus all scripts in mapScripts can appear in any context. That is the insanity of legacy IsMine.",
      "created_at": "2024-11-15T22:57:57Z",
      "updated_at": "2024-11-15T23:02:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844645672",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844645672"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1725,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844650818",
      "pull_request_review_id": 2439910552,
      "id": 1844650818,
      "node_id": "PRRC_kwDOABII585t8yNC",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844317743,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If a P2PK or P2PKH script exists in mapScripts, then the corresponding P2SH-P2PK and P2SH-P2PKH output script is spendable.",
      "created_at": "2024-11-15T23:07:06Z",
      "updated_at": "2024-11-15T23:07:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844650818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844650818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1745,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1746,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844651416",
      "pull_request_review_id": 2439911468,
      "id": 1844651416,
      "node_id": "PRRC_kwDOABII585t8yWY",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 107,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844334957,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Output script level.",
      "created_at": "2024-11-15T23:08:26Z",
      "updated_at": "2024-11-15T23:08:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844651416",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844651416"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1801,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844652679",
      "pull_request_review_id": 2439913312,
      "id": 1844652679,
      "node_id": "PRRC_kwDOABII585t8yqH",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::ANCHOR:\n+            return ctx == ScriptContext::TOP;\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && sols[0].size() != 33) return false;\n+            return true;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(sols[0])), pubkey) && !pubkey.IsCompressed()) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 131,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844338459,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's basically just casting types.\r\n\r\n`sols[0]` contains a vector of bytes which represents the hash of a pubkey. This is cast to the `uint160` type, which is then cast to the `CKeyID` type (which is really just a wrapper around `uint160`) which is the type that `GetPubKey` can take. There is no direct conversion from `std::vector<>` to `CKeyID` hence the `uint160` in between.\r\n\r\nIt doesn't make sense to pull this apart since the intermediate types are never used.",
      "created_at": "2024-11-15T23:11:12Z",
      "updated_at": "2024-11-15T23:11:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844652679",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844652679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1829,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1826,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844723731",
      "pull_request_review_id": 2440001939,
      "id": 1844723731,
      "node_id": "PRRC_kwDOABII585t9EAT",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::ANCHOR:\n+            return ctx == ScriptContext::TOP;\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && sols[0].size() != 33) return false;\n+            return true;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(sols[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(sols[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            CScriptID script_id{RIPEMD160(sols[0])};",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 149,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844342958,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It is possible that the solver could be rewritten to pull out all of the components of scripts into structs with proper typing and member names, but that is a much larger refactor that is out of scope for this PR.",
      "created_at": "2024-11-16T00:24:29Z",
      "updated_at": "2024-11-16T00:24:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844723731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844723731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1852,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844850200",
      "pull_request_review_id": 2440194435,
      "id": 1844850200,
      "node_id": "PRRC_kwDOABII585t9i4Y",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 15,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1841007320,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-11-16T02:16:17Z",
      "updated_at": "2024-11-16T02:16:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844850200",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844850200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1729,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1734,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844850300",
      "pull_request_review_id": 2440194643,
      "id": 1844850300,
      "node_id": "PRRC_kwDOABII585t9i58",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844166304,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've added a comment.",
      "created_at": "2024-11-16T02:16:25Z",
      "updated_at": "2024-11-16T02:16:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844850300",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844850300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1790,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1791,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844850356",
      "pull_request_review_id": 2440194727,
      "id": 1844850356,
      "node_id": "PRRC_kwDOABII585t9i60",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.\n+            // But the keys also must be compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh))) {\n+                if (all_keys_compressed(keys)) {\n+                    spks.insert(ms_wsh);\n+                    spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n                 }\n             }\n+            break;\n+        }\n+        }\n+    }\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& script_pair : mapScripts) {\n+        const CScript& script = script_pair.second;\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            uint160 hash{RIPEMD160(sols[0])};\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            if (GetCScript(CScriptID(hash), witness_script) &&\n+                !witness_script.IsPayToScriptHash() &&\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) &&\n+                spks.count(witness_script) > 0) {\n+                spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            }",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844244829,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've added additional tests to `wallet_migration.py`.",
      "created_at": "2024-11-16T02:16:40Z",
      "updated_at": "2024-11-16T02:16:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844850356",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844850356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1785,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1801,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851400",
      "pull_request_review_id": 2440195615,
      "id": 1844851400,
      "node_id": "PRRC_kwDOABII585t9jLI",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1841132532,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This comment has been reworded",
      "created_at": "2024-11-16T02:17:17Z",
      "updated_at": "2024-11-16T02:17:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844851400",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851400"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1741,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851480",
      "pull_request_review_id": 2440195698,
      "id": 1844851480,
      "node_id": "PRRC_kwDOABII585t9jMY",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 51,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1841207696,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've added some additional comments.",
      "created_at": "2024-11-16T02:17:26Z",
      "updated_at": "2024-11-16T02:17:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844851480",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851480"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1757,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1769,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851563",
      "pull_request_review_id": 2440195788,
      "id": 1844851563,
      "node_id": "PRRC_kwDOABII585t9jNr",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1841210613,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've reworded this comment.",
      "created_at": "2024-11-16T02:17:36Z",
      "updated_at": "2024-11-16T02:17:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844851563",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851563"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1765,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851603",
      "pull_request_review_id": 2440195833,
      "id": 1844851603,
      "node_id": "PRRC_kwDOABII585t9jOT",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844300642,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a comment",
      "created_at": "2024-11-16T02:17:44Z",
      "updated_at": "2024-11-16T02:17:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844851603",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1720,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1741,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851636",
      "pull_request_review_id": 2440195865,
      "id": 1844851636,
      "node_id": "PRRC_kwDOABII585t9jO0",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844302843,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Reworded the comment.",
      "created_at": "2024-11-16T02:17:52Z",
      "updated_at": "2024-11-16T02:17:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844851636",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1725,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851676",
      "pull_request_review_id": 2440195891,
      "id": 1844851676,
      "node_id": "PRRC_kwDOABII585t9jPc",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 26,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844305339,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a comment",
      "created_at": "2024-11-16T02:18:00Z",
      "updated_at": "2024-11-16T02:18:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844851676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1738,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851698",
      "pull_request_review_id": 2440195910,
      "id": 1844851698,
      "node_id": "PRRC_kwDOABII585t9jPy",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844306218,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-11-16T02:18:06Z",
      "updated_at": "2024-11-16T02:18:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844851698",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1742,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851723",
      "pull_request_review_id": 2440195925,
      "id": 1844851723,
      "node_id": "PRRC_kwDOABII585t9jQL",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844317743,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Reworded the comment.",
      "created_at": "2024-11-16T02:18:13Z",
      "updated_at": "2024-11-16T02:18:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844851723",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851723"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1745,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1746,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851735",
      "pull_request_review_id": 2440195946,
      "id": 1844851735,
      "node_id": "PRRC_kwDOABII585t9jQX",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // These are only spendable if the witness scripts is also spendable as a scriptPubKey\n+        // We will check these later after spks has been updated with spks from scripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // These scriptPubKeys have already been handled by dealing with the keys\n+        // However if these scripts are here, then the P2SH nested spk will be spendable if these are also scriptPubKeys\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n+            break;\n+        }\n+        case TxoutType::MULTISIG:\n+        {\n+            // Multisigs are only spendable if we have all of their keys\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Multisigs are always spendable inside of P2SH scripts\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // We need to have the P2WSH script for the P2WSH to be spendable.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1844326937,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Reworded the comment.",
      "created_at": "2024-11-16T02:18:23Z",
      "updated_at": "2024-11-16T02:18:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1844851735",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1844851735"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1772,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1845652266",
      "pull_request_review_id": 2441226741,
      "id": 1845652266,
      "node_id": "PRRC_kwDOABII585uAmsq",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n             }\n+            break;\n+        }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    // Lambda helper function to determine whether a script is valid, mainly looking at key compression requirements.\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        // Scripts with no nesting (arbitraty, unknown scripts) are always valid.\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // Taproot output scripts are always valid. Legacy wallets did not support Taproot spending so no nested inspection is required.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+            return ctx == ScriptContext::TOP;\n+        // P2PK in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && sols[0].size() != 33) return false;\n+            return true;\n+        // P2WPKH is allowed as an output script or in P2SH, but not inside of P2WSH\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        // P2PKH in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        // If the pubkey cannot be retrieved to check for compression, then the P2WSH-P2PKH is allowed.\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(sols[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        // P2SH is allowed only as an output script.\n+        // If the redeemScript is known, it must also be a valid script within P2SH.\n+        // If the redeemScript is not known, the P2SH output script is valid.\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(sols[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        // P2WSH is allowed as an output script or inside of P2SH, but not P2WSH.\n+        // If the witnessScript is known, it must also be a valid script within P2WSH.\n+        // If the witnessScript is not known, the P2WSH output script is valid.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            // CScriptID is the hash160 of the script. For P2WSH, we already have the SHA256 of the script,\n+            // so only RIPEMD160 of that is required to get the CScriptID for lookup.\n+            CScriptID script_id{RIPEMD160(sols[0])};\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2WSH);\n+            }\n+            return true;\n+        }\n+        // Multisig in any nesting level is valid, but inside of P2WSH, all pubkeys must be compressed.\n+        case TxoutType::MULTISIG:\n+        {\n+            if (ctx == ScriptContext::P2WSH) {\n+                std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+                if (!all_keys_compressed(keys)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        }\n+        assert(false);\n+    };\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& [id, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            // For a P2WSH output script to be spendable, we must know and inspect its witnessScript.\n+            if (GetCScript(id, witness_script) &&\n+                !witness_script.IsPayToScriptHash() && // P2SH inside of P2WSH is not allowed\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) && // Witness programs are not allowed inside of P2WSH\n+                // We only allow scripts that we would consider spendable as an output script.\n+                // Note that while this would exclude P2WSH-multisigs, we are already handling those in the first loop.\n+                spks.count(witness_script) > 0 &&\n+                // Pubkeys must be compressed.\n+                is_valid_script(script, ScriptContext::P2WSH)) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 193,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This call tests for P2WSH inside P2WSH and always returns `false`, hence the whole if condition is not fulfilled and the two lines below will never be executed (can be verified easily by putting an `assert(false)` in the body and running unit and wallet functional tests -- they still pass without crash). I assume this was meant to be\r\n```suggestion\r\n                is_valid_script(witness_script, ScriptContext::P2WSH)) {\r\n```\r\nIt's surprising though that the tests still passed. Either the tests are insufficient, or we really don't need this \"Iterate again for all the P2WSH scripts\" loop at all. :thinking: ",
      "created_at": "2024-11-17T21:12:05Z",
      "updated_at": "2024-11-17T21:12:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1845652266",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1845652266"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1889,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846226163",
      "pull_request_review_id": 2442077210,
      "id": 1846226163,
      "node_id": "PRRC_kwDOABII585uCyzz",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 7,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`Lambda`",
      "created_at": "2024-11-18T10:03:11Z",
      "updated_at": "2024-11-18T12:05:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1846226163",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846226163"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1720,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846279325",
      "pull_request_review_id": 2442077210,
      "id": 1846279325,
      "node_id": "PRRC_kwDOABII585uC_yd",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n             }\n+            break;\n+        }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    // Lambda helper function to determine whether a script is valid, mainly looking at key compression requirements.\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        // Scripts with no nesting (arbitraty, unknown scripts) are always valid.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`arbitrary`",
      "created_at": "2024-11-18T10:15:56Z",
      "updated_at": "2024-11-18T12:05:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1846279325",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846279325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1806,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846291918",
      "pull_request_review_id": 2442077210,
      "id": 1846291918,
      "node_id": "PRRC_kwDOABII585uDC3O",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n             }\n+            break;\n+        }\n         }\n     }\n \n+    enum class ScriptContext {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": 83,
      "original_position": 98,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We can't reuse `IsMineSigVersion` because it will be removed soon?\r\nCan we add few comments here like done in `IsMineSigVersion`? https://github.com/bitcoin/bitcoin/blob/28.x/src/wallet/scriptpubkeyman.cpp#L56-L67",
      "created_at": "2024-11-18T10:18:35Z",
      "updated_at": "2024-11-18T12:05:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1846291918",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846291918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1747,
      "original_line": 1747,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846392613",
      "pull_request_review_id": 2442077210,
      "id": 1846392613,
      "node_id": "PRRC_kwDOABII585uDbcl",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```diff\r\n- { return key.size() == 33; });\r\n+ { return key.size() == CPubKey::COMPRESSED_SIZE; });\r\n```\r\n\r\nThere's another usage down below as well on line 1816: https://github.com/bitcoin/bitcoin/commit/fa155991ff30bc001229e1d71bf44e8782f02d17#diff-55ce403d9c3440b4a38a261b7d452f84dd9a1d09b2a5ef1b4d3ac0c3567b9106R1816",
      "created_at": "2024-11-18T11:01:57Z",
      "updated_at": "2024-11-18T12:05:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1846392613",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846392613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1723,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846396195",
      "pull_request_review_id": 2442077210,
      "id": 1846396195,
      "node_id": "PRRC_kwDOABII585uDcUj",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1832978940,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```diff\r\n- std::vector<std::vector<unsigned char>> sols;\r\n+ std::vector<std::vector<unsigned char>> solutions;\r\n```\r\n\r\nAgree, would be easier to read.",
      "created_at": "2024-11-18T11:04:45Z",
      "updated_at": "2024-11-18T12:05:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1846396195",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846396195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846447833",
      "pull_request_review_id": 2442077210,
      "id": 1846447833,
      "node_id": "PRRC_kwDOABII585uDo7Z",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": 1846392613,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "There must be a reason for making `IsCompressedPublicKey()` here static, which I dont know about, otherwise, it could be used within `all_of` here, thereby getting rid of some logic duplication: https://github.com/bitcoin/bitcoin/blob/28.x/src/script/interpreter.cpp#L85 ",
      "created_at": "2024-11-18T11:45:05Z",
      "updated_at": "2024-11-18T12:05:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1846447833",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1846447833"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1723,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782223",
      "pull_request_review_id": 2446164372,
      "id": 1848782223,
      "node_id": "PRRC_kwDOABII585uMi2P",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n             }\n+            break;\n+        }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    // Lambda helper function to determine whether a script is valid, mainly looking at key compression requirements.\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        // Scripts with no nesting (arbitraty, unknown scripts) are always valid.\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // Taproot output scripts are always valid. Legacy wallets did not support Taproot spending so no nested inspection is required.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+            return ctx == ScriptContext::TOP;\n+        // P2PK in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && sols[0].size() != 33) return false;\n+            return true;\n+        // P2WPKH is allowed as an output script or in P2SH, but not inside of P2WSH\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        // P2PKH in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        // If the pubkey cannot be retrieved to check for compression, then the P2WSH-P2PKH is allowed.\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(sols[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        // P2SH is allowed only as an output script.\n+        // If the redeemScript is known, it must also be a valid script within P2SH.\n+        // If the redeemScript is not known, the P2SH output script is valid.\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(sols[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        // P2WSH is allowed as an output script or inside of P2SH, but not P2WSH.\n+        // If the witnessScript is known, it must also be a valid script within P2WSH.\n+        // If the witnessScript is not known, the P2WSH output script is valid.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            // CScriptID is the hash160 of the script. For P2WSH, we already have the SHA256 of the script,\n+            // so only RIPEMD160 of that is required to get the CScriptID for lookup.\n+            CScriptID script_id{RIPEMD160(sols[0])};\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2WSH);\n+            }\n+            return true;\n+        }\n+        // Multisig in any nesting level is valid, but inside of P2WSH, all pubkeys must be compressed.\n+        case TxoutType::MULTISIG:\n+        {\n+            if (ctx == ScriptContext::P2WSH) {\n+                std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+                if (!all_keys_compressed(keys)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        }\n+        assert(false);\n+    };\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& [id, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            // For a P2WSH output script to be spendable, we must know and inspect its witnessScript.\n+            if (GetCScript(id, witness_script) &&\n+                !witness_script.IsPayToScriptHash() && // P2SH inside of P2WSH is not allowed\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) && // Witness programs are not allowed inside of P2WSH\n+                // We only allow scripts that we would consider spendable as an output script.\n+                // Note that while this would exclude P2WSH-multisigs, we are already handling those in the first loop.\n+                spks.count(witness_script) > 0 &&\n+                // Pubkeys must be compressed.\n+                is_valid_script(script, ScriptContext::P2WSH)) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 193,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": 1845652266,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hmm, the test that is supposed to fail here is passing because the P2WSH scriptPubKey also ends up in the `setWatchOnly` so it is added when we iterate those.\r\n\r\nI think if the wallet was used normally, this loop probably isn't necessary. However, I am hesitant to remove it as in theory, if a P2WSH were in `mapScripts` and not in `setWatchOnly`, we would miss it but `IsMine()` would've still allowed it. I think the only way to get that though is through direct modification of the wallet file or with `importwallet` shenanigans.\r\n\r\nFixed it, but will continue thinking on a test.",
      "created_at": "2024-11-19T17:31:50Z",
      "updated_at": "2024-11-19T17:31:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1848782223",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782223"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1889,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782387",
      "pull_request_review_id": 2446164632,
      "id": 1848782387,
      "node_id": "PRRC_kwDOABII585uMi4z",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 7,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": 1846226163,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-11-19T17:31:57Z",
      "updated_at": "2024-11-19T17:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1848782387",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1720,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782476",
      "pull_request_review_id": 2446164780,
      "id": 1848782476,
      "node_id": "PRRC_kwDOABII585uMi6M",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n             }\n+            break;\n+        }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    // Lambda helper function to determine whether a script is valid, mainly looking at key compression requirements.\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        // Scripts with no nesting (arbitraty, unknown scripts) are always valid.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": 1846279325,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-11-19T17:32:02Z",
      "updated_at": "2024-11-19T17:32:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1848782476",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782476"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1806,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782538",
      "pull_request_review_id": 2446164884,
      "id": 1848782538,
      "node_id": "PRRC_kwDOABII585uMi7K",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n             }\n+            break;\n+        }\n         }\n     }\n \n+    enum class ScriptContext {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": 83,
      "original_position": 98,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": 1846291918,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-11-19T17:32:05Z",
      "updated_at": "2024-11-19T17:32:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1848782538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1747,
      "original_line": 1747,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782692",
      "pull_request_review_id": 2446165118,
      "id": 1848782692,
      "node_id": "PRRC_kwDOABII585uMi9k",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": 1846392613,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-11-19T17:32:13Z",
      "updated_at": "2024-11-19T17:32:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1848782692",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1723,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782930",
      "pull_request_review_id": 2446165470,
      "id": 1848782930,
      "node_id": "PRRC_kwDOABII585uMjBS",
      "diff_hunk": "@@ -1717,42 +1717,160 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // Insert every P2PK, P2PKH, and P2WPKH script. Multisigs are only included if we know\n+    // all of the keys (matches legacy wallet IsMine behavior).\n     // The watchonly ones will be in setWatchOnly which we deal with later\n     // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "4a1009f90e05ddde4a7f95e53fa16b8590140dac",
      "in_reply_to_id": 1832978940,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Renamed",
      "created_at": "2024-11-19T17:32:23Z",
      "updated_at": "2024-11-19T17:32:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1848782930",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848782930"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1851112761",
      "pull_request_review_id": 2449905553,
      "id": 1851112761,
      "node_id": "PRRC_kwDOABII585uVb05",
      "diff_hunk": "@@ -1717,42 +1717,187 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n+    // Lamba helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == 33; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n     for (const auto& script_pair : mapScripts) {\n         const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::SCRIPTHASH:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(sols[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n+            }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n             }\n+            break;\n+        }\n         }\n     }\n \n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    // Lambda helper function to determine whether a script is valid, mainly looking at key compression requirements.\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> sols;\n+        TxoutType spk_type = Solver(script, sols);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        // Scripts with no nesting (arbitraty, unknown scripts) are always valid.\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // Taproot output scripts are always valid. Legacy wallets did not support Taproot spending so no nested inspection is required.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+            return ctx == ScriptContext::TOP;\n+        // P2PK in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && sols[0].size() != 33) return false;\n+            return true;\n+        // P2WPKH is allowed as an output script or in P2SH, but not inside of P2WSH\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        // P2PKH in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        // If the pubkey cannot be retrieved to check for compression, then the P2WSH-P2PKH is allowed.\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(sols[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        // P2SH is allowed only as an output script.\n+        // If the redeemScript is known, it must also be a valid script within P2SH.\n+        // If the redeemScript is not known, the P2SH output script is valid.\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(sols[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        // P2WSH is allowed as an output script or inside of P2SH, but not P2WSH.\n+        // If the witnessScript is known, it must also be a valid script within P2WSH.\n+        // If the witnessScript is not known, the P2WSH output script is valid.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            // CScriptID is the hash160 of the script. For P2WSH, we already have the SHA256 of the script,\n+            // so only RIPEMD160 of that is required to get the CScriptID for lookup.\n+            CScriptID script_id{RIPEMD160(sols[0])};\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2WSH);\n+            }\n+            return true;\n+        }\n+        // Multisig in any nesting level is valid, but inside of P2WSH, all pubkeys must be compressed.\n+        case TxoutType::MULTISIG:\n+        {\n+            if (ctx == ScriptContext::P2WSH) {\n+                std::vector<std::vector<unsigned char>> keys(sols.begin() + 1, sols.begin() + sols.size() - 1);\n+                if (!all_keys_compressed(keys)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        }\n+        assert(false);\n+    };\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& [id, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> sols;\n+        TxoutType type = Solver(script, sols);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            // For a P2WSH output script to be spendable, we must know and inspect its witnessScript.\n+            if (GetCScript(id, witness_script) &&\n+                !witness_script.IsPayToScriptHash() && // P2SH inside of P2WSH is not allowed\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) && // Witness programs are not allowed inside of P2WSH\n+                // We only allow scripts that we would consider spendable as an output script.\n+                // Note that while this would exclude P2WSH-multisigs, we are already handling those in the first loop.\n+                spks.count(witness_script) > 0 &&\n+                // Pubkeys must be compressed.\n+                is_valid_script(script, ScriptContext::P2WSH)) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 193,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "fa155991ff30bc001229e1d71bf44e8782f02d17",
      "in_reply_to_id": 1845652266,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was able to contrive a test that requires this loop, which also revealed a bug.\r\n\r\nThe situation is if a `sh(wsh(pkh()))` is imported with `importmulti`, the `wsh(pkh())` will only be in `mapScripts`. However, this `wsh(pkh())` is still `ISMINE_SPENDABLE` and coins sent to it will be seen by the wallet. This loop is where that would be detected.",
      "created_at": "2024-11-20T23:26:05Z",
      "updated_at": "2024-11-20T23:26:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1851112761",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1851112761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1889,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1852300265",
      "pull_request_review_id": 2451750295,
      "id": 1852300265,
      "node_id": "PRRC_kwDOABII585uZ9vp",
      "diff_hunk": "@@ -1717,42 +1717,193 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 42,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "97893b124a072f9111942f3e572c9637c51dd481",
      "in_reply_to_id": null,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "comment: -there",
      "created_at": "2024-11-21T14:57:54Z",
      "updated_at": "2024-11-22T11:18:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1852300265",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1852300265"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1732,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1852336507",
      "pull_request_review_id": 2451750295,
      "id": 1852336507,
      "node_id": "PRRC_kwDOABII585uaGl7",
      "diff_hunk": "@@ -1717,42 +1717,193 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 101,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "97893b124a072f9111942f3e572c9637c51dd481",
      "in_reply_to_id": null,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe add an assertion on `solutions.size() >= 2`,as an internal check against future bugs in Solve (and maybe also in other places before the solutions vector is indexed).",
      "created_at": "2024-11-21T15:17:38Z",
      "updated_at": "2024-11-22T11:18:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1852336507",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1852336507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1778,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1853729309",
      "pull_request_review_id": 2451750295,
      "id": 1853729309,
      "node_id": "PRRC_kwDOABII585ufaod",
      "diff_hunk": "@@ -1717,42 +1717,193 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 64,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "97893b124a072f9111942f3e572c9637c51dd481",
      "in_reply_to_id": null,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "comment: in \"spks\"",
      "created_at": "2024-11-22T10:54:44Z",
      "updated_at": "2024-11-22T11:18:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1853729309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1853729309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1754,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1853733972",
      "pull_request_review_id": 2451750295,
      "id": 1853733972,
      "node_id": "PRRC_kwDOABII585ufbxU",
      "diff_hunk": "@@ -1717,42 +1717,193 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "97893b124a072f9111942f3e572c9637c51dd481",
      "in_reply_to_id": null,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Doing both inserting into and reading from spks here makes it somewhat harder to be confident that the behavior is independent from the specific order of processing mapScripts, but the comment above helps.",
      "created_at": "2024-11-22T10:58:24Z",
      "updated_at": "2024-11-22T11:18:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1853733972",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1853733972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1757,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1856939888",
      "pull_request_review_id": 2458976059,
      "id": 1856939888,
      "node_id": "PRRC_kwDOABII585urqdw",
      "diff_hunk": "@@ -1717,42 +1717,193 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n             }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n+            }\n+            break;\n+        }\n         }\n     }\n \n+    // Enum to track the execution context of a script, similar to the script interpreter's SigVersion.\n+    // It is separate to distinguish between top level scriptPubKey execution and P2SH redeemScript execution\n+    // which SigVersion does not distinguish. It also excludes Taproot and Tapscript as the legacy wallet\n+    // never supported those.\n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    // Lambda helper function to determine whether a script is valid, mainly looking at key compression requirements.\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> solutions;\n+        TxoutType spk_type = Solver(script, solutions);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        // Scripts with no nesting (arbitrary, unknown scripts) are always valid.\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // Taproot output scripts are always valid. Legacy wallets did not support Taproot spending so no nested inspection is required.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+            return ctx == ScriptContext::TOP;\n+        // P2PK in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && solutions[0].size() != CPubKey::COMPRESSED_SIZE) return false;\n+            return true;\n+        // P2WPKH is allowed as an output script or in P2SH, but not inside of P2WSH\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        // P2PKH in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        // If the pubkey cannot be retrieved to check for compression, then the P2WSH-P2PKH is allowed.\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(solutions[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        // P2SH is allowed only as an output script.\n+        // If the redeemScript is known, it must also be a valid script within P2SH.\n+        // If the redeemScript is not known, the P2SH output script is valid.\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(solutions[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        // P2WSH is allowed as an output script or inside of P2SH, but not P2WSH.\n+        // If the witnessScript is known, it must also be a valid script within P2WSH.\n+        // If the witnessScript is not known, the P2WSH output script is valid.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            // CScriptID is the hash160 of the script. For P2WSH, we already have the SHA256 of the script,\n+            // so only RIPEMD160 of that is required to get the CScriptID for lookup.\n+            CScriptID script_id{RIPEMD160(solutions[0])};\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2WSH);\n+            }\n+            return true;\n+        }\n+        // Multisig in any nesting level is valid, but inside of P2WSH, all pubkeys must be compressed.\n+        case TxoutType::MULTISIG:\n+        {\n+            if (ctx == ScriptContext::P2WSH) {\n+                std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+                if (!all_keys_compressed(keys)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        }\n+        assert(false);\n+    };\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& [id, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            CScriptID script_id{RIPEMD160(solutions[0])};\n+            // For a P2WSH output script to be spendable, we must know and inspect its witnessScript.\n+            if (GetCScript(script_id, witness_script) &&\n+                !witness_script.IsPayToScriptHash() && // P2SH inside of P2WSH is not allowed\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) && // Witness programs are not allowed inside of P2WSH",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 196,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "a5a81cf7bc380273a4678bcb843319b2fdaa9f1b",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It seems that these conditions are not needed, as the checks are done in `is_valid_script` below anyway (see `Solver` cases `TxoutType::SCRIPTHASH` and `TxoutType::WITNESS_V...`)?\r\n```suggestion\r\n```\r\nTests still pass without them.",
      "created_at": "2024-11-25T16:44:46Z",
      "updated_at": "2024-11-25T16:44:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1856939888",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1856939888"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1889,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1890,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1871951292",
      "pull_request_review_id": 2482657449,
      "id": 1871951292,
      "node_id": "PRRC_kwDOABII585vk7W8",
      "diff_hunk": "@@ -1717,42 +1717,193 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 42,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "97893b124a072f9111942f3e572c9637c51dd481",
      "in_reply_to_id": 1852300265,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-12-05T19:13:06Z",
      "updated_at": "2024-12-05T19:13:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1871951292",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1871951292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1732,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1871951364",
      "pull_request_review_id": 2482657565,
      "id": 1871951364,
      "node_id": "PRRC_kwDOABII585vk7YE",
      "diff_hunk": "@@ -1717,42 +1717,193 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 101,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "97893b124a072f9111942f3e572c9637c51dd481",
      "in_reply_to_id": 1852336507,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-12-05T19:13:09Z",
      "updated_at": "2024-12-05T19:13:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1871951364",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1871951364"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1778,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1871951566",
      "pull_request_review_id": 2482657974,
      "id": 1871951566,
      "node_id": "PRRC_kwDOABII585vk7bO",
      "diff_hunk": "@@ -1717,42 +1717,193 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 64,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "97893b124a072f9111942f3e572c9637c51dd481",
      "in_reply_to_id": 1853729309,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-12-05T19:13:24Z",
      "updated_at": "2024-12-05T19:13:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1871951566",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1871951566"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1754,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1871951767",
      "pull_request_review_id": 2482658275,
      "id": 1871951767,
      "node_id": "PRRC_kwDOABII585vk7eX",
      "diff_hunk": "@@ -1717,42 +1717,193 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if there its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spk\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n             }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n+            }\n+            break;\n+        }\n         }\n     }\n \n+    // Enum to track the execution context of a script, similar to the script interpreter's SigVersion.\n+    // It is separate to distinguish between top level scriptPubKey execution and P2SH redeemScript execution\n+    // which SigVersion does not distinguish. It also excludes Taproot and Tapscript as the legacy wallet\n+    // never supported those.\n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    // Lambda helper function to determine whether a script is valid, mainly looking at key compression requirements.\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> solutions;\n+        TxoutType spk_type = Solver(script, solutions);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        // Scripts with no nesting (arbitrary, unknown scripts) are always valid.\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // Taproot output scripts are always valid. Legacy wallets did not support Taproot spending so no nested inspection is required.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+            return ctx == ScriptContext::TOP;\n+        // P2PK in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && solutions[0].size() != CPubKey::COMPRESSED_SIZE) return false;\n+            return true;\n+        // P2WPKH is allowed as an output script or in P2SH, but not inside of P2WSH\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        // P2PKH in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        // If the pubkey cannot be retrieved to check for compression, then the P2WSH-P2PKH is allowed.\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(solutions[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        // P2SH is allowed only as an output script.\n+        // If the redeemScript is known, it must also be a valid script within P2SH.\n+        // If the redeemScript is not known, the P2SH output script is valid.\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(solutions[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        // P2WSH is allowed as an output script or inside of P2SH, but not P2WSH.\n+        // If the witnessScript is known, it must also be a valid script within P2WSH.\n+        // If the witnessScript is not known, the P2WSH output script is valid.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            // CScriptID is the hash160 of the script. For P2WSH, we already have the SHA256 of the script,\n+            // so only RIPEMD160 of that is required to get the CScriptID for lookup.\n+            CScriptID script_id{RIPEMD160(solutions[0])};\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2WSH);\n+            }\n+            return true;\n+        }\n+        // Multisig in any nesting level is valid, but inside of P2WSH, all pubkeys must be compressed.\n+        case TxoutType::MULTISIG:\n+        {\n+            if (ctx == ScriptContext::P2WSH) {\n+                std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+                if (!all_keys_compressed(keys)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        }\n+        assert(false);\n+    };\n+    // Iterate again for all the P2WSH scripts\n+    for (const auto& [id, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        if (type == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+            CScript witness_script;\n+            int wit_ver = -1;\n+            std::vector<unsigned char> wit_prog;\n+            CScriptID script_id{RIPEMD160(solutions[0])};\n+            // For a P2WSH output script to be spendable, we must know and inspect its witnessScript.\n+            if (GetCScript(script_id, witness_script) &&\n+                !witness_script.IsPayToScriptHash() && // P2SH inside of P2WSH is not allowed\n+                !witness_script.IsWitnessProgram(wit_ver, wit_prog) && // Witness programs are not allowed inside of P2WSH",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 196,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "a5a81cf7bc380273a4678bcb843319b2fdaa9f1b",
      "in_reply_to_id": 1856939888,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed they are redundant, removed.",
      "created_at": "2024-12-05T19:13:35Z",
      "updated_at": "2024-12-05T19:13:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1871951767",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1871951767"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1889,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1890,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873916913",
      "pull_request_review_id": 2485761578,
      "id": 1873916913,
      "node_id": "PRRC_kwDOABII585vsbPx",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")",
      "path": "test/functional/wallet_migration.py",
      "position": null,
      "original_position": 23,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe: \"test that non-multisig P2WSH output scripts are migrated\"",
      "created_at": "2024-12-06T20:04:34Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1873916913",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873916913"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1018,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873919286",
      "pull_request_review_id": 2485761578,
      "id": 1873919286,
      "node_id": "PRRC_kwDOABII585vsb02",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"p2wsh\")\n+\n+        # Craft wsh(pkh(key))\n+        pubkey = wallet.getaddressinfo(wallet.getnewaddress())[\"pubkey\"]\n+        pkh_script = key_to_p2pkh_script(pubkey).hex()\n+        wsh_pkh_script = script_to_p2wsh_script(pkh_script).hex()\n+        wsh_pkh_addr = script_to_p2wsh(pkh_script)\n+\n+        wallet.importaddress(address=pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_pkh_script, p2sh=False)\n+\n+        def_wallet.sendtoaddress(wsh_pkh_addr, 5)\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+\n+        wallet.migratewallet()",
      "path": "test/functional/wallet_migration.py",
      "position": null,
      "original_position": 41,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is there any way that you convince the test reader some more here that something happened with the wallet that might cause doing the same thing below is actually not just a no-op?",
      "created_at": "2024-12-06T20:07:09Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1873919286",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873919286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1036,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873934117",
      "pull_request_review_id": 2485761578,
      "id": 1873934117,
      "node_id": "PRRC_kwDOABII585vsfcl",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"p2wsh\")\n+\n+        # Craft wsh(pkh(key))\n+        pubkey = wallet.getaddressinfo(wallet.getnewaddress())[\"pubkey\"]\n+        pkh_script = key_to_p2pkh_script(pubkey).hex()\n+        wsh_pkh_script = script_to_p2wsh_script(pkh_script).hex()\n+        wsh_pkh_addr = script_to_p2wsh(pkh_script)\n+\n+        wallet.importaddress(address=pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_pkh_script, p2sh=False)\n+\n+        def_wallet.sendtoaddress(wsh_pkh_addr, 5)\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+\n+        wallet.migratewallet()\n+\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+        addr_info = wallet.getaddressinfo(wsh_pkh_addr)\n+        assert_equal(addr_info[\"ismine\"], True)\n+        assert_equal(addr_info[\"iswatchonly\"], False)\n+        assert_equal(addr_info[\"solvable\"], True)\n+\n+        wallet.unloadwallet()\n+\n+    def test_disallowed_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts with invalid witnessScripts are not migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"invalid_p2wsh\")\n+\n+        invalid_addrs = []\n+\n+        # Create wsh(pkh()) with both a compressed and an uncompressed private key\n+        # Although we create an sh(wsh(pkh())), we don't care about the sh(), just the wsh(pkh())\n+        # Wrapping it with sh() is just to avoid inserting the wsh(pkh()) into setWatchOnly\n+        # The one with the compressed key will be valid, while the one with the uncompressed will not\n+        # The sh(pkh()) will be valid, while wsh(pkh()) will not\n+        comp_eckey = ECKey()\n+        comp_eckey.generate(compressed=True)\n+        comp_pubkey = comp_eckey.get_pubkey().get_bytes().hex()\n+        comp_pkh_script = key_to_p2pkh_script(comp_pubkey).hex()\n+        comp_wsh_pkh_script = script_to_p2wsh_script(comp_pkh_script).hex()\n+        comp_sh_wsh_pkh_script = script_to_p2sh_script(comp_wsh_pkh_script).hex()\n+        comp_wsh_pkh_addr = script_to_p2wsh(comp_pkh_script)\n+\n+        uncomp_eckey = ECKey()\n+        uncomp_eckey.generate(compressed=False)\n+        uncomp_pubkey = uncomp_eckey.get_pubkey().get_bytes().hex()\n+        uncomp_pkh_script = key_to_p2pkh_script(uncomp_pubkey).hex()\n+        uncomp_wsh_pkh_script = script_to_p2wsh_script(uncomp_pkh_script).hex()\n+        uncomp_sh_wsh_pkh_script = script_to_p2sh_script(uncomp_wsh_pkh_script).hex()\n+        uncomp_wsh_pkh_addr = script_to_p2wsh(uncomp_pkh_script)\n+        invalid_addrs.append(uncomp_wsh_pkh_addr)\n+\n+        # Import them with importmulti to prevent the wsh(pkh()) from going into setWatchOnly\n+        # Use importmulti for the sh(wsh(pkh())) to prevent the wsh(pkh()) from going into setWatchOnly\n+        import_res = wallet.importmulti([\n+            {\n+                \"scriptPubKey\": comp_sh_wsh_pkh_script,\n+                \"timestamp\": \"now\",\n+                \"redeemscript\": comp_wsh_pkh_script,\n+                \"witnessscript\": comp_pkh_script,\n+                \"keys\": [\n+                    byte_to_base58(comp_eckey.get_bytes() + b\"\\x01\", 239),\n+                ],\n+            },\n+            {\n+                \"scriptPubKey\": uncomp_sh_wsh_pkh_script,\n+                \"timestamp\": \"now\",\n+                \"redeemscript\": uncomp_wsh_pkh_script,\n+                \"witnessscript\": uncomp_pkh_script,\n+                \"keys\": [\n+                    byte_to_base58(uncomp_eckey.get_bytes(), 239),\n+                ],\n+            },\n+        ])\n+        assert_equal(import_res[0][\"success\"], True)\n+        assert_equal(import_res[1][\"success\"], True)\n+\n+        # Create a wsh(sh(pkh())) - P2SH inside of P2WSH is invalid\n+        comp_sh_pkh_script = script_to_p2sh_script(comp_pkh_script).hex()\n+        wsh_sh_pkh_script = script_to_p2wsh_script(comp_sh_pkh_script).hex()\n+        wsh_sh_pkh_addr = script_to_p2wsh(comp_sh_pkh_script)\n+        invalid_addrs.append(wsh_sh_pkh_addr)\n+\n+        # Import wsh(sh(pkh()))\n+        wallet.importaddress(address=comp_sh_pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_sh_pkh_script, p2sh=False)\n+\n+        # Create a wsh(wsh(pkh())) - P2WSH inside of P2WSH is invalid\n+        wsh_wsh_pkh_script = script_to_p2wsh_script(comp_wsh_pkh_script).hex()\n+        wsh_wsh_pkh_addr = script_to_p2wsh(comp_wsh_pkh_script)\n+        invalid_addrs.append(wsh_wsh_pkh_addr)\n+\n+        # Import wsh(wsh(pkh()))\n+        wallet.importaddress(address=wsh_wsh_pkh_script, p2sh=False)\n+\n+        comp_wsh_pkh_addr_info = wallet.getaddressinfo(comp_wsh_pkh_addr)\n+        assert_equal(comp_wsh_pkh_addr_info[\"ismine\"], True)\n+        assert_equal(comp_wsh_pkh_addr_info[\"iswatchonly\"], False)\n+        assert \"embedded\" in comp_wsh_pkh_addr_info\n+\n+        for addr in invalid_addrs:\n+            addr_info = wallet.getaddressinfo(addr)\n+            assert_equal(addr_info[\"ismine\"], False)\n+            assert_equal(addr_info[\"iswatchonly\"], False)",
      "path": "test/functional/wallet_migration.py",
      "position": 160,
      "original_position": 132,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You could clarify the role of \"embedded\" here. My understanding is that the presence of it indicates that the imported data is present, which qualifies the two false results above.",
      "created_at": "2024-12-06T20:21:19Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1873934117",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873934117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1133,
      "original_line": 1133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873937684",
      "pull_request_review_id": 2485761578,
      "id": 1873937684,
      "node_id": "PRRC_kwDOABII585vsgUU",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"p2wsh\")\n+\n+        # Craft wsh(pkh(key))\n+        pubkey = wallet.getaddressinfo(wallet.getnewaddress())[\"pubkey\"]\n+        pkh_script = key_to_p2pkh_script(pubkey).hex()\n+        wsh_pkh_script = script_to_p2wsh_script(pkh_script).hex()\n+        wsh_pkh_addr = script_to_p2wsh(pkh_script)\n+\n+        wallet.importaddress(address=pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_pkh_script, p2sh=False)\n+\n+        def_wallet.sendtoaddress(wsh_pkh_addr, 5)\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+\n+        wallet.migratewallet()\n+\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+        addr_info = wallet.getaddressinfo(wsh_pkh_addr)\n+        assert_equal(addr_info[\"ismine\"], True)\n+        assert_equal(addr_info[\"iswatchonly\"], False)\n+        assert_equal(addr_info[\"solvable\"], True)\n+\n+        wallet.unloadwallet()\n+\n+    def test_disallowed_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts with invalid witnessScripts are not migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"invalid_p2wsh\")\n+\n+        invalid_addrs = []\n+\n+        # Create wsh(pkh()) with both a compressed and an uncompressed private key\n+        # Although we create an sh(wsh(pkh())), we don't care about the sh(), just the wsh(pkh())\n+        # Wrapping it with sh() is just to avoid inserting the wsh(pkh()) into setWatchOnly\n+        # The one with the compressed key will be valid, while the one with the uncompressed will not\n+        # The sh(pkh()) will be valid, while wsh(pkh()) will not\n+        comp_eckey = ECKey()\n+        comp_eckey.generate(compressed=True)\n+        comp_pubkey = comp_eckey.get_pubkey().get_bytes().hex()\n+        comp_pkh_script = key_to_p2pkh_script(comp_pubkey).hex()\n+        comp_wsh_pkh_script = script_to_p2wsh_script(comp_pkh_script).hex()\n+        comp_sh_wsh_pkh_script = script_to_p2sh_script(comp_wsh_pkh_script).hex()\n+        comp_wsh_pkh_addr = script_to_p2wsh(comp_pkh_script)\n+\n+        uncomp_eckey = ECKey()\n+        uncomp_eckey.generate(compressed=False)\n+        uncomp_pubkey = uncomp_eckey.get_pubkey().get_bytes().hex()\n+        uncomp_pkh_script = key_to_p2pkh_script(uncomp_pubkey).hex()\n+        uncomp_wsh_pkh_script = script_to_p2wsh_script(uncomp_pkh_script).hex()\n+        uncomp_sh_wsh_pkh_script = script_to_p2sh_script(uncomp_wsh_pkh_script).hex()\n+        uncomp_wsh_pkh_addr = script_to_p2wsh(uncomp_pkh_script)\n+        invalid_addrs.append(uncomp_wsh_pkh_addr)\n+\n+        # Import them with importmulti to prevent the wsh(pkh()) from going into setWatchOnly\n+        # Use importmulti for the sh(wsh(pkh())) to prevent the wsh(pkh()) from going into setWatchOnly\n+        import_res = wallet.importmulti([\n+            {\n+                \"scriptPubKey\": comp_sh_wsh_pkh_script,\n+                \"timestamp\": \"now\",\n+                \"redeemscript\": comp_wsh_pkh_script,\n+                \"witnessscript\": comp_pkh_script,\n+                \"keys\": [\n+                    byte_to_base58(comp_eckey.get_bytes() + b\"\\x01\", 239),\n+                ],\n+            },\n+            {\n+                \"scriptPubKey\": uncomp_sh_wsh_pkh_script,\n+                \"timestamp\": \"now\",\n+                \"redeemscript\": uncomp_wsh_pkh_script,\n+                \"witnessscript\": uncomp_pkh_script,\n+                \"keys\": [\n+                    byte_to_base58(uncomp_eckey.get_bytes(), 239),\n+                ],\n+            },\n+        ])\n+        assert_equal(import_res[0][\"success\"], True)\n+        assert_equal(import_res[1][\"success\"], True)\n+\n+        # Create a wsh(sh(pkh())) - P2SH inside of P2WSH is invalid\n+        comp_sh_pkh_script = script_to_p2sh_script(comp_pkh_script).hex()\n+        wsh_sh_pkh_script = script_to_p2wsh_script(comp_sh_pkh_script).hex()\n+        wsh_sh_pkh_addr = script_to_p2wsh(comp_sh_pkh_script)\n+        invalid_addrs.append(wsh_sh_pkh_addr)\n+\n+        # Import wsh(sh(pkh()))\n+        wallet.importaddress(address=comp_sh_pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_sh_pkh_script, p2sh=False)\n+\n+        # Create a wsh(wsh(pkh())) - P2WSH inside of P2WSH is invalid\n+        wsh_wsh_pkh_script = script_to_p2wsh_script(comp_wsh_pkh_script).hex()\n+        wsh_wsh_pkh_addr = script_to_p2wsh(comp_wsh_pkh_script)\n+        invalid_addrs.append(wsh_wsh_pkh_addr)\n+\n+        # Import wsh(wsh(pkh()))\n+        wallet.importaddress(address=wsh_wsh_pkh_script, p2sh=False)\n+\n+        comp_wsh_pkh_addr_info = wallet.getaddressinfo(comp_wsh_pkh_addr)\n+        assert_equal(comp_wsh_pkh_addr_info[\"ismine\"], True)\n+        assert_equal(comp_wsh_pkh_addr_info[\"iswatchonly\"], False)\n+        assert \"embedded\" in comp_wsh_pkh_addr_info\n+\n+        for addr in invalid_addrs:\n+            addr_info = wallet.getaddressinfo(addr)\n+            assert_equal(addr_info[\"ismine\"], False)\n+            assert_equal(addr_info[\"iswatchonly\"], False)\n+            assert \"embedded\" in addr_info\n+\n+        # Fund those output scripts\n+        def_wallet.send([{comp_wsh_pkh_addr: 1}] + [{k: i + 1} for i, k in enumerate(invalid_addrs)])\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()[\"mine\"][\"trusted\"], 1)\n+\n+        wallet.migratewallet()\n+\n+        assert_equal(wallet.getbalances()[\"mine\"][\"trusted\"], 1)\n+\n+        comp_wsh_pkh_addr_info = wallet.getaddressinfo(comp_wsh_pkh_addr)\n+        assert_equal(comp_wsh_pkh_addr_info[\"ismine\"], True)\n+        assert_equal(comp_wsh_pkh_addr_info[\"iswatchonly\"], False)\n+        assert \"embedded\" in comp_wsh_pkh_addr_info\n+\n+        for addr in invalid_addrs:\n+            addr_info = wallet.getaddressinfo(addr)\n+            assert_equal(addr_info[\"ismine\"], False)\n+            assert_equal(addr_info[\"iswatchonly\"], False)\n+            assert \"embedded\" not in addr_info",
      "path": "test/functional/wallet_migration.py",
      "position": 186,
      "original_position": 153,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Please highlight that only this line differs and what that indicates.",
      "created_at": "2024-12-06T20:24:49Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1873937684",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873937684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1159,
      "original_line": 1159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873953323",
      "pull_request_review_id": 2485761578,
      "id": 1873953323,
      "node_id": "PRRC_kwDOABII585vskIr",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"p2wsh\")\n+\n+        # Craft wsh(pkh(key))\n+        pubkey = wallet.getaddressinfo(wallet.getnewaddress())[\"pubkey\"]\n+        pkh_script = key_to_p2pkh_script(pubkey).hex()\n+        wsh_pkh_script = script_to_p2wsh_script(pkh_script).hex()\n+        wsh_pkh_addr = script_to_p2wsh(pkh_script)\n+\n+        wallet.importaddress(address=pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_pkh_script, p2sh=False)\n+\n+        def_wallet.sendtoaddress(wsh_pkh_addr, 5)\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+\n+        wallet.migratewallet()\n+\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+        addr_info = wallet.getaddressinfo(wsh_pkh_addr)\n+        assert_equal(addr_info[\"ismine\"], True)\n+        assert_equal(addr_info[\"iswatchonly\"], False)\n+        assert_equal(addr_info[\"solvable\"], True)\n+\n+        wallet.unloadwallet()\n+\n+    def test_disallowed_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts with invalid witnessScripts are not migrated\")",
      "path": "test/functional/wallet_migration.py",
      "position": null,
      "original_position": 52,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is it important to test that an invalid script that we can import for historical reasons is not migrated? Are we testing that these artifacts do not cause the migration to fail rather than them not being migrated?",
      "created_at": "2024-12-06T20:34:29Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1873953323",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1873953323"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1047,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874014319",
      "pull_request_review_id": 2485761578,
      "id": 1874014319,
      "node_id": "PRRC_kwDOABII585vszBv",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 40,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Perhaps rephrase this:\r\n\r\nP2SH outputs are tracked in legacy wallets per their redeemscripts. Redeemscripts only are used in the input script, and do not directly appear in spks. We will later generate the corresponding spks from the redeemscripts and can skip P2SH outputs here.",
      "created_at": "2024-12-06T21:28:27Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874014319",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874014319"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1747,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1748,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874054743",
      "pull_request_review_id": 2485761578,
      "id": 1874054743,
      "node_id": "PRRC_kwDOABII585vs85X",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spks\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why are we not generating the relevant spks for all keys directly in the initial loop? It would just mean that we would now perhaps recognize and be able to spend more output script types than before, so they should simply not appear in our history, but it might make the code simpler?",
      "created_at": "2024-12-06T22:15:39Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874054743",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874054743"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1762,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1769,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874058059",
      "pull_request_review_id": 2485761578,
      "id": 1874058059,
      "node_id": "PRRC_kwDOABII585vs9tL",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spks\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            Assert(solutions.size() >= 2);",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 83,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Errr, can a multisig be 0 of 0? If so, wouldn’t that only have a solution size of 1?",
      "created_at": "2024-12-06T22:21:11Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874058059",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874058059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1777,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874063348",
      "pull_request_review_id": 2485761578,
      "id": 1874063348,
      "node_id": "PRRC_kwDOABII585vs-_0",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spks\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            Assert(solutions.size() >= 2);\n+            std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n             }",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "At this point, the witness program, witness script, or redeemscript is in our mapScript, and we might have enough keys for the quorum but just not all of the keys.\r\n\r\nWhy does this require all the keys to be present in the wallet rather than just the threshold?",
      "created_at": "2024-12-06T22:27:39Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874063348",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874063348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1779,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1781,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874092015",
      "pull_request_review_id": 2485761578,
      "id": 1874092015,
      "node_id": "PRRC_kwDOABII585vtF_v",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spks\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            Assert(solutions.size() >= 2);\n+            std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n             }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n+            }\n+            break;\n+        }\n         }\n     }\n \n+    // Enum to track the execution context of a script, similar to the script interpreter's SigVersion.\n+    // It is separate to distinguish between top level scriptPubKey execution and P2SH redeemScript execution\n+    // which SigVersion does not distinguish. It also excludes Taproot and Tapscript as the legacy wallet\n+    // never supported those.\n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    // Lambda helper function to determine whether a script is valid, mainly looking at key compression requirements.\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> solutions;\n+        TxoutType spk_type = Solver(script, solutions);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        // Scripts with no nesting (arbitrary, unknown scripts) are always valid.\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // Taproot output scripts are always valid. Legacy wallets did not support Taproot spending so no nested inspection is required.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+            return ctx == ScriptContext::TOP;\n+        // P2PK in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && solutions[0].size() != CPubKey::COMPRESSED_SIZE) return false;\n+            return true;\n+        // P2WPKH is allowed as an output script or in P2SH, but not inside of P2WSH\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        // P2PKH in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        // If the pubkey cannot be retrieved to check for compression, then the P2WSH-P2PKH is allowed.\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(solutions[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        // P2SH is allowed only as an output script.\n+        // If the redeemScript is known, it must also be a valid script within P2SH.\n+        // If the redeemScript is not known, the P2SH output script is valid.\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(solutions[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        // P2WSH is allowed as an output script or inside of P2SH, but not P2WSH.\n+        // If the witnessScript is known, it must also be a valid script within P2WSH.\n+        // If the witnessScript is not known, the P2WSH output script is valid.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            // CScriptID is the hash160 of the script. For P2WSH, we already have the SHA256 of the script,\n+            // so only RIPEMD160 of that is required to get the CScriptID for lookup.\n+            CScriptID script_id{RIPEMD160(solutions[0])};\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2WSH);\n+            }\n+            return true;\n+        }\n+        // Multisig in any nesting level is valid, but inside of P2WSH, all pubkeys must be compressed.\n+        case TxoutType::MULTISIG:\n+        {\n+            if (ctx == ScriptContext::P2WSH) {\n+                std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+                if (!all_keys_compressed(keys)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        }\n+        assert(false);\n+    };\n+    // Iterate again for all the P2WSH scripts",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 185,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I’m pretty lost at this point. We already handled multisig and even really weird stuff like putting a PKH into a SH. What exactly are we looking for here that we then not also skip?",
      "created_at": "2024-12-06T22:48:16Z",
      "updated_at": "2024-12-06T22:55:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874092015",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874092015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1879,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874530028",
      "pull_request_review_id": 2486650885,
      "id": 1874530028,
      "node_id": "PRRC_kwDOABII585vuw7s",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"p2wsh\")\n+\n+        # Craft wsh(pkh(key))\n+        pubkey = wallet.getaddressinfo(wallet.getnewaddress())[\"pubkey\"]\n+        pkh_script = key_to_p2pkh_script(pubkey).hex()\n+        wsh_pkh_script = script_to_p2wsh_script(pkh_script).hex()\n+        wsh_pkh_addr = script_to_p2wsh(pkh_script)\n+\n+        wallet.importaddress(address=pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_pkh_script, p2sh=False)\n+\n+        def_wallet.sendtoaddress(wsh_pkh_addr, 5)\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+\n+        wallet.migratewallet()",
      "path": "test/functional/wallet_migration.py",
      "position": null,
      "original_position": 41,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": 1873919286,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We generally assume that test readers have a basic understanding of how RPCs work, such as that unless stated otherwise in their help docs, all RPCs throw when they fail.",
      "created_at": "2024-12-07T16:35:49Z",
      "updated_at": "2024-12-07T16:35:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874530028",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874530028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1036,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538328",
      "pull_request_review_id": 2486659867,
      "id": 1874538328,
      "node_id": "PRRC_kwDOABII585vuy9Y",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spks\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            Assert(solutions.size() >= 2);",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 83,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": 1874058059,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The Solver returns `TxoutType::NONSTANDARD` for 0-of-n, so this code cannot be reached in that case.",
      "created_at": "2024-12-07T17:38:53Z",
      "updated_at": "2024-12-07T17:39:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874538328",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538328"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1777,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538409",
      "pull_request_review_id": 2486659955,
      "id": 1874538409,
      "node_id": "PRRC_kwDOABII585vuy-p",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spks\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            Assert(solutions.size() >= 2);\n+            std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n             }",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": 1874063348,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "To maintain strict compatibility with `LegacyScriptPubKeyMan::IsMine()`. I don't think we should change this behavior in this PR.",
      "created_at": "2024-12-07T17:39:27Z",
      "updated_at": "2024-12-07T17:39:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874538409",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538409"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1779,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1781,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538455",
      "pull_request_review_id": 2486659999,
      "id": 1874538455,
      "node_id": "PRRC_kwDOABII585vuy_X",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")",
      "path": "test/functional/wallet_migration.py",
      "position": null,
      "original_position": 23,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": 1873916913,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-12-07T17:39:55Z",
      "updated_at": "2024-12-07T17:39:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874538455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1018,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538770",
      "pull_request_review_id": 2486660293,
      "id": 1874538770,
      "node_id": "PRRC_kwDOABII585vuzES",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"p2wsh\")\n+\n+        # Craft wsh(pkh(key))\n+        pubkey = wallet.getaddressinfo(wallet.getnewaddress())[\"pubkey\"]\n+        pkh_script = key_to_p2pkh_script(pubkey).hex()\n+        wsh_pkh_script = script_to_p2wsh_script(pkh_script).hex()\n+        wsh_pkh_addr = script_to_p2wsh(pkh_script)\n+\n+        wallet.importaddress(address=pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_pkh_script, p2sh=False)\n+\n+        def_wallet.sendtoaddress(wsh_pkh_addr, 5)\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+\n+        wallet.migratewallet()",
      "path": "test/functional/wallet_migration.py",
      "position": null,
      "original_position": 41,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": 1873919286,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since this PR needed to be rebased for #31248 which added a `migrate_and_get_rpc` helper function that replaced all `migratewallet` calls, I've added a check to that function to verify that the wallet is legacy before migration, and descriptors after.",
      "created_at": "2024-12-07T17:41:15Z",
      "updated_at": "2024-12-07T17:41:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874538770",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538770"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1036,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538801",
      "pull_request_review_id": 2486660315,
      "id": 1874538801,
      "node_id": "PRRC_kwDOABII585vuzEx",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"p2wsh\")\n+\n+        # Craft wsh(pkh(key))\n+        pubkey = wallet.getaddressinfo(wallet.getnewaddress())[\"pubkey\"]\n+        pkh_script = key_to_p2pkh_script(pubkey).hex()\n+        wsh_pkh_script = script_to_p2wsh_script(pkh_script).hex()\n+        wsh_pkh_addr = script_to_p2wsh(pkh_script)\n+\n+        wallet.importaddress(address=pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_pkh_script, p2sh=False)\n+\n+        def_wallet.sendtoaddress(wsh_pkh_addr, 5)\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+\n+        wallet.migratewallet()\n+\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+        addr_info = wallet.getaddressinfo(wsh_pkh_addr)\n+        assert_equal(addr_info[\"ismine\"], True)\n+        assert_equal(addr_info[\"iswatchonly\"], False)\n+        assert_equal(addr_info[\"solvable\"], True)\n+\n+        wallet.unloadwallet()\n+\n+    def test_disallowed_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts with invalid witnessScripts are not migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"invalid_p2wsh\")\n+\n+        invalid_addrs = []\n+\n+        # Create wsh(pkh()) with both a compressed and an uncompressed private key\n+        # Although we create an sh(wsh(pkh())), we don't care about the sh(), just the wsh(pkh())\n+        # Wrapping it with sh() is just to avoid inserting the wsh(pkh()) into setWatchOnly\n+        # The one with the compressed key will be valid, while the one with the uncompressed will not\n+        # The sh(pkh()) will be valid, while wsh(pkh()) will not\n+        comp_eckey = ECKey()\n+        comp_eckey.generate(compressed=True)\n+        comp_pubkey = comp_eckey.get_pubkey().get_bytes().hex()\n+        comp_pkh_script = key_to_p2pkh_script(comp_pubkey).hex()\n+        comp_wsh_pkh_script = script_to_p2wsh_script(comp_pkh_script).hex()\n+        comp_sh_wsh_pkh_script = script_to_p2sh_script(comp_wsh_pkh_script).hex()\n+        comp_wsh_pkh_addr = script_to_p2wsh(comp_pkh_script)\n+\n+        uncomp_eckey = ECKey()\n+        uncomp_eckey.generate(compressed=False)\n+        uncomp_pubkey = uncomp_eckey.get_pubkey().get_bytes().hex()\n+        uncomp_pkh_script = key_to_p2pkh_script(uncomp_pubkey).hex()\n+        uncomp_wsh_pkh_script = script_to_p2wsh_script(uncomp_pkh_script).hex()\n+        uncomp_sh_wsh_pkh_script = script_to_p2sh_script(uncomp_wsh_pkh_script).hex()\n+        uncomp_wsh_pkh_addr = script_to_p2wsh(uncomp_pkh_script)\n+        invalid_addrs.append(uncomp_wsh_pkh_addr)\n+\n+        # Import them with importmulti to prevent the wsh(pkh()) from going into setWatchOnly\n+        # Use importmulti for the sh(wsh(pkh())) to prevent the wsh(pkh()) from going into setWatchOnly\n+        import_res = wallet.importmulti([\n+            {\n+                \"scriptPubKey\": comp_sh_wsh_pkh_script,\n+                \"timestamp\": \"now\",\n+                \"redeemscript\": comp_wsh_pkh_script,\n+                \"witnessscript\": comp_pkh_script,\n+                \"keys\": [\n+                    byte_to_base58(comp_eckey.get_bytes() + b\"\\x01\", 239),\n+                ],\n+            },\n+            {\n+                \"scriptPubKey\": uncomp_sh_wsh_pkh_script,\n+                \"timestamp\": \"now\",\n+                \"redeemscript\": uncomp_wsh_pkh_script,\n+                \"witnessscript\": uncomp_pkh_script,\n+                \"keys\": [\n+                    byte_to_base58(uncomp_eckey.get_bytes(), 239),\n+                ],\n+            },\n+        ])\n+        assert_equal(import_res[0][\"success\"], True)\n+        assert_equal(import_res[1][\"success\"], True)\n+\n+        # Create a wsh(sh(pkh())) - P2SH inside of P2WSH is invalid\n+        comp_sh_pkh_script = script_to_p2sh_script(comp_pkh_script).hex()\n+        wsh_sh_pkh_script = script_to_p2wsh_script(comp_sh_pkh_script).hex()\n+        wsh_sh_pkh_addr = script_to_p2wsh(comp_sh_pkh_script)\n+        invalid_addrs.append(wsh_sh_pkh_addr)\n+\n+        # Import wsh(sh(pkh()))\n+        wallet.importaddress(address=comp_sh_pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_sh_pkh_script, p2sh=False)\n+\n+        # Create a wsh(wsh(pkh())) - P2WSH inside of P2WSH is invalid\n+        wsh_wsh_pkh_script = script_to_p2wsh_script(comp_wsh_pkh_script).hex()\n+        wsh_wsh_pkh_addr = script_to_p2wsh(comp_wsh_pkh_script)\n+        invalid_addrs.append(wsh_wsh_pkh_addr)\n+\n+        # Import wsh(wsh(pkh()))\n+        wallet.importaddress(address=wsh_wsh_pkh_script, p2sh=False)\n+\n+        comp_wsh_pkh_addr_info = wallet.getaddressinfo(comp_wsh_pkh_addr)\n+        assert_equal(comp_wsh_pkh_addr_info[\"ismine\"], True)\n+        assert_equal(comp_wsh_pkh_addr_info[\"iswatchonly\"], False)\n+        assert \"embedded\" in comp_wsh_pkh_addr_info\n+\n+        for addr in invalid_addrs:\n+            addr_info = wallet.getaddressinfo(addr)\n+            assert_equal(addr_info[\"ismine\"], False)\n+            assert_equal(addr_info[\"iswatchonly\"], False)",
      "path": "test/functional/wallet_migration.py",
      "position": 160,
      "original_position": 132,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": 1873934117,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added addtional comments.",
      "created_at": "2024-12-07T17:41:24Z",
      "updated_at": "2024-12-07T17:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874538801",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1133,
      "original_line": 1133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538814",
      "pull_request_review_id": 2486660335,
      "id": 1874538814,
      "node_id": "PRRC_kwDOABII585vuzE-",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"p2wsh\")\n+\n+        # Craft wsh(pkh(key))\n+        pubkey = wallet.getaddressinfo(wallet.getnewaddress())[\"pubkey\"]\n+        pkh_script = key_to_p2pkh_script(pubkey).hex()\n+        wsh_pkh_script = script_to_p2wsh_script(pkh_script).hex()\n+        wsh_pkh_addr = script_to_p2wsh(pkh_script)\n+\n+        wallet.importaddress(address=pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_pkh_script, p2sh=False)\n+\n+        def_wallet.sendtoaddress(wsh_pkh_addr, 5)\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+\n+        wallet.migratewallet()\n+\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+        addr_info = wallet.getaddressinfo(wsh_pkh_addr)\n+        assert_equal(addr_info[\"ismine\"], True)\n+        assert_equal(addr_info[\"iswatchonly\"], False)\n+        assert_equal(addr_info[\"solvable\"], True)\n+\n+        wallet.unloadwallet()\n+\n+    def test_disallowed_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts with invalid witnessScripts are not migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"invalid_p2wsh\")\n+\n+        invalid_addrs = []\n+\n+        # Create wsh(pkh()) with both a compressed and an uncompressed private key\n+        # Although we create an sh(wsh(pkh())), we don't care about the sh(), just the wsh(pkh())\n+        # Wrapping it with sh() is just to avoid inserting the wsh(pkh()) into setWatchOnly\n+        # The one with the compressed key will be valid, while the one with the uncompressed will not\n+        # The sh(pkh()) will be valid, while wsh(pkh()) will not\n+        comp_eckey = ECKey()\n+        comp_eckey.generate(compressed=True)\n+        comp_pubkey = comp_eckey.get_pubkey().get_bytes().hex()\n+        comp_pkh_script = key_to_p2pkh_script(comp_pubkey).hex()\n+        comp_wsh_pkh_script = script_to_p2wsh_script(comp_pkh_script).hex()\n+        comp_sh_wsh_pkh_script = script_to_p2sh_script(comp_wsh_pkh_script).hex()\n+        comp_wsh_pkh_addr = script_to_p2wsh(comp_pkh_script)\n+\n+        uncomp_eckey = ECKey()\n+        uncomp_eckey.generate(compressed=False)\n+        uncomp_pubkey = uncomp_eckey.get_pubkey().get_bytes().hex()\n+        uncomp_pkh_script = key_to_p2pkh_script(uncomp_pubkey).hex()\n+        uncomp_wsh_pkh_script = script_to_p2wsh_script(uncomp_pkh_script).hex()\n+        uncomp_sh_wsh_pkh_script = script_to_p2sh_script(uncomp_wsh_pkh_script).hex()\n+        uncomp_wsh_pkh_addr = script_to_p2wsh(uncomp_pkh_script)\n+        invalid_addrs.append(uncomp_wsh_pkh_addr)\n+\n+        # Import them with importmulti to prevent the wsh(pkh()) from going into setWatchOnly\n+        # Use importmulti for the sh(wsh(pkh())) to prevent the wsh(pkh()) from going into setWatchOnly\n+        import_res = wallet.importmulti([\n+            {\n+                \"scriptPubKey\": comp_sh_wsh_pkh_script,\n+                \"timestamp\": \"now\",\n+                \"redeemscript\": comp_wsh_pkh_script,\n+                \"witnessscript\": comp_pkh_script,\n+                \"keys\": [\n+                    byte_to_base58(comp_eckey.get_bytes() + b\"\\x01\", 239),\n+                ],\n+            },\n+            {\n+                \"scriptPubKey\": uncomp_sh_wsh_pkh_script,\n+                \"timestamp\": \"now\",\n+                \"redeemscript\": uncomp_wsh_pkh_script,\n+                \"witnessscript\": uncomp_pkh_script,\n+                \"keys\": [\n+                    byte_to_base58(uncomp_eckey.get_bytes(), 239),\n+                ],\n+            },\n+        ])\n+        assert_equal(import_res[0][\"success\"], True)\n+        assert_equal(import_res[1][\"success\"], True)\n+\n+        # Create a wsh(sh(pkh())) - P2SH inside of P2WSH is invalid\n+        comp_sh_pkh_script = script_to_p2sh_script(comp_pkh_script).hex()\n+        wsh_sh_pkh_script = script_to_p2wsh_script(comp_sh_pkh_script).hex()\n+        wsh_sh_pkh_addr = script_to_p2wsh(comp_sh_pkh_script)\n+        invalid_addrs.append(wsh_sh_pkh_addr)\n+\n+        # Import wsh(sh(pkh()))\n+        wallet.importaddress(address=comp_sh_pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_sh_pkh_script, p2sh=False)\n+\n+        # Create a wsh(wsh(pkh())) - P2WSH inside of P2WSH is invalid\n+        wsh_wsh_pkh_script = script_to_p2wsh_script(comp_wsh_pkh_script).hex()\n+        wsh_wsh_pkh_addr = script_to_p2wsh(comp_wsh_pkh_script)\n+        invalid_addrs.append(wsh_wsh_pkh_addr)\n+\n+        # Import wsh(wsh(pkh()))\n+        wallet.importaddress(address=wsh_wsh_pkh_script, p2sh=False)\n+\n+        comp_wsh_pkh_addr_info = wallet.getaddressinfo(comp_wsh_pkh_addr)\n+        assert_equal(comp_wsh_pkh_addr_info[\"ismine\"], True)\n+        assert_equal(comp_wsh_pkh_addr_info[\"iswatchonly\"], False)\n+        assert \"embedded\" in comp_wsh_pkh_addr_info\n+\n+        for addr in invalid_addrs:\n+            addr_info = wallet.getaddressinfo(addr)\n+            assert_equal(addr_info[\"ismine\"], False)\n+            assert_equal(addr_info[\"iswatchonly\"], False)\n+            assert \"embedded\" in addr_info\n+\n+        # Fund those output scripts\n+        def_wallet.send([{comp_wsh_pkh_addr: 1}] + [{k: i + 1} for i, k in enumerate(invalid_addrs)])\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()[\"mine\"][\"trusted\"], 1)\n+\n+        wallet.migratewallet()\n+\n+        assert_equal(wallet.getbalances()[\"mine\"][\"trusted\"], 1)\n+\n+        comp_wsh_pkh_addr_info = wallet.getaddressinfo(comp_wsh_pkh_addr)\n+        assert_equal(comp_wsh_pkh_addr_info[\"ismine\"], True)\n+        assert_equal(comp_wsh_pkh_addr_info[\"iswatchonly\"], False)\n+        assert \"embedded\" in comp_wsh_pkh_addr_info\n+\n+        for addr in invalid_addrs:\n+            addr_info = wallet.getaddressinfo(addr)\n+            assert_equal(addr_info[\"ismine\"], False)\n+            assert_equal(addr_info[\"iswatchonly\"], False)\n+            assert \"embedded\" not in addr_info",
      "path": "test/functional/wallet_migration.py",
      "position": 186,
      "original_position": 153,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": 1873937684,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added additional comments.",
      "created_at": "2024-12-07T17:41:33Z",
      "updated_at": "2024-12-07T17:41:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874538814",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538814"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1159,
      "original_line": 1159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538908",
      "pull_request_review_id": 2486660481,
      "id": 1874538908,
      "node_id": "PRRC_kwDOABII585vuzGc",
      "diff_hunk": "@@ -1012,6 +1014,140 @@ def check_comments():\n \n         wallet.unloadwallet()\n \n+    def test_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts are migrated\")\n+        def_wallet = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+\n+        wallet = self.create_legacy_wallet(\"p2wsh\")\n+\n+        # Craft wsh(pkh(key))\n+        pubkey = wallet.getaddressinfo(wallet.getnewaddress())[\"pubkey\"]\n+        pkh_script = key_to_p2pkh_script(pubkey).hex()\n+        wsh_pkh_script = script_to_p2wsh_script(pkh_script).hex()\n+        wsh_pkh_addr = script_to_p2wsh(pkh_script)\n+\n+        wallet.importaddress(address=pkh_script, p2sh=False)\n+        wallet.importaddress(address=wsh_pkh_script, p2sh=False)\n+\n+        def_wallet.sendtoaddress(wsh_pkh_addr, 5)\n+        self.generate(self.nodes[0], 6)\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+\n+        wallet.migratewallet()\n+\n+        assert_equal(wallet.getbalances()['mine']['trusted'], 5)\n+        addr_info = wallet.getaddressinfo(wsh_pkh_addr)\n+        assert_equal(addr_info[\"ismine\"], True)\n+        assert_equal(addr_info[\"iswatchonly\"], False)\n+        assert_equal(addr_info[\"solvable\"], True)\n+\n+        wallet.unloadwallet()\n+\n+    def test_disallowed_p2wsh(self):\n+        self.log.info(\"Test that P2WSH output scripts with invalid witnessScripts are not migrated\")",
      "path": "test/functional/wallet_migration.py",
      "position": null,
      "original_position": 52,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "82d974323c75861b3259ba801ca74623d9c68a2a",
      "in_reply_to_id": 1873953323,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Because invalid scripts can exist in the legacy wallet, but can cause issues (crashes, loading failure, etc.) in both migration and descriptor wallets. So we need to test that migration doesn't fail, and that those scripts do not end up in the descriptor wallet.",
      "created_at": "2024-12-07T17:42:40Z",
      "updated_at": "2024-12-07T17:42:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874538908",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538908"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1047,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538967",
      "pull_request_review_id": 2486660541,
      "id": 1874538967,
      "node_id": "PRRC_kwDOABII585vuzHX",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 40,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": 1874014319,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No, that's not correct. I've rephrased the comment to be clearer.",
      "created_at": "2024-12-07T17:43:09Z",
      "updated_at": "2024-12-07T17:43:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874538967",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874538967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1747,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1748,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874539064",
      "pull_request_review_id": 2486660726,
      "id": 1874539064,
      "node_id": "PRRC_kwDOABII585vuzI4",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spks\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": 1874054743,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-12-07T17:44:25Z",
      "updated_at": "2024-12-07T17:44:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874539064",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874539064"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": 1762,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1769,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874539430",
      "pull_request_review_id": 2486661093,
      "id": 1874539430,
      "node_id": "PRRC_kwDOABII585vuzOm",
      "diff_hunk": "@@ -1717,42 +1717,190 @@ std::unordered_set<CScript, SaltedSipHasher> LegacyDataSPKM::GetScriptPubKeys()\n         spks.insert(GetScriptForDestination(PKHash(pub)));\n     }\n \n-    // For every script in mapScript, only the ISMINE_SPENDABLE ones are being tracked.\n-    // The watchonly ones will be in setWatchOnly which we deal with later\n-    // For all keys, if they have segwit scripts, those scripts will end up in mapScripts\n-    for (const auto& script_pair : mapScripts) {\n-        const CScript& script = script_pair.second;\n-        if (IsMine(script) == ISMINE_SPENDABLE) {\n-            // Add ScriptHash for scripts that are not already P2SH\n-            if (!script.IsPayToScriptHash()) {\n+    // Lambda helper to check that all keys found by the solver are compressed\n+    const auto& all_keys_compressed = [](const std::vector<valtype>& keys) -> bool {\n+        return std::all_of(keys.cbegin(), keys.cend(),\n+               [](const auto& key) { return key.size() == CPubKey::COMPRESSED_SIZE; });\n+    };\n+\n+    // mapScripts is iterated to compute all additional spendable output scripts that utilize the contained scripts\n+    // as redeemScripts and witnessScripts.\n+    //\n+    // mapScripts contains redeemScripts and witnessScripts. It may also contain output scripts which,\n+    // in addition to being treated as output scripts, are also treated as redeemScripts and witnessScripts.\n+    // All scripts in mapScripts are treated as redeemScripts, unless that script is also a P2SH.\n+    // A script is only treated as a witnessScript if its corresponding P2WSH output script is in the map.\n+    for (const auto& [_, script] : mapScripts) {\n+        std::vector<std::vector<unsigned char>> solutions;\n+        TxoutType type = Solver(script, solutions);\n+        switch (type) {\n+        // We don't care about these types because they are not spendable\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // P2TR are not spendable as the legacy wallet never supported them.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+        // These are only spendable if the witness script is also spendable as a scriptPubKey\n+        // We will check these later after \"spks\" has been updated with the computed output scripts from mapScripts.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        // For P2SH to be spendable, we need to have the redeemScript, and if we have it, it will be handled when\n+        // this loop gets to it. A P2SH script itself cannot be nested in anything, so we can skip them.\n+        case TxoutType::SCRIPTHASH:\n+            break;\n+        // Any P2PK or P2PKH scripts found in mapScripts can be spent as P2SH-P2PK or P2SH-P2PKH respectively,\n+        // if we have the private key.\n+        // Since all private keys were iterated earlier and their corresponding P2PK and P2PKH scripts inserted\n+        // to \"spks\", we can simply check whether this P2PK or P2PKH script is in \"spks\" to determine spendability.\n+        case TxoutType::PUBKEY:\n+        case TxoutType::PUBKEYHASH:\n+            if (spks.count(script) > 0) {\n                 spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-            // For segwit scripts, we only consider them spendable if we have the segwit spk\n-            int wit_ver = -1;\n-            std::vector<unsigned char> witprog;\n-            if (script.IsWitnessProgram(wit_ver, witprog) && wit_ver == 0) {\n+            break;\n+        // P2WPKH scripts are only spendable if we have the private key.\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+        {\n+            CKeyID key_id{uint160(solutions[0])};\n+            CPubKey pubkey;\n+            if (GetPubKey(key_id, pubkey) && pubkey.IsCompressed() && HaveKey(key_id)) {\n                 spks.insert(script);\n+                // Also insert P2SH-P2WPKH output script\n+                spks.insert(GetScriptForDestination(ScriptHash(script)));\n             }\n-        } else {\n-            // Multisigs are special. They don't show up as ISMINE_SPENDABLE unless they are in a P2SH\n-            // So check the P2SH of a multisig to see if we should insert it\n-            std::vector<std::vector<unsigned char>> sols;\n-            TxoutType type = Solver(script, sols);\n-            if (type == TxoutType::MULTISIG) {\n-                CScript ms_spk = GetScriptForDestination(ScriptHash(script));\n-                if (IsMine(ms_spk) != ISMINE_NO) {\n-                    spks.insert(ms_spk);\n-                }\n+            break;\n+        }\n+        // Multisig scripts are spendable if they are inside of a P2SH or P2WSH, and we have all of the private keys.\n+        // Bare multisigs are never considered spendable\n+        case TxoutType::MULTISIG:\n+        {\n+            Assert(solutions.size() >= 2);\n+            std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+            if (!HaveKeys(keys, *this)) {\n+                break;\n             }\n+            // Insert P2SH-Multisig\n+            spks.insert(GetScriptForDestination(ScriptHash(script)));\n+            // P2WSH-Multisig output scripts are spendable if the P2WSH output script is also in mapScripts,\n+            // and all keys are compressed\n+            CScript ms_wsh = GetScriptForDestination(WitnessV0ScriptHash(script));\n+            if (HaveCScript(CScriptID(ms_wsh)) && all_keys_compressed(keys)) {\n+                spks.insert(ms_wsh);\n+                spks.insert(GetScriptForDestination(ScriptHash(ms_wsh)));\n+            }\n+            break;\n+        }\n         }\n     }\n \n+    // Enum to track the execution context of a script, similar to the script interpreter's SigVersion.\n+    // It is separate to distinguish between top level scriptPubKey execution and P2SH redeemScript execution\n+    // which SigVersion does not distinguish. It also excludes Taproot and Tapscript as the legacy wallet\n+    // never supported those.\n+    enum class ScriptContext {\n+        TOP,\n+        P2SH,\n+        P2WSH,\n+    };\n+    // Lambda helper function to determine whether a script is valid, mainly looking at key compression requirements.\n+    std::function<bool(const CScript&, const ScriptContext)> is_valid_script = [&](const CScript& script, const ScriptContext ctx) -> bool {\n+        std::vector<valtype> solutions;\n+        TxoutType spk_type = Solver(script, solutions);\n+\n+        CKeyID keyID;\n+        switch (spk_type) {\n+        // Scripts with no nesting (arbitrary, unknown scripts) are always valid.\n+        case TxoutType::NONSTANDARD:\n+        case TxoutType::NULL_DATA:\n+        case TxoutType::WITNESS_UNKNOWN:\n+        case TxoutType::ANCHOR:\n+        // Taproot output scripts are always valid. Legacy wallets did not support Taproot spending so no nested inspection is required.\n+        case TxoutType::WITNESS_V1_TAPROOT:\n+            return ctx == ScriptContext::TOP;\n+        // P2PK in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        case TxoutType::PUBKEY:\n+            if (ctx == ScriptContext::P2WSH && solutions[0].size() != CPubKey::COMPRESSED_SIZE) return false;\n+            return true;\n+        // P2WPKH is allowed as an output script or in P2SH, but not inside of P2WSH\n+        case TxoutType::WITNESS_V0_KEYHASH:\n+            return ctx != ScriptContext::P2WSH;\n+        // P2PKH in any nesting level is valid, but inside of P2WSH, the pubkey must also be compressed.\n+        // If the pubkey cannot be retrieved to check for compression, then the P2WSH-P2PKH is allowed.\n+        case TxoutType::PUBKEYHASH:\n+            if (ctx == ScriptContext::P2WSH) {\n+                CPubKey pubkey;\n+                if (GetPubKey(CKeyID(uint160(solutions[0])), pubkey) && !pubkey.IsCompressed()) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        // P2SH is allowed only as an output script.\n+        // If the redeemScript is known, it must also be a valid script within P2SH.\n+        // If the redeemScript is not known, the P2SH output script is valid.\n+        case TxoutType::SCRIPTHASH:\n+        {\n+            if (ctx != ScriptContext::TOP) return false;\n+            CScriptID script_id = CScriptID(uint160(solutions[0]));\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2SH);\n+            }\n+            return true;\n+        }\n+        // P2WSH is allowed as an output script or inside of P2SH, but not P2WSH.\n+        // If the witnessScript is known, it must also be a valid script within P2WSH.\n+        // If the witnessScript is not known, the P2WSH output script is valid.\n+        case TxoutType::WITNESS_V0_SCRIPTHASH:\n+        {\n+            if (ctx == ScriptContext::P2WSH) return false;\n+            // CScriptID is the hash160 of the script. For P2WSH, we already have the SHA256 of the script,\n+            // so only RIPEMD160 of that is required to get the CScriptID for lookup.\n+            CScriptID script_id{RIPEMD160(solutions[0])};\n+            CScript subscript;\n+            if (GetCScript(script_id, subscript)) {\n+                return is_valid_script(subscript, ScriptContext::P2WSH);\n+            }\n+            return true;\n+        }\n+        // Multisig in any nesting level is valid, but inside of P2WSH, all pubkeys must be compressed.\n+        case TxoutType::MULTISIG:\n+        {\n+            if (ctx == ScriptContext::P2WSH) {\n+                std::vector<std::vector<unsigned char>> keys(solutions.begin() + 1, solutions.begin() + solutions.size() - 1);\n+                if (!all_keys_compressed(keys)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        }\n+        assert(false);\n+    };\n+    // Iterate again for all the P2WSH scripts",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": null,
      "original_position": 185,
      "commit_id": "e09407c2924935b456cbbbe141bab0b4686f03ba",
      "original_commit_id": "5aba0cd226156d6e414531c56616d6e2c5913ccf",
      "in_reply_to_id": 1874092015,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This was to handle pkh inside of wsh, which was a previously unhandled case. Furthermore, I thought that it would be possible for other (nonstandard) scripts to be included in here, however further analysis shows that this is not possible as nonstandard scripts are always `ISMINE_NO`.\r\n\r\nI've removed this loop and added wsh handling for pkh to the loop above.",
      "created_at": "2024-12-07T17:46:55Z",
      "updated_at": "2024-12-07T17:46:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30328#discussion_r1874539430",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1874539430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30328"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1879,
      "side": "RIGHT"
    }
  ]
}