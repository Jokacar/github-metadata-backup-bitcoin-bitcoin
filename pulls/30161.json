{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161",
    "id": 1885111284,
    "node_id": "PR_kwDOABII585wXIP0",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30161",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30161.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30161.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/82258f0fd0239f0e17fae75cbf7479befd25e0fa",
    "number": 30161,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "util: add VecDeque",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Extracted from #30126.\r\n\r\nThis adds a `VecDeque` data type, inspired by `std::deque`, but backed by a single allocated memory region used as a ring buffer instead of a linked list of arrays. This gives better memory locality and less allocation overhead, plus better guarantees (some C++ standard library implementations, though not libstdc++ and libc++, use a separate allocation per element in a deque).\r\n\r\nIt is intended for the candidate set search queue in #30126, but may be useful as a replacement for `std::deque` in other places too. It's not a full drop-in replacement, as I did not add iteration support which is unnecessary for the intended use case, but nothing prevents adding that if needed.\r\n\r\nEverything is tested through a simulation-based fuzz test that compares the behavior with normal `std::deque` equivalent operations, both for trivially-copyable/destructible types and others.\r\n",
    "labels": [
      {
        "id": 241832923,
        "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
        "name": "Utils/log/libs",
        "description": "",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 6861582155,
        "node_id": "LA_kwDOABII588AAAABmPtvSw",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20CMake%20port",
        "name": "Needs CMake port",
        "description": "",
        "color": "0e8a16",
        "default": false
      }
    ],
    "created_at": "2024-05-23T17:21:08Z",
    "updated_at": "2024-05-27T12:59:30Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "1b0b2598569df71bc2de7f48fc8bf1aff8c3a2ba",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202405_ringbuffer",
      "ref": "202405_ringbuffer",
      "sha": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 21,
        "stargazers_count": 85,
        "watchers_count": 85,
        "size": 239983,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-05-26T13:32:23Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-05-05T10:02:28Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "327f08bb0cd91a22249395adeb34549e3c86ca76",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35451,
        "stargazers_count": 76567,
        "watchers_count": 76567,
        "size": 259279,
        "default_branch": "master",
        "open_issues_count": 691,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-05-27T00:39:48Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-05-27T12:51:25Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 677,
    "deletions": 0,
    "changed_files": 4,
    "commits": 2,
    "review_comments": 28,
    "comments": 5
  },
  "events": [
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T17:23:42Z",
      "updated_at": "2024-05-23T17:23:42Z",
      "source": {
        "issue": {
          "id": 2301284495,
          "node_id": "PR_kwDOABII585vttq-",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30126/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
          "number": 30126,
          "state": "open",
          "state_reason": null,
          "title": "Low-level cluster linearization code",
          "body": "Depends on #30160 and #30161. Eventually #28676 will end up being based on this.\r\n\r\nThis introduces low-level optimized cluster linearization code, including tests and some benchmarks. It is currently not hooked up to anything.\r\n\r\nRoughly the commits are organized into 3 groups:\r\n* Repeat of part of #29625.\r\n* Introduce unoptimized versions of candidate finding and linearizations, plus benchmarks and tests.\r\n* Add various optimizations step by step.\r\n\r\nUltimately, what this PR adds is two functions `Linearize` and `PostLinearize`, which operate on instances of `DepGraph` (instances of which represent pre-processed transaction clusters) to produce and/or improve linearizations for that cluster.\r\n\r\nAlong the way two new data structures are introduced (`util/bitset.h` and `util/ringbuffer.h`), which could be useful more broadly. They have their own commits, which include tests.\r\n\r\n---\r\n\r\nTo provide assurance, the code heavily relies on fuzz tests. A novel approach is used here, where the fuzz input is parsed using the serialization.h framework rather than `FuzzedDataProvider`, with a custom serializer/deserializer for `DepGraph` objects. By including serialization, it's possible to ascertain that the format can represent every relevant cluster, as well as potentially permitting the construction of ad-hoc fuzz inputs from clusters (not included in this PR, but used during development).\r\n\r\n---\r\n\r\nThe `Linearize(depgraph, iteration_limit, rng_seed, old_linearization)` function is an implementation of the (single) [LIMO](https://delvingbitcoin.org/t/limo-combining-the-best-parts-of-linearization-search-and-merging/825) algorithm, with the $S$ in every iteration found as the best out of (a) the best remaining ancestor set and (b) randomized computationally-bounded search. It incrementally builds up a linearization by finding good topologically-valid subsets to move to the front, in such a way that the resulting linearization has a diagram that is at least as good as the `old_linearization` passed in (if any).\r\n* Despite using both best ancestor set and search, this is not Double LIMO, as no intersections between these are involved; just the best of the two.\r\n* The `iteration_limit` and `rng_seed` only control the (b) randomized search. Even with 0 iterations, the result will be as good as the old linearization, and the included sets at every point will have a feerate at least as high as the best remaining ancestor set at that point.\r\n\r\nThe search algorithm used in the (b) step above largely follows Section 2 of [How to linearize your cluster](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303#h-2-finding-high-feerate-subsets-5), though with a few changes:\r\n* Connected component analysis is performed inside the search algorithm (creating initial work items per component for each candidate), rather than once at a higher level. This duplicates some work but is significantly simpler in implementation.\r\n* No ancestor-set based presplitting inside the search is performed; instead, the `best` value is initialized with the best topologically valid set known to the LIMO algorithm before search starts: the better one out of the highest-feerate remaining ancestor set, and the highest-feerate prefix of remaining transactions in `old_linearization`.\r\n* Work items are represented using an included set *inc* and an undefined set *und*, rather than included and excluded.\r\n* Potential sets *pot* are not computed for work items with empty *inc*.\r\n\r\nAt a high level, the only missing optimization from that post is bottleneck analysis; my thinking is that it only really helps with clusters that are already relatively cheap to linearize (doing so would need to be done at a higher level, not inside the search algorithm).\r\n\r\nThe `PostLinearize(depgraph, linearization)` function performs an in-place improvement of `linearization`, using two iterations of the [Linearization post-processing](https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201/8) algorithm. The first running from back to front, the second from front to back.\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 164208572,
              "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
              "name": "Mempool",
              "color": "fef2c0",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30126",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/30126",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/30126.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/30126.patch"
          },
          "created_at": "2024-05-16T20:29:15Z",
          "updated_at": "2024-05-26T13:32:24Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 12913817166,
      "node_id": "LE_lADOABII586J5NBmzwAAAAMBuTZO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913817166",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T18:36:59Z",
      "label": {
        "name": "Utils/log/libs",
        "color": "5319e7"
      }
    },
    {
      "event": "reviewed",
      "id": 2077153695,
      "node_id": "PRR_kwDOABII5857ztmf",
      "url": null,
      "actor": null,
      "commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2077153695",
      "submitted_at": "2024-05-24T14:53:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "commented",
      "id": 2129732891,
      "node_id": "IC_kwDOABII585-8SUb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129732891",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T14:53:02Z",
      "updated_at": "2024-05-27T12:12:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30161).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [hebasto](https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133351751) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2129732891",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12926712190,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCffl-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12926712190",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T15:34:51Z"
    },
    {
      "event": "reviewed",
      "id": 2077094091,
      "node_id": "PRR_kwDOABII5857zfDL",
      "url": null,
      "actor": null,
      "commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2077094091",
      "submitted_at": "2024-05-24T16:01:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927669713,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCjJXR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927669713",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:08:16Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927889932,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCj_IM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927889932",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:31:25Z"
    },
    {
      "event": "renamed",
      "id": 12927892872,
      "node_id": "RTE_lADOABII586J5NBmzwAAAAMCj_2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927892872",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:31:46Z",
      "rename": {
        "from": "util: add RingBuffer",
        "to": "util: add VecDeque"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927921771,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMCkG5r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927921771",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:35:23Z"
    },
    {
      "event": "labeled",
      "id": 12927922356,
      "node_id": "LE_lADOABII586J5NBmzwAAAAMCkHC0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927922356",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:35:27Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2130058565,
      "node_id": "IC_kwDOABII585-9h1F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130058565",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:35:28Z",
      "updated_at": "2024-05-24T17:35:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25390426376</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2130058565",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "reviewed",
      "id": 2077678840,
      "node_id": "PRR_kwDOABII58571tz4",
      "url": null,
      "actor": null,
      "commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#pullrequestreview-2077678840",
      "submitted_at": "2024-05-24T19:17:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
    },
    {
      "event": "unlabeled",
      "id": 12930212867,
      "node_id": "UNLE_lADOABII586J5NBmzwAAAAMCs2QD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12930212867",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T22:52:04Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMyODcyYjgxNjZhMzdhOTQ5MzhiZGI4MWI1MzNjZGMzMDc3NGE5YjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32872b8166a37a94938bdb81b533cdc30774a9b1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/32872b8166a37a94938bdb81b533cdc30774a9b1",
      "tree": {
        "sha": "89fb7dbc28d09c8d7d324664a4cbebda983b5d19",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/89fb7dbc28d09c8d7d324664a4cbebda983b5d19"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/327f08bb0cd91a22249395adeb34549e3c86ca76",
          "sha": "327f08bb0cd91a22249395adeb34549e3c86ca76",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/327f08bb0cd91a22249395adeb34549e3c86ca76"
        }
      ],
      "message": "util: add VecDeque\n\nThis is an STL-like container that interface-wise looks like std::deque, but\nis backed by a (fixed size, with vector-like capacity/reserve) circular buffer.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-25T23:57:34Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-02-07T19:38:52Z"
      },
      "sha": "32872b8166a37a94938bdb81b533cdc30774a9b1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDgyMjU4ZjBmZDAyMzlmMGUxN2ZhZTc1Y2JmNzQ3OWJlZmQyNWUwZmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "tree": {
        "sha": "1ab0bcabfd2bf2ff69ad8282210b0299a7a2fab3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ab0bcabfd2bf2ff69ad8282210b0299a7a2fab3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32872b8166a37a94938bdb81b533cdc30774a9b1",
          "sha": "32872b8166a37a94938bdb81b533cdc30774a9b1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/32872b8166a37a94938bdb81b533cdc30774a9b1"
        }
      ],
      "message": "tests: add fuzz tests for VecDeque",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-25T23:57:34Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-23T17:03:39Z"
      },
      "sha": "82258f0fd0239f0e17fae75cbf7479befd25e0fa"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934322753,
      "node_id": "HRFPE_lADOABII586J5NBmzwAAAAMC8hpB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934322753",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T23:58:43Z"
    },
    {
      "event": "commented",
      "id": 2131728449,
      "node_id": "IC_kwDOABII585_D5hB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2131728449",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-26T00:01:14Z",
      "updated_at": "2024-05-26T00:01:14Z",
      "author_association": "MEMBER",
      "body": "Apparently `std::is_trivially_default_constructible_v<T>` does not imply you can just memset 0 to construct the objects (or at least, I can't find evidence of that). So I've dropped that branch.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2131728449",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "labeled",
      "id": 12945161931,
      "node_id": "LE_lADOABII586J5NBmzwAAAAMDl37L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12945161931",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:09:26Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "commented",
      "id": 2133351751,
      "node_id": "IC_kwDOABII585_KF1H",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133351751",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:12:11Z",
      "updated_at": "2024-05-27T12:12:11Z",
      "author_association": "MEMBER",
      "body": "Concept ACK.",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133351751",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    },
    {
      "event": "commented",
      "id": 2133434672,
      "node_id": "IC_kwDOABII585_KaEw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133434672",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:59:30Z",
      "updated_at": "2024-05-27T12:59:30Z",
      "author_association": "MEMBER",
      "body": "> It's not a full drop-in replacement...\r\n\r\nThen, perhaps, it's a good chance to avoid `size_t` for parameter and return types in the interface?\r\n\r\nSee: [Signed and Unsigned Types in Interfaces](https://www.aristeia.com/Papers/C++ReportColumns/sep95.pdf)",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#issuecomment-2133434672",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30161"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870",
      "pull_request_review_id": 2077094091,
      "id": 1613576870,
      "node_id": "PRRC_kwDOABII585gLTqm",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Seems like this would be easier?\r\n```suggestion\r\n        unsigned idx = real.empty() ? 0 : provider.ConsumeIntegralInRange<unsigned>(0, real.size() - 1);\r\n```",
      "created_at": "2024-05-24T14:31:17Z",
      "updated_at": "2024-05-24T16:46:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613576870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613576870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996",
      "pull_request_review_id": 2077094091,
      "id": 1613595996,
      "node_id": "PRRC_kwDOABII585gLYVc",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        // Pick one operation based on value of command. Not all operations are always applicable.\r\n        // Loop through the applicable ones until command reaches 0 (avoids the need to compute\r\n        // the number of applicable commands ahead of time).\r\n```",
      "created_at": "2024-05-24T14:44:12Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613595996",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613595996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895",
      "pull_request_review_id": 2077153695,
      "id": 1613608895,
      "node_id": "PRRC_kwDOABII585gLbe_",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 34,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\r\n```\r\n\r\nstyle-nit: I think `inline` can be dropped, according to https://en.cppreference.com/w/cpp/language/inline\r\n\r\n> A function defined entirely inside a [class/struct/union definition](https://en.cppreference.com/w/cpp/language/classes), whether it's a member function or a non-member friend function, is implicitly an inline function [...]\r\n\r\n",
      "created_at": "2024-05-24T14:52:59Z",
      "updated_at": "2024-05-24T14:53:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613608895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613608895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296",
      "pull_request_review_id": 2077094091,
      "id": 1613637296,
      "node_id": "PRRC_kwDOABII585gLiaw",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There's an assumption that at least one of the operations is applicable every time. Pretty obviously true but I assigned variables to all the possible conditions while reviewing and used it to add an assertion. Might be easier to read so I figured I'd leave a comment.\r\n```suggestion\r\n        const bool non_empty{num_buffers != 0};\r\n        const bool non_full{num_buffers < MAX_BUFFERS};\r\n        const bool partially_full{num_buffers > 0 && num_buffers < MAX_BUFFERS};\r\n        const bool multiple_exist{num_buffers > 1};\r\n        const bool existing_buffer_nonfull{non_empty && sim[idx].size() < MAX_BUFFER_SIZE};\r\n        const bool existing_buffer_nonempty{non_empty && !sim[idx].empty()};\r\n        assert(non_full || non_empty || partially_full);\r\n        \r\n        while (true) {\r\n```",
      "created_at": "2024-05-24T15:13:13Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613637296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613637296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947",
      "pull_request_review_id": 2077094091,
      "id": 1613660947,
      "node_id": "PRRC_kwDOABII585gLoMT",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // Create entry for this object in g_tracker and populate m_track_entry\r\n    void Register()\r\n```",
      "created_at": "2024-05-24T15:31:26Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613660947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613660947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502",
      "pull_request_review_id": 2077094091,
      "id": 1613661502,
      "node_id": "PRRC_kwDOABII585gLoU-",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 324,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // Get value corresponding to this object in g_tracker\r\n    std::optional<uint64_t>& Deref()\r\n```",
      "created_at": "2024-05-24T15:31:47Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613661502",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613661502"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028",
      "pull_request_review_id": 2077094091,
      "id": 1613663028,
      "node_id": "PRRC_kwDOABII585gLos0",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 404,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`static_assert(!std::is_trivially_copyable_v<TrackedObj<1>>)` ?",
      "created_at": "2024-05-24T15:32:32Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613663028",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613663028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 404,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426",
      "pull_request_review_id": 2077266898,
      "id": 1613674426,
      "node_id": "PRRC_kwDOABII585gLre6",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    inline size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 34,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613608895,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.\r\n\r\n`inline` does have an effect beyond making it an inline function (in GCC and Clang it increases the eagerness of the compiler to actually inline the function), but that's the sort of optimization one should only do guided by benchmarks, which I haven't done, so I dropped the `inline` here.",
      "created_at": "2024-05-24T15:37:14Z",
      "updated_at": "2024-05-24T15:37:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613674426",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674426"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058",
      "pull_request_review_id": 2077094091,
      "id": 1613702058,
      "node_id": "PRRC_kwDOABII585gLyOq",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was slightly confused that this was called `RingBuffer` since the data structure itself doesn't act like a ring buffer i.e. will reallocate if adding items beyond capacity (I wrote `vExtraTxnForCompact` to use it before looking at the implementation and then realized I misunderstood the interface). But I now have read that `m_buffer` is the ring buffer - oops.",
      "created_at": "2024-05-24T15:57:09Z",
      "updated_at": "2024-05-24T16:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613702058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613702058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327",
      "pull_request_review_id": 2077390047,
      "id": 1613746327,
      "node_id": "PRRC_kwDOABII585gL9CX",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": 1613702058,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm, this is a good point. The `RingBuffer` class' interface isn't a ring buffer, but a deque; the implementation happens to use a ring buffer. Suggestions/bikeshedding for a better name welcome.",
      "created_at": "2024-05-24T16:33:21Z",
      "updated_at": "2024-05-24T16:33:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613746327",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613746327"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739",
      "pull_request_review_id": 2077411055,
      "id": 1613757739,
      "node_id": "PRRC_kwDOABII585gL_0r",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613576870,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"Integral in Rage\" sounds like a high-school metal band.",
      "created_at": "2024-05-24T16:42:55Z",
      "updated_at": "2024-05-24T16:42:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613757739",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613757739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731",
      "pull_request_review_id": 2077454937,
      "id": 1613785731,
      "node_id": "PRRC_kwDOABII585gMGqD",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613576870,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:34Z",
      "updated_at": "2024-05-24T17:08:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818",
      "pull_request_review_id": 2077455089,
      "id": 1613785818,
      "node_id": "PRRC_kwDOABII585gMGra",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613595996,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:40Z",
      "updated_at": "2024-05-24T17:08:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897",
      "pull_request_review_id": 2077455207,
      "id": 1613785897,
      "node_id": "PRRC_kwDOABII585gMGsp",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613637296,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:45Z",
      "updated_at": "2024-05-24T17:08:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785897",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977",
      "pull_request_review_id": 2077455350,
      "id": 1613785977,
      "node_id": "PRRC_kwDOABII585gMGt5",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 324,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613661502,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:08:52Z",
      "updated_at": "2024-05-24T17:08:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613785977",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785977"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034",
      "pull_request_review_id": 2077455436,
      "id": 1613786034,
      "node_id": "PRRC_kwDOABII585gMGuy",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": 1613702058,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In Rust they call it [`VecDeque`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html), maybe that's a naming option? (It even rhymes!)",
      "created_at": "2024-05-24T17:08:55Z",
      "updated_at": "2024-05-24T17:08:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786034",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106",
      "pull_request_review_id": 2077455546,
      "id": 1613786106,
      "node_id": "PRRC_kwDOABII585gMGv6",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613660947,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-05-24T17:09:00Z",
      "updated_at": "2024-05-24T17:09:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786106",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786106"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217",
      "pull_request_review_id": 2077455736,
      "id": 1613786217,
      "node_id": "PRRC_kwDOABII585gMGxp",
      "diff_hunk": "@@ -0,0 +1,408 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/ringbuffer.h>\n+\n+#include <iostream>\n+#include <deque>\n+#include <stdint.h>\n+\n+namespace {\n+\n+/** The maximum number of simultaneous buffers kept by the test. */\n+static constexpr size_t MAX_BUFFERS{3};\n+/** How many elements are kept in a buffer at most. */\n+static constexpr size_t MAX_BUFFER_SIZE{48};\n+/** How many operations are performed at most on the buffers in one test. */\n+static constexpr size_t MAX_OPERATIONS{1024};\n+\n+/** Perform a simulation fuzz test on RingBuffer type T.\n+ *\n+ * T must be constructible from a uint64_t seed, comparable to other T, copyable, and movable.\n+ */\n+template<typename T, bool CheckNoneLeft>\n+void TestType(Span<const uint8_t> buffer, uint64_t rng_tweak)\n+{\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    // Local RNG, only used for the seeds to initialize T objects with.\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>() ^ rng_tweak);\n+\n+    // Real circular buffers.\n+    std::vector<RingBuffer<T>> real;\n+    real.reserve(MAX_BUFFERS);\n+    // Simulated circular buffers.\n+    std::vector<std::deque<T>> sim;\n+    sim.reserve(MAX_BUFFERS);\n+    // Temporary object of type T.\n+    std::optional<T> tmp;\n+\n+    // Compare a real and a simulated buffer.\n+    auto compare_fn = [](const RingBuffer<T>& r, const std::deque<T>& s) {\n+        assert(r.size() == s.size());\n+        assert(r.empty() == s.empty());\n+        assert(r.capacity() >= r.size());\n+        if (s.size() == 0) return;\n+        assert(r.front() == s.front());\n+        assert(r.back() == s.back());\n+        for (size_t i = 0; i < s.size(); ++i) {\n+            assert(r[i] == s[i]);\n+        }\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes(), MAX_OPERATIONS) {\n+        auto cmd_byte = provider.ConsumeIntegral<uint8_t>();\n+        unsigned idx = real.empty() ? 0 : (unsigned{cmd_byte} * real.size()) >> 8;\n+        int command = cmd_byte % 32;\n+        const size_t num_buffers = sim.size();\n+        // Loop until command reaches 0 (not all commands are always applicable, and this approach\n+        // avoids the need to compute the number of applicable commands ahead of time).\n+        while (true) {\n+            if (num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Default construct. */\n+                real.emplace_back();\n+                sim.emplace_back();\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* resize() */\n+                size_t new_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                real[idx].resize(new_size);\n+                sim[idx].resize(new_size);\n+                assert(real[idx].size() == new_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* clear() */\n+                real[idx].clear();\n+                sim[idx].clear();\n+                assert(real[idx].empty());\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Copy construct default. */\n+                real[idx] = RingBuffer<T>();\n+                sim[idx].clear();\n+                assert(real[idx].size() == 0);\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* Destruct. */\n+                compare_fn(real.back(), sim.back());\n+                real.pop_back();\n+                sim.pop_back();\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Copy construct. */\n+                real.emplace_back(real[idx]);\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 0 && num_buffers < MAX_BUFFERS && command-- == 0) {\n+                /* Move construct. */\n+                RingBuffer<T> copy(real[idx]);\n+                real.emplace_back(std::move(copy));\n+                sim.emplace_back(sim[idx]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* swap() */\n+                swap(real[idx], real[(idx + 1) % num_buffers]);\n+                swap(sim[idx], sim[(idx + 1) % sim.size()]);\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Copy assign. */\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = real[(idx + 1) % num_buffers];\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers > 1 && command-- == 0) {\n+                /* Move assign. */\n+                RingBuffer<T> copy(real[(idx + 1) % num_buffers]);\n+                compare_fn(real[idx], sim[idx]);\n+                real[idx] = std::move(copy);\n+                sim[idx] = sim[(idx + 1) % sim.size()];\n+                break;\n+            }\n+            if (num_buffers != 0 && command-- == 0) {\n+                /* reserve() */\n+                size_t res_size = provider.ConsumeIntegralInRange<size_t>(0, MAX_BUFFER_SIZE);\n+                size_t old_cap = real[idx].capacity();\n+                size_t old_size = real[idx].size();\n+                real[idx].reserve(res_size);\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == std::max(old_cap, res_size));\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* shrink_to_fit() */\n+                size_t old_size = real[idx].size();\n+                real[idx].shrink_to_fit();\n+                assert(real[idx].size() == old_size);\n+                assert(real[idx].capacity() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_back(*tmp);\n+                sim[idx].push_back(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_back() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_back(*tmp);\n+                real[idx].push_back(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_back() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_back(seed);\n+                real[idx].emplace_back(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (copying) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                real[idx].push_front(*tmp);\n+                sim[idx].push_front(*tmp);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* push_front() (moving) */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].push_front(*tmp);\n+                real[idx].push_front(std::move(*tmp));\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && sim[idx].size() < MAX_BUFFER_SIZE && command-- == 0) {\n+                /* emplace_front() */\n+                uint64_t seed{rng()};\n+                size_t old_size = real[idx].size();\n+                size_t old_cap = real[idx].capacity();\n+                sim[idx].emplace_front(seed);\n+                real[idx].emplace_front(seed);\n+                assert(real[idx].size() == old_size + 1);\n+                if (old_cap > old_size) assert(real[idx].capacity() == old_cap);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* front() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].front() == real[idx].front());\n+                sim[idx].front() = *tmp;\n+                real[idx].front() = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* back() [modifying] */\n+                tmp = T(rng());\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx].back() == real[idx].back());\n+                sim[idx].back() = *tmp;\n+                real[idx].back() = *tmp;\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+            if (num_buffers != 0 && !sim[idx].empty() && command-- == 0) {\n+                /* operator[] [modifying] */\n+                tmp = T(rng());\n+                size_t pos = provider.ConsumeIntegralInRange<size_t>(0, sim[idx].size() - 1);\n+                size_t old_size = real[idx].size();\n+                assert(sim[idx][pos] == real[idx][pos]);\n+                sim[idx][pos] = *tmp;\n+                real[idx][pos] = std::move(*tmp);\n+                assert(real[idx].size() == old_size);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Fully compare the final state. */\n+    for (unsigned i = 0; i < sim.size(); ++i) {\n+        // Make sure const getters work.\n+        const RingBuffer<T>& realbuf = real[i];\n+        const std::deque<T>& simbuf = sim[i];\n+        compare_fn(realbuf, simbuf);\n+        for (unsigned j = 0; j < sim.size(); ++j) {\n+            assert((realbuf == real[j]) == (simbuf == sim[j]));\n+            assert(((realbuf <=> real[j]) >= 0) == (simbuf >= sim[j]));\n+            assert(((realbuf <=> real[j]) <= 0) == (simbuf <= sim[j]));\n+        }\n+        // Clear out the buffers so we can check below that no objects exist anymore.\n+        sim[i].clear();\n+        real[i].clear();\n+    }\n+\n+    if constexpr (CheckNoneLeft) {\n+        tmp = std::nullopt;\n+        T::CheckNoneExist();\n+    }\n+}\n+\n+/** Data structure with built-in tracking of all existing objects. */\n+template<size_t Size>\n+class TrackedObj\n+{\n+    static_assert(Size > 0);\n+\n+    /* Data type for map that actually stores the object data.\n+     *\n+     * The key is a pointer to the TrackedObj, the value is the uint64_t it was initialized with.\n+     * Default-constructed and moved-from objects hold an std::nullopt.\n+     */\n+    using track_map_type = std::map<const TrackedObj<Size>*, std::optional<uint64_t>>;\n+\n+private:\n+\n+    /** Actual map. */\n+    static inline track_map_type g_tracker;\n+\n+    /** Iterators into the tracker map for this object.\n+     *\n+     * This is an array of size Size, all holding the same value, to give the object configurable\n+     * size. The value is g_tracker.end() if this object is not fully initialized. */\n+    typename track_map_type::iterator m_track_entry[Size];\n+\n+    void Check() const\n+    {\n+        auto it = g_tracker.find(this);\n+        for (size_t i = 0; i < Size; ++i) {\n+            assert(m_track_entry[i] == it);\n+        }\n+    }\n+\n+    void Register()\n+    {\n+        auto [it, inserted] = g_tracker.emplace(this, std::nullopt);\n+        assert(inserted);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = it;\n+        }\n+    }\n+\n+    void Deregister()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        g_tracker.erase(m_track_entry[0]);\n+        for (size_t i = 0; i < Size; ++i) {\n+            m_track_entry[i] = g_tracker.end();\n+        }\n+    }\n+\n+    std::optional<uint64_t>& Deref()\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+    const std::optional<uint64_t>& Deref() const\n+    {\n+        Check();\n+        assert(m_track_entry[0] != g_tracker.end());\n+        return m_track_entry[0]->second;\n+    }\n+\n+public:\n+    ~TrackedObj() { Deregister(); }\n+    TrackedObj() { Register(); }\n+\n+    TrackedObj(uint64_t value)\n+    {\n+        Register();\n+        Deref() = value;\n+    }\n+\n+    TrackedObj(const TrackedObj& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+    }\n+\n+    TrackedObj(TrackedObj&& other)\n+    {\n+        Register();\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+    }\n+\n+    TrackedObj& operator=(const TrackedObj& other)\n+    {\n+        Deref() = other.Deref();\n+        return *this;\n+    }\n+\n+    TrackedObj& operator=(TrackedObj&& other)\n+    {\n+        Deref() = other.Deref();\n+        other.Deref() = std::nullopt;\n+        return *this;\n+    }\n+\n+    friend bool operator==(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        return a.Deref() == b.Deref();\n+    }\n+\n+    friend std::strong_ordering operator<=>(const TrackedObj& a, const TrackedObj& b)\n+    {\n+        // Libc++ 15 & 16 do not support std::optional<T>::operator<=> yet. See\n+        // https://reviews.llvm.org/D146392.\n+        if (!a.Deref().has_value() || !b.Deref().has_value()) {\n+            return a.Deref().has_value() <=> b.Deref().has_value();\n+        }\n+        return *a.Deref() <=> *b.Deref();\n+    }\n+\n+    static void CheckNoneExist()\n+    {\n+        assert(g_tracker.empty());\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(ringbuffer)\n+{\n+    // Run the test with simple uints (which are std::is_trivially_copyable_v).\n+    TestType<uint8_t, false>(buffer, 1);\n+    TestType<uint16_t, false>(buffer, 2);\n+    TestType<uint32_t, false>(buffer, 3);\n+    TestType<uint64_t, false>(buffer, 4);\n+    // Run the test with TrackedObjs (which are not).",
      "path": "src/test/fuzz/ringbuffer.cpp",
      "position": null,
      "original_position": 404,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "017272dff1076068d5d878dbe599fb5a3e12115c",
      "in_reply_to_id": 1613663028,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done (and more).",
      "created_at": "2024-05-24T17:09:08Z",
      "updated_at": "2024-05-24T17:09:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613786217",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613786217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 404,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244",
      "pull_request_review_id": 2077498512,
      "id": 1613810244,
      "node_id": "PRRC_kwDOABII585gMMpE",
      "diff_hunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_RINGBUFFER_H\n+#define BITCOIN_UTIL_RINGBUFFER_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class RingBuffer",
      "path": "src/util/ringbuffer.h",
      "position": null,
      "original_position": 23,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "c2a4915257f7b2303cd17a9a30728157616b5ce6",
      "in_reply_to_id": 1613702058,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Renamed!",
      "created_at": "2024-05-24T17:32:13Z",
      "updated_at": "2024-05-24T17:32:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613810244",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613810244"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882",
      "pull_request_review_id": 2077678840,
      "id": 1613915882,
      "node_id": "PRRC_kwDOABII585gMmbq",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 162,
      "original_position": 171,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could do (i think 3?) memcmp here if `is_trivially_copyable_v`, but maybe it's not worth the complexity of differing offsets.",
      "created_at": "2024-05-24T19:17:04Z",
      "updated_at": "2024-05-24T19:17:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613915882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613915882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 162,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119",
      "pull_request_review_id": 2077689045,
      "id": 1613922119,
      "node_id": "PRRC_kwDOABII585gMn9H",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 162,
      "original_position": 171,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Trivially copyable does not imply a trivial `operator!=`, I think.",
      "created_at": "2024-05-24T19:19:53Z",
      "updated_at": "2024-05-24T19:22:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613922119",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613922119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 162,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002",
      "pull_request_review_id": 2077694876,
      "id": 1613925002,
      "node_id": "PRRC_kwDOABII585gMoqK",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 162,
      "original_position": 171,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "From https://en.cppreference.com/w/cpp/types/is_trivially_copyable:\r\n\"Objects of trivially-copyable types that are not potentially-overlapping subobjects are the only C++ objects that may be safely copied with [std::memcpy](https://en.cppreference.com/w/cpp/string/byte/memcpy) or serialized to/from binary files with [std::ofstream::write()](https://en.cppreference.com/w/cpp/io/basic_ostream/write) / [std::ifstream::read()](https://en.cppreference.com/w/cpp/io/basic_istream/read).\"\r\n\r\nI assume anything that can be memcpy'd can be memcmp'd.",
      "created_at": "2024-05-24T19:22:58Z",
      "updated_at": "2024-05-24T19:23:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613925002",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613925002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 162,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027",
      "pull_request_review_id": 2077727864,
      "id": 1613941027,
      "node_id": "PRRC_kwDOABII585gMskj",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 162,
      "original_position": 171,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I certainly see why it's reasonable why trivial types would have a trivial comparison operator, but there is no guarantee for that. I think you can have a trivially-constructible type with an complex `operator==` (for such a type you'd expect that something that was memcpy'd you end up with a result that satisfies ==, but I don't think that's required, and it also doesn't work the other way around: objects could satisfy == without being bitwise identical).",
      "created_at": "2024-05-24T19:31:04Z",
      "updated_at": "2024-05-24T19:31:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613941027",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613941027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 162,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540",
      "pull_request_review_id": 2077737706,
      "id": 1613943540,
      "node_id": "PRRC_kwDOABII585gMtL0",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 162,
      "original_position": 171,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok, yeah, agreed.",
      "created_at": "2024-05-24T19:34:39Z",
      "updated_at": "2024-05-24T19:34:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1613943540",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613943540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 162,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973",
      "pull_request_review_id": 2078066616,
      "id": 1614029973,
      "node_id": "PRRC_kwDOABII585gNCSV",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 162,
      "original_position": 171,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just adding for posterity because I went down a rabbit hole for this:\r\n\r\nIt seems clang's `__is_trivially_equality_comparable` builtin would do what we want here:\r\n> Returns true if comparing two objects of the provided type is known to be equivalent to comparing their object representations. Note that types containing padding bytes are never trivially equality comparable.\r\n\r\n[From libc++](https://github.com/llvm/llvm-project/blob/main/libcxx/include/__type_traits/is_equality_comparable.h#L36C1-L37C41):\r\n```c++\r\n// A type is_trivially_equality_comparable if the expression `a == b` is equivalent to `std::memcmp(&a, &b, sizeof(T))`\r\n// (with `a` and `b` being of type `T`).\r\n```\r\nNot that it's worth using here.",
      "created_at": "2024-05-24T21:14:50Z",
      "updated_at": "2024-05-24T22:11:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614029973",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614029973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 162,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880",
      "pull_request_review_id": 2078108333,
      "id": 1614066880,
      "node_id": "PRRC_kwDOABII585gNLTA",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECDEQUE_H\n+#define BITCOIN_UTIL_VECDEQUE_H\n+\n+#include <util/check.h>\n+\n+#include <cstring>\n+#include <memory>\n+\n+/** Data structure largely mimicking std::deque, but using single preallocated ring buffer.\n+ *\n+ * - More efficient and better memory locality than std::deque.\n+ * - Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], ...) are O(1),\n+ *   unless reallocation is needed (in which case they are O(n)).\n+ * - Supports reserve(), capacity(), shrink_to_fit() like vectors.\n+ * - No iterator support.\n+ * - Data is not stored in a single contiguous block, so no data().\n+ */\n+template<typename T>\n+class VecDeque\n+{\n+    /** Pointer to allocated memory. Can contain constructed and uninitialized T objects. */\n+    T* m_buffer{nullptr};\n+    /** m_buffer + m_offset points to first object. m_offset < m_capacity. */\n+    size_t m_offset{0};\n+    /** Number of objects in the container. m_size < m_capacity. */\n+    size_t m_size{0};\n+    /** The size of m_buffer, expressed as a multiple of the size of T. */\n+    size_t m_capacity{0};\n+\n+    size_t FirstPart() const noexcept { return std::min(m_capacity - m_offset, m_size); }\n+\n+    void Reallocate(size_t capacity)\n+    {\n+        Assume(capacity >= m_size);\n+        Assume(m_capacity == 0 || m_offset < m_capacity);\n+        // Allocate new buffer.\n+        T* new_buffer = capacity ? std::allocator<T>().allocate(capacity) : nullptr;\n+        if (capacity) {\n+            if constexpr (std::is_trivially_copyable_v<T>) {\n+                // When T is trivially copyable, just copy the data over from old to new buffer.\n+                size_t first_part = FirstPart();\n+                if (first_part != 0) {\n+                    std::memcpy(new_buffer, m_buffer + m_offset, first_part * sizeof(T));\n+                }\n+                if (first_part != m_size) {\n+                    std::memcpy(new_buffer + first_part, m_buffer, (m_size - first_part) * sizeof(T));\n+                }\n+            } else {\n+                // Otherwise move-construct in place in the new buffer, and destroy old buffer objects.\n+                size_t old_pos = m_offset;\n+                for (size_t new_pos = 0; new_pos < m_size; ++new_pos) {\n+                    std::construct_at<T>(new_buffer + new_pos, std::move(*(m_buffer + old_pos)));\n+                    std::destroy_at<T>(m_buffer + old_pos);\n+                    ++old_pos;\n+                    if (old_pos == m_capacity) old_pos = 0;\n+                }\n+            }\n+        }\n+        // Deallocate old buffer and update housekeeping.\n+        std::allocator<T>().deallocate(m_buffer, m_capacity);\n+        m_buffer = new_buffer;\n+        m_offset = 0;\n+        m_capacity = capacity;\n+    }\n+\n+    /** What index in the buffer does logical entry number pos have? */\n+    size_t Index(size_t pos) const noexcept\n+    {\n+        if (pos >= m_capacity - m_offset) {\n+            return pos - (m_capacity - m_offset);\n+        } else {\n+            return pos + m_offset;\n+        }\n+    }\n+\n+    /** Specialization of resize() that can only shrink. Separate so that clear() can call it\n+     *  without requiring a default T constructor. */\n+    void ResizeDown(size_t size)\n+    {\n+        Assume(size <= m_size);\n+        if constexpr (std::is_trivially_destructible_v<T>) {\n+            // If T is trivially destructible, we do not need to do anything but update the\n+            // housekeeping record. Default constructor or zero-filling will be used when\n+            // the space is reused.\n+            m_size = size;\n+        } else {\n+            // If not, we need to invoke the destructor for every element separately.\n+            while (m_size > size) {\n+                std::destroy_at<T>(m_buffer + Index(m_size - 1));\n+                --m_size;\n+            }\n+        }\n+    }\n+\n+public:\n+    VecDeque() noexcept = default;\n+\n+    void resize(size_t size)\n+    {\n+        if (size < m_size) {\n+            // Delegate to ResizeDown when shrinking.\n+            ResizeDown(size);\n+        } else if (size > m_size) {\n+            // When growing, first see if we need to allocate more space.\n+            if (size > m_capacity) Reallocate(size);\n+            if constexpr (std::is_trivially_constructible_v<T>) {\n+                // If T is trivially constructible, just zero-initialize the area being used.\n+                size_t first_part = std::min(m_capacity - Index(m_size), size - m_size);\n+                if (first_part) std::fill(m_buffer + Index(m_size), m_buffer + Index(m_size) + first_part, 0);\n+                if (first_part < size - m_size) std::fill(m_buffer, m_buffer + size - m_size - first_part, 0);\n+                m_size = size;\n+            } else {\n+                // Otherwise invoke the default constructor for every element separately.\n+                while (m_size < size) {\n+                    std::construct_at<T>(m_buffer + Index(m_size));\n+                    ++m_size;\n+                }\n+            }\n+        }\n+    }\n+\n+    void clear() { ResizeDown(0); }\n+\n+    ~VecDeque()\n+    {\n+        clear();\n+        Reallocate(0);\n+    }\n+\n+    VecDeque& operator=(const VecDeque& other)\n+    {\n+        clear();\n+        Reallocate(other.m_size);\n+        if constexpr (std::is_trivially_copyable_v<T>) {\n+            size_t first_part = other.FirstPart();\n+            if (first_part != 0) {\n+                std::memcpy(m_buffer, other.m_buffer + other.m_offset, first_part * sizeof(T));\n+            }\n+            if (first_part != other.m_size) {\n+                std::memcpy(m_buffer + first_part, other.m_buffer, (other.m_size - first_part) * sizeof(T));\n+            }\n+            m_size = other.m_size;\n+        } else {\n+            while (m_size < other.m_size) {\n+                std::construct_at<T>(m_buffer + Index(m_size), other[m_size]);\n+                ++m_size;\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    void swap(VecDeque& other) noexcept\n+    {\n+        std::swap(m_buffer, other.m_buffer);\n+        std::swap(m_offset, other.m_offset);\n+        std::swap(m_size, other.m_size);\n+        std::swap(m_capacity, other.m_capacity);\n+    }\n+\n+    friend void swap(VecDeque& a, VecDeque& b) noexcept { a.swap(b); }\n+    VecDeque& operator=(VecDeque&& other) noexcept { swap(other); return *this; }\n+    VecDeque(const VecDeque& other) { *this = other; }\n+    VecDeque(VecDeque&& other) noexcept { swap(other); }\n+\n+    bool friend operator==(const VecDeque& a, const VecDeque& b)\n+    {\n+        if (a.m_size != b.m_size) return false;",
      "path": "src/util/vecdeque.h",
      "position": 162,
      "original_position": 171,
      "commit_id": "82258f0fd0239f0e17fae75cbf7479befd25e0fa",
      "original_commit_id": "f4d6f4a8548c63dbed72aa618d64b7ac2e7fcbad",
      "in_reply_to_id": 1613915882,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting!",
      "created_at": "2024-05-24T21:56:18Z",
      "updated_at": "2024-05-24T21:56:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30161#discussion_r1614066880",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1614066880"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30161"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 162,
      "original_line": 162,
      "side": "RIGHT"
    }
  ]
}