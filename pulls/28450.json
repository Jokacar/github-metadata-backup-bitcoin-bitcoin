{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450",
    "id": 1510432768,
    "node_id": "PR_kwDOABII585aB2AA",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/28450",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/28450.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/28450.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/262ab8ef7860d43cebc9d04721e3a075b4edf06e",
    "number": 28450,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "Add package evaluation fuzzer",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This fuzzer target caught the issue in https://github.com/bitcoin/bitcoin/pull/28251 within 5 minutes on master branch, and an additional issue which I've applied a preliminary patch to cover.\r\n\r\nFuzzer target does the following:\r\n\r\n1) Picks mempool confgs, including max package size, count, mempool size, etc\r\n2) Generates 1 to 26 transactions with arbitrary coins/fees, the first N-1 spending only confirmed outpoints\r\n3) Nth transaction, if >1, sweeps all unconfirmed outpoints in mempool\r\n4) If N==1, it may submit it through single-tx submission path, to allow for more interesting topologies\r\n5) Otherwise submits through package submission interface\r\n6) Repeat 1-5  a few hundred times per mempool instance\r\n\r\nIn other words, it ends up building chains of txns in the mempool using parents-and-children packages, which is currently the topology supported on master.\r\n\r\nThe test itself is a direct rip of tx_pool.cpp, with a number of assertions removed because they were failing for unknown reasons, likely due to the notification changes of single tx submission to package, which is used to track addition/removal of transactions in the test. I'll continue working on re-adding these assertions for further invariant testing.",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "created_at": "2023-09-11T14:10:48Z",
    "updated_at": "2024-09-27T20:47:48Z",
    "closed_at": "2023-09-28T11:06:18Z",
    "mergeable_state": "unknown",
    "merged_at": "2023-09-28T11:06:18Z",
    "merge_commit_sha": "6619d6a8dca5a4d8e664a76526ac6bef3eb17831",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "instagibbs:2023-08-mid-package-trim-sep-8-fuzz",
      "ref": "2023-08-mid-package-trim-sep-8-fuzz",
      "sha": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 13910191,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMzkxMDE5MQ==",
        "name": "bitcoin",
        "full_name": "instagibbs/bitcoin",
        "owner": {
          "login": "instagibbs",
          "id": 5767891,
          "node_id": "MDQ6VXNlcjU3Njc4OTE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/instagibbs",
          "html_url": "https://github.com/instagibbs",
          "followers_url": "https://api.github.com/users/instagibbs/followers",
          "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
          "organizations_url": "https://api.github.com/users/instagibbs/orgs",
          "repos_url": "https://api.github.com/users/instagibbs/repos",
          "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/instagibbs/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/instagibbs/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/instagibbs/bitcoin",
        "archive_url": "https://api.github.com/repos/instagibbs/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/instagibbs/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/instagibbs/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/instagibbs/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/instagibbs/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/instagibbs/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/instagibbs/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/instagibbs/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/instagibbs/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/instagibbs/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/instagibbs/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/instagibbs/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/instagibbs/bitcoin/events",
        "forks_url": "https://api.github.com/repos/instagibbs/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/instagibbs/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/instagibbs/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/instagibbs/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/instagibbs/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/instagibbs/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/instagibbs/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/instagibbs/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/instagibbs/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/instagibbs/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/instagibbs/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/instagibbs/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/instagibbs/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/instagibbs/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/instagibbs/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/instagibbs/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:instagibbs/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/instagibbs/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/instagibbs/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/instagibbs/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/instagibbs/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/instagibbs/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/instagibbs/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/instagibbs/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/instagibbs/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/instagibbs/bitcoin/hooks",
        "svn_url": "https://github.com/instagibbs/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 2,
        "watchers_count": 2,
        "size": 246574,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-09-24T04:43:32Z",
        "created_at": "2013-10-27T20:56:53Z",
        "updated_at": "2024-08-28T03:28:00Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "c9f288244b8d183e09a917025922b99e3368ef78",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36212,
        "stargazers_count": 78569,
        "watchers_count": 78569,
        "size": 269032,
        "default_branch": "master",
        "open_issues_count": 662,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-09-27T10:17:47Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-09-27T20:20:55Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 295,
    "deletions": 0,
    "changed_files": 2,
    "commits": 1,
    "review_comments": 60,
    "comments": 20
  },
  "events": [
    {
      "event": "commented",
      "id": 1713970394,
      "node_id": "IC_kwDOABII585mKRza",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713970394",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:10:51Z",
      "updated_at": "2023-09-28T10:59:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [murchandamus](https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1738042370), [glozow](https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1648426550), [dergoegge](https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1648493171) |\n| Concept ACK | [darosior](https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713984415), [brunoerg](https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1622579860), [MarcoFalke](https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719137408) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#26711](https://github.com/bitcoin/bitcoin/pull/26711) (validate package transactions with their in-package ancestor sets by glozow)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713970394",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "commented",
      "id": 1713971539,
      "node_id": "IC_kwDOABII585mKSFT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713971539",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:11:27Z",
      "updated_at": "2023-09-11T14:11:27Z",
      "author_association": "MEMBER",
      "body": "cc @glozow @MarcoFalke ",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713971539",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "mentioned",
      "id": 10334873734,
      "node_id": "MEE_lADOABII585wsHV1zwAAAAJoAaiG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10334873734",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:11:27Z"
    },
    {
      "event": "subscribed",
      "id": 10334873757,
      "node_id": "SE_lADOABII585wsHV1zwAAAAJoAaid",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10334873757",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:11:27Z"
    },
    {
      "event": "mentioned",
      "id": 10334873791,
      "node_id": "MEE_lADOABII585wsHV1zwAAAAJoAai_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10334873791",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:11:28Z"
    },
    {
      "event": "subscribed",
      "id": 10334873815,
      "node_id": "SE_lADOABII585wsHV1zwAAAAJoAajX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10334873815",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:11:28Z"
    },
    {
      "event": "labeled",
      "id": 10334889646,
      "node_id": "LE_lADOABII585wsHV1zwAAAAJoAeau",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10334889646",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:12:47Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "commented",
      "id": 1713984415,
      "node_id": "IC_kwDOABII585mKVOf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713984415",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:18:02Z",
      "updated_at": "2023-09-11T14:18:02Z",
      "author_association": "MEMBER",
      "body": "Awesome, Concept ACK.",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1713984415",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "reviewed",
      "id": 1620122880,
      "node_id": "PRR_kwDOABII585gkR0A",
      "url": null,
      "actor": null,
      "commit_id": "f06cf5b0549b741f6825e8dfea8ee97bcf7ed572",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "concept ACK, really nice :rocket: ",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1620122880",
      "submitted_at": "2023-09-11T14:22:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10335417113,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJoCfMZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10335417113",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:53:58Z"
    },
    {
      "event": "labeled",
      "id": 10335417974,
      "node_id": "LE_lADOABII585wsHV1zwAAAAJoCfZ2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10335417974",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T14:54:02Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "review_requested",
      "id": 10335536114,
      "node_id": "RRE_lADOABII585wsHV1zwAAAAJoC8Py",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10335536114",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T15:03:11Z",
      "requested_reviewer": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1620240896,
      "node_id": "PRR_kwDOABII585gkuoA",
      "url": null,
      "actor": null,
      "commit_id": "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1620240896",
      "submitted_at": "2023-09-11T15:16:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "reviewed",
      "id": 1622579860,
      "node_id": "PRR_kwDOABII585gtpqU",
      "url": null,
      "actor": null,
      "commit_id": "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1622579860",
      "submitted_at": "2023-09-12T15:46:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "labeled",
      "id": 10362619051,
      "node_id": "LE_lADOABII585wsHV1zwAAAAJpqQSr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10362619051",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:49:40Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10362815882,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJprAWK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10362815882",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T18:06:18Z"
    },
    {
      "event": "renamed",
      "id": 10362828971,
      "node_id": "RTE_lADOABII585wsHV1zwAAAAJprDir",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10362828971",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T18:07:53Z",
      "rename": {
        "from": "WIP: Add package evaluation fuzzer",
        "to": "Add package evaluation fuzzer"
      }
    },
    {
      "event": "commented",
      "id": 1718092570,
      "node_id": "IC_kwDOABII585maAMa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1718092570",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T18:09:05Z",
      "updated_at": "2023-09-13T18:09:05Z",
      "author_association": "MEMBER",
      "body": "rebased on master, removed arg round-trip, un-marked WIP",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1718092570",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "unlabeled",
      "id": 10363703696,
      "node_id": "UNLE_lADOABII585wsHV1zwAAAAJpuZGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10363703696",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T19:40:02Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 10364109573,
      "node_id": "UNLE_lADOABII585wsHV1zwAAAAJpv8MF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10364109573",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T20:03:07Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1719137408,
      "node_id": "IC_kwDOABII585md_SA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719137408",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-14T09:52:45Z",
      "updated_at": "2023-09-14T09:52:45Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, I guess this also picks up https://github.com/bitcoin/bitcoin/pull/25778 ?",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719137408",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "commented",
      "id": 1719217351,
      "node_id": "IC_kwDOABII585meSzH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719217351",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-14T10:47:56Z",
      "updated_at": "2023-09-14T10:47:56Z",
      "author_association": "MEMBER",
      "body": "Any interest in using `CheckPackageMempoolAcceptResult` from https://github.com/bitcoin/bitcoin/pull/26711/commits/baf475de599c82e7718ffefd7f0481fc88217853? It checks that a result contains the fields we expect based on whether it's supposed to be valid.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719217351",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "commented",
      "id": 1719512750,
      "node_id": "IC_kwDOABII585mfa6u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1719512750",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-14T14:00:21Z",
      "updated_at": "2023-09-14T14:30:23Z",
      "author_association": "MEMBER",
      "body": "@MarcoFalke oh, had no idea it existed. Yes I think this should subsume it. I kept it a separate fuzz target to allow more specialization for what we're covering.\r\n\r\n> Any interest in using CheckPackageMempoolAcceptResult from https://github.com/bitcoin/bitcoin/commit/baf475de599c82e7718ffefd7f0481fc88217853? It checks that a result contains the fields we expect based on whether it's supposed to be valid.\r\n\r\nI might take a subset of that, but a few parts wouldn't be useful since I'm firing off random packages that may or may not be valid, and the mempool may trim things even if they're valid?\r\n\r\nedit: In other words, please consider this PR review-ready :+1: ",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1719512750",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "mentioned",
      "id": 10372772049,
      "node_id": "MEE_lADOABII585wsHV1zwAAAAJqQ_DR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10372772049",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-14T14:00:21Z"
    },
    {
      "event": "subscribed",
      "id": 10372772062,
      "node_id": "SE_lADOABII585wsHV1zwAAAAJqQ_De",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10372772062",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-14T14:00:21Z"
    },
    {
      "event": "reviewed",
      "id": 1627544107,
      "node_id": "PRR_kwDOABII585hAlor",
      "url": null,
      "actor": null,
      "commit_id": "28f45d6883d06c56dfd7444eeb82b30cff6b8c1b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1627544107",
      "submitted_at": "2023-09-14T18:42:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10383711688,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJq6t3I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10383711688",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-15T13:45:58Z"
    },
    {
      "event": "commented",
      "id": 1721311984,
      "node_id": "IC_kwDOABII585mmSLw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1721311984",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-15T13:46:43Z",
      "updated_at": "2023-09-15T18:52:30Z",
      "author_association": "MEMBER",
      "body": "removed the second commit to not impede review of the various bugfix PRs individually\r\n\r\nrebasing on this should result in no known crashes: https://github.com/bitcoin/bitcoin/pull/28471\r\nhttps://github.com/bitcoin/bitcoin/pull/28472",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1721311984",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "reviewed",
      "id": 1635411567,
      "node_id": "PRR_kwDOABII585hemZv",
      "url": null,
      "actor": null,
      "commit_id": "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1635411567",
      "submitted_at": "2023-09-20T11:27:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10423717001,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJtTUyJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10423717001",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-20T14:02:00Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10423730456,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJtTYEY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10423730456",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-20T14:03:06Z"
    },
    {
      "event": "commented",
      "id": 1727984710,
      "node_id": "IC_kwDOABII585m_vRG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1727984710",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-20T15:45:23Z",
      "updated_at": "2023-09-20T15:45:23Z",
      "author_association": "MEMBER",
      "body": "updated with cleanups",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1727984710",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "commented",
      "id": 1729293183,
      "node_id": "IC_kwDOABII585nEut_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729293183",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-21T10:27:42Z",
      "updated_at": "2023-09-21T10:27:42Z",
      "author_association": "MEMBER",
      "body": "from discussions with others:\r\n\r\n1) I have a PR built on https://github.com/bitcoin/bitcoin/pull/26711 which generalized from this fairly basic topology to general ancestor packages, including the last tx spending any subset of outpoints, and any package transactions potentially spending other package outpoints. I'd like to make sure it's getting relatively targeted coverage before switching to that, so deferring to after this PR.\r\n2) We can add coverage where we mutate the wtxid of txns\r\n3) Also should allow duplication of inputs\r\n\r\nI plan on doing these in the follow-up on top of #26711 ",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1729293183",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "reviewed",
      "id": 1637502233,
      "node_id": "PRR_kwDOABII585hmk0Z",
      "url": null,
      "actor": null,
      "commit_id": "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1637502233",
      "submitted_at": "2023-09-21T10:37:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "reviewed",
      "id": 1637516869,
      "node_id": "PRR_kwDOABII585hmoZF",
      "url": null,
      "actor": null,
      "commit_id": "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1637516869",
      "submitted_at": "2023-09-21T10:45:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10434063619,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJt6y0D",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10434063619",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-21T11:23:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10437804001,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJuJD_h",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10437804001",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-21T16:16:17Z"
    },
    {
      "event": "commented",
      "id": 1729897131,
      "node_id": "IC_kwDOABII585nHCKr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729897131",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-21T16:17:07Z",
      "updated_at": "2023-09-21T16:17:07Z",
      "author_association": "MEMBER",
      "body": "rebased on latest master on top of #28471 \r\n\r\nShould not be crashing anymore :crossed_fingers: cc @dergoegge ",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1729897131",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "mentioned",
      "id": 10437811977,
      "node_id": "MEE_lADOABII585wsHV1zwAAAAJuJF8J",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10437811977",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-21T16:17:08Z"
    },
    {
      "event": "subscribed",
      "id": 10437812004,
      "node_id": "SE_lADOABII585wsHV1zwAAAAJuJF8k",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10437812004",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-21T16:17:08Z"
    },
    {
      "event": "reviewed",
      "id": 1641093035,
      "node_id": "PRR_kwDOABII585h0Rer",
      "url": null,
      "actor": null,
      "commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1641093035",
      "submitted_at": "2023-09-24T16:39:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "reviewed",
      "id": 1641097915,
      "node_id": "PRR_kwDOABII585h0Sq7",
      "url": null,
      "actor": null,
      "commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1641097915",
      "submitted_at": "2023-09-24T17:27:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "reviewed",
      "id": 1641098600,
      "node_id": "PRR_kwDOABII585h0S1o",
      "url": null,
      "actor": null,
      "commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1641098600",
      "submitted_at": "2023-09-24T17:35:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "reviewed",
      "id": 1641957355,
      "node_id": "PRR_kwDOABII585h3kfr",
      "url": null,
      "actor": null,
      "commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "A few quick questions, looks correct to me though some bits are a little confusing. I know future updates are planned so feel free to save for later if I'm scope creeping too much.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1641957355",
      "submitted_at": "2023-09-25T16:43:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "commented",
      "id": 1734117140,
      "node_id": "IC_kwDOABII585nXIcU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1734117140",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-25T16:45:14Z",
      "updated_at": "2023-09-25T16:45:14Z",
      "author_association": "MEMBER",
      "body": "CI failure is a functional test so I'd assume unrelated",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1734117140",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "commented",
      "id": 1735258305,
      "node_id": "IC_kwDOABII585nbfDB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735258305",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-26T10:24:53Z",
      "updated_at": "2023-09-26T10:24:53Z",
      "author_association": "MEMBER",
      "body": "Made a coverage report: https://dergoegge.github.io/bitcoin-coverage/pr28450/fuzz.coverage/index.html",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1735258305",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "commented",
      "id": 1735324430,
      "node_id": "IC_kwDOABII585nbvMO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735324430",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-26T11:12:26Z",
      "updated_at": "2023-09-26T11:12:26Z",
      "author_association": "MEMBER",
      "body": "> Made a coverage report: https://dergoegge.github.io/bitcoin-coverage/pr28450/fuzz.coverage/index.html\r\n\r\nLooks pretty good to me, noting the main missing bits:\r\n- same-txid-different-witness\r\n- policy script checks failing\r\n- bad-txns-too-many-sigops\r\n- being granted CPFP carve out and then failing\r\n\r\n^which have already been marked as followups.\r\n\r\nThere's no package-not-child-with-unconfirmed-parents which is by design. Also looks like RBF rules are red, perhaps it'll take a while to hit them?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1735324430",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "commented",
      "id": 1735410372,
      "node_id": "IC_kwDOABII585ncELE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735410372",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-26T12:04:03Z",
      "updated_at": "2023-09-26T12:04:03Z",
      "author_association": "MEMBER",
      "body": "> Also looks like RBF rules are red, perhaps it'll take a while to hit them?\r\n\r\nThe seed corpus from the report was the result of 5000+ cpu hours, so I'd say it's likely just not able to hit the rbf paths.",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1735410372",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10475372999,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJwYYHH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10475372999",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-26T13:37:51Z"
    },
    {
      "event": "commented",
      "id": 1735569725,
      "node_id": "IC_kwDOABII585ncrE9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1735569725",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-26T13:42:04Z",
      "updated_at": "2023-09-26T13:44:43Z",
      "author_association": "MEMBER",
      "body": "> Also looks like RBF rules are red, perhaps it'll take a while to hit them?\r\n\r\nA couple of those cases would look difficult to hit without intention/design to do so. One I'm unsure how it hasn't been hit, something to look at later especially as we approach package rbf.\r\n\r\n> I think achow is wondering if this is redundant with outpoints_rbf? Since new transactions are always created using outpoints_rbf inputs.\r\n\r\nCan't find the actual place to reply(thanks github), removed outpoints_supply entirely as it's vestigial\r\n\r\n----\r\n\r\nTook all suggestions, pushed\r\n\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1735569725",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "reviewed",
      "id": 1644525101,
      "node_id": "PRR_kwDOABII585iBXYt",
      "url": null,
      "actor": null,
      "commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK 3707ed7c0d02d86ff86c159bbd746acfa52db145\r\nCode and coverage look good. Will run overnight to sanity check that outpointsupdater hasn't broken anything.\r\n\r\nCouple more ideas for post-26711 expansions:\r\n- add nonexistent outpoint to hit missing inputs cases\r\n- shuffle before submission",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1644525101",
      "submitted_at": "2023-09-26T15:20:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "reviewed",
      "id": 1644818585,
      "node_id": "PRR_kwDOABII585iCfCZ",
      "url": null,
      "actor": null,
      "commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1644818585",
      "submitted_at": "2023-09-26T17:20:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10487111446,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJxFJ8W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10487111446",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T12:51:16Z"
    },
    {
      "event": "commented",
      "id": 1737337723,
      "node_id": "IC_kwDOABII585njat7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1737337723",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T12:52:27Z",
      "updated_at": "2023-09-27T12:52:27Z",
      "author_association": "MEMBER",
      "body": "Removed the `Final` subroutine to get a slight speedup since it seems unnecessary, leaving just the `tx_pool.check()` which should catch all issues.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1737337723",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10487728348,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJxHgjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10487728348",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T13:39:35Z"
    },
    {
      "event": "labeled",
      "id": 10487729861,
      "node_id": "LE_lADOABII585wsHV1zwAAAAJxHg7F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10487729861",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T13:39:41Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1737437856,
      "node_id": "IC_kwDOABII585njzKg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1737437856",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T13:47:38Z",
      "updated_at": "2023-09-27T13:47:38Z",
      "author_association": "MEMBER",
      "body": "Going to hold off on all subsequent nits to get this in to un-draft #26711 and start building on top",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1737437856",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "commented",
      "id": 1737530369,
      "node_id": "IC_kwDOABII585nkJwB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1737530369",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T14:36:17Z",
      "updated_at": "2023-09-27T14:36:17Z",
      "author_association": "MEMBER",
      "body": "https://github.com/bitcoin/bitcoin/pull/28450/checks?check_run_id=17181111860 multiprocess build having an issue of some kind",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1737530369",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "reviewed",
      "id": 1646836890,
      "node_id": "PRR_kwDOABII585iKLya",
      "url": null,
      "actor": null,
      "commit_id": "6e46822537c6ba42fbcf8d528df3ffaf5a873bf5",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1646836890",
      "submitted_at": "2023-09-27T15:50:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "unlabeled",
      "id": 10489618728,
      "node_id": "UNLE_lADOABII585wsHV1zwAAAAJxOuEo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10489618728",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T16:08:32Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10490355443,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJxRh7z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10490355443",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T17:24:56Z"
    },
    {
      "event": "reviewed",
      "id": 1640110887,
      "node_id": "PRR_kwDOABII585hwhsn",
      "url": null,
      "actor": null,
      "commit_id": "70879e4f02e522ee82b563917ef6700efe4cf5dd",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1640110887",
      "submitted_at": "2023-09-27T20:01:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI2MmFiOGVmNzg2MGQ0M2NlYmM5ZDA0NzIxZTNhMDc1YjRlZGYwNmU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "tree": {
        "sha": "892b4505aaac13e0f90e05132727a577cc29f7bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/892b4505aaac13e0f90e05132727a577cc29f7bc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2303fd2f4332f1414526219c54804c8277e1bb5b",
          "sha": "2303fd2f4332f1414526219c54804c8277e1bb5b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2303fd2f4332f1414526219c54804c8277e1bb5b"
        }
      ],
      "message": "Add package evaluation fuzzer",
      "committer": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-09-27T20:27:05Z"
      },
      "author": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-09-11T13:53:37Z"
      },
      "sha": "262ab8ef7860d43cebc9d04721e3a075b4edf06e"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10491894400,
      "node_id": "HRFPE_lADOABII585wsHV1zwAAAAJxXZqA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10491894400",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T20:27:21Z"
    },
    {
      "event": "commented",
      "id": 1738042370,
      "node_id": "IC_kwDOABII585nmGwC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1738042370",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T20:35:33Z",
      "updated_at": "2023-09-27T20:35:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 262ab8ef7860d43cebc9d04721e3a075b4edf06e\r\n\r\nNote that this is the first time I review something from the package relay project, so take that for whatever it’s worth",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#issuecomment-1738042370",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28450"
    },
    {
      "event": "review_requested",
      "id": 10491966712,
      "node_id": "RRE_lADOABII585wsHV1zwAAAAJxXrT4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10491966712",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-27T20:35:38Z",
      "requested_reviewer": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1648426550,
      "node_id": "PRR_kwDOABII585iQP42",
      "url": null,
      "actor": null,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reACK 262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1648426550",
      "submitted_at": "2023-09-28T10:31:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "review_requested",
      "id": 10497584043,
      "node_id": "RRE_lADOABII585wsHV1zwAAAAJxtGur",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10497584043",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-28T10:42:59Z",
      "requested_reviewer": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1648493171,
      "node_id": "PRR_kwDOABII585iQgJz",
      "url": null,
      "actor": null,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "tACK 262ab8ef7860d43cebc9d04721e3a075b4edf06e\r\n\r\nWill generate and submit inputs to qa-assets once this is merged",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#pullrequestreview-1648493171",
      "submitted_at": "2023-09-28T10:59:12Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
    },
    {
      "event": "merged",
      "id": 10497852872,
      "node_id": "ME_lADOABII585wsHV1zwAAAAJxuIXI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10497852872",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6619d6a8dca5a4d8e664a76526ac6bef3eb17831",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6619d6a8dca5a4d8e664a76526ac6bef3eb17831",
      "created_at": "2023-09-28T11:06:18Z"
    },
    {
      "event": "closed",
      "id": 10497852923,
      "node_id": "CE_lADOABII585wsHV1zwAAAAJxuIX7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10497852923",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-28T11:06:18Z"
    },
    {
      "event": "referenced",
      "id": 10566409624,
      "node_id": "REFE_lADOABII585wsHV1zwAAAAJ1zp2Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10566409624",
      "actor": {
        "login": "Frank-GER",
        "id": 87550788,
        "node_id": "MDQ6VXNlcjg3NTUwNzg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/87550788?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Frank-GER",
        "html_url": "https://github.com/Frank-GER",
        "followers_url": "https://api.github.com/users/Frank-GER/followers",
        "following_url": "https://api.github.com/users/Frank-GER/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Frank-GER/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Frank-GER/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Frank-GER/subscriptions",
        "organizations_url": "https://api.github.com/users/Frank-GER/orgs",
        "repos_url": "https://api.github.com/users/Frank-GER/repos",
        "events_url": "https://api.github.com/users/Frank-GER/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Frank-GER/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "461bf19b50f36a409c1524bde83efc411383cd54",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/461bf19b50f36a409c1524bde83efc411383cd54",
      "created_at": "2023-10-05T16:57:12Z"
    },
    {
      "event": "locked",
      "id": 14436146618,
      "node_id": "LOE_lADOABII585wsHV1zwAAAANcdh26",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14436146618",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-27T20:47:48Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321625656",
      "pull_request_review_id": 1620122880,
      "id": 1321625656,
      "node_id": "PRRC_kwDOABII585Oxmg4",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "f06cf5b0549b741f6825e8dfea8ee97bcf7ed572",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe worth adding `-bytespersigop` too?",
      "created_at": "2023-09-11T14:15:13Z",
      "updated_at": "2023-09-11T14:22:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321625656",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321625656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321690708",
      "pull_request_review_id": 1620226361,
      "id": 1321690708,
      "node_id": "PRRC_kwDOABII585Ox2ZU",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "f06cf5b0549b741f6825e8dfea8ee97bcf7ed572",
      "in_reply_to_id": 1321625656,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "to take advantage of this, probably would need to do some bare mulitisigs? wouldn't hurt to add I suppose",
      "created_at": "2023-09-11T15:02:07Z",
      "updated_at": "2023-09-11T15:02:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321690708",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321690708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321699963",
      "pull_request_review_id": 1620240896,
      "id": 1321699963,
      "node_id": "PRRC_kwDOABII585Ox4p7",
      "diff_hunk": "@@ -0,0 +1,351 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));\n+    args.ForceSetArg(\"-bytespersigop\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999)));\n+}\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 126,
      "original_position": 132,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could set all the options here instead of round tripping through the args man?",
      "created_at": "2023-09-11T15:08:06Z",
      "updated_at": "2023-09-11T15:16:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1321699963",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1321699963"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": 124,
      "original_start_line": 130,
      "start_side": "RIGHT",
      "line": 126,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324888195",
      "pull_request_review_id": 1625146817,
      "id": 1324888195,
      "node_id": "PRRC_kwDOABII585O-DCD",
      "diff_hunk": "@@ -0,0 +1,351 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void SetMempoolConstraints(ArgsManager& args, FuzzedDataProvider& fuzzed_data_provider)\n+{\n+    args.ForceSetArg(\"-limitancestorcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitancestorsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-limitdescendantcount\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50)));\n+    args.ForceSetArg(\"-limitdescendantsize\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202)));\n+    args.ForceSetArg(\"-maxmempool\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200)));\n+    args.ForceSetArg(\"-mempoolexpiry\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)));\n+    args.ForceSetArg(\"-bytespersigop\",\n+                     ToString(fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999)));\n+}\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 126,
      "original_position": 132,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3654ad4152f139e6583f819d7d039fd7cdd5dc7f",
      "in_reply_to_id": 1321699963,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-09-13T18:06:41Z",
      "updated_at": "2023-09-13T18:06:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1324888195",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1324888195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": 124,
      "original_start_line": 130,
      "start_side": "RIGHT",
      "line": 126,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1326380398",
      "pull_request_review_id": 1627544107,
      "id": 1326380398,
      "node_id": "PRRC_kwDOABII585PDvVu",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 212,
      "original_position": 211,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "28f45d6883d06c56dfd7444eeb82b30cff6b8c1b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "future work: making the tx >40kWu sometimes, along with other invariant checks, would have likely allowed the fuzzer to catch https://github.com/bitcoin/bitcoin/pull/28472",
      "created_at": "2023-09-14T18:42:01Z",
      "updated_at": "2023-09-14T18:42:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1326380398",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1326380398"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 212,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487664",
      "pull_request_review_id": 1635411567,
      "id": 1331487664,
      "node_id": "PRRC_kwDOABII585PXOOw",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 140,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think this set is ever actually used.",
      "created_at": "2023-09-20T11:26:35Z",
      "updated_at": "2023-09-20T11:27:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487664",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487664"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487971",
      "pull_request_review_id": 1635411567,
      "id": 1331487971,
      "node_id": "PRRC_kwDOABII585PXOTj",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type != MempoolAcceptResult::ResultType::INVALID) {\n+                        Assert(true);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 295,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`Assert(true)` seems to not be useful.",
      "created_at": "2023-09-20T11:26:51Z",
      "updated_at": "2023-09-20T11:27:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331487971",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331487971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 294,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331488544",
      "pull_request_review_id": 1635411567,
      "id": 1331488544,
      "node_id": "PRRC_kwDOABII585PXOcg",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 118,
      "original_position": 115,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems a bit odd to me that the chain limits could go up to 50 but we only create packages of up to 26.",
      "created_at": "2023-09-20T11:27:28Z",
      "updated_at": "2023-09-20T11:27:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331488544",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331488544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": 116,
      "original_start_line": 113,
      "start_side": "RIGHT",
      "line": 118,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331652861",
      "pull_request_review_id": 1635676679,
      "id": 1331652861,
      "node_id": "PRRC_kwDOABII585PX2j9",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 118,
      "original_position": 115,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "in_reply_to_id": 1331488544,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's chain limits vs package limit checks, I think it's useful\r\n\r\ne.g., we could have 26 txns in the mempool, and submit another 25",
      "created_at": "2023-09-20T13:40:30Z",
      "updated_at": "2023-09-20T14:14:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331652861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331652861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": 116,
      "original_start_line": 113,
      "start_side": "RIGHT",
      "line": 118,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331684820",
      "pull_request_review_id": 1635727786,
      "id": 1331684820,
      "node_id": "PRRC_kwDOABII585PX-XU",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 140,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "in_reply_to_id": 1331487664,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it is added to in `insert_tx` when used in `created_by_tx` arg. Lets each new package consider newly-entered outpoints in the mempool",
      "created_at": "2023-09-20T14:01:30Z",
      "updated_at": "2023-09-20T14:01:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331684820",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331684820"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331685986",
      "pull_request_review_id": 1635729649,
      "id": 1331685986,
      "node_id": "PRRC_kwDOABII585PX-pi",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type != MempoolAcceptResult::ResultType::INVALID) {\n+                        Assert(true);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 295,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "in_reply_to_id": 1331487971,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed debugging code",
      "created_at": "2023-09-20T14:02:19Z",
      "updated_at": "2023-09-20T14:02:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1331685986",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1331685986"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 294,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332851868",
      "pull_request_review_id": 1637502233,
      "id": 1332851868,
      "node_id": "PRRC_kwDOABII585PcbSc",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 257,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In bf7436cde8ba7eac0912817f6f8a41828cb60bc2: In `ProcessNewPackage`, couldn't we just use `single_submit` for `/*test_accept=*/` directly, instead of creating `package_submit`? ",
      "created_at": "2023-09-21T10:37:56Z",
      "updated_at": "2023-09-21T10:37:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332851868",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332851868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332860797",
      "pull_request_review_id": 1637516869,
      "id": 1332860797,
      "node_id": "PRRC_kwDOABII585Pcdd9",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In bf7436cde8ba7eac0912817f6f8a41828cb60bc2: I think `amount_view` hasn't been used.",
      "created_at": "2023-09-21T10:45:36Z",
      "updated_at": "2023-09-21T10:45:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332860797",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332860797"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902420",
      "pull_request_review_id": 1637583711,
      "id": 1332902420,
      "node_id": "PRRC_kwDOABII585PcnoU",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "in_reply_to_id": 1332860797,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "deleted",
      "created_at": "2023-09-21T11:24:08Z",
      "updated_at": "2023-09-21T11:24:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902420",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902922",
      "pull_request_review_id": 1637584469,
      "id": 1332902922,
      "node_id": "PRRC_kwDOABII585PcnwK",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 257,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "in_reply_to_id": 1332851868,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I find this ever so slightly more readable myself, opinions may vary ",
      "created_at": "2023-09-21T11:24:37Z",
      "updated_at": "2023-09-21T11:24:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1332902922",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1332902922"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1334477155",
      "pull_request_review_id": 1640110887,
      "id": 1334477155,
      "node_id": "PRRC_kwDOABII585PioFj",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Since every block needs a coinbase transaction, is >= 1 really what you wanted to check here?",
      "created_at": "2023-09-22T14:41:59Z",
      "updated_at": "2023-09-27T20:01:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1334477155",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1334477155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335215049",
      "pull_request_review_id": 1641093035,
      "id": 1335215049,
      "node_id": "PRRC_kwDOABII585PlcPJ",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 234,
      "original_position": 230,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why is it calling `MockTime` again? I guess to trigger the `nLockTime`? ",
      "created_at": "2023-09-24T16:39:21Z",
      "updated_at": "2023-09-24T17:44:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335215049",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335215049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 234,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335220434",
      "pull_request_review_id": 1641097915,
      "id": 1335220434,
      "node_id": "PRRC_kwDOABII585PldjS",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 244,
      "original_position": 240,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 2ecdc2183f0a1291730ae8728fa3d847b9cf80b5: Couldn't we prioritise more than 1 transaction?",
      "created_at": "2023-09-24T17:27:43Z",
      "updated_at": "2023-09-24T17:27:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335220434",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335220434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 244,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335221272",
      "pull_request_review_id": 1641098600,
      "id": 1335221272,
      "node_id": "PRRC_kwDOABII585PldwY",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 276,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 2ecdc2183f0a1291730ae8728fa3d847b9cf80b5: Does it make sense to check whether the state is invalid if we previously assert that is valid?",
      "created_at": "2023-09-24T17:35:32Z",
      "updated_at": "2023-09-24T19:22:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335221272",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335221272"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232415",
      "pull_request_review_id": 1641109462,
      "id": 1335232415,
      "node_id": "PRRC_kwDOABII585Plgef",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 234,
      "original_position": 230,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335215049,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it's called for each package separately, sometimes, yes",
      "created_at": "2023-09-24T19:12:19Z",
      "updated_at": "2023-09-24T19:12:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335232415",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 234,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232777",
      "pull_request_review_id": 1641109814,
      "id": 1335232777,
      "node_id": "PRRC_kwDOABII585PlgkJ",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 244,
      "original_position": 240,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335220434,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes, I'm not sure if it will end up covering more interesting cases though",
      "created_at": "2023-09-24T19:16:17Z",
      "updated_at": "2023-09-24T19:16:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335232777",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232777"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 244,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232955",
      "pull_request_review_id": 1641109948,
      "id": 1335232955,
      "node_id": "PRRC_kwDOABII585Plgm7",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 276,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335221272,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sorry can you be a bit more explicit in what you're asking to do? ",
      "created_at": "2023-09-24T19:17:43Z",
      "updated_at": "2023-09-24T19:17:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335232955",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335232955"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335776752",
      "pull_request_review_id": 1641957355,
      "id": 1335776752,
      "node_id": "PRRC_kwDOABII585PnlXw",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Question: this effectively tests that `CreateNewBlock` creates a coinbase, is that intended?",
      "created_at": "2023-09-25T11:51:27Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335776752",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335776752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335782946",
      "pull_request_review_id": 1641957355,
      "id": 1335782946,
      "node_id": "PRRC_kwDOABII585Pnm4i",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could be slightly stronger by getting the descendant count of `tx_to_remove` and checking here that `all_txids.size() == info_all.size() - descendant_count`",
      "created_at": "2023-09-25T11:58:03Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335782946",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335782946"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 89,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335798543",
      "pull_request_review_id": 1641957355,
      "id": 1335798543,
      "node_id": "PRRC_kwDOABII585PnqsP",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 276,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335221272,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think he's suggesting that the checks are redundant and to remove one",
      "created_at": "2023-09-25T12:11:47Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335798543",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335798543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 276,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335807638",
      "pull_request_review_id": 1641957355,
      "id": 1335807638,
      "node_id": "PRRC_kwDOABII585Pns6W",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 253,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This was a bit confusing. Perhaps adding this comment beforehand would help clarify things\r\n\r\n\"When there are multiple transactions in the package, we call ProcessNewPackage(txs, test_accept=false) and AcceptToMemoryPool(txs.back(), test_accept=true). When there is only 1 transaction, we might flip it (the package is a test accept and ATMP is a submission).\"",
      "created_at": "2023-09-25T12:20:38Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335807638",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335807638"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 250,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335839442",
      "pull_request_review_id": 1641957355,
      "id": 1335839442,
      "node_id": "PRRC_kwDOABII585Pn0rS",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 140,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "in_reply_to_id": 1331487664,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think achow is wondering if this is redundant with `outpoints_rbf`? Since new transactions are always created using `outpoints_rbf` inputs.",
      "created_at": "2023-09-25T12:46:05Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335839442",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335839442"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335849114",
      "pull_request_review_id": 1641957355,
      "id": 1335849114,
      "node_id": "PRRC_kwDOABII585Pn3Ca",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 222,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This can also go under `if (!last_tx)`, right? There's no need to add the last tx's outputs since we won't need them",
      "created_at": "2023-09-25T12:53:46Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335849114",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335849114"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 218,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335851668",
      "pull_request_review_id": 1641957355,
      "id": 1335851668,
      "node_id": "PRRC_kwDOABII585Pn3qU",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 277,
      "original_position": 273,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would be nice to remind ourselves what this means, e.g. \"There is only 1 transaction in the package. We did a test-package-accept and a ATMP\"",
      "created_at": "2023-09-25T12:55:51Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335851668",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335851668"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335863257",
      "pull_request_review_id": 1641957355,
      "id": 1335863257,
      "node_id": "PRRC_kwDOABII585Pn6fZ",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 214,
      "original_position": 212,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Question: this means transactions in the package can conflict with each other, right? It's possible to select the same outpoint from `outpoints_rbf` for 2 parents in the same package?",
      "created_at": "2023-09-25T13:05:51Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335863257",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335863257"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335867121",
      "pull_request_review_id": 1641957355,
      "id": 1335867121,
      "node_id": "PRRC_kwDOABII585Pn7bx",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 173,
      "original_position": 174,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe add `Assert(!outpoints_rbf.empty())` at the top",
      "created_at": "2023-09-25T13:09:17Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335867121",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335867121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 173,
      "original_line": 173,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335872892",
      "pull_request_review_id": 1641957355,
      "id": 1335872892,
      "node_id": "PRRC_kwDOABII585Pn818",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type == MempoolAcceptResult::ResultType::INVALID) {\n+                        removed.erase(wtxid_to_tx[k]);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Helper to insert spent and created outpoints of a tx into collections\n+        using Sets = std::vector<std::reference_wrapper<std::set<COutPoint>>>;\n+        const auto insert_tx = [](Sets created_by_tx, Sets consumed_by_tx, const auto& tx) {\n+            for (size_t i{0}; i < tx.vout.size(); ++i) {\n+                for (auto& set : created_by_tx) {\n+                    set.get().emplace(tx.GetHash(), i);\n+                }\n+            }\n+            for (const auto& in : tx.vin) {\n+                for (auto& set : consumed_by_tx) {\n+                    set.get().insert(in.prevout);\n+                }\n+            }\n+        };\n+\n+        // Add created outpoints, remove spent outpoints\n+        {\n+            // Outpoints that no longer exist at all\n+            std::set<COutPoint> consumed_erased;\n+            // Outpoints that no longer count toward the total supply\n+            std::set<COutPoint> consumed_supply;\n+            for (const auto& removed_tx : removed) {\n+                insert_tx(/*created_by_tx=*/{consumed_erased}, /*consumed_by_tx=*/{outpoints_supply}, /*tx=*/*removed_tx);\n+            }\n+            for (const auto& added_tx : added) {\n+                insert_tx(/*created_by_tx=*/{outpoints_supply, outpoints_rbf}, /*consumed_by_tx=*/{consumed_supply}, /*tx=*/*added_tx);\n+            }\n+            for (const auto& p : consumed_erased) {\n+                outpoints_supply.erase(p);\n+                outpoints_rbf.erase(p);\n+            }\n+            for (const auto& p : consumed_supply) {\n+                outpoints_supply.erase(p);\n+            }\n+        }",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 334,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is kinda convoluted... could we just update `outpoints_supply` and `outpoints_rbf` directly on the `TransactionAddedToMempool` and `TransactionRemovedFromMempool` callbacks instead of the added/removed sets? took a stab in https://github.com/glozow/bitcoin/commit/df433f82364502b443d433918af0a0cf4196d210",
      "created_at": "2023-09-25T13:14:07Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1335872892",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1335872892"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 315,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 287,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1336145901",
      "pull_request_review_id": 1641957355,
      "id": 1336145901,
      "node_id": "PRRC_kwDOABII585Po_ft",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 253,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335807638,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also... wondering why allow `num_txs` to be less than 2 anyway? Isn't this test kind of the same as what's in the tx_pool fuzzer?",
      "created_at": "2023-09-25T16:41:58Z",
      "updated_at": "2023-09-25T16:43:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1336145901",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1336145901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 250,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337226446",
      "pull_request_review_id": 1644297068,
      "id": 1337226446,
      "node_id": "PRRC_kwDOABII585PtHTO",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 140,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "93d7c5c09c86f9543433d87a2ca074f35cac0fe6",
      "in_reply_to_id": 1331487664,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "was used prior but no longer, removed until it's needed again",
      "created_at": "2023-09-26T13:38:49Z",
      "updated_at": "2023-09-26T13:38:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337226446",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337226446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227133",
      "pull_request_review_id": 1644298098,
      "id": 1337227133,
      "node_id": "PRRC_kwDOABII585PtHd9",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335776752,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed as it's not very interesting a check",
      "created_at": "2023-09-26T13:39:15Z",
      "updated_at": "2023-09-26T13:39:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227133",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227133"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227312",
      "pull_request_review_id": 1644298410,
      "id": 1337227312,
      "node_id": "PRRC_kwDOABII585PtHgw",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335782946,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-09-26T13:39:23Z",
      "updated_at": "2023-09-26T13:39:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227312",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227312"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 89,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227564",
      "pull_request_review_id": 1644298870,
      "id": 1337227564,
      "node_id": "PRRC_kwDOABII585PtHks",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            Assert(accepted != res.m_state.IsInvalid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());\n+            }\n+        } else {\n+            // This is empty if it fails early checks, or \"full\" if transactions are looked at deeper\n+            Assert(result_package.m_tx_results.size() == txs.size() || result_package.m_tx_results.empty());\n+            if (result_package.m_state.GetResult() == PackageValidationResult::PCKG_POLICY) {\n+                for (const auto& tx : txs) {\n+                    removed.erase(tx);\n+                }\n+            } else {\n+                for (const auto& [k, v] : result_package.m_tx_results) {\n+                    if (v.m_result_type == MempoolAcceptResult::ResultType::INVALID) {\n+                        removed.erase(wtxid_to_tx[k]);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Helper to insert spent and created outpoints of a tx into collections\n+        using Sets = std::vector<std::reference_wrapper<std::set<COutPoint>>>;\n+        const auto insert_tx = [](Sets created_by_tx, Sets consumed_by_tx, const auto& tx) {\n+            for (size_t i{0}; i < tx.vout.size(); ++i) {\n+                for (auto& set : created_by_tx) {\n+                    set.get().emplace(tx.GetHash(), i);\n+                }\n+            }\n+            for (const auto& in : tx.vin) {\n+                for (auto& set : consumed_by_tx) {\n+                    set.get().insert(in.prevout);\n+                }\n+            }\n+        };\n+\n+        // Add created outpoints, remove spent outpoints\n+        {\n+            // Outpoints that no longer exist at all\n+            std::set<COutPoint> consumed_erased;\n+            // Outpoints that no longer count toward the total supply\n+            std::set<COutPoint> consumed_supply;\n+            for (const auto& removed_tx : removed) {\n+                insert_tx(/*created_by_tx=*/{consumed_erased}, /*consumed_by_tx=*/{outpoints_supply}, /*tx=*/*removed_tx);\n+            }\n+            for (const auto& added_tx : added) {\n+                insert_tx(/*created_by_tx=*/{outpoints_supply, outpoints_rbf}, /*consumed_by_tx=*/{consumed_supply}, /*tx=*/*added_tx);\n+            }\n+            for (const auto& p : consumed_erased) {\n+                outpoints_supply.erase(p);\n+                outpoints_rbf.erase(p);\n+            }\n+            for (const auto& p : consumed_supply) {\n+                outpoints_supply.erase(p);\n+            }\n+        }",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 334,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335872892,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "taken, thanks",
      "created_at": "2023-09-26T13:39:35Z",
      "updated_at": "2023-09-26T13:39:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227564",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 315,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 287,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227691",
      "pull_request_review_id": 1644299068,
      "id": 1337227691,
      "node_id": "PRRC_kwDOABII585PtHmr",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 173,
      "original_position": 174,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335867121,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-09-26T13:39:39Z",
      "updated_at": "2023-09-26T13:39:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227691",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227691"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 173,
      "original_line": 173,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227987",
      "pull_request_review_id": 1644299448,
      "id": 1337227987,
      "node_id": "PRRC_kwDOABII585PtHrT",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 214,
      "original_position": 212,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335863257,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes",
      "created_at": "2023-09-26T13:39:46Z",
      "updated_at": "2023-09-26T13:39:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337227987",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337227987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228126",
      "pull_request_review_id": 1644299658,
      "id": 1337228126,
      "node_id": "PRRC_kwDOABII585PtHte",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        if (single_submit) {",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 277,
      "original_position": 273,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335851668,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-09-26T13:39:50Z",
      "updated_at": "2023-09-26T13:39:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337228126",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 277,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228741",
      "pull_request_review_id": 1644300692,
      "id": 1337228741,
      "node_id": "PRRC_kwDOABII585PtH3F",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 222,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335849114,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done, had to keep the outpoints_value check outside though since it needs all generated outpoints",
      "created_at": "2023-09-26T13:40:06Z",
      "updated_at": "2023-09-26T13:40:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337228741",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337228741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 218,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337231154",
      "pull_request_review_id": 1644304537,
      "id": 1337231154,
      "node_id": "PRRC_kwDOABII585PtIcy",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 253,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335807638,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Also... wondering why allow num_txs to be less than 2 anyway?\r\n\r\n1) it can get rejected by ProcessNewPackage\r\n2) it can cause the existing mempool to be somewhat more interesting maybe",
      "created_at": "2023-09-26T13:40:47Z",
      "updated_at": "2023-09-26T13:40:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337231154",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337231154"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 250,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337364357",
      "pull_request_review_id": 1644525101,
      "id": 1337364357,
      "node_id": "PRRC_kwDOABII585Pto-F",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "note: `g_outpoints_coinbase_init_immature` seems unused rn, I assume the plan is to maybe spend immature coinbases later?",
      "created_at": "2023-09-26T15:03:51Z",
      "updated_at": "2023-09-26T15:20:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337364357",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337364357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337366755",
      "pull_request_review_id": 1644525101,
      "id": 1337366755,
      "node_id": "PRRC_kwDOABII585Ptpjj",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        const auto tx_it = WITH_LOCK(tx_pool.cs, return tx_pool.mapTx.find(tx_to_remove.GetHash()));\n+        size_t num_descendants = tx_it->GetCountWithDescendants();\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() == info_all.size() - num_descendants);\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 199,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: `outpoints_rbf` contains unconfirmed, no?\r\n```suggestion\r\n            // Note that this test currently only spends package outputs in last transaction.\r\n```",
      "created_at": "2023-09-26T15:05:30Z",
      "updated_at": "2023-09-26T15:20:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337366755",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337366755"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337375763",
      "pull_request_review_id": 1644525101,
      "id": 1337375763,
      "node_id": "PRRC_kwDOABII585PtrwT",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        const auto tx_it = WITH_LOCK(tx_pool.cs, return tx_pool.mapTx.find(tx_to_remove.GetHash()));\n+        size_t num_descendants = tx_it->GetCountWithDescendants();\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() == info_all.size() - num_descendants);\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                Assert(!outpoints.empty());\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    // no need to update or erase from outpoints_value\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                    // Cache the in-package outpoints being made\n+                    for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                        package_outpoints.emplace(tx->GetHash(), i);\n+                    }\n+                }\n+                // We need newly-created values for the duration of this run\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // When there are multiple transactions in the package, we call ProcessNewPackage(txs, test_accept=false)\n+        // and AcceptToMemoryPool(txs.back(), test_accept=true). When there is only 1 transaction, we might flip it\n+        // (the package is a test accept and ATMP is a submission).\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        // There is only 1 transaction in the package. We did a test-package-accept and a ATMP\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 318,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: I think these `removed.erase()` calls might be unnecessary now that you don't use it to update `outpoints_rbf`.",
      "created_at": "2023-09-26T15:11:51Z",
      "updated_at": "2023-09-26T15:20:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337375763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337375763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337553597",
      "pull_request_review_id": 1644818585,
      "id": 1337553597,
      "node_id": "PRRC_kwDOABII585PuXK9",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        const auto tx_it = WITH_LOCK(tx_pool.cs, return tx_pool.mapTx.find(tx_to_remove.GetHash()));\n+        size_t num_descendants = tx_it->GetCountWithDescendants();\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() == info_all.size() - num_descendants);\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                Assert(!outpoints.empty());\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    // no need to update or erase from outpoints_value\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                    // Cache the in-package outpoints being made\n+                    for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                        package_outpoints.emplace(tx->GetHash(), i);\n+                    }\n+                }\n+                // We need newly-created values for the duration of this run\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 279,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`removed` doesn't seem to actually be used anywhere.",
      "created_at": "2023-09-26T17:20:08Z",
      "updated_at": "2023-09-26T17:20:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1337553597",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1337553597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338559536",
      "pull_request_review_id": 1646401582,
      "id": 1338559536,
      "node_id": "PRRC_kwDOABII585PyMww",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "in_reply_to_id": 1337364357,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed, won't be used in near future",
      "created_at": "2023-09-27T12:51:24Z",
      "updated_at": "2023-09-27T12:51:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1338559536",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338559536"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338559624",
      "pull_request_review_id": 1646401838,
      "id": 1338559624,
      "node_id": "PRRC_kwDOABII585PyMyI",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        const auto tx_it = WITH_LOCK(tx_pool.cs, return tx_pool.mapTx.find(tx_to_remove.GetHash()));\n+        size_t num_descendants = tx_it->GetCountWithDescendants();\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() == info_all.size() - num_descendants);\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 199,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "in_reply_to_id": 1337366755,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "taken",
      "created_at": "2023-09-27T12:51:29Z",
      "updated_at": "2023-09-27T12:51:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1338559624",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338559624"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338559837",
      "pull_request_review_id": 1646402297,
      "id": 1338559837,
      "node_id": "PRRC_kwDOABII585PyM1d",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        const auto tx_it = WITH_LOCK(tx_pool.cs, return tx_pool.mapTx.find(tx_to_remove.GetHash()));\n+        size_t num_descendants = tx_it->GetCountWithDescendants();\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() == info_all.size() - num_descendants);\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                Assert(!outpoints.empty());\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    // no need to update or erase from outpoints_value\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                    // Cache the in-package outpoints being made\n+                    for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                        package_outpoints.emplace(tx->GetHash(), i);\n+                    }\n+                }\n+                // We need newly-created values for the duration of this run\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // When there are multiple transactions in the package, we call ProcessNewPackage(txs, test_accept=false)\n+        // and AcceptToMemoryPool(txs.back(), test_accept=true). When there is only 1 transaction, we might flip it\n+        // (the package is a test accept and ATMP is a submission).\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));\n+        // If something went wrong due to a package-specific policy, it might not return a\n+        // validation result for the transaction.\n+        if (result_package.m_state.GetResult() != PackageValidationResult::PCKG_POLICY) {\n+            auto it = result_package.m_tx_results.find(txs.back()->GetWitnessHash());\n+            Assert(it != result_package.m_tx_results.end());\n+            Assert(it->second.m_result_type == MempoolAcceptResult::ResultType::VALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::INVALID ||\n+                   it->second.m_result_type == MempoolAcceptResult::ResultType::MEMPOOL_ENTRY);\n+        }\n+\n+        const auto res = WITH_LOCK(::cs_main, return AcceptToMemoryPool(chainstate, txs.back(), GetTime(), bypass_limits, /*test_accept=*/!single_submit));\n+        const bool accepted = res.m_result_type == MempoolAcceptResult::ResultType::VALID;\n+\n+        SyncWithValidationInterfaceQueue();\n+        UnregisterSharedValidationInterface(txr);\n+\n+        // There is only 1 transaction in the package. We did a test-package-accept and a ATMP\n+        if (single_submit) {\n+            Assert(accepted != added.empty());\n+            Assert(accepted == res.m_state.IsValid());\n+            if (accepted) {\n+                Assert(added.size() == 1);\n+                Assert(txs.back() == *added.begin());\n+            } else {\n+                // Do not consider rejected transaction removed\n+                removed.erase(txs.back());",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 318,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "in_reply_to_id": 1337375763,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed `removed` entirely",
      "created_at": "2023-09-27T12:51:36Z",
      "updated_at": "2023-09-27T12:51:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1338559837",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338559837"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 318,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338559915",
      "pull_request_review_id": 1646402502,
      "id": 1338559915,
      "node_id": "PRRC_kwDOABII585PyM2r",
      "diff_hunk": "@@ -0,0 +1,341 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        const auto tx_it = WITH_LOCK(tx_pool.cs, return tx_pool.mapTx.find(tx_to_remove.GetHash()));\n+        size_t num_descendants = tx_it->GetCountWithDescendants();\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() == info_all.size() - num_descendants);\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                Assert(!outpoints.empty());\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    // no need to update or erase from outpoints_value\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                    // Cache the in-package outpoints being made\n+                    for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                        package_outpoints.emplace(tx->GetHash(), i);\n+                    }\n+                }\n+                // We need newly-created values for the duration of this run\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 279,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "3707ed7c0d02d86ff86c159bbd746acfa52db145",
      "in_reply_to_id": 1337553597,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed `removed` entirely",
      "created_at": "2023-09-27T12:51:40Z",
      "updated_at": "2023-09-27T12:51:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1338559915",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338559915"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338731747",
      "pull_request_review_id": 1646836890,
      "id": 1338731747,
      "node_id": "PRRC_kwDOABII585Py2zj",
      "diff_hunk": "@@ -0,0 +1,297 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        if (i < COINBASE_MATURITY) {\n+            // Remember the txids to avoid expensive disk access later on\n+            g_outpoints_coinbase_init_mature.push_back(prevout);\n+        }\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& a)\n+        : m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 96,
      "original_position": 96,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "6e46822537c6ba42fbcf8d528df3ffaf5a873bf5",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this can cause a false positive crash on line 281. In the \"mempool full\" case where a tx gets added and then removed in `TrimToSize()`, it'll fire `TransactionAddedToMempool` and `TransactionRemovedFromMempool`. Then `accepted` will be false but `added` won't be empty.\r\n\r\n```suggestion\r\n        // Transactions may be entered and booted any number of times\r\n        m_added.erase(tx);\r\n```",
      "created_at": "2023-09-27T14:46:50Z",
      "updated_at": "2023-09-27T15:50:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1338731747",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338731747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 96,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338959818",
      "pull_request_review_id": 1647225885,
      "id": 1338959818,
      "node_id": "PRRC_kwDOABII585PzufK",
      "diff_hunk": "@@ -0,0 +1,297 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        if (i < COINBASE_MATURITY) {\n+            // Remember the txids to avoid expensive disk access later on\n+            g_outpoints_coinbase_init_mature.push_back(prevout);\n+        }\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& a)\n+        : m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": 96,
      "original_position": 96,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "6e46822537c6ba42fbcf8d528df3ffaf5a873bf5",
      "in_reply_to_id": 1338731747,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sounds right, surprised I haven't hit this since it quite often chooses tiny mempool sizes too small for even a single transaction to enter.\r\n\r\nTaken.",
      "created_at": "2023-09-27T17:24:57Z",
      "updated_at": "2023-09-27T17:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1338959818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1338959818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 96,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339094884",
      "pull_request_review_id": 1640110887,
      "id": 1339094884,
      "node_id": "PRRC_kwDOABII585P0Pdk",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 257,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "in_reply_to_id": 1332851868,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I also found the new variable `package_submit` confusing as well. I don't see the point of creating an additional variable, especially since it’s only passed once and negated.",
      "created_at": "2023-09-27T19:16:44Z",
      "updated_at": "2023-09-27T20:01:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1339094884",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339094884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339132101",
      "pull_request_review_id": 1640110887,
      "id": 1339132101,
      "node_id": "PRRC_kwDOABII585P0YjF",
      "diff_hunk": "@@ -0,0 +1,298 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        if (i < COINBASE_MATURITY) {\n+            // Remember the txids to avoid expensive disk access later on\n+            g_outpoints_coinbase_init_mature.push_back(prevout);\n+        }\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& a)\n+        : m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+         m_added.erase(tx);\n+    }\n+};\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 161,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "70879e4f02e522ee82b563917ef6700efe4cf5dd",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This map appears to get filled but never read from.",
      "created_at": "2023-09-27T19:50:48Z",
      "updated_at": "2023-09-27T20:01:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1339132101",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339132101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339135014",
      "pull_request_review_id": 1640110887,
      "id": 1339135014,
      "node_id": "PRRC_kwDOABII585P0ZQm",
      "diff_hunk": "@@ -0,0 +1,298 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        if (i < COINBASE_MATURITY) {\n+            // Remember the txids to avoid expensive disk access later on\n+            g_outpoints_coinbase_init_mature.push_back(prevout);\n+        }\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& a)\n+        : m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+         m_added.erase(tx);\n+    }\n+};\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 141,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "70879e4f02e522ee82b563917ef6700efe4cf5dd",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I found this name confusing, because it doesn't really seem related to RBF, but rather just a list of all outpoints that were ever available for spending, even if they already got spent by another transaction.",
      "created_at": "2023-09-27T19:53:25Z",
      "updated_at": "2023-09-27T20:01:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1339135014",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339135014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 140,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339170731",
      "pull_request_review_id": 1647501270,
      "id": 1339170731,
      "node_id": "PRRC_kwDOABII585P0h-r",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1334477155,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed this already circa https://github.com/bitcoin/bitcoin/pull/28450/commits/70879e4f02e522ee82b563917ef6700efe4cf5dd",
      "created_at": "2023-09-27T20:24:50Z",
      "updated_at": "2023-09-27T20:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1339170731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339170731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339173460",
      "pull_request_review_id": 1647505049,
      "id": 1339173460,
      "node_id": "PRRC_kwDOABII585P0ipU",
      "diff_hunk": "@@ -0,0 +1,298 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        if (i < COINBASE_MATURITY) {\n+            // Remember the txids to avoid expensive disk access later on\n+            g_outpoints_coinbase_init_mature.push_back(prevout);\n+        }\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& a)\n+        : m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+         m_added.erase(tx);\n+    }\n+};\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 141,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "70879e4f02e522ee82b563917ef6700efe4cf5dd",
      "in_reply_to_id": 1339135014,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "was going to change this anyways, renaming to `mempool_outpoints`",
      "created_at": "2023-09-27T20:26:49Z",
      "updated_at": "2023-09-27T20:26:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1339173460",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339173460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 140,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339173989",
      "pull_request_review_id": 1647505674,
      "id": 1339173989,
      "node_id": "PRRC_kwDOABII585P0ixl",
      "diff_hunk": "@@ -0,0 +1,298 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        if (i < COINBASE_MATURITY) {\n+            // Remember the txids to avoid expensive disk access later on\n+            g_outpoints_coinbase_init_mature.push_back(prevout);\n+        }\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct OutpointsUpdater final : public CValidationInterface {\n+    std::set<COutPoint>& m_outpoints_rbf;\n+\n+    explicit OutpointsUpdater(std::set<COutPoint>& r)\n+        : m_outpoints_rbf{r} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // for coins spent we always want to be able to rbf so they're not removed\n+\n+        // outputs from this tx can now be spent\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.insert(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // outpoints spent by this tx are now available\n+        for (const auto& input : tx->vin) {\n+            // Could already exist if this was a replacement\n+            m_outpoints_rbf.insert(input.prevout);\n+        }\n+        // outpoints created by this tx no longer exist\n+        for (uint32_t index{0}; index < tx->vout.size(); ++index) {\n+            m_outpoints_rbf.erase(COutPoint{tx->GetHash(), index});\n+        }\n+    }\n+};\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& a)\n+        : m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+         m_added.erase(tx);\n+    }\n+};\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the unsubmitted package\n+    std::set<COutPoint> outpoints_rbf;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_rbf.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    auto outpoints_updater = std::make_shared<OutpointsUpdater>(outpoints_rbf);\n+    RegisterSharedValidationInterface(outpoints_updater);\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_rbf.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 161,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "70879e4f02e522ee82b563917ef6700efe4cf5dd",
      "in_reply_to_id": 1339132101,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed",
      "created_at": "2023-09-27T20:27:13Z",
      "updated_at": "2023-09-27T20:27:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1339173989",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339173989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339176590",
      "pull_request_review_id": 1647509049,
      "id": 1339176590,
      "node_id": "PRRC_kwDOABII585P0jaO",
      "diff_hunk": "@@ -0,0 +1,339 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    const CCoinsViewMemPool amount_view{WITH_LOCK(::cs_main, return &chainstate.CoinsTip()), tx_pool};\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;\n+\n+        const auto result_package = WITH_LOCK(::cs_main,\n+                                    return ProcessNewPackage(chainstate, tx_pool, txs, /*test_accept=*/!package_submit));",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 257,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "bf7436cde8ba7eac0912817f6f8a41828cb60bc2",
      "in_reply_to_id": 1332851868,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ok fine, removed :)",
      "created_at": "2023-09-27T20:29:30Z",
      "updated_at": "2023-09-27T20:29:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1339176590",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1339176590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1340090802",
      "pull_request_review_id": 1648762419,
      "id": 1340090802,
      "node_id": "PRRC_kwDOABII585P4Cmy",
      "diff_hunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <node/context.h>\n+#include <node/mempool_args.h>\n+#include <node/miner.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <util/rbf.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+using node::BlockAssembler;\n+using node::NodeContext;\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::vector<COutPoint> g_outpoints_coinbase_init_mature;\n+std::vector<COutPoint> g_outpoints_coinbase_init_immature;\n+\n+struct MockedTxPool : public CTxMemPool {\n+    void RollingFeeUpdate() EXCLUSIVE_LOCKS_REQUIRED(!cs)\n+    {\n+        LOCK(cs);\n+        lastRollingFeeUpdate = GetTime();\n+        blockSinceLastRollingFeeBump = true;\n+    }\n+};\n+\n+void initialize_tx_pool()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+\n+    for (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n+        // Remember the txids to avoid expensive disk access later on\n+        auto& outpoints = i < COINBASE_MATURITY ?\n+                              g_outpoints_coinbase_init_mature :\n+                              g_outpoints_coinbase_init_immature;\n+        outpoints.push_back(prevout);\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+struct TransactionsDelta final : public CValidationInterface {\n+    std::set<CTransactionRef>& m_removed;\n+    std::set<CTransactionRef>& m_added;\n+\n+    explicit TransactionsDelta(std::set<CTransactionRef>& r, std::set<CTransactionRef>& a)\n+        : m_removed{r}, m_added{a} {}\n+\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_added.insert(tx);\n+    }\n+\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t /* mempool_sequence */) override\n+    {\n+        // Transactions may be entered and booted any number of times\n+        m_removed.insert(tx);\n+    }\n+};\n+\n+void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Chainstate& chainstate)\n+{\n+    WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    {\n+        BlockAssembler::Options options;\n+        options.nBlockMaxWeight = fuzzed_data_provider.ConsumeIntegralInRange(0U, MAX_BLOCK_WEIGHT);\n+        options.blockMinFeeRate = CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/COIN)};\n+        auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n+        auto block_template = assembler.CreateNewBlock(CScript{} << OP_TRUE);\n+        Assert(block_template->block.vtx.size() >= 1);\n+    }\n+    const auto info_all = tx_pool.infoAll();\n+    if (!info_all.empty()) {\n+        const auto& tx_to_remove = *PickValue(fuzzed_data_provider, info_all).tx;\n+        WITH_LOCK(tx_pool.cs, tx_pool.removeRecursive(tx_to_remove, MemPoolRemovalReason::BLOCK /* dummy */));\n+        std::vector<uint256> all_txids;\n+        tx_pool.queryHashes(all_txids);\n+        assert(all_txids.size() < info_all.size());\n+        WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n+    }\n+    SyncWithValidationInterfaceQueue();\n+}\n+\n+void MockTime(FuzzedDataProvider& fuzzed_data_provider, const Chainstate& chainstate)\n+{\n+    const auto time = ConsumeTime(fuzzed_data_provider,\n+                                  chainstate.m_chain.Tip()->GetMedianTimePast() + 1,\n+                                  std::numeric_limits<decltype(chainstate.m_chain.Tip()->nTime)>::max());\n+    SetMockTime(time);\n+}\n+\n+CTxMemPool MakeMempool(FuzzedDataProvider& fuzzed_data_provider, const NodeContext& node)\n+{\n+    // Take the default options for tests...\n+    CTxMemPool::Options mempool_opts{MemPoolOptionsForTest(node)};\n+\n+\n+    // ...override specific options for this specific fuzz suite\n+    mempool_opts.limits.ancestor_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.ancestor_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.limits.descendant_count = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 50);\n+    mempool_opts.limits.descendant_size_vbytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 202) * 1'000;\n+    mempool_opts.max_size_bytes = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 200) * 1'000'000;\n+    mempool_opts.expiry = std::chrono::hours{fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(0, 999)};\n+    nBytesPerSigOp = fuzzed_data_provider.ConsumeIntegralInRange<unsigned>(1, 999);\n+\n+    mempool_opts.estimator = nullptr;\n+    mempool_opts.check_ratio = 1;\n+    mempool_opts.require_standard = fuzzed_data_provider.ConsumeBool();\n+\n+    // ...and construct a CTxMemPool from it\n+    return CTxMemPool{mempool_opts};\n+}\n+\n+FUZZ_TARGET(tx_package_eval, .init = initialize_tx_pool)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const auto& node = g_setup->m_node;\n+    auto& chainstate{static_cast<DummyChainState&>(node.chainman->ActiveChainstate())};\n+\n+    MockTime(fuzzed_data_provider, chainstate);\n+\n+    // All RBF-spendable outpoints outside of the immediate package\n+    std::set<COutPoint> outpoints_rbf;\n+    // All outpoints counting toward the total supply (subset of outpoints_rbf)\n+    std::set<COutPoint> outpoints_supply;\n+    std::map<COutPoint, CAmount> outpoints_value;\n+    for (const auto& outpoint : g_outpoints_coinbase_init_mature) {\n+        Assert(outpoints_supply.insert(outpoint).second);\n+        outpoints_value[outpoint] = 50 * COIN;\n+    }\n+\n+    // Seeded by coinbase outputs first\n+    outpoints_rbf = outpoints_supply;\n+\n+    CTxMemPool tx_pool_{MakeMempool(fuzzed_data_provider, node)};\n+    MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n+\n+    chainstate.SetMempool(&tx_pool);\n+\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n+        Assert(!outpoints_supply.empty());\n+\n+        std::vector<CTransactionRef> txs;\n+        std::map<uint256, CTransactionRef> wtxid_to_tx;\n+\n+\n+        // Make packages of 1-to-26 transactions\n+        const auto num_txs = (size_t) fuzzed_data_provider.ConsumeIntegralInRange<int>(1, 26);\n+        std::set<COutPoint> package_outpoints;\n+        while (txs.size() < num_txs) {\n+\n+            // Last transaction in a package needs to be a child of parents to get further in validation\n+            // so the last transaction to be generated(in a >1 package) must spend all package-made outputs\n+            // Note that this test currently only spends unconfirmed outputs in last transaction.\n+            bool last_tx = num_txs > 1 && txs.size() == num_txs - 1;\n+\n+            // Create transaction to add to the mempool\n+            const CTransactionRef tx = [&] {\n+                CMutableTransaction tx_mut;\n+                tx_mut.nVersion = CTransaction::CURRENT_VERSION;\n+                tx_mut.nLockTime = fuzzed_data_provider.ConsumeBool() ? 0 : fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+                // Last tx will sweep all outpoints in package\n+                const auto num_in = last_tx ? package_outpoints.size()  : fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size());\n+                const auto num_out = fuzzed_data_provider.ConsumeIntegralInRange<int>(1, outpoints_rbf.size() * 2);\n+\n+                auto& outpoints = last_tx ? package_outpoints : outpoints_rbf;\n+\n+                CAmount amount_in{0};\n+                for (size_t i = 0; i < num_in; ++i) {\n+                    // Pop random outpoint\n+                    auto pop = outpoints.begin();\n+                    std::advance(pop, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, outpoints.size() - 1));\n+                    const auto outpoint = *pop;\n+                    outpoints.erase(pop);\n+                    amount_in += outpoints_value.at(outpoint);\n+\n+                    // Create input\n+                    const auto sequence = ConsumeSequence(fuzzed_data_provider);\n+                    const auto script_sig = CScript{};\n+                    const auto script_wit_stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+                    CTxIn in;\n+                    in.prevout = outpoint;\n+                    in.nSequence = sequence;\n+                    in.scriptSig = script_sig;\n+                    in.scriptWitness.stack = script_wit_stack;\n+\n+                    tx_mut.vin.push_back(in);\n+                }\n+                const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(0, amount_in);\n+                const auto amount_out = (amount_in - amount_fee) / num_out;\n+                for (int i = 0; i < num_out; ++i) {\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\n+                }\n+                // TODO vary transaction sizes to catch size-related issues\n+                auto tx = MakeTransactionRef(tx_mut);\n+                // Restore previously removed outpoints, except in-package outpoints\n+                if (!last_tx) {\n+                    for (const auto& in : tx->vin) {\n+                        Assert(outpoints.insert(in.prevout).second);\n+                    }\n+                }\n+                // Cache the in-package outpoints being made\n+                for (size_t i = 0; i < tx->vout.size(); ++i) {\n+                    package_outpoints.emplace(tx->GetHash(), i);\n+                    outpoints_value[COutPoint(tx->GetHash(), i)] = tx->vout[i].nValue;\n+                }\n+                return tx;\n+            }();\n+            txs.push_back(tx);\n+            wtxid_to_tx[tx->GetWitnessHash()] = tx;\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            MockTime(fuzzed_data_provider, chainstate);\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            tx_pool.RollingFeeUpdate();\n+        }\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            const auto& txid = fuzzed_data_provider.ConsumeBool() ?\n+                                   txs.back()->GetHash() :\n+                                   PickValue(fuzzed_data_provider, outpoints_rbf).hash;\n+            const auto delta = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-50 * COIN, +50 * COIN);\n+            tx_pool.PrioritiseTransaction(txid, delta);\n+        }\n+\n+        // Remember all removed and added transactions\n+        std::set<CTransactionRef> removed;\n+        std::set<CTransactionRef> added;\n+        auto txr = std::make_shared<TransactionsDelta>(removed, added);\n+        RegisterSharedValidationInterface(txr);\n+        const bool bypass_limits = fuzzed_data_provider.ConsumeBool();\n+\n+        // Single-tx packages should be rejected, so do that sometimes, and sometimes send it via single submission\n+        // to allow it into the mempool by itself to make more interesting mempool packages\n+        auto single_submit = txs.size() == 1 && fuzzed_data_provider.ConsumeBool();\n+        auto package_submit = !single_submit;",
      "path": "src/test/fuzz/package_eval.cpp",
      "position": null,
      "original_position": 253,
      "commit_id": "262ab8ef7860d43cebc9d04721e3a075b4edf06e",
      "original_commit_id": "2ecdc2183f0a1291730ae8728fa3d847b9cf80b5",
      "in_reply_to_id": 1335807638,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh I was mistaken, AcceptPackage takes package sizes of 1(I was thinking of BIP331 probably!). This PR could have been a bit simpler I think by removing single accept path.",
      "created_at": "2023-09-28T12:43:23Z",
      "updated_at": "2023-09-28T12:43:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28450#discussion_r1340090802",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1340090802"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28450"
        }
      },
      "start_line": null,
      "original_start_line": 250,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    }
  ]
}