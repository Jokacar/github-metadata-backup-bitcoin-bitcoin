{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
    "id": 963791657,
    "node_id": "PR_kwDOABII5845cksp",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/25325",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/25325.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/25325.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/9f947fc3d4b779f017332135323b34e8f216f613",
    "number": 25325,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Add pool based memory resource",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "A memory resource similar to `std::pmr::unsynchronized_pool_resource`, but optimized for node-based containers. The goal is to be able to cache more coins with the same memory usage, and allocate/deallocate faster.\r\n\r\nThis is a reimplementation of #22702. The goal was to implement it in a way that is simpler to review & test\r\n\r\n* There is now a generic `PoolResource` for allocating/deallocating memory. This has practically the same API as `std::pmr::memory_resource`. (Unfortunately I cannot use std::pmr because libc++ simply doesn't implement that API).\r\n* Thanks to sipa there is now a fuzzer for PoolResource! On a fast machine I ran it for ~770 million executions without finding any issue.\r\n\r\n* The estimation of the correct node size is now gone, PoolResource now has multiple pools and just needs to be created large enough to have space for the unordered_map nodes.\r\n\r\nI ran benchmarks with #22702, mergebase, and this PR. Frequency locked Intel i7-8700, clang++ 13.0.1 to reindex up to block 690000.\r\n\r\n```sh\r\nbitcoind -dbcache=5000 -assumevalid=00000000000000000002a23d6df20eecec15b21d32c75833cce28f113de888b7 -reindex-chainstate -printtoconsole=0 -stopatheight=690000\r\n```\r\n\r\nThe performance is practically identical with #22702, just 0.4% slower. It's ~21% faster than master:\r\n\r\n![Progress in Million Transactions over Time(2)](https://user-images.githubusercontent.com/14386/173288685-91952ade-f304-4825-8bfb-0725a71ca17b.png)\r\n\r\n![Size of Cache in MiB over Time](https://user-images.githubusercontent.com/14386/173291421-e6b410be-ac77-479b-ad24-5fafcebf81eb.png)\r\nNote that on cache drops mergebase's memory doesnt go so far down because it does not free the `CCoinsMap` bucket array.\r\n\r\n![Size of Cache in Million tx over Time(1)](https://user-images.githubusercontent.com/14386/173288703-a80c9c9e-93c8-4a16-9df8-610c89c61cc4.png)\r\n",
    "labels": [
      {
        "id": 97470796,
        "node_id": "MDU6TGFiZWw5NzQ3MDc5Ng==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/UTXO%20Db%20and%20Indexes",
        "name": "UTXO Db and Indexes",
        "color": "fbca04",
        "default": false
      }
    ],
    "created_at": "2022-06-10T07:16:06Z",
    "updated_at": "2023-12-04T12:15:11Z",
    "closed_at": "2023-04-20T20:20:32Z",
    "mergeable_state": "unknown",
    "merged_at": "2023-04-20T20:20:32Z",
    "merge_commit_sha": "5aa0c82ccd6ceb4a141686fc8658f679de75a787",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_teams": [],
    "head": {
      "label": "martinus:2022-06-very-not-scary-NodePoolResource",
      "ref": "2022-06-very-not-scary-NodePoolResource",
      "sha": "9f947fc3d4b779f017332135323b34e8f216f613",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 107273866,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMDcyNzM4NjY=",
        "name": "bitcoin",
        "full_name": "martinus/bitcoin",
        "owner": {
          "login": "martinus",
          "id": 14386,
          "node_id": "MDQ6VXNlcjE0Mzg2",
          "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/martinus",
          "html_url": "https://github.com/martinus",
          "followers_url": "https://api.github.com/users/martinus/followers",
          "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
          "organizations_url": "https://api.github.com/users/martinus/orgs",
          "repos_url": "https://api.github.com/users/martinus/repos",
          "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/martinus/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/martinus/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/martinus/bitcoin",
        "archive_url": "https://api.github.com/repos/martinus/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/martinus/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/martinus/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/martinus/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/martinus/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/martinus/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/martinus/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/martinus/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/martinus/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/martinus/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/martinus/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/martinus/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/martinus/bitcoin/events",
        "forks_url": "https://api.github.com/repos/martinus/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/martinus/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/martinus/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/martinus/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/martinus/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/martinus/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/martinus/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/martinus/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/martinus/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/martinus/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/martinus/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/martinus/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/martinus/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/martinus/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/martinus/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/martinus/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:martinus/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/martinus/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/martinus/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/martinus/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/martinus/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/martinus/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/martinus/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/martinus/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/martinus/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/martinus/bitcoin/hooks",
        "svn_url": "https://github.com/martinus/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 242072,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-12-04T12:15:11Z",
        "created_at": "2017-10-17T13:40:13Z",
        "updated_at": "2023-07-11T15:23:38Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "23056436461a8b3af1a504b9638c48e8c8170652",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36078,
        "stargazers_count": 72443,
        "watchers_count": 72443,
        "size": 246235,
        "default_branch": "master",
        "open_issues_count": 654,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-12-04T12:54:56Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-12-04T11:49:32Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 1004,
    "deletions": 24,
    "changed_files": 16,
    "commits": 5,
    "review_comments": 108,
    "comments": 37
  },
  "events": [
    {
      "event": "convert_to_draft",
      "id": 6783954200,
      "node_id": "CTDE_lADOABII585Lh0inzwAAAAGUWu0Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6783954200",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-10T08:08:57Z"
    },
    {
      "event": "labeled",
      "id": 6784376013,
      "node_id": "LE_lADOABII585Lh0inzwAAAAGUYVzN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6784376013",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-10T09:13:27Z",
      "label": {
        "name": "Build system",
        "color": "5319e7"
      }
    },
    {
      "event": "labeled",
      "id": 6784376014,
      "node_id": "LE_lADOABII585Lh0inzwAAAAGUYVzO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6784376014",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-10T09:13:27Z",
      "label": {
        "name": "UTXO Db and Indexes",
        "color": "fbca04"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6787031449,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUieGZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6787031449",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-10T15:45:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6787659040,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUk3Ug",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6787659040",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-10T17:23:26Z"
    },
    {
      "event": "commented",
      "id": 1152596519,
      "node_id": "IC_kwDOABII585Eszon",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1152596519",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-10T17:46:23Z",
      "updated_at": "2023-04-20T20:11:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [john-moffett](https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1356988307), [jonatack](https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1357119390), [LarryRuane](https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1483180518), [achow101](https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1516886734) |\n| Stale ACK | [sipa](https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1349066025) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1152596519",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-10T18:15:21Z",
      "updated_at": "2022-06-10T18:15:21Z",
      "source": {
        "issue": {
          "id": 1260364605,
          "node_id": "PR_kwDOABII5845F7Be",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25274",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25274/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25274/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25274/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25274",
          "number": 25274,
          "state": "closed",
          "state_reason": null,
          "title": "[WIP] add free list to unordered map",
          "body": "This is offered as a \"dumb\" alternative to @martinus's very clever #22702, seeking some approach ACK before I spend more time polishing it. \r\n\r\nInstead of using a custom allocator, we just take advantage of the statically assertable fact that a node_handle is smaller than the COutpoint key type (or really, key type or value type, but key type happens to be big enough) to build a free list of extracted nodes that we then don't have to reallocate to reinsert. This would enable us to initialize a cacheMap with any number of nodes we like by inserting with N sequential COutpoints, and then removing them, or by calling reserve (unclear if any functional difference?).\r\n\r\nIn particular, this does not require mucking with any map internals, it's just using the external guts in a 'well defined but weird' way. Perhaps something like this is less scary @laanwj?\r\n\r\nOffered in WIP status for approach ACKs, missing (at least):\r\n\r\n1. Count total allocation size / count elements in free list\r\n2. Deallocate/clear the free list correctly (nodes in free list remain reinsertable after clear)\r\n3. make the create_new_cache_coin function have all the emplace-like behaviors we might want\r\n4. Any thorough review of correctness5. \r\n5. Generically wrapping it for any map where sizeof(K) >= sizeof(node_type).\r\n\r\nIn contrast to #22702, this approach would likely not save any space in allocations, since it can't allocate pages at a time.\r\n",
          "user": {
            "login": "JeremyRubin",
            "id": 886523,
            "node_id": "MDQ6VXNlcjg4NjUyMw==",
            "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/JeremyRubin",
            "html_url": "https://github.com/JeremyRubin",
            "followers_url": "https://api.github.com/users/JeremyRubin/followers",
            "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
            "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
            "repos_url": "https://api.github.com/users/JeremyRubin/repos",
            "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 97470796,
              "node_id": "MDU6TGFiZWw5NzQ3MDc5Ng==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/UTXO%20Db%20and%20Indexes",
              "name": "UTXO Db and Indexes",
              "color": "fbca04",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 2,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25274",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25274",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25274.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25274.patch"
          },
          "closed_at": "2022-06-10T20:40:24Z",
          "created_at": "2022-06-03T20:50:42Z",
          "updated_at": "2023-06-10T10:05:49Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T00:42:15Z",
      "updated_at": "2022-06-11T00:42:15Z",
      "source": {
        "issue": {
          "id": 523562117,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MzQxNTQwMTkx",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17487",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17487/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17487/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17487/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/17487",
          "number": 17487,
          "state": "closed",
          "state_reason": null,
          "title": "coins: allow write to disk without cache drop",
          "body": "This is part of the [assumeutxo project](https://github.com/bitcoin/bitcoin/projects/11):\r\n\r\nParent PR: #15606 \r\nIssue: #15605 \r\nSpecification: https://github.com/jamesob/assumeutxo-docs/tree/master/proposal\r\n\r\n---\r\n\r\nIn certain circumstances, we may want to flush chainstate data to disk without\r\nemptying `cacheCoins`, which affects performance. UTXO snapshot\r\nactivation is one such case, as we populate `cacheCoins` with the snapshot\r\ncontents and want to persist immediately afterwards but also enter IBD.\r\n\r\nSee also #15265, which makes the case that under normal operation a\r\nflush-without-erase doesn't necessarily add much benefit. I open this PR\r\neven in light of the previous discussion because (i) flush-without-erase\r\nalmost certainly provides benefit in the case of snapshot activation (especially\r\non spinning disk hardware) and (ii) this diff is fairly small and gives us convenient \r\noptions for more granular cache management without changing existing policy. \r\n\r\nSee also #15218. ",
          "user": {
            "login": "jamesob",
            "id": 73197,
            "node_id": "MDQ6VXNlcjczMTk3",
            "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jamesob",
            "html_url": "https://github.com/jamesob",
            "followers_url": "https://api.github.com/users/jamesob/followers",
            "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
            "organizations_url": "https://api.github.com/users/jamesob/orgs",
            "repos_url": "https://api.github.com/users/jamesob/repos",
            "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jamesob/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 97470796,
              "node_id": "MDU6TGFiZWw5NzQ3MDc5Ng==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/UTXO%20Db%20and%20Indexes",
              "name": "UTXO Db and Indexes",
              "color": "fbca04",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 51,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/17487",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/17487",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/17487.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/17487.patch"
          },
          "closed_at": "2023-01-30T16:01:39Z",
          "created_at": "2019-11-15T16:17:46Z",
          "updated_at": "2023-01-30T19:37:59Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6789546291,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUsEEz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6789546291",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T04:18:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6789560172,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUsHds",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6789560172",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T04:37:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6789579082,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUsMFK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6789579082",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T05:03:14Z"
    },
    {
      "event": "reviewed",
      "id": 1003429046,
      "node_id": "PRR_kwDOABII5847zxy2",
      "url": null,
      "actor": null,
      "commit_id": "ba380163e189493bc6edd12dfe1cd9ce82214305",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "Riahiamirreza",
        "id": 54557628,
        "node_id": "MDQ6VXNlcjU0NTU3NjI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/54557628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Riahiamirreza",
        "html_url": "https://github.com/Riahiamirreza",
        "followers_url": "https://api.github.com/users/Riahiamirreza/followers",
        "following_url": "https://api.github.com/users/Riahiamirreza/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Riahiamirreza/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Riahiamirreza/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Riahiamirreza/subscriptions",
        "organizations_url": "https://api.github.com/users/Riahiamirreza/orgs",
        "repos_url": "https://api.github.com/users/Riahiamirreza/repos",
        "events_url": "https://api.github.com/users/Riahiamirreza/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Riahiamirreza/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1003429046",
      "submitted_at": "2022-06-11T06:13:26Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6789642314,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUsbhK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6789642314",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T06:26:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6789797864,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUtBfo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6789797864",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T09:30:14Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6789835230,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUtKne",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6789835230",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T10:14:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6790094994,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUuKCS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6790094994",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T13:52:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6790139830,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGUuU-2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6790139830",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T14:37:46Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-11T15:42:57Z",
      "updated_at": "2022-06-11T15:42:57Z",
      "source": {
        "issue": {
          "id": 1229958480,
          "node_id": "PR_kwDOABII5843g-VF",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25097",
          "number": 25097,
          "state": "closed",
          "state_reason": null,
          "title": "test: Unit tests for taproot/tapscript coverage in `interpreter.cpp`",
          "body": "[Unit tests are not complete to resolve #23279 - _yet_.  But those additional tests - see this space for future developments! - will not change the code presented here.]\r\n\r\nThis PR provides unit tests for Taproot functionality in `script/interpreter.cpp`, #23279.\r\n\r\nGoal is to show correctness vs specifications in BIPs 341/342, and to improve code coverage in Taproot functionality there.\r\n\r\nIntent is to unit test completely without changing `interpreter.cpp` itself to provide visibility into static functions/private methods.  Thus some of the tests must be \"indirect\", testing the unit-under-test by probing a visible caller.  This makes those specific tests somewhat fragile as they depend on code paths in the caller, which may change in the future.  However, such tests are written so they will fail if the unit-under-test isn't actually called.  This is noted in the code of those specific tests.\r\n\r\nNo changes to Bitcoin Core are made - just unit tests added.  The Boost Test framework file `boost/test/execution_monitor.hpp` was added to the lint whitelist - this is acceptable because it is a documented public header of the Boost Test framework, which is already part of the project.\r\n\r\n- [x] `EvalChecksigTapscript`\r\n- [x] `HandleMissingData`\r\n- [x] `SignatureHashSchnorr` - now with full _path_ coverage\r\n- [x] `GenericTransactionSignatureChecker<T>::VerifySchnorrSignature`\r\n- [x] `GenericTransactionSignatureChecker<T>::CheckSchnorrSignature`\r\n- [x] `ComputeTaprootMerkleRoot`\r\n- [ ] `SigVersion::TAPSCRIPT` code paths in `ExecuteWitnessScript`\r\n- [x] Taproot code paths in `VerifyWitnessProgram`\r\n- [ ] Tapscript code paths in `VerifyWitnessProgram`\r\n\r\n**TODO:** Full Tapscript (BIP-342) unit tests yet to be completed.\r\n**TODO:** Does anything need to be done with `libconsensus`? Please advise!\r\n\r\n2 commits:\r\n\r\n1. Add new utility functions to `src/test/util` that are not only used in these tests but may also be useful for future unit tests.  Also, refactor some existing utility functions from current tests (mainly, `script_tests.cpp`) into `src/test/util` so they can be more widely used too.  All of these new test utility functions have unit tests themselves, in `src/test/test_utils_tests.cpp`.\r\n1. All the tests for Taproot/Tapscript functionality requested by #23279 in a new file `src/test/script_tapscript_tests.cpp`.  Code coverage runs show 100% coverage of lines and near 100% coverage of branches.\r\n\r\n**DEATH TRAP AHEAD!:** These unit tests include \"death tests\" (name comes from Googletest framework): Tests that check that an `assert` actually fails.  These are handled with a Boost `execution_monitor` (mentioned above) _but_ the asserts _still issue messages_ even when correctly trapped by the Boost Test framework.  You'll see the following in the logs:\r\n\r\n```\r\ngitpod /workspace/bitcoin/src/test (23279-taproot-unit-tests) $ ./test_bitcoin \r\nRunning 527 test cases...\r\ntest_bitcoin: script/interpreter.cpp:1495: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `false' failed.\r\ntest_bitcoin: script/interpreter.cpp:1497: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `in_pos < tx_to.vin.size()' failed.\r\ntest_bitcoin: script/interpreter.cpp:1528: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_annex_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1556: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_tapleaf_hash_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1559: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_codeseparator_pos_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1469: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Missing data\"' failed.\r\ntest_bitcoin: script/interpreter.cpp:1474: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Unknown MissingDataBehavior value\"' failed.\r\n\r\n*** No errors detected\r\ngitpod /workspace/bitcoin/src/test (23279-taproot-unit-tests) $ \r\n```\r\n\r\nThese specific `Assertion ... failed` messages are _expected_.  The tests triggering them properly _pass_ iff the `assert` (and no other) is _triggered_.\r\n\r\n-----\r\n\r\nCoverage results 2022-06-05 showing Taproot coverage (Tapscript tests not yet complete) when _only running_ `script_tapscript_tests.cpp`:\r\n\r\n|  |   |\r\n|--:|:--|\r\n|`EvalChecksigTapscript`|<img alt=\"EvalChecksigTapscript\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067379-4815fd13-1eca-4fdc-afb3-ab321f644ca6.png\">|\r\n|`HandleMissingData`|<img alt=\"HandleMissingData coverage\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172066800-7ad85065-448c-4300-8f5f-bbdaeb5bc885.png\">|\r\n|`SignatureHashSchnorr`|<img alt=\"SignatureHashSchnorr coverage\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067034-c8d65908-bf41-4420-8a5d-5c023f85824a.png\">|\r\n|`GenericTransaction-`<br>`SignatureChecker<T>::`<br>`CheckSchnorrSignature`|<img alt=\"CheckSchnorrSignature\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067232-b58ea75a-9df7-4f02-b291-c1adda4792e8.png\">|\r\n|`ComputeTaprootMerkleRoot`|<img alt=\"ComputeTaprootMerkleRoot\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067270-d15ac048-6001-4a8f-b0a7-f62b76cf584b.png\">|\r\n|`VerifyWitnessProgram`<br>(Taproot only)|<img alt=\"VerifyWitnessProgram\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067308-c23ccaaa-dbee-43ea-b2df-cbee9ba375ed.png\">|\r\n\r\n",
          "user": {
            "login": "david-bakin",
            "id": 4162948,
            "node_id": "MDQ6VXNlcjQxNjI5NDg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/david-bakin",
            "html_url": "https://github.com/david-bakin",
            "followers_url": "https://api.github.com/users/david-bakin/followers",
            "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
            "organizations_url": "https://api.github.com/users/david-bakin/orgs",
            "repos_url": "https://api.github.com/users/david-bakin/repos",
            "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/david-bakin/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 19,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25097",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25097.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25097.patch"
          },
          "closed_at": "2022-11-10T17:16:20Z",
          "created_at": "2022-05-09T16:17:57Z",
          "updated_at": "2023-11-10T12:18:04Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6791724030,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGU0Xv-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6791724030",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-12T17:13:00Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6791828118,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGU0xKW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6791828118",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-12T19:01:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6791847327,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGU012f",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6791847327",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-12T19:18:58Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6791860301,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGU05BN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6791860301",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-12T19:32:12Z"
    },
    {
      "event": "renamed",
      "id": 6793269914,
      "node_id": "RTE_lADOABII585Lh0inzwAAAAGU6RKa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6793269914",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-13T06:18:53Z",
      "rename": {
        "from": "[WIP] Add pool based memory resource",
        "to": "Add pool based memory resource"
      }
    },
    {
      "event": "ready_for_review",
      "id": 6793274083,
      "node_id": "RFRE_lADOABII585Lh0inzwAAAAGU6SLj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6793274083",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-13T06:19:44Z"
    },
    {
      "event": "added_to_project",
      "id": 6794816213,
      "node_id": "ATPE_lADOABII585Lh0inzwAAAAGVAKrV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6794816213",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-13T10:13:21Z",
      "project_card": {
        "id": 83116647,
        "url": "https://api.github.com/projects/columns/cards/83116647",
        "project_id": 481835,
        "project_url": "https://api.github.com/projects/481835",
        "column_name": "Blockers"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-15T15:43:03Z",
      "updated_at": "2022-06-15T15:43:03Z",
      "source": {
        "issue": {
          "id": 541348481,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MzU2MDE2MTI5",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17786",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17786/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17786/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/17786/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/17786",
          "number": 17786,
          "state": "closed",
          "state_reason": null,
          "title": "refactor: Nuke policy/fees->mempool circular dependencies",
          "body": "This PR:\r\n- gets rid of the `policy/fees` -> `txmempool` -> `policy/fees` circular dependency\r\n- is an alternative to #13949, which nukes only one circular dependency",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 45,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/17786",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/17786",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/17786.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/17786.patch"
          },
          "closed_at": "2022-11-19T01:05:22Z",
          "created_at": "2019-12-21T17:08:37Z",
          "updated_at": "2023-11-30T12:20:31Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6834278587,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAGXWtC7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6834278587",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-19T05:13:03Z"
    },
    {
      "event": "commented",
      "id": 1159619246,
      "node_id": "IC_kwDOABII585FHmKu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1159619246",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-19T05:15:23Z",
      "updated_at": "2022-06-19T05:15:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "rebased to 9205b60 with minor fixes in `pool.h` so it is usable in `boost::unordered_map`",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1159619246",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-29T22:46:11Z",
      "updated_at": "2022-07-29T22:46:11Z",
      "source": {
        "issue": {
          "id": 1316592675,
          "node_id": "PR_kwDOABII5848BwTe",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25695",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25695/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25695/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25695/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25695",
          "number": 25695,
          "state": "closed",
          "state_reason": null,
          "title": "tidy: add modernize-use-using",
          "body": "Refactor and introduce `modernize-use-using` into our clang-tidy job. Given we already use both, consolidate to the later.\r\n\r\nSee: https://releases.llvm.org/14.0.0/tools/clang/tools/extra/docs/clang-tidy/checks/modernize-use-using.html.",
          "user": {
            "login": "fanquake",
            "id": 863730,
            "node_id": "MDQ6VXNlcjg2MzczMA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fanquake",
            "html_url": "https://github.com/fanquake",
            "followers_url": "https://api.github.com/users/fanquake/followers",
            "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
            "organizations_url": "https://api.github.com/users/fanquake/orgs",
            "repos_url": "https://api.github.com/users/fanquake/repos",
            "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fanquake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25695",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25695",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25695.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25695.patch"
          },
          "closed_at": "2022-12-05T11:19:11Z",
          "created_at": "2022-07-25T10:19:42Z",
          "updated_at": "2023-11-06T10:28:56Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "unlabeled",
      "id": 7215149080,
      "node_id": "UNLE_lADOABII585Lh0inzwAAAAGuDnAY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7215149080",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-08-18T14:55:30Z",
      "label": {
        "name": "Build system",
        "color": "5319e7"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-08-23T15:29:19Z",
      "updated_at": "2022-08-23T15:29:19Z",
      "source": {
        "issue": {
          "id": 1348033414,
          "node_id": "PR_kwDOABII5849pYkL",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25909",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25909/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25909/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25909/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25909",
          "number": 25909,
          "state": "closed",
          "state_reason": null,
          "title": "wallet: coverage for receiving txes with same id but different witness data",
          "body": "Based on #11240 context, adding test coverage for the behavior introduced in #11225 and to the current wallet limitations.\r\n\r\nThis is the first step towards adding the ability to store multiple transactions with same tx id but different witness data in the wallet. Verifying and testing the current behavior before introducing the new features.\r\n\r\nThe following cases are covered:\r\n\r\n1) Two p2wpkh spending transactions with the same hash are received:\r\nThe first one with segwit data stripped, and the second one with segwit data.\r\n   \r\n   Result ->  the wallet will update the stored tx, saving the witness data.\r\n\r\n2) Two p2wsh multisig spending txes with the same hash but a different witness are received:\r\nThe first is added to the wallet via the mempool acceptance flow.\r\nwhile the second one, is added to the wallet via the block connection flow.\r\n\r\n   Result -> the wallet will NOT update the stored transaction. The first received transaction\r\nwill take precedence over any following-up transaction. Detached to the fact that the\r\noriginal transaction didn't get into a block and the second one did.\r\n\r\nExtra Note:\r\nDid it on an unit test merely because wanted to review other parts of the sources while was doing it. Could migrate it into a functional test if reviewers wants it as well.",
          "user": {
            "login": "furszy",
            "id": 5377650,
            "node_id": "MDQ6VXNlcjUzNzc2NTA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/furszy",
            "html_url": "https://github.com/furszy",
            "followers_url": "https://api.github.com/users/furszy/followers",
            "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
            "organizations_url": "https://api.github.com/users/furszy/orgs",
            "repos_url": "https://api.github.com/users/furszy/repos",
            "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/furszy/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 149424,
              "node_id": "MDU6TGFiZWwxNDk0MjQ=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Wallet",
              "name": "Wallet",
              "color": "08a781",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 7,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25909",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25909",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25909.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25909.patch"
          },
          "closed_at": "2023-09-21T10:42:43Z",
          "created_at": "2022-08-23T14:16:13Z",
          "updated_at": "2023-09-21T10:42:44Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1082762327,
      "node_id": "PRR_kwDOABII585AiaRX",
      "url": null,
      "actor": null,
      "commit_id": "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1082762327",
      "submitted_at": "2022-08-23T19:55:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "reviewed",
      "id": 1082773235,
      "node_id": "PRR_kwDOABII585Aic7z",
      "url": null,
      "actor": null,
      "commit_id": "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1082773235",
      "submitted_at": "2022-08-23T20:04:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-09-17T17:07:34Z",
      "updated_at": "2022-09-17T17:07:34Z",
      "source": {
        "issue": {
          "id": 1360707418,
          "node_id": "PR_kwDOABII584-TvTS",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25991",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25991/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25991/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25991/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25991",
          "number": 25991,
          "state": "closed",
          "state_reason": null,
          "title": "Wallet: Add foreign_outputs metadata to support CoinJoin transactions",
          "body": "Fixes #14136\r\n\r\nDoes not fix GUI (can be done in GUI-side PR afterward)",
          "user": {
            "login": "luke-jr",
            "id": 1095675,
            "node_id": "MDQ6VXNlcjEwOTU2NzU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/luke-jr",
            "html_url": "https://github.com/luke-jr",
            "followers_url": "https://api.github.com/users/luke-jr/followers",
            "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
            "organizations_url": "https://api.github.com/users/luke-jr/orgs",
            "repos_url": "https://api.github.com/users/luke-jr/repos",
            "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/luke-jr/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 149424,
              "node_id": "MDU6TGFiZWwxNDk0MjQ=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Wallet",
              "name": "Wallet",
              "color": "08a781",
              "default": false
            },
            {
              "id": 749416508,
              "node_id": "MDU6TGFiZWw3NDk0MTY1MDg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Up%20for%20grabs",
              "name": "Up for grabs",
              "color": "99a810",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 16,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25991",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25991",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25991.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25991.patch"
          },
          "closed_at": "2023-09-20T16:09:08Z",
          "created_at": "2022-09-03T00:49:20Z",
          "updated_at": "2023-09-20T16:09:19Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1250328856,
      "node_id": "IC_kwDOABII585KhoEY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1250328856",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-09-18T15:13:09Z",
      "updated_at": "2022-09-18T15:13:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "In a semi-related event, I've recently created a big benchmark of a lot of different hashmaps. See here: https://martin.ankerl.com/2022/08/27/hashmap-bench-01/\r\n\r\nSome findings that I think are relevant for this PR:\r\n\r\n* I have added the `PoolAllocator` developed here to the benchmarks and combined it with both `std::unordered_map` and `boost::unordered_map` and it works without any problems.\r\n* boost has completely reworked the hashmap and released that in version 1.80. Just changing the map to that implementation will probably provide some speedup. [More info here](https://www.boost.org/doc/libs/1_80_0/libs/unordered/doc/html/unordered.html#benchmarks).\r\n* Both `boost::unordered_map` and `std::unordered_map` benefit a lot memory-wise from the `PoolAllocator`.\r\n* Boost has it's own pool allocator: `boost::container::pmr::unsynchronized_pool_resource` It behaves relatively similar to PoolAllocator, although slower in my benchmarks. So this might be an alternative to the `PoolAllocator`.\r\n* Other implementations like `gtl::parallel_flat_hash_map` are much faster and have low memory overhead, so they might be a good choice performance wise, although they carry much more risk because usage is not so widespread.",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1250328856",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7451418963,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAG8I6FT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7451418963",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-09-24T06:10:44Z"
    },
    {
      "event": "commented",
      "id": 1256876909,
      "node_id": "IC_kwDOABII585K6mtt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1256876909",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-09-24T06:11:40Z",
      "updated_at": "2022-09-24T06:11:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased to [f1b20f0](https://github.com/bitcoin/bitcoin/commit/f1b20f04644ddc07bd9bbfc066f9701d54139d52) to fix copyright header in `xoroshiro128plusplus.h`. Nothing else changed.",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1256876909",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-09-24T16:38:35Z",
      "updated_at": "2022-09-24T16:38:35Z",
      "source": {
        "issue": {
          "id": 1381623925,
          "node_id": "PR_kwDOABII584_YzZB",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26153",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26153/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26153/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26153/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26153",
          "number": 26153,
          "state": "closed",
          "state_reason": null,
          "title": "Reduce wasted pseudorandom bytes in ChaCha20 + various improvements",
          "body": "This is an alternative to #25354 (by my benchmarking, somewhat faster), subsumes #25712, and adds additional test vectors.\r\n\r\nIt separates the multiple-of-64-bytes-only \"core\" logic (which becomes simpler) from a layer around which performs caching/slicing to support arbitrary byte amounts. Both have their uses (in particular, the MuHash3072 code can benefit from multiple-of-64-bytes assumptions), plus the separation results in more readable code. Also, since FastRandomContext effectively had its own (more naive) caching on top of ChaCha20, that can be dropped in favor of ChaCha20's new built-in caching.\r\n\r\nI thought about rebasing #25712 on top of this, but the changes before are fairly extensive, so redid it instead.",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 14,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26153",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26153",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26153.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26153.patch"
          },
          "closed_at": "2023-02-15T14:59:06Z",
          "created_at": "2022-09-21T23:22:32Z",
          "updated_at": "2023-07-18T18:37:33Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-10T16:34:53Z",
      "updated_at": "2022-10-10T16:34:53Z",
      "source": {
        "issue": {
          "id": 1403073198,
          "node_id": "PR_kwDOABII585AfUHt",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26286",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26286/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26286/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26286/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26286",
          "number": 26286,
          "state": "closed",
          "state_reason": null,
          "title": "test: Remove unused txmempool include from tests",
          "body": "Seems odd to include this heavy header in all tests despite it only being used in a few tests.\r\n\r\nCan be reviewed with `--color-moved=dimmed-zebra --ignore-all-space`",
          "user": {
            "login": "maflcko",
            "id": 6399679,
            "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/maflcko",
            "html_url": "https://github.com/maflcko",
            "followers_url": "https://api.github.com/users/maflcko/followers",
            "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
            "organizations_url": "https://api.github.com/users/maflcko/orgs",
            "repos_url": "https://api.github.com/users/maflcko/repos",
            "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/maflcko/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26286",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26286",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26286.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26286.patch"
          },
          "closed_at": "2022-10-19T07:43:42Z",
          "created_at": "2022-10-10T12:11:26Z",
          "updated_at": "2023-10-19T12:15:14Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 7619634714,
      "node_id": "LE_lADOABII585Lh0inzwAAAAHGKmYa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7619634714",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-19T09:31:26Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7641917505,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAHHfmhB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7641917505",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-21T15:56:03Z"
    },
    {
      "event": "commented",
      "id": 1287155740,
      "node_id": "IC_kwDOABII585MuHAc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1287155740",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-21T15:58:23Z",
      "updated_at": "2022-10-21T17:22:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebase to 509d97a fixes merge conflict in `Makefile.test_util.include`, fixes a comment, adds benchmark priority, fix Win64 64bit shift warning.",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1287155740",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "unlabeled",
      "id": 7642053450,
      "node_id": "UNLE_lADOABII585Lh0inzwAAAAHHgHtK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7642053450",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-21T16:15:33Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7642458976,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAHHhqtg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7642458976",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-21T17:21:12Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-23T03:33:17Z",
      "updated_at": "2022-10-23T03:33:17Z",
      "source": {
        "issue": {
          "id": 1269628212,
          "node_id": "PR_kwDOABII5845knyj",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25361",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25361/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25361/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25361/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/25361",
          "number": 25361,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Cipher suite",
          "body": "This PR supersedes #20962 and introduces a two-layered cipher suite used in the latest draft of [BIP324](https://github.com/bitcoin/bips/pull/1378).\r\n\r\n* Inner layer uses [RFC8439](https://datatracker.ietf.org/doc/html/rfc8439) which comes with a formal [security analysis](https://eprint.iacr.org/2014/613.pdf) so any novelty introduced by our cipher suite still offers a baseline confidence in confidentiality and authenticity. The RFC8439 instance is re-keyed every 256 messages for forward secrecy.\r\n* Outer layer uses a forward secure version of ChaCha20, `FSChaCha20` which re-keys itself every 256 messages for forward secrecy. It is used to encrypt the message length resulting in a pseudorandom byte stream.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 17,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25361",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/25361",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/25361.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/25361.patch"
          },
          "closed_at": "2023-05-06T11:11:09Z",
          "created_at": "2022-06-13T15:40:56Z",
          "updated_at": "2023-05-06T11:11:09Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-23T05:23:10Z",
      "updated_at": "2022-10-23T05:23:10Z",
      "source": {
        "issue": {
          "id": 1167366626,
          "node_id": "PR_kwDOABII5840WLLa",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24545/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24545",
          "number": 24545,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Enable v2 P2P encrypted transport",
          "body": "This PR brings together all other BIP324 PRs and enables v2 encrypted P2P transport.\r\n\r\nBuilds on top of PRs: #25361, #23233, #23561, #23432. It looks like there's a lot of commits, but **only the last 12 commits belong in this PR**. The rest will be merged with upstream PRs.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).\r\n\r\nBIP324 is [here](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki).\r\n\r\n### Running a v2 node\r\n#### Get the code\r\n```\r\ngit remote add bip324 git@github.com:dhruv/bitcoin.git\r\ngit fetch bip324\r\ngit checkout bip324/bip324-enable\r\n```\r\n\r\n#### Build for your OS\r\n\r\nFollow the appropriate instructions [here](https://github.com/bitcoin/bitcoin/blob/master/doc/README.md)\r\n\r\n#### Run the node\r\n\r\n```\r\nsrc/bitcoind -conf=CONFIG_FILE -v2transport=1\r\n```\r\n\r\n#### Connect with a friend's v2 node\r\n```\r\nsrc/bitcoin-cli -conf=CONFIG_FILE addnode \"FRIEND_IP:FRIEND_PORT\" \"add\" true\r\n```\r\nThe last parameter(`p2p_v2:true`) signals to your node that the peer is running a v2 supportive client and we should attempt to make an encrypted P2P connection (you're simulating the `NODE_P2P_V2` service flag advertisement manually). Should that fail however (say because the peer told you mistakenly, lied, etc.), this code will downgrade the connection to unencrypted v1 transport.\r\n\r\n### Things you are helpful to test\r\n\r\n* If your friend's node is a v2 node, you can see with wireshark that the bytes are pseudorandom (the easiest way to confirm this is that with a v1 connection, wireshark will tell you it has detected a Bitcoin connection and it'll even parse out the metadata like message type, etc; with v2, wireshark has no idea -- of course that _could_ be because wireshark does simply not know v2, but it is because the bytestream is pseudorandom)\r\n* Compare the v2 encrypted session id exposed via `getpeerinfo` as `v2_session_id` with your friend.\r\n* Add another peer that is actually v1, but try `addnode` still indicating v2 support. You should see with wireshark that after a failed attempt at a v2 handshake, the connection is downgraded to unencrypted v1 and wireshark can parse it.\r\n\r\nI've been told there are v2 nodes running at (happy to update the list as more people run persistent v2 nodes; message me and I'll add it here):\r\n```\r\nbe.anyone.eu.org\r\nrp7k2go3s5lyj3fnj6zn62ktarlrsft2ohlsxkyd7v3e3idqyptvread.onion:8333\r\njdcoysubtxazi7dketpyb5rnjorvxad4onftveohash2pdwkgw4bvnqd.onion:8333\r\nxci6cphki2pdb5qe7axzrcxcxabkbm24z4zlv2hn4ziy6grquqco2kyd.onion:8333\r\nslvtesfgg3mkksqqzh67al4sq6dx3rhlzqepa4ny7jonzuckg6msf3id.onion:8333\r\ngifm4fnj3vua664xhgeanx5fnpco3txkqy4amr4txbfsciiyrkxpf2qd.onion:8333\r\n300:5ecb:6b8a:d837::3:8333\r\n300:5ecb:6b8a:d837::a6d6:8333\r\n2001:470:1f1a:365::2:8333\r\n2001:470:1f1b:365:aa20:66ff:fe3f:1909:8333\r\n184.74.240.157:8533\r\n95.179.145.232:8333\r\n```",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 47,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24545",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24545",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24545.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24545.patch"
          },
          "closed_at": "2023-05-06T11:14:46Z",
          "created_at": "2022-03-12T18:43:06Z",
          "updated_at": "2023-09-15T02:47:56Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-23T18:20:10Z",
      "updated_at": "2022-10-23T18:20:10Z",
      "source": {
        "issue": {
          "id": 1059245454,
          "node_id": "PR_kwDOABII584uzo7R",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23561",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23561/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23561/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23561/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23561",
          "number": 23561,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Handshake prerequisites",
          "body": "Depends on #25361 for some constants, and on https://github.com/bitcoin-core/secp256k1/pull/1129 for ellswift integrated XDH but can be reviewed independently. Only the last 5 commits belong to this PR.\r\n\r\nThis PR adds xonly [ECDH](https://gist.github.com/dhruv/5b1275751bc98f3b64bcafce7876b489#Initial_handshake) and [HKDF](https://gist.github.com/dhruv/5b1275751bc98f3b64bcafce7876b489#keys-and-session-id-derivation) key derivation code for BIP324. Unit, bench and fuzz tests are included.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 31,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23561",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23561",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23561.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23561.patch"
          },
          "closed_at": "2023-04-18T08:50:23Z",
          "created_at": "2021-11-20T22:50:38Z",
          "updated_at": "2023-04-18T08:50:23Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-23T18:43:13Z",
      "updated_at": "2022-10-23T18:43:13Z",
      "source": {
        "issue": {
          "id": 1021384855,
          "node_id": "PR_kwDOABII584s9UYg",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/23233/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/23233",
          "number": 23233,
          "state": "closed",
          "state_reason": null,
          "title": "BIP324: Add encrypted p2p transport {de}serializer",
          "body": "Revives #18242. Depends on #25361 (please review that first, the last 4 commits are to be reviewed here).\r\n\r\nThis PR adds a p2p message transport {de}serializer for encrypted packets leveraging the BIP324 specification.\r\n\r\nThe dependency tree for BIP324 PRs is [here](https://bip324.com/sections/code-review/).",
          "user": {
            "login": "dhruv",
            "id": 856960,
            "node_id": "MDQ6VXNlcjg1Njk2MA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dhruv",
            "html_url": "https://github.com/dhruv",
            "followers_url": "https://api.github.com/users/dhruv/followers",
            "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
            "organizations_url": "https://api.github.com/users/dhruv/orgs",
            "repos_url": "https://api.github.com/users/dhruv/repos",
            "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dhruv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 34,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/23233",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/23233",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/23233.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/23233.patch"
          },
          "closed_at": "2023-05-06T11:11:30Z",
          "created_at": "2021-10-08T19:01:33Z",
          "updated_at": "2023-05-06T11:11:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1154271326,
      "node_id": "PRR_kwDOABII585EzMhe",
      "url": null,
      "actor": null,
      "commit_id": "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "The code looks good but it is spooky to review.\r\nI have benchmarked the PR by running `bitcoind -dbcache=5000 -assumevalid=00000000000000000002a23d6df20eecec15b21d32c75833cce28f113de888b7 -reindex-chainstate -printtoconsole=0` and compared the time elapsed between the reindexing of blocks between height=165618 and height=686269 on both master and this PR on mainnet.\r\n\r\nMaster took 18h06mins and this PR took 13h46mins, corresponding to a reduction of ~24% which matches the PR description.",
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1154271326",
      "submitted_at": "2022-10-25T08:09:58Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "reviewed",
      "id": 1154619863,
      "node_id": "PRR_kwDOABII585E0hnX",
      "url": null,
      "actor": null,
      "commit_id": "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I have also verified that using the default cache (`450MB`), this PR reindexes the chainstate faster than on master.\r\n\r\n### Master\r\n`./src/bitcoind -testnet -reindex-chainstate  -stopatheight=1000000 -printtoconsole=0`\r\nreal\t10m6.978s\r\nuser\t9m4.140s\r\nsys\t1m34.479s\r\n\r\n### PR\r\n`./src/bitcoind -testnet -reindex-chainstate  -stopatheight=1000000 -printtoconsole=0`\r\nreal\t9m32.270s\r\nuser\t8m29.061s\r\nsys\t1m26.911s",
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1154619863",
      "submitted_at": "2022-10-25T11:15:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "labeled",
      "id": 7848557915,
      "node_id": "LE_lADOABII585Lh0inzwAAAAHTz31b",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7848557915",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-19T01:44:04Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 7860104758,
      "node_id": "UNLE_lADOABII585Lh0inzwAAAAHUf642",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7860104758",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-21T18:22:52Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-21T19:39:52Z",
      "updated_at": "2022-11-21T19:39:52Z",
      "source": {
        "issue": {
          "id": 1455276823,
          "node_id": "PR_kwDOABII585DN8Df",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26532",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26532/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26532/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26532/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26532",
          "number": 26532,
          "state": "closed",
          "state_reason": null,
          "title": "wallet: bugfix, invalid crypted key \"checksum_valid\" set",
          "body": "At wallet load time, the crypted key \"checksum_valid\" variable is always set to false. Which, on every wallet decryption call, forces the process to re-write all the ckeys to db when it's not needed.\r\n\r\nNote:\r\nThe first commit fixes the issue, the two commits in the middle are cleanups so `DuplicateMockDatabase`\r\ncan be used without duplicating code. And, the last one is pure test coverage for the crypted keys loading\r\nprocess.\r\n\r\nIncludes test coverage for the following scenarios:\r\n\r\n1) \"All ckeys checksums valid\" test:\r\nLoads an encrypted wallet with all the crypted keys with a valid checksum and\r\nverifies that 'CWallet::Unlock' doesn't force an entire crypted keys re-write.\r\n\r\n    (we force a complete ckeys re-write if we find any missing crypted key checksum\r\nduring the wallet loading process)\r\n\r\n2) \"Missing checksum in one ckey\" test:\r\nVerifies that loading up a wallet with, at least one, 'ckey' with no checksum\r\ntriggers a complete re-write of the crypted keys.\r\n\r\n3) \"Invalid ckey checksum error\" test:\r\nVerifies that loading up a ckey with an invalid checksum stops the wallet loading\r\nprocess with a corruption error.\r\n\r\n4) \"Invalid ckey pubkey error\" test:\r\nVerifies that loading up a ckey with an invalid pubkey stops the wallet loading\r\nprocess with a corruption error.",
          "user": {
            "login": "furszy",
            "id": 5377650,
            "node_id": "MDQ6VXNlcjUzNzc2NTA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/furszy",
            "html_url": "https://github.com/furszy",
            "followers_url": "https://api.github.com/users/furszy/followers",
            "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
            "organizations_url": "https://api.github.com/users/furszy/orgs",
            "repos_url": "https://api.github.com/users/furszy/repos",
            "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/furszy/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 149424,
              "node_id": "MDU6TGFiZWwxNDk0MjQ=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Wallet",
              "name": "Wallet",
              "color": "08a781",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 5,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26532",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26532",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26532.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26532.patch"
          },
          "closed_at": "2022-11-29T23:55:20Z",
          "created_at": "2022-11-18T14:55:54Z",
          "updated_at": "2023-05-27T01:47:17Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 7917763480,
      "node_id": "LE_lADOABII585Lh0inzwAAAAHX73uY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7917763480",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T01:21:14Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7924505341,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAHYVlr9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7924505341",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T17:59:47Z"
    },
    {
      "event": "unlabeled",
      "id": 7924699633,
      "node_id": "UNLE_lADOABII585Lh0inzwAAAAHYWVHx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7924699633",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T18:27:11Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-01T05:26:15Z",
      "updated_at": "2022-12-01T05:26:15Z",
      "source": {
        "issue": {
          "id": 1470372521,
          "node_id": "PR_kwDOABII585EAnN1",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26615",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26615/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26615/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26615/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26615",
          "number": 26615,
          "state": "closed",
          "state_reason": null,
          "title": "test: Make `mempool_tests/MempoolSizeLimitTest` allocation-neutral",
          "body": "Split from https://github.com/bitcoin/bitcoin/pull/26614 as it can be considered as a sort of a prerequisite, and it is easier to review.",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            },
            {
              "id": 164208572,
              "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
              "name": "Mempool",
              "color": "fef2c0",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 3,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26615",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26615",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26615.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26615.patch"
          },
          "closed_at": "2023-03-21T17:51:10Z",
          "created_at": "2022-11-30T23:41:53Z",
          "updated_at": "2023-03-21T17:51:10Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-01T05:27:55Z",
      "updated_at": "2022-12-01T05:27:55Z",
      "source": {
        "issue": {
          "id": 1470320536,
          "node_id": "PR_kwDOABII585EAbte",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26614",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26614/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26614/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26614/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26614",
          "number": 26614,
          "state": "closed",
          "state_reason": null,
          "title": "Accurately account for mempool index memory ",
          "body": "Picked https://github.com/bitcoin/bitcoin/pull/18086:\r\n\r\n> This introduces a C++ allocator class (`memusage::AccountingAllocator`) which enables containers that accurately account for all their memory allocations in a tracker variable.\r\n>\r\n> This is then used to replace the heuristics in the mempool to guess memory usage.\r\n",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 164208572,
              "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
              "name": "Mempool",
              "color": "fef2c0",
              "default": false
            },
            {
              "id": 326918230,
              "node_id": "MDU6TGFiZWwzMjY5MTgyMzA=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Resource%20usage",
              "name": "Resource usage",
              "color": "981023",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 3,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26614",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26614",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26614.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26614.patch"
          },
          "closed_at": "2023-03-21T17:44:19Z",
          "created_at": "2022-11-30T22:49:48Z",
          "updated_at": "2023-03-21T17:44:19Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1338010318,
      "node_id": "IC_kwDOABII585PwGrO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1338010318",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-05T19:19:48Z",
      "updated_at": "2022-12-05T19:19:48Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, this approach is much easier to be convinced about, I feel. Happy to see that most of the performance gains carry over.\r\n\r\nI've ran a partial reindex under valgrind with this PR (to height 592178, which took several days), to really stress test it. No issues. I'll do a more in-depth code review soon.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1338010318",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-17T13:33:34Z",
      "updated_at": "2022-12-17T13:33:34Z",
      "source": {
        "issue": {
          "id": 1191033673,
          "node_id": "PR_kwDOABII5841jAnn",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24748/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/24748",
          "number": 24748,
          "state": "open",
          "state_reason": null,
          "title": "test/BIP324: functional tests for v2 P2P encryption",
          "body": "This PR introduces support for v2 P2P encryption(BIP 324) in the existing functional test framework and adds functional tests for the same.\r\n\r\n### commits overview\r\n1. introduces a new class `EncryptedP2PState` to store the keys, functions for performing the initial v2 handshake and encryption/decryption.\r\n3. this class is used by `P2PConnection` in inbound/outbound connections to perform the initial v2 handshake before the v1 version handshake. Only after the initial v2 handshake is performed do application layer P2P messages(version, verack etc..) get exchanged. (in a v2 connection)\r\n    - `v2_state` is the object of class `EncryptedP2PState` in `P2PConnection` used to store its keys, session-id etc.\r\n    - a node [advertising](https://github.com/stratospher/blogosphere/blob/main/integration_test_bip324.md#advertising-to-support-v2-p2p) support for  v2 P2P is different from a node actually [supporting v2 P2P](https://github.com/stratospher/blogosphere/blob/main/integration_test_bip324.md#supporting-v2-p2p) (differ when false advertisement of services occur)\r\n        - introduce a boolean variable `supports_v2_p2p` in `P2PConnection` to denote if it supports v2 P2P.\r\n        - introduce a boolean variable `advertises_v2_p2p` to denote whether `P2PConnection` which mimics peer behaviour advertises V2 P2P support. Default option is `False`.\r\n    - In the test framework, you can create Inbound and Outbound connections to `TestNode`\r\n        1. During **Inbound Connections**, `P2PConnection` is the initiator [`TestNode` <--------- `P2PConnection`]\r\n            - Case 1:\r\n                - if the `TestNode` advertises/signals v2 P2P support (means `self.nodes[i]` set up with `\"-v2transport=1\"`), different behaviour will be exhibited based on whether:\r\n                    1. `P2PConnection` supports v2 P2P\r\n                    2. `P2PConnection` does not support v2 P2P\r\n               - In a real world scenario, the initiator node would intrinsically know if they support v2 P2P based on whatever code they choose to run. However, in the test scenario where we mimic peer behaviour, we have no way of knowing if `P2PConnection` should support v2 P2P or not. So `supports_v2_p2p` boolean variable is used as an option to enable support for v2 P2P in `P2PConnection`.\r\n              - Since the `TestNode` advertises v2 P2P support (using \"-v2transport=1\"), our initiator `P2PConnection` would send:\r\n                1. (if the `P2PConnection` supports v2 P2P) ellswift + garbage bytes to initiate the connection\r\n                2. (if the `P2PConnection` does not support v2 P2P) version message to initiate the connection\r\n           - Case 2:\r\n                - if the `TestNode` doesn't signal v2 P2P support; `P2PConnection` being the initiator would send version message to initiate a connection.\r\n       2. During **Outbound Connections** [TestNode --------> P2PConnection]\r\n           - initiator `TestNode` would send:\r\n                - (if the `P2PConnection` advertises v2 P2P) ellswift + garbage bytes to initiate the connection\r\n                - (if the `P2PConnection` advertises v2 P2P) version message to initiate the connection\r\n          - Suppose `P2PConnection` advertises v2 P2P support when it actually doesn't support v2 P2P (false advertisement scenario)\r\n               - `TestNode` sends ellswift + garbage bytes\r\n               - `P2PConnection` receives but can't process it and disconnects.\r\n               - `TestNode` then tries using v1 P2P and sends version message\r\n               - `P2PConnection` receives/processes this successfully and they communicate on v1 P2P\r\n\r\n4. the encrypted P2P messages follow a different format - 3 byte length + 1-13 byte message_type + payload + 16 byte MAC\r\n5. includes support for testing decoy messages and v2 connection downgrade(using false advertisement - when a v2 node makes an outbound connection to a node which doesn't support v2 but is advertised as v2 by some malicious\r\nintermediary)\r\n\r\n### run the tests\r\n* functional test - `test/functional/p2p_v2_encrypted.py` `test/functional/p2p_v2_earlykeyresponse.py`\r\n\r\nI'm also super grateful to @ dhruv for his really valuable feedback on this branch.\r\nAlso written a more elaborate explanation here - https://github.com/stratospher/blogosphere/blob/main/integration_test_bip324.md",
          "user": {
            "login": "stratospher",
            "id": 44024636,
            "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
            "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/stratospher",
            "html_url": "https://github.com/stratospher",
            "followers_url": "https://api.github.com/users/stratospher/followers",
            "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
            "organizations_url": "https://api.github.com/users/stratospher/orgs",
            "repos_url": "https://api.github.com/users/stratospher/repos",
            "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/stratospher/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 19,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/24748",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/24748.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/24748.patch"
          },
          "created_at": "2022-04-03T20:14:51Z",
          "updated_at": "2023-11-30T07:11:26Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T22:12:01Z",
      "updated_at": "2023-01-04T22:12:01Z",
      "source": {
        "issue": {
          "id": 1519092836,
          "node_id": "PR_kwDOABII585Godbn",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26812",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26812/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26812/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26812/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26812",
          "number": 26812,
          "state": "open",
          "state_reason": null,
          "title": "test: add end-to-end tests for CConnman and PeerManager",
          "body": "Add fuzz and unit tests that write (fuzzed) data to a mocked socket and inspect what CConnman/PeerManager have written back to the socket, or check the internal state to verify that the behavior is as expected.\r\n\r\nThis is now possible, after most of https://github.com/bitcoin/bitcoin/pull/21878 has been merged - we don't do any syscalls (e.g. `connect()`, `recv()`) from the high level code and using a mocked socket allows testing the entire networking stack without opening actual network connections.",
          "user": {
            "login": "vasild",
            "id": 266751,
            "node_id": "MDQ6VXNlcjI2Njc1MQ==",
            "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/vasild",
            "html_url": "https://github.com/vasild",
            "followers_url": "https://api.github.com/users/vasild/followers",
            "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
            "organizations_url": "https://api.github.com/users/vasild/orgs",
            "repos_url": "https://api.github.com/users/vasild/repos",
            "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/vasild/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 29,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26812",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26812",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26812.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26812.patch"
          },
          "created_at": "2023-01-04T14:39:37Z",
          "updated_at": "2023-12-02T11:58:50Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1262647120,
      "node_id": "PRR_kwDOABII585LQndQ",
      "url": null,
      "actor": null,
      "commit_id": "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1262647120",
      "submitted_at": "2023-01-19T22:13:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8322901149,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAHwFWSd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8322901149",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-20T16:04:08Z"
    },
    {
      "event": "reviewed",
      "id": 1264557141,
      "node_id": "PRR_kwDOABII585LX5xV",
      "url": null,
      "actor": null,
      "commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewing. Verified that each commit @  80722d838f9a5fdbbbd82f97d353e45b5d375ad8 builds cleanly with unit tests green.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1264557141",
      "submitted_at": "2023-01-21T01:37:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-23T06:02:58Z",
      "updated_at": "2023-01-23T06:02:58Z",
      "source": {
        "issue": {
          "id": 1551607876,
          "node_id": "PR_kwDOABII585IQMXF",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26940",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26940/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26940/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26940/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26940",
          "number": 26940,
          "state": "closed",
          "state_reason": null,
          "title": "test: create random and coins utils, add amount helper, dedupe add_coin",
          "body": "- Move random test utilities from `setup_common` to a new `random` file, as many tests don't use this code.\r\n\r\n- Create a helper to generate semi-random CAmounts up to `MONEY_RANGE` rather than only uint32, and use the helper in the unit tests.\r\n\r\n- De-duplicate a shared `add_coin` method by extracting it to a `coins` test utility.\r\n",
          "user": {
            "login": "jonatack",
            "id": 2415484,
            "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonatack",
            "html_url": "https://github.com/jonatack",
            "followers_url": "https://api.github.com/users/jonatack/followers",
            "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
            "organizations_url": "https://api.github.com/users/jonatack/orgs",
            "repos_url": "https://api.github.com/users/jonatack/repos",
            "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonatack/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 14,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26940",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26940",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26940.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26940.patch"
          },
          "closed_at": "2023-02-17T22:28:27Z",
          "created_at": "2023-01-21T00:07:02Z",
          "updated_at": "2023-04-05T20:58:44Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1266351016,
      "node_id": "PRR_kwDOABII585Levuo",
      "url": null,
      "actor": null,
      "commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code review ACK apart from one comment:",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1266351016",
      "submitted_at": "2023-01-23T22:08:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "reviewed",
      "id": 1268371465,
      "node_id": "PRR_kwDOABII585LmdAJ",
      "url": null,
      "actor": null,
      "commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "WIP review of the first commit 2bbe0f8eeae274fc30, none of my comments below are blockers.\r\n\r\n<details><summary>Some minor testing and poking around</summary><p>\r\n\r\nHave been running this patch on mainnet since January 20 without issues (M1 macOS 13.1/13.2, clang 15) but not yet done the reindex described the OP.\r\n\r\nBench results of `$ ./src/bench/bench_bitcoin -filter='Pool*.*'`\r\n```diff\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               29.85 |       33,505,082.42 |    0.3% |      0.02 | `PoolAllocator_StdUnorderedMap`\r\n|               13.03 |       76,732,499.95 |    0.4% |      0.01 | `PoolAllocator_StdUnorderedMapWithPoolResource`\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               28.63 |       34,927,088.12 |    0.2% |      0.02 | `PoolAllocator_StdUnorderedMap`\r\n|               12.56 |       79,586,875.90 |    0.5% |      0.01 | `PoolAllocator_StdUnorderedMapWithPoolResource`\r\n```\r\n\r\nThese are the values that build on my machine (fuzz test disabled):\r\n\r\n```diff\r\n     static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\r\n     static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\r\n     static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\r\n+    static_assert(ALIGN_BYTES == 8);\r\n+    static_assert(sizeof(ListNode) == 8);\r\n+    static_assert(alignof(ListNode) == 8);\r\n+    static_assert(ELEM_ALIGN_BYTES == 8);\r\n```\r\n\r\n</p></details>\r\n",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1268371465",
      "submitted_at": "2023-01-24T22:08:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "reviewed",
      "id": 1269855171,
      "node_id": "PRR_kwDOABII585LsHPD",
      "url": null,
      "actor": null,
      "commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 80722d838f9a5fdbbbd82f97d353e45b5d375ad8 modulo open comments and questions",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1269855171",
      "submitted_at": "2023-01-25T21:50:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8376394985,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAHzRaTp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8376394985",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-27T19:22:53Z"
    },
    {
      "event": "commented",
      "id": 1407093805,
      "node_id": "IC_kwDOABII585T3owt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407093805",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-27T21:30:38Z",
      "updated_at": "2023-01-27T22:26:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK e7158613dcafd0065a94b03c8013ee4ced8ec3e3 per `git range-diff 4b51290 80722d8 e715861`\r\n",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407093805",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "commented",
      "id": 1407124835,
      "node_id": "IC_kwDOABII585T3wVj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407124835",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-27T22:07:31Z",
      "updated_at": "2023-01-27T22:07:31Z",
      "author_association": "MEMBER",
      "body": "ACK e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407124835",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "commented",
      "id": 1407297445,
      "node_id": "IC_kwDOABII585T4ael",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407297445",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-28T05:24:25Z",
      "updated_at": "2023-01-28T05:24:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for reviewing @jonatack and @sipa! I've addressed all comments with e715861",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407297445",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "mentioned",
      "id": 8378934996,
      "node_id": "MEE_lADOABII585Lh0inzwAAAAHzbGbU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8378934996",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-28T05:24:25Z"
    },
    {
      "event": "subscribed",
      "id": 8378935004,
      "node_id": "SE_lADOABII585Lh0inzwAAAAHzbGbc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8378935004",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-28T05:24:25Z"
    },
    {
      "event": "mentioned",
      "id": 8378935013,
      "node_id": "MEE_lADOABII585Lh0inzwAAAAHzbGbl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8378935013",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-28T05:24:26Z"
    },
    {
      "event": "subscribed",
      "id": 8378935016,
      "node_id": "SE_lADOABII585Lh0inzwAAAAHzbGbo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8378935016",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-28T05:24:26Z"
    },
    {
      "event": "commented",
      "id": 1408930176,
      "node_id": "IC_kwDOABII585T-pGA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1408930176",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T16:21:39Z",
      "updated_at": "2023-01-30T16:21:39Z",
      "author_association": "MEMBER",
      "body": "Needs (fairly trivial) rebase after merge of #17487.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1408930176",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "labeled",
      "id": 8390484275,
      "node_id": "LE_lADOABII585Lh0inzwAAAAH0HKEz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8390484275",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T17:05:04Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8390585195,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAH0Hitr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8390585195",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T17:15:33Z"
    },
    {
      "event": "commented",
      "id": 1409017964,
      "node_id": "IC_kwDOABII585T--hs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409017964",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T17:21:07Z",
      "updated_at": "2023-01-30T17:21:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased to resolve conflicts, diff should be viewable with `git range-diff 82903a7 e715861 f58a5eee6f`",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409017964",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "commented",
      "id": 1409063626,
      "node_id": "IC_kwDOABII585T_JrK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409063626",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T17:53:18Z",
      "updated_at": "2023-01-30T19:00:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "<strike>re-ACK f58a5eee6ff69582d6e46e93dd52e07202d257a8</strike>\r\n\r\nThe unit test CI failures look unrelated -- I didn't reproduce them running `make check` locally (Clang 15 on ARM64). \r\n\r\nEdit: there are now more of the failures and some seem related.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409063626",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "commented",
      "id": 1409090307,
      "node_id": "IC_kwDOABII585T_QMD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409090307",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T18:12:09Z",
      "updated_at": "2023-01-30T18:33:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "Hm it looks like in some environments the new check fails:\r\n```\r\ncoins_tests.cpp(984): error: in \"coins_tests/ccoins_flush_behavior\": check view->DynamicMemoryUsage() < cache_usage has failed\r\n```\r\n\r\nI think the problem is this: The test from @jamesob assumes that memory usage goes down when the cache is flushed. But the pool is internally using chunks of 262144 bytes, and when flushed this memory block will be deallocated but might be allocated again right away when the map is created, so memory usage doesn't necessarily change. E.g. in Windows some control block is immediately allocated for the map, and this makes the pool allocator allocate its first chunk",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409090307",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "mentioned",
      "id": 8391283605,
      "node_id": "MEE_lADOABII585Lh0inzwAAAAH0KNOV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8391283605",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T18:33:46Z"
    },
    {
      "event": "subscribed",
      "id": 8391283626,
      "node_id": "SE_lADOABII585Lh0inzwAAAAH0KNOq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8391283626",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T18:33:46Z"
    },
    {
      "event": "unlabeled",
      "id": 8391634999,
      "node_id": "UNLE_lADOABII585Lh0inzwAAAAH0LjA3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8391634999",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T19:15:39Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1409322773,
      "node_id": "IC_kwDOABII585UAI8V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409322773",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T20:58:30Z",
      "updated_at": "2023-01-30T21:04:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "Fixup LGTM modulo squashing. The remaining CI failures are due to https://cirrus-ci.com/task/5963593934438400 (that seems unrelated?) and to https://github.com/bitcoin/bitcoin/issues/27001 that should be fixed in https://github.com/bitcoin/bitcoin/pull/26998.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409322773",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T21:20:11Z",
      "updated_at": "2023-01-30T21:20:11Z",
      "source": {
        "issue": {
          "id": 1562874006,
          "node_id": "PR_kwDOABII585I1nwv",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26999",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26999/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26999/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26999/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26999",
          "number": 26999,
          "state": "closed",
          "state_reason": null,
          "title": "A few follow-ups to #17487 (coins write without cache drop)",
          "body": "This addresses a few nits left open in #17487.",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 6,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26999",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26999",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26999.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26999.patch"
          },
          "closed_at": "2023-01-30T22:17:06Z",
          "created_at": "2023-01-30T17:34:25Z",
          "updated_at": "2023-01-30T22:17:06Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "labeled",
      "id": 8393540524,
      "node_id": "LE_lADOABII585Lh0inzwAAAAH0S0Os",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8393540524",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-30T23:33:12Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8395807103,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAH0bdl_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8395807103",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-31T06:09:06Z"
    },
    {
      "event": "commented",
      "id": 1409824656,
      "node_id": "IC_kwDOABII585UCDeQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409824656",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-31T06:11:59Z",
      "updated_at": "2023-01-31T06:11:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "Squashed and rebased again due to #26999\r\n\r\nSee the full range-diff after the 2 rebases: `git range-diff ceb74b8 e715861 c25a754b`\r\n\r\nBiggest change was updating the method `TestFlushBehavior` in coins_test.cpp",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409824656",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "unlabeled",
      "id": 8396442915,
      "node_id": "UNLE_lADOABII585Lh0inzwAAAAH0d40j",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8396442915",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-31T07:52:43Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8396580490,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAH0eaaK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8396580490",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-31T08:09:57Z"
    },
    {
      "event": "commented",
      "id": 1411143425,
      "node_id": "IC_kwDOABII585UHFcB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1411143425",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-31T22:16:50Z",
      "updated_at": "2023-01-31T22:16:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK 0007d69f249068a14b9b5a97d46ace9dabdc2c8b",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1411143425",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-02T20:39:54Z",
      "updated_at": "2023-02-02T20:39:54Z",
      "source": {
        "issue": {
          "id": 1565136299,
          "node_id": "PR_kwDOABII585I9P0A",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27011",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27011/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27011/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27011/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27011",
          "number": 27011,
          "state": "closed",
          "state_reason": null,
          "title": "Add simulation-based `CCoinsViewCache` fuzzer",
          "body": "The fuzzer goes through a sequence of operations that get applied to both a real stack of `CCoinsViewCache` objects, and to simulation data, comparing the two at the end.\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27011",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27011.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27011.patch"
          },
          "closed_at": "2023-02-13T14:33:57Z",
          "created_at": "2023-01-31T23:12:21Z",
          "updated_at": "2023-02-18T07:01:44Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1414360875,
      "node_id": "IC_kwDOABII585UTW8r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1414360875",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-02T20:56:06Z",
      "updated_at": "2023-02-02T20:56:06Z",
      "author_association": "MEMBER",
      "body": "FWIW, I rebased this on top of #27011, and am running a few CPU cores on it. No issues so far.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1414360875",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "labeled",
      "id": 8505848501,
      "node_id": "LE_lADOABII585Lh0inzwAAAAH6_PK1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8505848501",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-13T15:34:58Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8512188124,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAH7Xa7c",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8512188124",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-14T07:30:49Z"
    },
    {
      "event": "commented",
      "id": 1429293948,
      "node_id": "IC_kwDOABII585VMUt8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1429293948",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-14T08:04:10Z",
      "updated_at": "2023-02-14T08:04:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased due to #27011. Note that this adds a `/*deterministic=*/true` [here in test/fuzz/coins_view.cpp](https://github.com/bitcoin/bitcoin/pull/25325/commits/78f597be2879c39d9d2b98e21ed0120d2308de20#diff-1ef3b6a1936b50f3d5ec4a1786d9e2d63d1a3e1815b103e67f20601995f355b4R119), see `git range-diff 0007d69...78f597b`",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1429293948",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "unlabeled",
      "id": 8512988580,
      "node_id": "UNLE_lADOABII585Lh0inzwAAAAH7aeWk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8512988580",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-14T09:08:34Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1298020717,
      "node_id": "PRR_kwDOABII585NXjlt",
      "url": null,
      "actor": null,
      "commit_id": "78f597be2879c39d9d2b98e21ed0120d2308de20",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK 78f597be2879c39d9d2b98e21ed0120d2308de20 reviewed `git range-diff 2c1fe27 0007d69 78f597b` and as a sanity check locally ran debug build and unit tests and fuzz build with briefly running the `coins_view` and `coinscache_sim` fuzzers",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1298020717",
      "submitted_at": "2023-02-14T16:58:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "review_requested",
      "id": 8517721942,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAH7sh9W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8517721942",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-14T16:58:24Z",
      "requested_reviewer": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "labeled",
      "id": 8527541445,
      "node_id": "LE_lADOABII585Lh0inzwAAAAH8R_TF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8527541445",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-15T15:49:08Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8528845750,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAH8W9u2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8528845750",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-15T18:04:19Z"
    },
    {
      "event": "commented",
      "id": 1431795348,
      "node_id": "IC_kwDOABII585VV3aU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431795348",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-15T18:07:47Z",
      "updated_at": "2023-02-15T18:07:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "yet another rebase, only dropping the \"Add xoroshiro128++ PRNG\" commit which has already been added in #26153 (commit 5f05b27841af0bed1b6e7de5f46ffe33e5919e4d)",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1431795348",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "unlabeled",
      "id": 8529935887,
      "node_id": "UNLE_lADOABII585Lh0inzwAAAAH8bH4P",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8529935887",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-15T20:09:03Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1433537441,
      "node_id": "IC_kwDOABII585Vcguh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433537441",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T18:34:04Z",
      "updated_at": "2023-02-16T18:34:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK b5eba9ad001f1035dd641bc5880cb6bb53a8b07f",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1433537441",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "labeled",
      "id": 8551781934,
      "node_id": "LE_lADOABII585Lh0inzwAAAAH9udYu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8551781934",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-17T23:35:28Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1435501826,
      "node_id": "IC_kwDOABII585VkAUC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435501826",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-18T06:50:26Z",
      "updated_at": "2023-02-18T07:11:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased adds `#include <test/util/random.h>`",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1435501826",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8552495718,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAH9xLpm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8552495718",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-18T06:50:43Z"
    },
    {
      "event": "unlabeled",
      "id": 8552561567,
      "node_id": "UNLE_lADOABII585Lh0inzwAAAAH9xbuf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8552561567",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-18T07:48:17Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1435700864,
      "node_id": "IC_kwDOABII585Vkw6A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435700864",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-18T15:32:21Z",
      "updated_at": "2023-02-18T15:32:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1435700864",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "reviewed",
      "id": 1313921906,
      "node_id": "PRR_kwDOABII585OUNty",
      "url": null,
      "actor": null,
      "commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d\r\n\r\nTested and code reviewed. Very nice improvement.\r\n\r\nLeft tiny nits in documentation, but please ignore unless updating for other reasons.",
      "user": {
        "login": "john-moffett",
        "id": 116917595,
        "node_id": "U_kgDOBvgFWw",
        "avatar_url": "https://avatars.githubusercontent.com/u/116917595?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/john-moffett",
        "html_url": "https://github.com/john-moffett",
        "followers_url": "https://api.github.com/users/john-moffett/followers",
        "following_url": "https://api.github.com/users/john-moffett/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/john-moffett/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/john-moffett/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/john-moffett/subscriptions",
        "organizations_url": "https://api.github.com/users/john-moffett/orgs",
        "repos_url": "https://api.github.com/users/john-moffett/repos",
        "events_url": "https://api.github.com/users/john-moffett/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/john-moffett/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1313921906",
      "submitted_at": "2023-02-24T17:12:53Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "reviewed",
      "id": 1324475821,
      "node_id": "PRR_kwDOABII585O8eWt",
      "url": null,
      "actor": null,
      "commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I'd like to review more, but don't let me hold you up. I'm hosting [review club on this PR](https://bitcoincore.reviews/25325) on March 8 (next week); anyone here should feel free to join since you know this PR better than I do!",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1324475821",
      "submitted_at": "2023-03-04T08:12:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "commented",
      "id": 1454703666,
      "node_id": "IC_kwDOABII585WtQQy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1454703666",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-04T11:13:37Z",
      "updated_at": "2023-03-04T11:13:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "@LarryRuane awesome that you'll hold a PR review club about this PR! I'll try to join, but can't yet guarantee that I'll have the time.",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1454703666",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "mentioned",
      "id": 8665837860,
      "node_id": "MEE_lADOABII585Lh0inzwAAAAIEhjEk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8665837860",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-04T11:13:37Z"
    },
    {
      "event": "subscribed",
      "id": 8665837863,
      "node_id": "SE_lADOABII585Lh0inzwAAAAIEhjEn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8665837863",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-04T11:13:37Z"
    },
    {
      "event": "reviewed",
      "id": 1329522422,
      "node_id": "PRR_kwDOABII585PPub2",
      "url": null,
      "actor": null,
      "commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Looks good.",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1329522422",
      "submitted_at": "2023-03-08T15:18:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "referenced",
      "id": 8724138804,
      "node_id": "REFE_lADOABII585Lh0inzwAAAAIH_8s0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8724138804",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "c16086fe2cf63d016b2a0aa44820c59ff36f57f6",
      "commit_url": "https://api.github.com/repos/martinus/map_benchmark/commits/c16086fe2cf63d016b2a0aa44820c59ff36f57f6",
      "created_at": "2023-03-11T15:00:17Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T15:00:27Z",
      "updated_at": "2023-03-11T15:00:27Z",
      "source": {
        "issue": {
          "id": 1620041547,
          "node_id": "PR_kwDOCBoVkc5L0lvT",
          "url": "https://api.github.com/repos/martinus/map_benchmark/issues/30",
          "repository_url": "https://api.github.com/repos/martinus/map_benchmark",
          "labels_url": "https://api.github.com/repos/martinus/map_benchmark/issues/30/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/martinus/map_benchmark/issues/30/comments",
          "events_url": "https://api.github.com/repos/martinus/map_benchmark/issues/30/events",
          "html_url": "https://github.com/martinus/map_benchmark/pull/30",
          "number": 30,
          "state": "closed",
          "state_reason": null,
          "title": "Update pool.h with latest version",
          "body": "from https://github.com/bitcoin/bitcoin/pull/25325",
          "user": {
            "login": "martinus",
            "id": 14386,
            "node_id": "MDQ6VXNlcjE0Mzg2",
            "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/martinus",
            "html_url": "https://github.com/martinus",
            "followers_url": "https://api.github.com/users/martinus/followers",
            "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
            "organizations_url": "https://api.github.com/users/martinus/orgs",
            "repos_url": "https://api.github.com/users/martinus/repos",
            "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/martinus/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "OWNER",
          "locked": false,
          "comments": 0,
          "pull_request": {
            "url": "https://api.github.com/repos/martinus/map_benchmark/pulls/30",
            "html_url": "https://github.com/martinus/map_benchmark/pull/30",
            "diff_url": "https://github.com/martinus/map_benchmark/pull/30.diff",
            "patch_url": "https://github.com/martinus/map_benchmark/pull/30.patch"
          },
          "closed_at": "2023-03-11T15:00:36Z",
          "created_at": "2023-03-11T15:00:27Z",
          "updated_at": "2023-03-11T15:00:36Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1349066025,
      "node_id": "PRR_kwDOABII585QaR0p",
      "url": null,
      "actor": null,
      "commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1349066025",
      "submitted_at": "2023-03-20T17:18:26Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "review_requested",
      "id": 8797456451,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIMXohD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8797456451",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-20T17:34:45Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 8797457131,
      "node_id": "RRRE_lADOABII585Lh0inzwAAAAIMXorr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8797457131",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-20T17:34:49Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8797457150,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIMXor-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8797457150",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-20T17:34:49Z",
      "requested_reviewer": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8797459182,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIMXpLu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8797459182",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-20T17:35:01Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1477135406,
      "node_id": "IC_kwDOABII585YC0wu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477135406",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T00:46:06Z",
      "updated_at": "2023-03-21T00:46:06Z",
      "author_association": "MEMBER",
      "body": "Kicked off a bitcoinperf run; will have some results tomorrow.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1477135406",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "review_request_removed",
      "id": 8800435408,
      "node_id": "RRRE_lADOABII585Lh0inzwAAAAIMi_zQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8800435408",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T00:46:09Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1477800508,
      "node_id": "IC_kwDOABII585YFXI8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477800508",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T13:02:45Z",
      "updated_at": "2023-03-21T13:02:45Z",
      "author_association": "MEMBER",
      "body": "Cool! Seeing a **~8% speedup** over a modern region of the chain with **lower memory usage**.\r\n\r\n---\r\n\r\n![ibd local range dbcache=8000 667200 697200](https://user-images.githubusercontent.com/73197/226613375-a9d038f5-f596-4a04-af8e-a63798ab4752.png)\r\n\r\n|                 bench name                 |                                                                                                     command                                                                                                     |\r\n|--------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.dbcache=8000.667200.697200 | `bitcoind -dbcache=8000 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n\r\n### #25325 vs. $mergebase (absolute)\r\n|                         bench name                         |  x  |           #25325           |        $mergebase         |\r\n|------------------------------------------------------------|----:|----------------------------|---------------------------|\r\n| ibd.local.range.dbcache=8000.667200.697200.total_secs      |   3 | 4205.0444 (± 23.6683)      | 4536.8536 (± 7.9194)      |\r\n| ibd.local.range.dbcache=8000.667200.697200.peak_rss_KiB    |   3 | 4428684.0000 (± 3557.8525) | 4806934.6667 (± 108.7791) |\r\n| ibd.local.range.dbcache=8000.667200.697200.cpu_kernel_secs |   3 | 210.8233 (± 1.0422)        | 209.8300 (± 0.9361)       |\r\n| ibd.local.range.dbcache=8000.667200.697200.cpu_user_secs   |   3 | 26000.4633 (± 15.5244)     | 26412.5367 (± 8.9365)     |\r\n\r\n\r\n### #25325 vs. $mergebase (relative)\r\n|                         bench name                         |  x  | #25325 | $mergebase |\r\n|------------------------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.dbcache=8000.667200.697200.total_secs      |   3 |   1.00 |      1.079 |\r\n| ibd.local.range.dbcache=8000.667200.697200.peak_rss_KiB    |   3 |   1.00 |      1.085 |\r\n| ibd.local.range.dbcache=8000.667200.697200.cpu_kernel_secs |   3 |   1.00 |      1.000 |\r\n| ibd.local.range.dbcache=8000.667200.697200.cpu_user_secs   |   3 |   1.00 |      1.016 |\r\n\r\n",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1477800508",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "commented",
      "id": 1477921746,
      "node_id": "IC_kwDOABII585YF0vS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477921746",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T14:18:06Z",
      "updated_at": "2023-03-21T14:18:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the benchmark @jamesob! There was no cache flush in the benchmark, that's why the memory usage was lower. When flushes would happen with e.g. lower dbcache size or longer range of blocks memory usage should be about equal, but then there should be an even larger performance benefit for this PR because it can cache more data with the same memory.",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1477921746",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "mentioned",
      "id": 8806216691,
      "node_id": "MEE_lADOABII585Lh0inzwAAAAIM5DPz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8806216691",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T14:18:06Z"
    },
    {
      "event": "subscribed",
      "id": 8806216724,
      "node_id": "SE_lADOABII585Lh0inzwAAAAIM5DQU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8806216724",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T14:18:07Z"
    },
    {
      "event": "commented",
      "id": 1477939852,
      "node_id": "IC_kwDOABII585YF5KM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477939852",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T14:28:01Z",
      "updated_at": "2023-03-21T14:28:01Z",
      "author_association": "MEMBER",
      "body": "> When flushes would happen with e.g. lower dbcache size or longer range of blocks memory usage should be about equal, but then there should be an even larger performance benefit for this PR because it can cache more data with the same memory.\r\n\r\nYup - I started another run with dbcache=1000.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1477939852",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "commented",
      "id": 1478663359,
      "node_id": "IC_kwDOABII585YIpy_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1478663359",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T22:16:19Z",
      "updated_at": "2023-03-21T22:16:19Z",
      "author_association": "MEMBER",
      "body": "Light ACK d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d\r\n\r\nNot particularly well versed in allocators, but the logic of the allocator and its tests makes sense, and the benchmarks seem to show there is a noticeable improvement.\r\n\r\nOne thing I did notice though is that when configured with `--enable-debug`, the benchmark `PoolAllocator_StdUnorderedMapWithPoolResource` is a little bit slower than `PoolAllocator_StdUnorderedMap`. Without `--enable-debug`, it's quite a bit faster. I didn't measure the effect of this in actual IBD, but configuring with `--enable-debug` is already known to make things slower, so it shouldn't matter much.\r\n\r\nWith `--enable-debug`:\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |         bra/op |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|---------------:|--------:|----------:|:----------\r\n|              239.73 |        4,171,384.12 |    0.1% |        2,516.56 |         401.94 |    0.1% |      0.14 | `PoolAllocator_StdUnorderedMap`\r\n|              277.15 |        3,608,128.61 |    0.1% |        2,792.06 |         432.32 |    0.1% |      0.17 | `PoolAllocator_StdUnorderedMapWithPoolResource`\r\n\r\nWithout `--enable-debug`:\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |         bra/op |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|---------------:|--------:|----------:|:----------\r\n|               21.53 |       46,436,178.12 |    0.3% |          279.84 |          59.34 |    0.4% |      0.01 | `PoolAllocator_StdUnorderedMap`\r\n|               10.45 |       95,674,714.97 |    0.2% |           82.34 |          13.71 |    0.8% |      0.01 | `PoolAllocator_StdUnorderedMapWithPoolResource`",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1478663359",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "commented",
      "id": 1478764099,
      "node_id": "IC_kwDOABII585YJCZD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1478764099",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-22T00:34:05Z",
      "updated_at": "2023-03-22T00:34:05Z",
      "author_association": "MEMBER",
      "body": "Back with results for dbcache=1000; less noticeable speedup (5%) and increased memory usage (11%).\r\n\r\n---\r\n\r\n![ibd local range dbcache=1000 667200 697200](https://user-images.githubusercontent.com/73197/226771758-dc8f9974-8304-472e-a9fb-15c2e493d5f2.png)\r\n\r\n|                 bench name                 |                                                                                                     command                                                                                                     |\r\n|--------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.dbcache=1000.667200.697200 | `bitcoind -dbcache=1000 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n\r\n### #25325 vs. $mergebase (absolute)\r\n|                         bench name                         |  x  |           #25325            |         $mergebase         |\r\n|------------------------------------------------------------|----:|-----------------------------|----------------------------|\r\n| ibd.local.range.dbcache=1000.667200.697200.total_secs      |   3 | 4721.4819 (± 11.2932)       | 4990.6752 (± 19.7466)      |\r\n| ibd.local.range.dbcache=1000.667200.697200.peak_rss_KiB    |   3 | 2906596.0000 (± 86412.3208) | 2607876.0000 (± 4288.9414) |\r\n| ibd.local.range.dbcache=1000.667200.697200.cpu_kernel_secs |   3 | 499.0333 (± 4.3527)         | 581.9333 (± 4.1179)        |\r\n| ibd.local.range.dbcache=1000.667200.697200.cpu_user_secs   |   3 | 26882.3333 (± 17.6349)      | 27490.5000 (± 12.0885)     |\r\n\r\n\r\n### #25325 vs. $mergebase (relative)\r\n|                         bench name                         |  x  | #25325 | $mergebase |\r\n|------------------------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.dbcache=1000.667200.697200.total_secs      |   3 |   1.00 |      1.057 |\r\n| ibd.local.range.dbcache=1000.667200.697200.peak_rss_KiB    |   3 |   1.11 |      1.000 |\r\n| ibd.local.range.dbcache=1000.667200.697200.cpu_kernel_secs |   3 |   1.00 |      1.166 |\r\n| ibd.local.range.dbcache=1000.667200.697200.cpu_user_secs   |   3 |   1.00 |      1.023 |\r\n\r\n",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1478764099",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "reviewed",
      "id": 1351433045,
      "node_id": "PRR_kwDOABII585QjTtV",
      "url": null,
      "actor": null,
      "commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "All comments are non-blocking, except I am concerned about zero-length allocations.\r\n\r\nI stepped through `pool_tests.cpp` in the debugger and all was as expected. I didn't run or review the fuzz test or the other modified unit tests, but I'll try to get to those in the next couple of days.",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1351433045",
      "submitted_at": "2023-03-22T01:42:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "commented",
      "id": 1479679004,
      "node_id": "IC_kwDOABII585YMhwc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1479679004",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-22T14:33:52Z",
      "updated_at": "2023-03-22T14:33:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1479679004",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "commented",
      "id": 1479975523,
      "node_id": "IC_kwDOABII585YNqJj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1479975523",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-22T17:23:55Z",
      "updated_at": "2023-03-22T17:23:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "@jamesob interesting that it didn't see a bigger speedup, but I guess it depends on a lot of other factors as well. How fast is your harddisk, and how much RAM does your computer have?",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1479975523",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "mentioned",
      "id": 8819480396,
      "node_id": "MEE_lADOABII585Lh0inzwAAAAINrpdM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8819480396",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-22T17:23:56Z"
    },
    {
      "event": "subscribed",
      "id": 8819480426,
      "node_id": "SE_lADOABII585Lh0inzwAAAAINrpdq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8819480426",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-22T17:23:56Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI4NDAxYzMyODE5NzhiZWVkNjE5OGIyZjk3ODJiNmE4ZGQzNWNiZDc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8401c3281978beed6198b2f9782b6a8dd35cbd7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b8401c3281978beed6198b2f9782b6a8dd35cbd7",
      "tree": {
        "sha": "fb740536de54eb5bc056b52da7430c9137b0edd2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb740536de54eb5bc056b52da7430c9137b0edd2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/23056436461a8b3af1a504b9638c48e8c8170652",
          "sha": "23056436461a8b3af1a504b9638c48e8c8170652",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/23056436461a8b3af1a504b9638c48e8c8170652"
        }
      ],
      "message": "Add pool based memory resource & allocator\n\nA memory resource similar to std::pmr::unsynchronized_pool_resource, but\noptimized for node-based containers.\n\nCo-Authored-By: Pieter Wuille <pieter@wuille.net>",
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2023-03-23T18:38:38Z"
      },
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2022-06-11T07:23:51Z"
      },
      "sha": "b8401c3281978beed6198b2f9782b6a8dd35cbd7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGUxOTk0M2YwNDllZDhhYTRmMzJhMWQ4NDQwYTlmYmYxNjAzNjdmMGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e19943f049ed8aa4f32a1d8440a9fbf160367f0f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e19943f049ed8aa4f32a1d8440a9fbf160367f0f",
      "tree": {
        "sha": "ad5c684a7b0188649c620754635db9a630a25c41",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad5c684a7b0188649c620754635db9a630a25c41"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8401c3281978beed6198b2f9782b6a8dd35cbd7",
          "sha": "b8401c3281978beed6198b2f9782b6a8dd35cbd7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b8401c3281978beed6198b2f9782b6a8dd35cbd7"
        }
      ],
      "message": "Calculate memory usage correctly for unordered_maps that use PoolAllocator\n\nExtracts the resource from a PoolAllocator and uses it for\ncalculation of the node's memory usage.",
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2023-03-23T18:38:38Z"
      },
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2022-06-11T07:28:13Z"
      },
      "sha": "e19943f049ed8aa4f32a1d8440a9fbf160367f0f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDFhZmNhNmI2NjNiYjU0MDIyYWZmZjE5M2ZkOWQ4Mzg1NjYwNmIxODk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1afca6b663bb54022afff193fd9d83856606b189",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1afca6b663bb54022afff193fd9d83856606b189",
      "tree": {
        "sha": "f38acbcf3e224a0d6c5625d723449c62c6ffe65c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f38acbcf3e224a0d6c5625d723449c62c6ffe65c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e19943f049ed8aa4f32a1d8440a9fbf160367f0f",
          "sha": "e19943f049ed8aa4f32a1d8440a9fbf160367f0f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e19943f049ed8aa4f32a1d8440a9fbf160367f0f"
        }
      ],
      "message": "Add PoolResource fuzzer\n\nFuzzes PoolResource with random allocations/deallocations, and multiple\nasserts.\n\nCo-Authored-By: Pieter Wuille <pieter@wuille.net>",
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2023-03-23T18:38:38Z"
      },
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2022-06-11T08:48:35Z"
      },
      "sha": "1afca6b663bb54022afff193fd9d83856606b189"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDVlNGFjNWFiZjU0ZjhlNmQ2MzMwZGYwYzczMTE5YWEwY2NhNGMxMDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e4ac5abf54f8e6d6330df0c73119aa0cca4c103",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5e4ac5abf54f8e6d6330df0c73119aa0cca4c103",
      "tree": {
        "sha": "5a5310f5fdf6302a89ee35127e6cf4c9b02b1b8a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5a5310f5fdf6302a89ee35127e6cf4c9b02b1b8a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1afca6b663bb54022afff193fd9d83856606b189",
          "sha": "1afca6b663bb54022afff193fd9d83856606b189",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1afca6b663bb54022afff193fd9d83856606b189"
        }
      ],
      "message": "Call ReallocateCache() on each Flush()\n\nThis frees up all associated memory with the map, not only the nodes.\nThis is necessary in preparation for using the PoolAllocator for\nCCoinsMap, which does not actually free any memory on clear().",
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2023-03-23T18:38:38Z"
      },
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2022-06-11T09:00:53Z"
      },
      "sha": "5e4ac5abf54f8e6d6330df0c73119aa0cca4c103"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDlmOTQ3ZmMzZDRiNzc5ZjAxNzMzMjEzNTMyM2IzNGU4ZjIxNmY2MTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f947fc3d4b779f017332135323b34e8f216f613",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9f947fc3d4b779f017332135323b34e8f216f613",
      "tree": {
        "sha": "49244aeb19a2d6cf2f76eb75bf384bd6c6b31b96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/49244aeb19a2d6cf2f76eb75bf384bd6c6b31b96"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e4ac5abf54f8e6d6330df0c73119aa0cca4c103",
          "sha": "5e4ac5abf54f8e6d6330df0c73119aa0cca4c103",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5e4ac5abf54f8e6d6330df0c73119aa0cca4c103"
        }
      ],
      "message": "Use PoolAllocator for CCoinsMap\n\nIn my benchmarks, using this pool allocator for CCoinsMap gives about\n20% faster `-reindex-chainstate` with -dbcache=5000 with practically the\nsame memory usage. The change in max RSS changed was 0.3%.\n\nThe `validation_flush_tests` tests need to be updated because\nmemory allocation is now done in large pools instead of one node at a\ntime, so the limits need to be updated accordingly.",
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2023-03-23T18:38:38Z"
      },
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2022-06-11T09:27:38Z"
      },
      "sha": "9f947fc3d4b779f017332135323b34e8f216f613"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8831530560,
      "node_id": "HRFPE_lADOABII585Lh0inzwAAAAIOZnZA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8831530560",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-23T19:26:08Z"
    },
    {
      "event": "commented",
      "id": 1481782854,
      "node_id": "IC_kwDOABII585YUjZG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1481782854",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-23T19:34:26Z",
      "updated_at": "2023-03-24T05:46:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated  d87cb99 -> 9f947fc3d4b779f017332135323b34e8f216f613 ([pr25325.1](https://github.com/martinus/bitcoin/commits/pr25325.1) -> [pr25325.2](https://github.com/martinus/bitcoin/commits/pr25325.2))\r\n\r\nThere is a single behavior change in pool.h, now `NumElemAlignBytes` adds `+ (bytes == 0)` so that allocations of 0 bytes work with the PoolAllocator.\r\n\r\nOther than that, updated tests to include allocation of 0 bytes, and fixed all the nits.\r\n\r\nI tried to to benchmark to see any diffference with the new `+ (bytes == 0)` check or with the `bytes > 0 ?` variant, and all behave exactly the same in the `PoolAllocator_StdUnorderedMapWithPoolResource` benchmark. Exactly the same number of instructions, same number of branches, and the time fluctuates only due to measurement precision:\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |         bra/op |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------\r\n|               40.69 |       24,575,107.54 |    0.1% |          151.20 |          129.46 |  1.168 |          23.54 |    2.1% |      1.10 | old d87cb99bb3\r\n|               40.70 |       24,568,640.94 |    0.2% |          151.20 |          129.48 |  1.168 |          23.54 |    2.0% |      1.10 | `bytes > 0 ?`\r\n|               40.47 |       24,707,366.33 |    0.7% |          151.20 |          128.74 |  1.174 |          23.54 |    2.1% |      1.10 | new  9f947fc3d4: `+ (bytes == 0)`\r\n",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1481782854",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "reviewed",
      "id": 1356988307,
      "node_id": "PRR_kwDOABII585Q4f-T",
      "url": null,
      "actor": null,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 9f947fc3d4b779f017332135323b34e8f216f613\r\n\r\nVerified the changes with `range-diff`:\r\n\r\n```diff\r\n1:  45508ec79 ! 1:  b8401c328 Add pool based memory resource & allocator\r\n    @@ src/support/allocators/pool.h (new)\r\n-     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\r\n+     * whenever it is accessed, but `m_available_memory_end` caches this for clarity and efficiency.\r\n    @@ src/support/allocators/pool.h (new)\r\n-     * into m_free_lists.\r\n+     * into m_free_lists. Round up for the special case when bytes==0.\r\n    @@ src/support/allocators/pool.h (new)\r\n-        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\r\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES + (bytes == 0);\r\n    @@ src/support/allocators/pool.h (new)\r\n-        // if there is still any available memory is left, put it into the freelist.\r\n+        // if there is still any available memory left, put it into the freelist.\r\n    @@ src/test/pool_tests.cpp (new)\r\n-    block = resource.Allocate(8, 1);\r\n+    void* b = resource.Allocate(8, 1);\r\n+    BOOST_TEST(b == block); // we got the same block of memory as before\r\n    @@ src/test/pool_tests.cpp (new)\r\n-    // can't use chunk because alignment is too big\r\n-    block = resource.Allocate(8, 16);\r\n+    // can't use resource because alignment is too big, allocate system memory\r\n+    b = resource.Allocate(8, 16);\r\n+    BOOST_TEST(b != block);\r\n+    block = b;\r\n    @@ src/test/pool_tests.cpp (new)\r\n+\r\n+    // it's possible that 0 bytes are allocated, make sure this works. In that case the call is forwarded to operator new\r\n+    // 0 bytes takes one entry from the first freelist\r\n+    void* p = resource.Allocate(0, 1);\r\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\r\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\r\n+\r\n+    resource.Deallocate(p, 0, 1);\r\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\r\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\r\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\r\n    @@ src/test/pool_tests.cpp (new)\r\n-    auto counts = PoolResourceTester::FreeListSizes(resource);\r\n    @@ src/test/pool_tests.cpp (new)\r\n-    for (uint8_t num_bytes = 1; num_bytes < num_allocs; +num_bytes) {\r\n+    for (uint8_t num_bytes = 0; num_bytes < num_allocs; +num_bytes) {\r\n    @@ src/test/pool_tests.cpp (new)\r\n-        // set each byte to i\r\n+        // set each byte to num_bytes\r\n    @@ src/test/pool_tests.cpp (new)\r\n-    uint8_t val = 1;\r\n+    uint8_t val = 0;\r\n    @@ src/test/pool_tests.cpp (new)\r\n-            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128\r\n-            std::size_t size = (InsecureRandRange(2000) / alignment + 1) * alignment; // multiple of alignment\r\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(8);          // 1, 2, ..., 128\r\n+            std::size_t size = (InsecureRandRange(200) / alignment + 1) * alignment; // multiple of alignment\r\n    @@ src/test/util/poolresourcetester.h (new)\r\n-        for (std::byte* ptr : resource.m_allocated_chunks) {\r\n+        for (const std::byte* ptr : resource.m_allocated_chunks) {\r\n    @@ src/test/util/poolresourcetester.h (new)\r\n-            assert(free_block.size <= chunk_size_remaining);                 // ensure we no overflow\r\n+            assert(free_block.size <= chunk_size_remaining);                 // ensure no overflow\r\n    @@ src/test/util/poolresourcetester.h (new)\r\n-        assert(chunk_ptr_remaining == chunks.back().ptr + chunks.back().size); // ensure we are t the end of the chunks\r\n+        // ensure we are at the end of the chunks\r\n+        assert(chunk_ptr_remaining == chunk_it->ptr + chunk_it->size);\r\n+    +chunk_it;\r\n+        assert(chunk_it == chunks.end());\r\n2:  ed2e1cbe8 = 2:  e19943f04 Calculate memory usage correctly for unordered_maps that use PoolAllocator\r\n3:  477e16dbf = 3:  1afca6b66 Add PoolResource fuzzer\r\n4:  d6b85474d = 4:  5e4ac5abf Call ReallocateCache() on each Flush()\r\n5:  d87cb99bb ! 5:  9f947fc3d Use PoolAllocator for CCoinsMap\r\n    @@ src/coins.h: struct CCoinsCacheEntry\r\n+/**\r\n+ * PoolAllocator's MAX_BLOCK_SIZE_BYTES parameter here uses sizeof the data, and adds the size\r\n+ * of 4 pointers. We do not know the exact node size used in the std::unordered_node implementation\r\n+ * because it is implementation defined. Most implementations have an overhead of 1 or 2 pointers,\r\n+ * so nodes can be connected in a linked list, and in some cases the hash value is stored as well.\r\n+ * Using an additional sizeof(void*)*4 for MAX_BLOCK_SIZE_BYTES should thus be sufficient so that\r\n+ * all implementations can allocate the nodes from the PoolAllocator.\r\n+ */\r\n\r\n```",
      "user": {
        "login": "john-moffett",
        "id": 116917595,
        "node_id": "U_kgDOBvgFWw",
        "avatar_url": "https://avatars.githubusercontent.com/u/116917595?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/john-moffett",
        "html_url": "https://github.com/john-moffett",
        "followers_url": "https://api.github.com/users/john-moffett/followers",
        "following_url": "https://api.github.com/users/john-moffett/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/john-moffett/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/john-moffett/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/john-moffett/subscriptions",
        "organizations_url": "https://api.github.com/users/john-moffett/orgs",
        "repos_url": "https://api.github.com/users/john-moffett/repos",
        "events_url": "https://api.github.com/users/john-moffett/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/john-moffett/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1356988307",
      "submitted_at": "2023-03-24T15:48:45Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "review_requested",
      "id": 8840310148,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIO7G2E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8840310148",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T15:48:52Z",
      "requested_reviewer": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8840310160,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIO7G2Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8840310160",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T15:48:52Z",
      "requested_reviewer": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8840310208,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIO7G3A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8840310208",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T15:48:52Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8840310232,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIO7G3Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8840310232",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T15:48:52Z",
      "requested_reviewer": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 8841019827,
      "node_id": "RRRE_lADOABII585Lh0inzwAAAAIO90Gz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8841019827",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T17:03:52Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8841019984,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIO90JQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8841019984",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T17:03:53Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 8841024633,
      "node_id": "RRRE_lADOABII585Lh0inzwAAAAIO91R5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8841024633",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T17:04:23Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8841024819,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIO91Uz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8841024819",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T17:04:24Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1357119390,
      "node_id": "PRR_kwDOABII585Q4_-e",
      "url": null,
      "actor": null,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Nice review work, @LarryRuane.\r\n\r\nre-ACK 9f947fc3d4b779f017332135323b34e8f216f613",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1357119390",
      "submitted_at": "2023-03-24T17:05:00Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
    },
    {
      "event": "review_request_removed",
      "id": 8841031336,
      "node_id": "RRRE_lADOABII585Lh0inzwAAAAIO926o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8841031336",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T17:05:07Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8841031499,
      "node_id": "RRE_lADOABII585Lh0inzwAAAAIO929L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8841031499",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T17:05:08Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1483180518,
      "node_id": "IC_kwDOABII585YZ4nm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1483180518",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T17:40:22Z",
      "updated_at": "2023-03-24T17:40:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 9f947fc3d4b779f017332135323b34e8f216f613",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1483180518",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "review_request_removed",
      "id": 8841329326,
      "node_id": "RRRE_lADOABII585Lh0inzwAAAAIO-_qu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8841329326",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-24T17:40:28Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1486343844,
      "node_id": "IC_kwDOABII585Yl86k",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1486343844",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-28T07:21:26Z",
      "updated_at": "2023-03-28T07:21:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "@sipa could you have another look after my update from d87cb99 -> 9f947fc3d4b779f017332135323b34e8f216f613?",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1486343844",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "mentioned",
      "id": 8861639518,
      "node_id": "MEE_lADOABII585Lh0inzwAAAAIQMeNe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8861639518",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-28T07:21:26Z"
    },
    {
      "event": "subscribed",
      "id": 8861639534,
      "node_id": "SE_lADOABII585Lh0inzwAAAAIQMeNu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8861639534",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-28T07:21:26Z"
    },
    {
      "event": "referenced",
      "id": 8928092322,
      "node_id": "REFE_lADOABII585Lh0inzwAAAAIUJ-Ci",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8928092322",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "319adf5b4d8d43855c130b54e8a030b2cdd4129c",
      "commit_url": "https://api.github.com/repos/martinus/map_benchmark/commits/319adf5b4d8d43855c130b54e8a030b2cdd4129c",
      "created_at": "2023-04-04T19:32:33Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T21:14:01Z",
      "updated_at": "2023-04-05T21:14:01Z",
      "source": {
        "issue": {
          "id": 1656304703,
          "node_id": "I_kwDOCoXYYs5iuTQ_",
          "url": "https://api.github.com/repos/LarryRuane/bitcoin/issues/7",
          "repository_url": "https://api.github.com/repos/LarryRuane/bitcoin",
          "labels_url": "https://api.github.com/repos/LarryRuane/bitcoin/issues/7/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/LarryRuane/bitcoin/issues/7/comments",
          "events_url": "https://api.github.com/repos/LarryRuane/bitcoin/issues/7/events",
          "html_url": "https://github.com/LarryRuane/bitcoin/issues/7",
          "number": 7,
          "state": "open",
          "state_reason": null,
          "title": "speed up IBD by not storing unspent coins in UTXO memory cache",
          "body": "## Background\r\n\r\nThe UTXO, aka chainstate, database is stored on disk and partially in a memory cache whose size is determined by [`-dbcache`](https://github.com/bitcoin/bitcoin/blob/master/doc/reduce-memory.md#in-memory-caches)`). The size of this cache significantly affects IBD time. As we validate each block, we loop through its transactions, and verify that each input spends an existing UTXO. Even if we're not checking signatures (AssumeValid), we verify that the input refers to an _unspent_ output (to prevent double-spends). It's much faster if the UTXO is in the memory cache. We also add each transaction output to our memory UTXO cache so a subsequent transaction can refer to it. This memory cache is implemented as an unordered map whose key is an outpoint (txid and output index) and whose data is the scriptPubKey (what's needed to validate the input that wants to spend this output). When this cache becomes full, we flush it to disk; you can see those flushing cliffs in [graphs](https://github.com/bitcoin/bitcoin/pull/25325#issue-1267157159).\r\n\r\nWe don't flush a \"dirty\" in-memory UTXO entry to disk right away, because another near-term tx may spend this UTXO -- even within the same block. In that case, we never write this UTXO to disk! That's a nice savings. I think this explains the downward arcs of those graphs before each flush. UTXOs are continuously added to the cache at about the same rate, but as the cache becomes populated, it's more likely that inputs spend UTXOs that are in the memory cache, which allows those UTXOs to be dropped (and never written to disk). So the net rate of addition to the cache slows down. If the cache is large enough to hold the entire UTXO set, then the cache size would gradually level off. But it's unusual for node runners to configure the cache to be this large.\r\n\r\nAs an aside, it seems like an improvement would be to retain these items in the memory cache after we flush them to disk, instead of clearing the memory cache. There may be a reason I'm not aware of that this can't be done (or done easily).\r\n\r\n## The problem\r\n\r\nThere are many coins, such as Satoshi's early coins, that to this day have not been spent. They will eventually get flushed to disk -- but they hold onto memory until that happens. This means there is less memory available for other UTXOs that _will_ be spent before being flushed. The time Satoshi's coins are sitting in memory isn't a very efficient use of that memory.\r\n\r\nOne interesting property of IBD is that we know the (likely) future. Every node will go through the same sequence of coin creation and spending (in the database) until reaching the tip.\r\n\r\n## A solution\r\n\r\nSo the idea is, we have a static, hard-coded bloom filter (in the source code) that's probably updated for each major release (similar to the AssumeValid block hash). This bloom filter will contain outpoints referring to UTXOs that remain unspent (at least up to the time the filter is constructed), such as Satoshi's coins. When we add an entry to the memory cache, if the outpoint is (probably) in the bloom filter, then we want to flush it to disk -- and _free its cache entry in memory_ -- soon. The flushing seems to be done in batches, so we may need to bundle up a bunch of these and flush them at the same time. (I haven't figured out how to do this yet.) This will free up cache space, making it more likely that an input we're validating refers to a UTXO that is in the memory cache (and thus doesn't need to be read from disk). It makes the cache more effective -- storing items that are more likely to be needed. It would have the same effect as having a larger cache.\r\n\r\nA bloom filter can have false-positives, so we may flush some cache entries that do get spent, and that may make it worse when those get spent than currently. But if we size the filter correctly, this should be rare. We could instead invert the sense of the filter so it contains entries that _will be spent_ (and flush entries that are _not_ in the filter). This way, the false positives would cause us to keep entries in the cache that would be better to flush. But that's no different from today. I'm not sure which way around the filter should be implemented, but for now, let's assume it contains _unspent_ UTXOs.\r\n\r\nA refinement to this idea would be to add UTXOs to the bloom filter that are long-lived, not spent \"soon\" for some definition of soon. Unfortunately, this definition would ideally depend on the node's `-dbcache` setting, which we can't predict when we're creating the static bloom filter. We could have a few filters and use the appropriate one based on cache size, but that may be getting too complicated. If we choose \"soon\" based on the default cache size, that may be close enough. Also, we could not activate this optimization (do these \"early\" flushes) at all until the cache becomes something like 90% full. That way if a node is configured with a very large cache, this change wouldn't make performance worse.\r\n\r\nAnother refinement (thanks to @theStack) would be to inspect the scriptPubKey to see if the output is likely or actually unspendable (for example, dust or public keys not on the curve, or time locks).\r\n\r\nNote that this idea doesn't increase trust in the devs; it's just a performance improvement in the most likely case.\r\n",
          "user": {
            "login": "LarryRuane",
            "id": 8321330,
            "node_id": "MDQ6VXNlcjgzMjEzMzA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/LarryRuane",
            "html_url": "https://github.com/LarryRuane",
            "followers_url": "https://api.github.com/users/LarryRuane/followers",
            "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
            "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
            "repos_url": "https://api.github.com/users/LarryRuane/repos",
            "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "OWNER",
          "locked": false,
          "comments": 4,
          "created_at": "2023-04-05T21:14:01Z",
          "updated_at": "2023-04-21T17:05:19Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1516886734,
      "node_id": "IC_kwDOABII585aadrO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1516886734",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-20T20:11:08Z",
      "updated_at": "2023-04-20T20:11:08Z",
      "author_association": "MEMBER",
      "body": "re-ACK 9f947fc3d4b779f017332135323b34e8f216f613",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1516886734",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "review_request_removed",
      "id": 9061160787,
      "node_id": "RRRE_lADOABII585Lh0inzwAAAAIcFldT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9061160787",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-20T20:11:14Z",
      "requested_reviewer": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "merged",
      "id": 9061235384,
      "node_id": "ME_lADOABII585Lh0inzwAAAAIcF3q4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9061235384",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5aa0c82ccd6ceb4a141686fc8658f679de75a787",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5aa0c82ccd6ceb4a141686fc8658f679de75a787",
      "created_at": "2023-04-20T20:20:32Z"
    },
    {
      "event": "closed",
      "id": 9061235468,
      "node_id": "CE_lADOABII585Lh0inzwAAAAIcF3sM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9061235468",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-20T20:20:33Z"
    },
    {
      "event": "commented",
      "id": 1516910306,
      "node_id": "IC_kwDOABII585aajbi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1516910306",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-20T20:32:53Z",
      "updated_at": "2023-04-20T20:32:53Z",
      "author_association": "MEMBER",
      "body": "Posthumous utACK 9f947fc3d4b779f017332135323b34e8f216f613",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1516910306",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "commented",
      "id": 1517233030,
      "node_id": "IC_kwDOABII585abyOG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1517233030",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-21T04:12:56Z",
      "updated_at": "2023-04-21T04:12:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "Wohoo :tada: Thanks everyone for making this happen!",
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1517233030",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25325"
    },
    {
      "event": "referenced",
      "id": 9070256673,
      "node_id": "REFE_lADOABII585Lh0inzwAAAAIcoSIh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9070256673",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "634c900ebdb87b272abbe8ed3085f0a04fe47e6b",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/634c900ebdb87b272abbe8ed3085f0a04fe47e6b",
      "created_at": "2023-04-21T18:56:20Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "benthecarman",
        "id": 15256660,
        "node_id": "MDQ6VXNlcjE1MjU2NjYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/15256660?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benthecarman",
        "html_url": "https://github.com/benthecarman",
        "followers_url": "https://api.github.com/users/benthecarman/followers",
        "following_url": "https://api.github.com/users/benthecarman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benthecarman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benthecarman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benthecarman/subscriptions",
        "organizations_url": "https://api.github.com/users/benthecarman/orgs",
        "repos_url": "https://api.github.com/users/benthecarman/repos",
        "events_url": "https://api.github.com/users/benthecarman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benthecarman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-03T13:35:31Z",
      "updated_at": "2023-05-03T13:35:31Z",
      "source": {
        "issue": {
          "id": 1681693734,
          "node_id": "I_kwDOExOzMs5kPJwm",
          "url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com/issues/19",
          "repository_url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com",
          "labels_url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com/issues/19/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com/issues/19/comments",
          "events_url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com/issues/19/events",
          "html_url": "https://github.com/austinbitdevs/austinbitdevs.com/issues/19",
          "number": 19,
          "state": "closed",
          "state_reason": "completed",
          "title": "May topics",
          "body": null,
          "user": {
            "login": "justinmoon",
            "id": 4335621,
            "node_id": "MDQ6VXNlcjQzMzU2MjE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/4335621?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/justinmoon",
            "html_url": "https://github.com/justinmoon",
            "followers_url": "https://api.github.com/users/justinmoon/followers",
            "following_url": "https://api.github.com/users/justinmoon/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/justinmoon/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/justinmoon/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/justinmoon/subscriptions",
            "organizations_url": "https://api.github.com/users/justinmoon/orgs",
            "repos_url": "https://api.github.com/users/justinmoon/repos",
            "events_url": "https://api.github.com/users/justinmoon/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/justinmoon/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "COLLABORATOR",
          "locked": false,
          "comments": 11,
          "closed_at": "2023-05-19T23:55:42Z",
          "created_at": "2023-04-24T17:03:26Z",
          "updated_at": "2023-05-19T23:55:42Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-13T13:57:41Z",
      "updated_at": "2023-05-13T13:57:41Z",
      "source": {
        "issue": {
          "id": 1707810171,
          "node_id": "PR_kwDOABII585QZcbO",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27642",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27642/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27642/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27642/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27642",
          "number": 27642,
          "state": "closed",
          "state_reason": null,
          "title": "init: add MALLOC_ARENA_MAX=1 to systemd",
          "body": "This adds the MALLOC_ARENA_MAX=1 environment variable as suggested in https://github.com/bitcoin/bitcoin/blob/master/doc/reduce-memory.md#linux-specific to the systemd service file definition.\r\n\r\nWithout this env var, memory usage can grow significantly especially when rpcthreads is increased above its default value.\r\n\r\nCloses https://github.com/bitcoin/bitcoin/issues/24542.\r\n\r\nI have tested this change myself with positive results after dealing with memory consumption issues for a long time using systemd on a 8GB RAM raspi4. I figure a similar change may be desirable for the OpenRC and CentOS init files, but I don't have a way to test them and I'm not even exactly sure how environment variables should be added there (via export statements?).",
          "user": {
            "login": "sangaman",
            "id": 3440835,
            "node_id": "MDQ6VXNlcjM0NDA4MzU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3440835?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sangaman",
            "html_url": "https://github.com/sangaman",
            "followers_url": "https://api.github.com/users/sangaman/followers",
            "following_url": "https://api.github.com/users/sangaman/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sangaman/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sangaman/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sangaman/subscriptions",
            "organizations_url": "https://api.github.com/users/sangaman/orgs",
            "repos_url": "https://api.github.com/users/sangaman/repos",
            "events_url": "https://api.github.com/users/sangaman/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sangaman/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 15,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27642",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27642",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27642.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27642.patch"
          },
          "closed_at": "2023-09-20T17:39:12Z",
          "created_at": "2023-05-12T15:15:26Z",
          "updated_at": "2023-09-20T17:39:13Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-25T03:32:07Z",
      "updated_at": "2023-05-25T03:32:07Z",
      "source": {
        "issue": {
          "id": 1725022323,
          "node_id": "PR_kwDOABII585RTX9A",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27748",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27748/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27748/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27748/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27748",
          "number": 27748,
          "state": "closed",
          "state_reason": null,
          "title": "util: generalize accounting of system-allocated memory in pool resource",
          "body": "Follow-on to PR #25325, \"Add pool based memory resource\"\r\n\r\nThe `DynamicUsage()` function for the version of `unordered_map` that uses the `PoolAllocator` returns a close approximation of the amount of physical memory used by the map. (This is the map used for the dbcache.) It accounts for several of the allocator's internal data structures, such as the memory chunks and the freelist. It also includes the `unordered_map`'s bucket array (vector), which is a bit out of place because the rest of the pool allocator doesn't know or make any assumption about the type of container that the pool allocator is being used for, namely, currently only `std::unordered_map`.\r\n\r\nThis change could prevent a possible future pool memory usage calculation error, although it would likely be a small error: If the pool is configured with a large `MAX_BLOCK_SIZE_BYTES`, it could turn out that the size of the bucket array is small enough to be allocated by the resource allocator; it would then be double-counted.\r\n\r\nAnother aspect of the pool allocator that this PR improves is a refactor of the pool allocator's `DynamicUsage()` implementation, to move details about the pool allocator's internal data structures out of `memusage.h`, which is a general source file, to the allocator's `pool.h`.",
          "user": {
            "login": "LarryRuane",
            "id": 8321330,
            "node_id": "MDQ6VXNlcjgzMjEzMzA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/LarryRuane",
            "html_url": "https://github.com/LarryRuane",
            "followers_url": "https://api.github.com/users/LarryRuane/followers",
            "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
            "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
            "repos_url": "https://api.github.com/users/LarryRuane/repos",
            "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135961,
              "node_id": "MDU6TGFiZWwxMzU5NjE=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
              "name": "Refactoring",
              "color": "E6F6D6",
              "default": false
            },
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 15,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27748",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27748",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27748.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27748.patch"
          },
          "closed_at": "2023-11-28T18:28:10Z",
          "created_at": "2023-05-25T03:32:07Z",
          "updated_at": "2023-11-28T18:28:11Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-10T15:24:37Z",
      "updated_at": "2023-08-10T15:24:37Z",
      "source": {
        "issue": {
          "id": 1844923348,
          "node_id": "I_kwDOABII585t90vU",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28249",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28249/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28249/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28249/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/28249",
          "number": 28249,
          "state": "open",
          "state_reason": null,
          "title": "Raise maximum -dbcache setting",
          "body": "### Please describe the feature you'd like to see added.\n\n`nMaxDbCache` was set to 16 GB back in 2015:  https://github.com/bitcoin/bitcoin/commit/b3ed4236beb7f68e1720ceb3da15e0c3682ef629#diff-d102b6032635ce90158c1e6e614f03b50e4449aa46ce23370da5387a658342fd\r\n\r\nThe UTXO set has been growing significantly over the past few months so we should probably raise it.\n\n### Is your feature related to a problem, if so please describe it.\n\nDoing IBD without flushing dbcache is faster. That said, I'm not sure how much one single flush matters.\n\n### Describe the solution you'd like\n\nMake `nMaxDbCache` bigger.\n\n### Describe any alternatives you've considered\n\n_No response_\n\n### Please leave any additional context\n\nMuch growth recently:\r\nhttps://statoshi.info/d/000000009/unspent-transaction-output-set?orgId=1&from=now%2Fy&to=now&refresh=5s&viewPanel=8",
          "user": {
            "login": "Sjors",
            "id": 10217,
            "node_id": "MDQ6VXNlcjEwMjE3",
            "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/Sjors",
            "html_url": "https://github.com/Sjors",
            "followers_url": "https://api.github.com/users/Sjors/followers",
            "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
            "organizations_url": "https://api.github.com/users/Sjors/orgs",
            "repos_url": "https://api.github.com/users/Sjors/repos",
            "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/Sjors/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 64583,
              "node_id": "MDU6TGFiZWw2NDU4Mw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature",
              "name": "Feature",
              "color": "7cf575",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 8,
          "created_at": "2023-08-10T10:43:08Z",
          "updated_at": "2023-08-28T16:05:23Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-09T12:37:47Z",
      "updated_at": "2023-09-09T12:37:47Z",
      "source": {
        "issue": {
          "id": 1888680244,
          "node_id": "I_kwDOABII585wkvk0",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28440",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28440/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28440/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28440/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/28440",
          "number": 28440,
          "state": "closed",
          "state_reason": "completed",
          "title": "Impossible to run bitcoin on a Raspberry Pi 4 with 8GB, on Raspian 64 bit, which ships a 32 bit version of Docker (ARMHF instead of ARM64)",
          "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Current behaviour\r\n\r\n```\r\nbitcoind_1  | 2023-09-09T10:04:30Z UpdateTip: new best=00000000000000000a1f0a5dc852ab81d720fb9dceec91bc42f1461a3cf4d3d5 height=371331 version=0x00000003 log2_work=83.254030 tx=81012235 date='2015-08-24T15:55:06Z' progress=0.093034 cache=226.8MiB(31141716txo)\r\nbitcoind_1  | 2023-09-09T10:04:31Z UpdateTip: new best=000000000000000000509e83cabd4f3f02c62638470357eff53275c9532da94f height=371332 version=0x00000003 log2_work=83.254059 tx=81013228 date='2015-08-24T16:03:31Z' progress=0.093036 cache=226.8MiB(31141264txo)\r\nbitcoind_1  | 2023-09-09T10:04:31Z UpdateTip: new best=00000000000000001434c5b3995a1c065fc434fdd1098dbb65020bdf57d90f2a height=371333 version=0x00000003 log2_work=83.254088 tx=81015020 date='2015-08-24T16:21:46Z' progress=0.093038 cache=226.8MiB(31140795txo)\r\nbitcoind_1  | 2023-09-09T10:04:31Z UpdateTip: new best=00000000000000000796a4bd624aeaf6d81b24e666e5db3e7fa62f094df3bc96 height=371334 version=0x00000003 log2_work=83.254117 tx=81015365 date='2015-08-24T16:23:46Z' progress=0.093038 cache=226.8MiB(31141560txo)\r\nbitcoind_1  | 2023-09-09T10:04:32Z UpdateTip: new best=000000000000000006b17425eda94c210ef5111c20c10d1829829d0eeaf905a9 height=371335 version=0x00000003 log2_work=83.254146 tx=81016765 date='2015-08-24T16:35:39Z' progress=0.093040 cache=226.8MiB(31142260txo)\r\nbitcoind_1  | 2023-09-09T10:04:32Z UpdateTip: new best=00000000000000000c684f7fbcbd0bf42879ca1143844d34c5d4ae28358fb41f height=371336 version=0x00000003 log2_work=83.254175 tx=81017385 date='2015-08-24T16:44:52Z' progress=0.093040 cache=226.8MiB(31141393txo)\r\nbitcoind_1  | 2023-09-09T10:04:32Z UpdateTip: new best=00000000000000001004395fb5a59a4d44e51e7f9ff3504c2a5d6e7f06885680 height=371337 version=0x00000003 log2_work=83.254204 tx=81017610 date='2015-08-24T17:00:31Z' progress=0.093041 cache=226.8MiB(31135360txo)\r\nbitcoind_1  | 2023-09-09T10:04:32Z UpdateTip: new best=00000000000000000fb4a9c39dbbf671d79b0eee48cb2f3c85ae39a5005e82d6 height=371338 version=0x00000003 log2_work=83.254234 tx=81019260 date='2015-08-24T17:14:47Z' progress=0.093042 cache=226.8MiB(31134479txo)\r\nbitcoind_1  | 2023-09-09T10:04:33Z UpdateTip: new best=000000000000000006c32b4c4231d2c129a43fae47e2f729530baa1e198a71b8 height=371339 version=0x00000003 log2_work=83.254263 tx=81020779 date='2015-08-24T17:18:04Z' progress=0.093044 cache=226.8MiB(31133741txo)\r\nbitcoind_1  | 2023-09-09T10:04:33Z UpdateTip: new best=0000000000000000101b9824fbbbf52b158c04d33aeab910954cfce6c4c658a6 height=371340 version=0x00000003 log2_work=83.254292 tx=81021579 date='2015-08-24T17:23:07Z' progress=0.093045 cache=226.8MiB(31133299txo)\r\nbitcoind_1  | 2023-09-09T10:04:33Z UpdateTip: new best=000000000000000008aa6cf51dfde20be1d54e671494a44fb7f252fd4e913162 height=371341 version=0x00000003 log2_work=83.254321 tx=81023741 date='2015-08-24T17:44:26Z' progress=0.093048 cache=226.8MiB(31133550txo)\r\nbitcoind_1  | 2023-09-09T10:04:33Z Error: Out of memory. Terminating.\r\nbitcoind_1  | terminate called without an active exception\r\n```\r\n\r\nMemory usage at the time it crashed:\r\n\r\n```\r\n11:02:02    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\r\n11:02:07       231712   3738772   4107264     51.34     26084   3429852   4710940     38.63   4251760   3238784     93412\r\n11:02:12       231144   3711664   4135192     51.69     25796   3403248   4788664     39.27   4272024   3212576     30548\r\n11:02:17       213516   3723396   4123420     51.54     25812   3432576   4785520     39.24   4268160   3241888     59588\r\n11:02:22       218356   3730188   4116724     51.46     25776   3434476   4786956     39.26   4269748   3243840     89336\r\n11:02:27       228116   3730640   4116264     51.45     25760   3425196   4780584     39.20   4266152   3234516    120972\r\n11:02:32       204724   3713548   4133328     51.67     25456   3431848   4788772     39.27   4272332   3240804    147996\r\n11:02:37       224444   3716164   4131268     51.64     24652   3415048   4788176     39.27   4270996   3223820     15020\r\n11:02:42       253200   3719404   4129136     51.62     25084   3388780   4790644     39.29   4272240   3199076     30304\r\n11:02:47       232160   3710116   4138496     51.73     25476   3399732   4789644     39.28   4273788   3210472     50216\r\n11:02:52       205368   3713000   4135524     51.70     25828   3428468   4789020     39.27   4273788   3239492     76856\r\n11:02:57       211364   3703688   4144752     51.81     25868   3413388   4791064     39.29   4277112   3224240     95920\r\n11:03:02       226660   3704636   4143856     51.80     25712   3399384   4789360     39.28   4276240   3210116    117380\r\n11:03:07       215064   3701712   4146716     51.84     26112   3407656   4795896     39.33   4280708   3218744    145936\r\n11:03:12       207360   3706752   4142552     51.78     26256   3418984   4797584     39.34   4280072   3231016     18036\r\n11:03:17       217064   3715432   4133840     51.67     26256   3417940   4795044     39.32   4279848   3229952     43368\r\n11:03:22       217284   3712796   4136340     51.71     26264   3415216   4794976     39.32   4280332   3227112     73268\r\n11:03:27       210508   3704160   4144884     51.81     26272   3413412   4794444     39.32   4279876   3225244     99088\r\n11:03:32       224988   3703424   4145876     51.82     26232   3398252   4799232     39.36   4283672   3210292    127728\r\n11:03:37       206192   3713316   4136632     51.71     26264   3425568   4799268     39.36   4282624   3238272    148084\r\n11:03:42       212172   3723348   4126960     51.59     26288   3429108   4791204     39.29   4277816   3242172     26408\r\n11:03:47       240548   3725292   4125248     51.57     26276   3403016   4792492     39.30   4280592   3216308     56844\r\n11:03:52       203952   3710732   4139928     51.75     26308   3424324   4797664     39.34   4282804   3237752     78048\r\n11:03:57       215576   3716332   4134396     51.68     26324   3418392   4800320     39.37   4283368   3231808    100300\r\n11:04:02       205540   3705280   4145444     51.82     26348   3417292   4803828     39.39   4285928   3230756    115348\r\n11:04:07       213100   3704864   4145792     51.82     26340   3409512   4804740     39.40   4287800   3222948    135688\r\n11:04:12       214424   3709124   4141832     51.77     26356   3411916   4800868     39.37   4286328   3225704     16632\r\n11:04:17       204652   3702028   4148892     51.86     26356   3414520   4800116     39.36   4287616   3228256     47500\r\n11:04:22       213052   3681992   4168880     52.11     26356   3386772   4812260     39.46   4297872   3200484     77004\r\n11:04:27       208780   3681020   4169712     52.12     26348   3390016   4822388     39.55   4305700   3203616    108244\r\n11:04:32       200124   3665384   4185420     52.32     25968   3383348   4824268     39.56   4307804   3196628    124520\r\n11:04:37       215756   3665912   4184724     52.31     23580   3369252   4824364     39.56   4307996   3180076    494028\r\n11:04:42      1971324   3617144   4184700     52.31     19708   1641096   4822548     39.55   4307480   1448108    654576\r\n11:04:47      1740108   3612528   4189324     52.37     19728   1862428   4822548     39.55   4307484   1669464    744892\r\n11:04:52      1581404   3611644   4190256     52.38     19740   2015900   4822548     39.55   4307488   1823000    762952\r\n11:04:57      1454928   3611664   4190204     52.38     19756   2138980   4822548     39.55   4307488   1946068    742872\r\n11:05:02      1376868   3631312   4170632     52.13     19768   2233992   4784572     39.24   4286420   2041124    706744\r\n11:05:07      1267544   3630916   4170936     52.14     19780   2340000   4784572     39.24   4286432   2147080    667320\r\n11:05:12      1155152   3631364   4170732     52.14     19792   2449516   4784572     39.24   4286300   2256872    635532\r\n11:05:17      1045588   3631688   4170492     52.13     19804   2556456   4784572     39.24   4286268   2363868    603200\r\n11:05:22       913040   3632364   4169824     52.12     19816   2685936   4784572     39.24   4286284   2493380    581092\r\n11:05:27       843540   3630500   4171756     52.15     19836   2751728   4786388     39.25   4286796   2559224    519916\r\n11:05:32       688180   3629032   4173132     52.17     19848   2901696   4784572     39.24   4286304   2709140    522620\r\n11:05:37       558748   3628956   4173360     52.17     19860   3027208   4784572     39.24   4286312   2834752    508664\r\n11:05:42       392452   3628156   4174080     52.18     19872   3188348   4784572     39.24   4286332   2995828    538724\r\n11:05:47       239560   3627644   4174488     52.18     19880   3336584   4786388     39.25   4286840   3144000    531308\r\n11:05:52       203756   3628228   4174148     52.18     19900   3371784   4784572     39.24   4286308   3179412    498168\r\n11:05:57       133836   3628928   4173400     52.17     19920   3440480   4784572     39.24   4286312   3248100    430364\r\n11:06:02        94968   3629700   4172180     52.15     19868   3479136   4784572     39.24   4286384   3286264    359504\r\n11:06:07        87700   3679172   4172144     52.15     19880   3485776   4784572     39.24   4286480   3293272    472160\r\n11:06:12        79144   3679704   4171608     52.15     19892   3494220   4784572     39.24   4286488   3301728    505572\r\n11:06:17        75152   3680568   4170708     52.14     19908   3498656   4784572     39.24   4286500   3306124    562968\r\n11:06:22        79244   3631112   4171068     52.14     19920   3493912   4784572     39.24   4286512   3301244    570720\r\n11:06:27        75452   3679644   4167668     52.10     19908   3500708   4784572     39.24   4287352   3303904    553348\r\n11:06:32        74328   3680424   4166868     52.09     19916   3502296   4784572     39.24   4287512   3305468    585032\r\n```\r\n\r\nIt never gets to use the swap (but it also shouldn't, using RAM usage at only 50%:\r\n```\r\n$ free -h\r\n               total        used        free      shared  buff/cache   available\r\nMem:           7.6Gi       392Mi       3.3Gi       1.0Mi       3.9Gi       7.1Gi\r\nSwap:          4.0Gi          0B       4.0Gi\r\n```\r\n\r\nMy bitcoin.conf:\r\n```\r\nserver=1\r\nrpcuser=****************\r\nrpcpassword=****************\r\n\r\n[main]\r\nrpcbind=0.0.0.0\r\nrpcallowip=0.0.0.0/0\r\nrpcport=8332\r\ntxindex=1\r\nzmqpubrawblock=tcp://0.0.0.0:28332\r\nzmqpubrawtx=tcp://0.0.0.0:28333\r\n\r\n[test]\r\nrpcbind=0.0.0.0\r\nrpcallowip=0.0.0.0/0\r\ntestnet=0\r\nrpcport=18332\r\nzmqpubrawblock=tcp://0.0.0.0:38332\r\nzmqpubrawtx=tcp://0.0.0.0:38333\r\n```\r\n\r\nI have tried to play around with **dbcache**, **maxsigcachesize**, **maxconnections**, and **rpcthreads**. Same error, exactly at ~9% sync.\r\n\r\n### Expected behaviour\r\n\r\nFor it to run smoothly without crashing.\r\n\r\n### Steps to reproduce\r\n\r\n**On a Raspberry Pi 4, 8GB version.**\r\n\r\nAdd the following docker-compose.yaml:\r\n\r\n```\r\nversion: '3'\r\nservices:\r\n  bitcoind:\r\n    build: .\r\n    volumes:\r\n      - ./bitcoind_data:/root/.bitcoin\r\n    restart: always\r\n```\r\n\r\nPut the bitcoin.conf inside `./bitcoind_data` relative to where you placed the compose file:\r\n\r\n```\r\nserver=1\r\nrpcuser=****************\r\nrpcpassword=****************\r\n\r\n[main]\r\nrpcbind=0.0.0.0\r\nrpcallowip=0.0.0.0/0\r\nrpcport=8332\r\ntxindex=1\r\nzmqpubrawblock=tcp://0.0.0.0:28332\r\nzmqpubrawtx=tcp://0.0.0.0:28333\r\n\r\n[test]\r\nrpcbind=0.0.0.0\r\nrpcallowip=0.0.0.0/0\r\ntestnet=0\r\nrpcport=18332\r\nzmqpubrawblock=tcp://0.0.0.0:38332\r\nzmqpubrawtx=tcp://0.0.0.0:38333\r\n```\r\n\r\nAnd the following Dockerfile in `.`:\r\n```\r\nFROM debian:trixie-20230814-slim\r\n\r\nRUN apt-get update\r\nRUN apt-get install -y git build-essential libtool autotools-dev automake pkg-config bsdmainutils python3 libevent-dev libboost-dev libsqlite3-dev libzmq3-dev libqt5gui5 libqt5core5a libqt5dbus5 qttools5-dev qttools5-dev-tools\r\n\r\nRUN git clone -b master https://github.com/bitcoin/bitcoin.git\r\n\r\nWORKDIR bitcoin\r\n\r\nRUN ./autogen.sh\r\nRUN ./configure\r\nRUN make -j \"$(($(nproc)+1))\"\r\nRUN make install\r\nRUN apt-get install -y tree\r\n\r\nWORKDIR /root\r\n\r\nENTRYPOINT [\"bitcoind\"]\r\n```\r\n\r\nThen run `docker-compose up` and wait about 40 mins, until it reaches a point (in my case progress ~0.09, ~250mb cache) and terminates the process.\r\n\r\n### Relevant log output\r\n\r\n```\r\nbitcoind_1  | 2023-09-09T10:04:30Z UpdateTip: new best=00000000000000000a1f0a5dc852ab81d720fb9dceec91bc42f1461a3cf4d3d5 height=371331 version=0x00000003 log2_work=83.254030 tx=81012235 date='2015-08-24T15:55:06Z' progress=0.093034 cache=226.8MiB(31141716txo)\r\nbitcoind_1  | 2023-09-09T10:04:31Z UpdateTip: new best=000000000000000000509e83cabd4f3f02c62638470357eff53275c9532da94f height=371332 version=0x00000003 log2_work=83.254059 tx=81013228 date='2015-08-24T16:03:31Z' progress=0.093036 cache=226.8MiB(31141264txo)\r\nbitcoind_1  | 2023-09-09T10:04:31Z UpdateTip: new best=00000000000000001434c5b3995a1c065fc434fdd1098dbb65020bdf57d90f2a height=371333 version=0x00000003 log2_work=83.254088 tx=81015020 date='2015-08-24T16:21:46Z' progress=0.093038 cache=226.8MiB(31140795txo)\r\nbitcoind_1  | 2023-09-09T10:04:31Z UpdateTip: new best=00000000000000000796a4bd624aeaf6d81b24e666e5db3e7fa62f094df3bc96 height=371334 version=0x00000003 log2_work=83.254117 tx=81015365 date='2015-08-24T16:23:46Z' progress=0.093038 cache=226.8MiB(31141560txo)\r\nbitcoind_1  | 2023-09-09T10:04:32Z UpdateTip: new best=000000000000000006b17425eda94c210ef5111c20c10d1829829d0eeaf905a9 height=371335 version=0x00000003 log2_work=83.254146 tx=81016765 date='2015-08-24T16:35:39Z' progress=0.093040 cache=226.8MiB(31142260txo)\r\nbitcoind_1  | 2023-09-09T10:04:32Z UpdateTip: new best=00000000000000000c684f7fbcbd0bf42879ca1143844d34c5d4ae28358fb41f height=371336 version=0x00000003 log2_work=83.254175 tx=81017385 date='2015-08-24T16:44:52Z' progress=0.093040 cache=226.8MiB(31141393txo)\r\nbitcoind_1  | 2023-09-09T10:04:32Z UpdateTip: new best=00000000000000001004395fb5a59a4d44e51e7f9ff3504c2a5d6e7f06885680 height=371337 version=0x00000003 log2_work=83.254204 tx=81017610 date='2015-08-24T17:00:31Z' progress=0.093041 cache=226.8MiB(31135360txo)\r\nbitcoind_1  | 2023-09-09T10:04:32Z UpdateTip: new best=00000000000000000fb4a9c39dbbf671d79b0eee48cb2f3c85ae39a5005e82d6 height=371338 version=0x00000003 log2_work=83.254234 tx=81019260 date='2015-08-24T17:14:47Z' progress=0.093042 cache=226.8MiB(31134479txo)\r\nbitcoind_1  | 2023-09-09T10:04:33Z UpdateTip: new best=000000000000000006c32b4c4231d2c129a43fae47e2f729530baa1e198a71b8 height=371339 version=0x00000003 log2_work=83.254263 tx=81020779 date='2015-08-24T17:18:04Z' progress=0.093044 cache=226.8MiB(31133741txo)\r\nbitcoind_1  | 2023-09-09T10:04:33Z UpdateTip: new best=0000000000000000101b9824fbbbf52b158c04d33aeab910954cfce6c4c658a6 height=371340 version=0x00000003 log2_work=83.254292 tx=81021579 date='2015-08-24T17:23:07Z' progress=0.093045 cache=226.8MiB(31133299txo)\r\nbitcoind_1  | 2023-09-09T10:04:33Z UpdateTip: new best=000000000000000008aa6cf51dfde20be1d54e671494a44fb7f252fd4e913162 height=371341 version=0x00000003 log2_work=83.254321 tx=81023741 date='2015-08-24T17:44:26Z' progress=0.093048 cache=226.8MiB(31133550txo)\r\nbitcoind_1  | 2023-09-09T10:04:33Z Error: Out of memory. Terminating.\r\nbitcoind_1  | terminate called without an active exception\r\n```\r\n\r\n### How did you obtain Bitcoin Core\r\n\r\nCompiled from source\r\n\r\n### What version of Bitcoin Core are you using?\r\n\r\n25.0\r\n\r\n### Operating system and version\r\n\r\nRaspbian Light\r\nLinux raspberrypi 6.1.21-v8+ #1642 SMP PREEMPT Mon Apr  3 17:24:16 BST 2023 aarch64 GNU/Linux\r\n\r\n### Machine specifications\r\n\r\nhttps://www.raspberrypi.com/products/raspberry-pi-4-model-b/specifications/",
          "user": {
            "login": "FeatureSpitter",
            "id": 39516190,
            "node_id": "MDQ6VXNlcjM5NTE2MTkw",
            "avatar_url": "https://avatars.githubusercontent.com/u/39516190?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/FeatureSpitter",
            "html_url": "https://github.com/FeatureSpitter",
            "followers_url": "https://api.github.com/users/FeatureSpitter/followers",
            "following_url": "https://api.github.com/users/FeatureSpitter/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/FeatureSpitter/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/FeatureSpitter/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/FeatureSpitter/subscriptions",
            "organizations_url": "https://api.github.com/users/FeatureSpitter/orgs",
            "repos_url": "https://api.github.com/users/FeatureSpitter/repos",
            "events_url": "https://api.github.com/users/FeatureSpitter/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/FeatureSpitter/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 234878,
              "node_id": "MDU6TGFiZWwyMzQ4Nzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Linux/Unix",
              "name": "Linux/Unix",
              "color": "770000",
              "default": false
            },
            {
              "id": 159815356,
              "node_id": "MDU6TGFiZWwxNTk4MTUzNTY=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Upstream",
              "name": "Upstream",
              "color": "bfd4f2",
              "default": false
            },
            {
              "id": 326918230,
              "node_id": "MDU6TGFiZWwzMjY5MTgyMzA=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Resource%20usage",
              "name": "Resource usage",
              "color": "981023",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 45,
          "closed_at": "2023-10-09T19:24:35Z",
          "created_at": "2023-09-09T10:14:39Z",
          "updated_at": "2023-11-19T16:30:26Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-17T19:30:28Z",
      "updated_at": "2023-11-17T19:30:28Z",
      "source": {
        "issue": {
          "id": 1999781747,
          "node_id": "I_kwDOABII5853Mj9z",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28906",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28906/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28906/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28906/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/28906",
          "number": 28906,
          "state": "closed",
          "state_reason": "completed",
          "title": "RAM usage regression in 26.x and master on ARM 32-bit",
          "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Current behaviour\r\n\r\nThe `bitcoind -dbcache=100 -par=4 -disablewallet -reindex-chainstate` command fails with OOM. First reported in https://github.com/bitcoin/bitcoin/issues/28718#issuecomment-1807197107.\r\n\r\n### Expected behaviour\r\n\r\nRAM usage does not exceed 0.9 GB.\r\n\r\n### Steps to reproduce\r\n\r\n100% reproducibility with Guix compiled binaries.\r\n\r\n### Relevant log output\r\n\r\n```\r\n2023-11-17T18:43:31Z [loadblk] UpdateTip: new best=000000000000000016d35e6ca77dea6f4e2caa387f245a712b1df5bbab3c559c height=314541 version=0x00000002 log2_work=80.091273 tx=44112815 date='2014-08-08T11:42:41Z' progress=0.049410 cache=105.6MiB(13710725txo)\r\n```\r\n\r\n### How did you obtain Bitcoin Core\r\n\r\nCompiled from source\r\n\r\n### What version of Bitcoin Core are you using?\r\n\r\nmaster@5aa0c82ccd6ceb4a141686fc8658f679de75a787\r\n\r\n### Operating system and version\r\n\r\nArmbian 23.8.3 jammy, 1 GB swap-file\r\n\r\n### Machine specifications\r\n\r\narmv7l, 8 cores, 2 GB RAM",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 326918230,
              "node_id": "MDU6TGFiZWwzMjY5MTgyMzA=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Resource%20usage",
              "name": "Resource usage",
              "color": "981023",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/60",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60/labels",
            "id": 9286970,
            "node_id": "MI_kwDOABII584AjbU6",
            "number": 60,
            "state": "open",
            "title": "26.0",
            "description": "",
            "creator": {
              "login": "fanquake",
              "id": 863730,
              "node_id": "MDQ6VXNlcjg2MzczMA==",
              "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/fanquake",
              "html_url": "https://github.com/fanquake",
              "followers_url": "https://api.github.com/users/fanquake/followers",
              "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
              "organizations_url": "https://api.github.com/users/fanquake/orgs",
              "repos_url": "https://api.github.com/users/fanquake/repos",
              "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/fanquake/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 1,
            "closed_issues": 115,
            "created_at": "2023-04-15T11:36:05Z",
            "updated_at": "2023-12-04T10:55:25Z"
          },
          "locked": false,
          "comments": 41,
          "closed_at": "2023-11-22T11:15:36Z",
          "created_at": "2023-11-17T19:28:48Z",
          "updated_at": "2023-11-22T11:15:37Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-19T16:27:48Z",
      "updated_at": "2023-11-19T16:27:48Z",
      "source": {
        "issue": {
          "id": 1991240705,
          "node_id": "I_kwDOABII5852r-wB",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28866",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28866/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28866/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28866/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/28866",
          "number": 28866,
          "state": "closed",
          "state_reason": "completed",
          "title": "26.0 RC Testing Guide Feedback",
          "body": "This issue is to discuss the [26.0 Release Candidate Testing Guide](https://github.com/bitcoin-core/bitcoin-devwiki/wiki/26.0-Release-Candidate-Testing-Guide). If you have any issues with or feedback on the document, please leave a comment here.\r\n\r\nNote: this is for feedback on the document, not on Bitcoin Core or on the 26.0 changes. Please see the https://github.com/bitcoin/bitcoin/issues/28718 for instructions on how to report bug/results.\r\n\r\nThank you for your feedback",
          "user": {
            "login": "m3dwards",
            "id": 1204616,
            "node_id": "MDQ6VXNlcjEyMDQ2MTY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1204616?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/m3dwards",
            "html_url": "https://github.com/m3dwards",
            "followers_url": "https://api.github.com/users/m3dwards/followers",
            "following_url": "https://api.github.com/users/m3dwards/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/m3dwards/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/m3dwards/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/m3dwards/subscriptions",
            "organizations_url": "https://api.github.com/users/m3dwards/orgs",
            "repos_url": "https://api.github.com/users/m3dwards/repos",
            "events_url": "https://api.github.com/users/m3dwards/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/m3dwards/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/60",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60/labels",
            "id": 9286970,
            "node_id": "MI_kwDOABII584AjbU6",
            "number": 60,
            "state": "open",
            "title": "26.0",
            "description": "",
            "creator": {
              "login": "fanquake",
              "id": 863730,
              "node_id": "MDQ6VXNlcjg2MzczMA==",
              "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/fanquake",
              "html_url": "https://github.com/fanquake",
              "followers_url": "https://api.github.com/users/fanquake/followers",
              "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
              "organizations_url": "https://api.github.com/users/fanquake/orgs",
              "repos_url": "https://api.github.com/users/fanquake/repos",
              "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/fanquake/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 1,
            "closed_issues": 115,
            "created_at": "2023-04-15T11:36:05Z",
            "updated_at": "2023-12-04T10:55:25Z"
          },
          "locked": false,
          "comments": 13,
          "closed_at": "2023-12-04T10:46:42Z",
          "created_at": "2023-11-13T18:41:57Z",
          "updated_at": "2023-12-04T10:46:42Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-19T17:14:13Z",
      "updated_at": "2023-11-19T17:14:13Z",
      "source": {
        "issue": {
          "id": 2000926395,
          "node_id": "PR_kwDOABII585f1-gk",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28913",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28913/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28913/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28913/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28913",
          "number": 28913,
          "state": "closed",
          "state_reason": null,
          "title": "coins: make sure PoolAllocator uses the correct alignment",
          "body": "The class `CTxOut` has a member `CAmount` which is an int64_t, and on ARM 32bit int64_t are 8 byte aligned, which is larger than the pointer alignment of 4 bytes.\r\n\r\nSo for `CCoinsMap` to be able to use the pool, we need to use the alignment of the member instead of just `alignof(void*)`.\r\n\r\nThis fixes #28906 (first noted in https://github.com/bitcoin/bitcoin/issues/28718#issuecomment-1807197107) and #28440.",
          "user": {
            "login": "martinus",
            "id": 14386,
            "node_id": "MDQ6VXNlcjE0Mzg2",
            "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/martinus",
            "html_url": "https://github.com/martinus",
            "followers_url": "https://api.github.com/users/martinus/followers",
            "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
            "organizations_url": "https://api.github.com/users/martinus/orgs",
            "repos_url": "https://api.github.com/users/martinus/repos",
            "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/martinus/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 97470796,
              "node_id": "MDU6TGFiZWw5NzQ3MDc5Ng==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/UTXO%20Db%20and%20Indexes",
              "name": "UTXO Db and Indexes",
              "color": "fbca04",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/60",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60/labels",
            "id": 9286970,
            "node_id": "MI_kwDOABII584AjbU6",
            "number": 60,
            "state": "open",
            "title": "26.0",
            "description": "",
            "creator": {
              "login": "fanquake",
              "id": 863730,
              "node_id": "MDQ6VXNlcjg2MzczMA==",
              "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/fanquake",
              "html_url": "https://github.com/fanquake",
              "followers_url": "https://api.github.com/users/fanquake/followers",
              "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
              "organizations_url": "https://api.github.com/users/fanquake/orgs",
              "repos_url": "https://api.github.com/users/fanquake/repos",
              "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/fanquake/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 1,
            "closed_issues": 115,
            "created_at": "2023-04-15T11:36:05Z",
            "updated_at": "2023-12-04T10:55:25Z"
          },
          "locked": false,
          "comments": 13,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28913",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28913",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28913.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28913.patch"
          },
          "closed_at": "2023-11-22T11:15:38Z",
          "created_at": "2023-11-19T16:25:53Z",
          "updated_at": "2023-11-22T15:17:50Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_deleted",
      "id": 11138293152,
      "node_id": "HRDE_lADOABII585Lh0inzwAAAAKX5N2g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11138293152",
      "actor": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-04T12:15:11Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953055591",
      "pull_request_review_id": 1082762327,
      "id": 953055591,
      "node_id": "PRRC_kwDOABII5844znln",
      "diff_hunk": "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+#define BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+\n+#include <cstdint>\n+#include <limits>\n+\n+/** xoroshiro128++ PRNG. Extremely fast, not appropriate for cryptographic purposes.\n+ *\n+ * Memory footprint is 128bit, period is 2^128 - 1.\n+ * This class is not thread-safe.\n+ *\n+ * Reference implementation available at https://prng.di.unimi.it/xoroshiro128plusplus.c\n+ * See https://prng.di.unimi.it/\n+ */\n+class XoRoShiRo128PlusPlus\n+{\n+    uint64_t m_s0;\n+    uint64_t m_s1;\n+\n+    [[nodiscard]] constexpr static uint64_t rotl(uint64_t x, int n)\n+    {\n+        return (x << n) | (x >> (64 - n));\n+    }\n+\n+    [[nodiscard]] constexpr static uint64_t SplitMix64(uint64_t& seedval) noexcept",
      "path": "src/test/util/xoroshiro128plusplus.h",
      "position": null,
      "original_position": 30,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No need for passing `seedval` by reference.",
      "created_at": "2022-08-23T19:55:02Z",
      "updated_at": "2022-08-23T19:55:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953055591",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953055591"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953062958",
      "pull_request_review_id": 1082773235,
      "id": 953062958,
      "node_id": "PRRC_kwDOABII5844zpYu",
      "diff_hunk": "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto",
      "path": "src/test/util/xoroshiro128plusplus.h",
      "position": null,
      "original_position": 1,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Pretty sure this was not written by Satoshi, or in 2010.",
      "created_at": "2022-08-23T20:04:37Z",
      "updated_at": "2022-08-23T20:04:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953062958",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953062958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953067528",
      "pull_request_review_id": 1082780041,
      "id": 953067528,
      "node_id": "PRRC_kwDOABII5844zqgI",
      "diff_hunk": "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+#define BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+\n+#include <cstdint>\n+#include <limits>\n+\n+/** xoroshiro128++ PRNG. Extremely fast, not appropriate for cryptographic purposes.\n+ *\n+ * Memory footprint is 128bit, period is 2^128 - 1.\n+ * This class is not thread-safe.\n+ *\n+ * Reference implementation available at https://prng.di.unimi.it/xoroshiro128plusplus.c\n+ * See https://prng.di.unimi.it/\n+ */\n+class XoRoShiRo128PlusPlus\n+{\n+    uint64_t m_s0;\n+    uint64_t m_s1;\n+\n+    [[nodiscard]] constexpr static uint64_t rotl(uint64_t x, int n)\n+    {\n+        return (x << n) | (x >> (64 - n));\n+    }\n+\n+    [[nodiscard]] constexpr static uint64_t SplitMix64(uint64_t& seedval) noexcept",
      "path": "src/test/util/xoroshiro128plusplus.h",
      "position": null,
      "original_position": 30,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "in_reply_to_id": 953055591,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually this it is necessary because `seedval` is modified, see the constructor in line 42 where `m_s0` and `m_s1` are initialized. I could use a pointer instead of reference or add a comment to make that more clear?",
      "created_at": "2022-08-23T20:10:49Z",
      "updated_at": "2022-08-23T20:10:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953067528",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953067528"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953069117",
      "pull_request_review_id": 1082783050,
      "id": 953069117,
      "node_id": "PRRC_kwDOABII5844zq49",
      "diff_hunk": "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+#define BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+\n+#include <cstdint>\n+#include <limits>\n+\n+/** xoroshiro128++ PRNG. Extremely fast, not appropriate for cryptographic purposes.\n+ *\n+ * Memory footprint is 128bit, period is 2^128 - 1.\n+ * This class is not thread-safe.\n+ *\n+ * Reference implementation available at https://prng.di.unimi.it/xoroshiro128plusplus.c\n+ * See https://prng.di.unimi.it/\n+ */\n+class XoRoShiRo128PlusPlus\n+{\n+    uint64_t m_s0;\n+    uint64_t m_s1;\n+\n+    [[nodiscard]] constexpr static uint64_t rotl(uint64_t x, int n)\n+    {\n+        return (x << n) | (x >> (64 - n));\n+    }\n+\n+    [[nodiscard]] constexpr static uint64_t SplitMix64(uint64_t& seedval) noexcept",
      "path": "src/test/util/xoroshiro128plusplus.h",
      "position": null,
      "original_position": 30,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "in_reply_to_id": 953055591,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, no, I just didn't pay attention to how it was used. My mistake.",
      "created_at": "2022-08-23T20:13:00Z",
      "updated_at": "2022-08-23T20:13:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953069117",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953069117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/973734050",
      "pull_request_review_id": 1111554848,
      "id": 973734050,
      "node_id": "PRRC_kwDOABII5846CgCi",
      "diff_hunk": "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto",
      "path": "src/test/util/xoroshiro128plusplus.h",
      "position": null,
      "original_position": 1,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "in_reply_to_id": 953062958,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's how rumors start! Maybe it was Satoshi? ;-) I'll update that.",
      "created_at": "2022-09-18T15:00:16Z",
      "updated_at": "2022-09-18T15:00:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r973734050",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/973734050"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/979171391",
      "pull_request_review_id": 1119175139,
      "id": 979171391,
      "node_id": "PRRC_kwDOABII5846XPg_",
      "diff_hunk": "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto",
      "path": "src/test/util/xoroshiro128plusplus.h",
      "position": null,
      "original_position": 1,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "in_reply_to_id": 953062958,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2022-09-24T06:11:46Z",
      "updated_at": "2022-09-24T06:11:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r979171391",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/979171391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004102333",
      "pull_request_review_id": 1154271326,
      "id": 1004102333,
      "node_id": "PRRC_kwDOABII58472WK9",
      "diff_hunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final",
      "path": "src/support/allocators/pool.h",
      "position": 70,
      "original_position": 70,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "de694ed10bfa623596a41e35c95c13e757787b07",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "de694ed10bfa623596a41e35c95c13e757787b07: consider deleting copy ctor and copy assignment operators\r\n```diff\r\ndiff --git a/src/support/allocators/pool.h b/src/support/allocators/pool.h\r\nindex 5c04bb31e..00bd1ed90 100644\r\n--- a/src/support/allocators/pool.h\r\n+++ b/src/support/allocators/pool.h\r\n@@ -269,6 +269,9 @@ public:\r\n     {\r\n         return m_chunk_size_bytes;\r\n     }\r\n+\r\n+    PoolResource(const PoolResource&) = delete;\r\n+    PoolResource& operator=(const PoolResource&) = delete;\r\n };\r\n```",
      "created_at": "2022-10-25T07:27:36Z",
      "updated_at": "2022-10-25T08:09:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004102333",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004102333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 70,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004112858",
      "pull_request_review_id": 1154271326,
      "id": 1004112858,
      "node_id": "PRRC_kwDOABII58472Yva",
      "diff_hunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)",
      "path": "src/support/allocators/pool.h",
      "position": 142,
      "original_position": 142,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "de694ed10bfa623596a41e35c95c13e757787b07",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "de694ed10bfa623596a41e35c95c13e757787b07: maybe use templates instead of `void*`?\r\n```diff\r\ndiff --git a/src/support/allocators/pool.h b/src/support/allocators/pool.h\r\nindex 5c04bb31e..38c5f9d62 100644\r\n--- a/src/support/allocators/pool.h\r\n+++ b/src/support/allocators/pool.h\r\n@@ -139,7 +139,8 @@ class PoolResource final\r\n     /**\r\n      * Replaces node with placement constructed ListNode that points to the previous node\r\n      */\r\n-    void PlacementAddToList(void* p, ListNode*& node)\r\n+    template <typename T>\r\n+    void PlacementAddToList(T* p, ListNode*& node)\r\n     {\r\n         node = new (p) ListNode{node};\r\n     }\r\n@@ -232,7 +233,8 @@ public:\r\n     /**\r\n      * Returns a block to the freelists, or deletes the block when it did not come from the cunks.\r\n      */\r\n-    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\r\n+    template <typename T>\r\n+    void Deallocate(T* p, std::size_t bytes, std::size_t alignment) noexcept\r\n     {\r\n         if (IsFreeListUsable(bytes, alignment)) {\r\n             const std::size_t num_alignments = NumElemAlignBytes(bytes);\r\n```",
      "created_at": "2022-10-25T07:38:21Z",
      "updated_at": "2022-10-25T08:09:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004112858",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004112858"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 142,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004137199",
      "pull_request_review_id": 1154271326,
      "id": 1004137199,
      "node_id": "PRRC_kwDOABII58472erv",
      "diff_hunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "path": "src/support/allocators/pool.h",
      "position": 101,
      "original_position": 101,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "de694ed10bfa623596a41e35c95c13e757787b07: might slightly improve performance but haven't benchmarked\r\n```suggestion\r\n    std::vector<std::byte*> m_allocated_chunks{};\r\n```",
      "created_at": "2022-10-25T08:02:29Z",
      "updated_at": "2022-10-25T08:09:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004137199",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004137199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1009306384",
      "pull_request_review_id": 1161718255,
      "id": 1009306384,
      "node_id": "PRRC_kwDOABII5848KMsQ",
      "diff_hunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)",
      "path": "src/support/allocators/pool.h",
      "position": 142,
      "original_position": 142,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "de694ed10bfa623596a41e35c95c13e757787b07",
      "in_reply_to_id": 1004112858,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it's better to leave this as void*, because I don't want any overloaded operator new or operator delete called depending on the type.",
      "created_at": "2022-10-31T11:25:10Z",
      "updated_at": "2022-10-31T11:25:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1009306384",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1009306384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 142,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036283541",
      "pull_request_review_id": 1199784602,
      "id": 1036283541,
      "node_id": "PRRC_kwDOABII5849xG6V",
      "diff_hunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final",
      "path": "src/support/allocators/pool.h",
      "position": 70,
      "original_position": 70,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "de694ed10bfa623596a41e35c95c13e757787b07",
      "in_reply_to_id": 1004102333,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll add these when I rebase to fix the merge conflict :+1: ",
      "created_at": "2022-11-30T17:55:51Z",
      "updated_at": "2022-11-30T17:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036283541",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036283541"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 70,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036285674",
      "pull_request_review_id": 1199787521,
      "id": 1036285674,
      "node_id": "PRRC_kwDOABII5849xHbq",
      "diff_hunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "path": "src/support/allocators/pool.h",
      "position": 101,
      "original_position": 101,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "in_reply_to_id": 1004137199,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I thought std::list is more fitting here, because I don't need random access, and only every once in a while one element is added. The list is only iterated once when bitcoind shutsdown. So it's not at all performance relevant here",
      "created_at": "2022-11-30T17:57:55Z",
      "updated_at": "2022-11-30T17:57:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036285674",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036285674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081878044",
      "pull_request_review_id": 1262647120,
      "id": 1081878044,
      "node_id": "PRRC_kwDOABII585AfCYc",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 64,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Typo: space before `3`",
      "created_at": "2023-01-19T21:22:38Z",
      "updated_at": "2023-01-19T22:13:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081878044",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081878044"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081883320",
      "pull_request_review_id": 1262647120,
      "id": 1081883320,
      "node_id": "PRRC_kwDOABII585AfDq4",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};",
      "path": "src/support/allocators/pool.h",
      "position": 107,
      "original_position": 107,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Allocators don't need to be able to handle allocations of size 0, so I think the `+ 1` could be dropped here (shifting the indices down by 1).",
      "created_at": "2023-01-19T21:27:33Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081883320",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081883320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 107,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081894944",
      "pull_request_review_id": 1262647120,
      "id": 1081894944,
      "node_id": "PRRC_kwDOABII585AfGgg",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;",
      "path": "src/support/allocators/pool.h",
      "position": 193,
      "original_position": 193,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I know there are rules that make move constructors/assignment operators not automatically appear when copy equivalents are specified, but I'd still prefer explicitly disabling those too.",
      "created_at": "2023-01-19T21:38:52Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081894944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081894944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 193,
      "original_line": 193,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081903348",
      "pull_request_review_id": 1262647120,
      "id": 1081903348,
      "node_id": "PRRC_kwDOABII585AfIj0",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 215,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems this comment would be more appropriate if put a few lines higher. The placement here makes it look like it's related to the freelist empty test.",
      "created_at": "2023-01-19T21:47:10Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081903348",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081903348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909031",
      "pull_request_review_id": 1262647120,
      "id": 1081909031,
      "node_id": "PRRC_kwDOABII585AfJ8n",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.",
      "path": "src/support/allocators/pool.h",
      "position": 223,
      "original_position": 223,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This comment seems like it should be moved up as well.",
      "created_at": "2023-01-19T21:52:49Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909031",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909200",
      "pull_request_review_id": 1262647120,
      "id": 1081909200,
      "node_id": "PRRC_kwDOABII585AfJ_Q",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),",
      "path": "src/support/allocators/pool.h",
      "position": 230,
      "original_position": 230,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "And this one too.",
      "created_at": "2023-01-19T21:53:03Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909200",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 230,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909913",
      "pull_request_review_id": 1262647120,
      "id": 1081909913,
      "node_id": "PRRC_kwDOABII585AfKKZ",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 234,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think there is an upstream resource; it's just handled by the default allocator.",
      "created_at": "2023-01-19T21:53:45Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909913",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909913"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910140",
      "pull_request_review_id": 1262647120,
      "id": 1081910140,
      "node_id": "PRRC_kwDOABII585AfKN8",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 239,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Typo: `cunks`.",
      "created_at": "2023-01-19T21:54:01Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910140",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910577",
      "pull_request_review_id": 1262647120,
      "id": 1081910577,
      "node_id": "PRRC_kwDOABII585AfKUx",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to the upstream resource.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 249,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Likewise, no upstream resource here?",
      "created_at": "2023-01-19T21:54:37Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910577",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081913776",
      "pull_request_review_id": 1262647120,
      "id": 1081913776,
      "node_id": "PRRC_kwDOABII585AfLGw",
      "diff_hunk": "@@ -0,0 +1,127 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            // std::cout << \"free_block=(\" << (void*)free_block.ptr << \", \" << free_block.size << \"), chunk=(\" << (void*)chunk_ptr_remaining << \", \" << chunk_size_remaining << \")\" << std::endl;",
      "path": "src/test/util/poolresourcetester.h",
      "position": null,
      "original_position": 115,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This seems like a debugging leftover.",
      "created_at": "2023-01-19T21:58:43Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081913776",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081913776"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081922160",
      "pull_request_review_id": 1262647120,
      "id": 1081922160,
      "node_id": "PRRC_kwDOABII585AfNJw",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "path": "src/support/allocators/pool.h",
      "position": 101,
      "original_position": 101,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could this use `std::forward_list`?",
      "created_at": "2023-01-19T22:09:09Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081922160",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081922160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081923544",
      "pull_request_review_id": 1262647120,
      "id": 1081923544,
      "node_id": "PRRC_kwDOABII585AfNfY",
      "diff_hunk": "@@ -166,6 +167,23 @@ static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n     return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n+template <class Key, class T, class Hash, class Pred, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+static inline size_t DynamicUsage(const std::unordered_map<Key,\n+                                                           T,\n+                                                           Hash,\n+                                                           Pred,\n+                                                           PoolAllocator<std::pair<const Key, T>,\n+                                                                         MAX_BLOCK_SIZE_BYTES,\n+                                                                         ALIGN_BYTES>>& m)\n+{\n+    auto* pool_resource = m.get_allocator().resource();\n+\n+    size_t estimated_list_node_size = MallocUsage(sizeof(void*) * 3);",
      "path": "src/memusage.h",
      "position": 25,
      "original_position": 23,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "ecc73d72c72287b8e630266dc5bd08786dc85780",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A comment to explain where this estimation formula comes from would be useful (or encapsulate the `sizeof(void*) * 3` constant as a static member of the resource?).",
      "created_at": "2023-01-19T22:10:36Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081923544",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081923544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081925749",
      "pull_request_review_id": 1262647120,
      "id": 1081925749,
      "node_id": "PRRC_kwDOABII585AfOB1",
      "diff_hunk": "@@ -217,7 +226,8 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * declared as \"const\".\n      */\n     mutable uint256 hashBlock;\n-    mutable CCoinsMap cacheCoins;\n+    mutable CCoinsMapMemoryResource cacheCoinsMemoryResource{};",
      "path": "src/coins.h",
      "position": null,
      "original_position": 30,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: use variable names following the style guide when introducing new ones (e.g. `m_cache_coins_memory_resource`).",
      "created_at": "2023-01-19T22:12:55Z",
      "updated_at": "2023-01-19T22:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081925749",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081925749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082378917",
      "pull_request_review_id": 1263376994,
      "id": 1082378917,
      "node_id": "PRRC_kwDOABII585Ag8ql",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};",
      "path": "src/support/allocators/pool.h",
      "position": 107,
      "original_position": 107,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081883320,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not 100% sure that is the case\r\n\r\nIn https://eel.is/c++draft/allocator.requirements#general-39 it states that \"the return value is unspecified\", so it it seems to me that it can be any value, but it doesn't say that the behavior is unspecified. So it could return any pointer or even `nullptr`\r\n\r\nIn http://eel.is/c++draft/basic.stc.dynamic.allocation#2 it says \"The effect of indirecting through a pointer returned from a request for zero size is undefined\", so one might return any value, but it must not be dereferenced (which seems logic, with 0 elements there's nothing to dereference). The footnote here says \"C++ differs from C in requiring a zero request to return a non-null pointer\", so this too seems like a pointer should be returned\r\n\r\nSo I think `allocate(0)` is not forbidden",
      "created_at": "2023-01-20T11:15:37Z",
      "updated_at": "2023-01-20T11:15:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082378917",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082378917"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 107,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082384437",
      "pull_request_review_id": 1263391388,
      "id": 1082384437,
      "node_id": "PRRC_kwDOABII585Ag-A1",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 215,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081903348,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll remove the comment, it doesn't make much sense",
      "created_at": "2023-01-20T11:22:43Z",
      "updated_at": "2023-01-20T11:22:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082384437",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082384437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082385811",
      "pull_request_review_id": 1263395000,
      "id": 1082385811,
      "node_id": "PRRC_kwDOABII585Ag-WT",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.",
      "path": "src/support/allocators/pool.h",
      "position": 223,
      "original_position": 223,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081909031,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The location seems ok to me, when that line is reached we know the freelist is empty so we need to get memory from the chunk",
      "created_at": "2023-01-20T11:24:27Z",
      "updated_at": "2023-01-20T11:24:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082385811",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082385811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082387056",
      "pull_request_review_id": 1263398108,
      "id": 1082387056,
      "node_id": "PRRC_kwDOABII585Ag-pw",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),",
      "path": "src/support/allocators/pool.h",
      "position": 230,
      "original_position": 230,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081909200,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think that line fits too, this comments on  the `m_available_memory_it + round_bytes`",
      "created_at": "2023-01-20T11:25:56Z",
      "updated_at": "2023-01-20T11:25:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082387056",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082387056"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 230,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082577659",
      "pull_request_review_id": 1263645793,
      "id": 1082577659,
      "node_id": "PRRC_kwDOABII585AhtL7",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "path": "src/support/allocators/pool.h",
      "position": 101,
      "original_position": 101,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081922160,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I could, but itt would be less convenient, because forward_list doesn't even have a `size()` which I use in `NumAllocatedChunks()`",
      "created_at": "2023-01-20T14:03:44Z",
      "updated_at": "2023-01-20T14:03:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082577659",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082577659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082640705",
      "pull_request_review_id": 1263736203,
      "id": 1082640705,
      "node_id": "PRRC_kwDOABII585Ah8lB",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};",
      "path": "src/support/allocators/pool.h",
      "position": 107,
      "original_position": 107,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081883320,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fair enough.",
      "created_at": "2023-01-20T14:45:49Z",
      "updated_at": "2023-01-20T14:45:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082640705",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082640705"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 107,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082683009",
      "pull_request_review_id": 1263783313,
      "id": 1082683009,
      "node_id": "PRRC_kwDOABII585AiG6B",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "path": "src/support/allocators/pool.h",
      "position": 101,
      "original_position": 101,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081922160,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I see; it'd reduce memory usage very slightly, but if it comes with extra complexity it's probably not worth it.",
      "created_at": "2023-01-20T15:12:56Z",
      "updated_at": "2023-01-20T15:12:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082683009",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082683009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685605",
      "pull_request_review_id": 1263787310,
      "id": 1082685605,
      "node_id": "PRRC_kwDOABII585AiHil",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.",
      "path": "src/support/allocators/pool.h",
      "position": 223,
      "original_position": 223,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081909031,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok, it's just a tiny nit of course. Given the somewhat out of place comment above I wondered if perhaps a few more comments somehow got misplaced.",
      "created_at": "2023-01-20T15:15:15Z",
      "updated_at": "2023-01-20T15:15:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685605",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685801",
      "pull_request_review_id": 1263787539,
      "id": 1082685801,
      "node_id": "PRRC_kwDOABII585AiHlp",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),",
      "path": "src/support/allocators/pool.h",
      "position": 230,
      "original_position": 230,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081909200,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok.",
      "created_at": "2023-01-20T15:15:22Z",
      "updated_at": "2023-01-20T15:15:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685801",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 230,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083220507",
      "pull_request_review_id": 1264557141,
      "id": 1083220507,
      "node_id": "PRRC_kwDOABII585AkKIb",
      "diff_hunk": "@@ -112,6 +112,7 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/pool_tests.cpp \\",
      "path": "src/Makefile.test.include",
      "position": null,
      "original_position": 4,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Noticed while running `make check` and looking for `pool_tests` in the output: the following minor change in the first commit  2bbe0f8eeae274fc30d924c6762cbb7a392f3b32 will run the tests in the expected order.\r\n\r\n<details><summary>suggestion</summary><p>\r\n\r\n```diff\r\n   test/net_tests.cpp \\\r\n   test/netbase_tests.cpp \\\r\n-  test/pool_tests.cpp \\\r\n   test/orphanage_tests.cpp \\\r\n   test/pmt_tests.cpp \\\r\n   test/policy_fee_tests.cpp \\\r\n   test/policyestimator_tests.cpp \\\r\n+  test/pool_tests.cpp \\\r\n   test/pow_tests.cpp \\\r\n```\r\n\r\ncurrently\r\n\r\n```\r\nRunning tests: net_peer_eviction_tests from test/net_peer_eviction_tests.cpp\r\nRunning tests: net_tests from test/net_tests.cpp\r\nRunning tests: netbase_tests from test/netbase_tests.cpp\r\nRunning tests: pool_tests from test/pool_tests.cpp\r\nRunning tests: orphanage_tests from test/orphanage_tests.cpp\r\nRunning tests: pmt_tests from test/pmt_tests.cpp\r\nRunning tests: policy_fee_tests from test/policy_fee_tests.cpp\r\n```\r\n\r\nafter\r\n\r\n```\r\nRunning tests: pmt_tests from test/pmt_tests.cpp\r\nRunning tests: policy_fee_tests from test/policy_fee_tests.cpp\r\nRunning tests: policyestimator_tests from test/policyestimator_tests.cpp\r\nRunning tests: pool_tests from test/pool_tests.cpp\r\nRunning tests: pow_tests from test/pow_tests.cpp\r\nRunning tests: prevector_tests from test/prevector_tests.cpp\r\nRunning tests: raii_event_tests from test/raii_event_tests.cpp\r\n```\r\n</p></details>\r\n",
      "created_at": "2023-01-21T01:33:47Z",
      "updated_at": "2023-01-21T01:43:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083220507",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083220507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249932",
      "pull_request_review_id": 1264592811,
      "id": 1083249932,
      "node_id": "PRRC_kwDOABII585AkRUM",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 64,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081878044,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in rebase to 80722d8",
      "created_at": "2023-01-21T06:09:41Z",
      "updated_at": "2023-01-21T06:09:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249932",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249938",
      "pull_request_review_id": 1264592818,
      "id": 1083249938,
      "node_id": "PRRC_kwDOABII585AkRUS",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 215,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081903348,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in rebase to 80722d8",
      "created_at": "2023-01-21T06:09:49Z",
      "updated_at": "2023-01-21T06:09:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249938",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249976",
      "pull_request_review_id": 1264592846,
      "id": 1083249976,
      "node_id": "PRRC_kwDOABII585AkRU4",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 234,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081909913,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in rebase to 80722d8",
      "created_at": "2023-01-21T06:10:05Z",
      "updated_at": "2023-01-21T06:10:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249976",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249976"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 234,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250008",
      "pull_request_review_id": 1264592853,
      "id": 1083250008,
      "node_id": "PRRC_kwDOABII585AkRVY",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 239,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081910140,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in rebase to 80722d8",
      "created_at": "2023-01-21T06:10:12Z",
      "updated_at": "2023-01-21T06:10:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250008",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250013",
      "pull_request_review_id": 1264592861,
      "id": 1083250013,
      "node_id": "PRRC_kwDOABII585AkRVd",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to the upstream resource.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 249,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081910577,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in rebase to 80722d8",
      "created_at": "2023-01-21T06:10:18Z",
      "updated_at": "2023-01-21T06:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250013",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250035",
      "pull_request_review_id": 1264592876,
      "id": 1083250035,
      "node_id": "PRRC_kwDOABII585AkRVz",
      "diff_hunk": "@@ -217,7 +226,8 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * declared as \"const\".\n      */\n     mutable uint256 hashBlock;\n-    mutable CCoinsMap cacheCoins;\n+    mutable CCoinsMapMemoryResource cacheCoinsMemoryResource{};",
      "path": "src/coins.h",
      "position": null,
      "original_position": 30,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "in_reply_to_id": 1081925749,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in rebase to 80722d8",
      "created_at": "2023-01-21T06:10:29Z",
      "updated_at": "2023-01-21T06:10:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250035",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250755",
      "pull_request_review_id": 1264593480,
      "id": 1083250755,
      "node_id": "PRRC_kwDOABII585AkRhD",
      "diff_hunk": "@@ -112,6 +112,7 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/pool_tests.cpp \\",
      "path": "src/Makefile.test.include",
      "position": null,
      "original_position": 4,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1083220507,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting that the order here has any effect on the order of tests, I would have expected that the test suite orders alphabetically. I'll add this to my next update",
      "created_at": "2023-01-21T06:18:17Z",
      "updated_at": "2023-01-21T06:18:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250755",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250755"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250811",
      "pull_request_review_id": 1264593524,
      "id": 1083250811,
      "node_id": "PRRC_kwDOABII585AkRh7",
      "diff_hunk": "@@ -0,0 +1,127 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            // std::cout << \"free_block=(\" << (void*)free_block.ptr << \", \" << free_block.size << \"), chunk=(\" << (void*)chunk_ptr_remaining << \", \" << chunk_size_remaining << \")\" << std::endl;",
      "path": "src/test/util/poolresourcetester.h",
      "position": null,
      "original_position": 115,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "in_reply_to_id": 1081913776,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed in rebase to 80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at": "2023-01-21T06:18:49Z",
      "updated_at": "2023-01-21T06:18:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250811",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1084564591",
      "pull_request_review_id": 1266351016,
      "id": 1084564591,
      "node_id": "PRRC_kwDOABII585ApSRv",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 225,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe this is technically speaking UB: it may construct an out-of-bounds pointer; even without dereferencing, doing so is UB (unless it's the exactly-one-past-the-end pointer). It's of course fine in practice, but I think the proper way to write it is `round_bytes > m_available_memory_end - m_available_memory_it`.\r\n\r\nFrom https://en.cppreference.com/w/cpp/language/operator_arithmetic:\r\n\r\n> If the pointer `P` points to the ith element of an array, then the expressions `P + n`, `n + P`, and `P - n` are pointers of the same type that point to the i+nth, i+nth, and i-nth element of the same array, respectively. The result of pointer addition may also be a one-past-the-end pointer (that is, pointer `P` such that the expression `P - 1` points to the last element of the array). Any other situations (that is, attempts to generate a pointer that isn't pointing at an element of the same array or one past the end) invoke undefined behavior. \r\n\r\n",
      "created_at": "2023-01-23T21:16:40Z",
      "updated_at": "2023-01-23T22:16:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1084564591",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1084564591"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085963632",
      "pull_request_review_id": 1268371465,
      "id": 1085963632,
      "node_id": "PRRC_kwDOABII585Aun1w",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 261,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "2bbe0f8eeae274f Is the public helper member `PoolResource::IsEqual()` intended to be used (it's currently not)?",
      "created_at": "2023-01-24T21:37:32Z",
      "updated_at": "2023-01-24T22:08:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085963632",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085963632"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085967553",
      "pull_request_review_id": 1268371465,
      "id": 1085967553,
      "node_id": "PRRC_kwDOABII585AuozB",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 117,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "2bbe0f8eeae274 it looks like `CHUNK_SIZE_BYTES` should be `m_chunk_size_bytes` or `ChunkSizeBytes()`\r\n```suggestion\r\n     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() +  m_chunk_size_bytes`\r\n```\r\n",
      "created_at": "2023-01-24T21:41:52Z",
      "updated_at": "2023-01-24T22:10:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085967553",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085967553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085970688",
      "pull_request_review_id": 1268371465,
      "id": 1085970688,
      "node_id": "PRRC_kwDOABII585AupkA",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 105,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "2bbe0f8eeae274f `BLOCK_ALIGNMENT_BYTES` is undefined (maybe `n * block alignment bytes`?)",
      "created_at": "2023-01-24T21:44:45Z",
      "updated_at": "2023-01-25T21:52:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085970688",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085970688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086981056",
      "pull_request_review_id": 1269855171,
      "id": 1086981056,
      "node_id": "PRRC_kwDOABII585AygPA",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "path": "src/support/allocators/pool.h",
      "position": 296,
      "original_position": 305,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/commit/2bbe0f8eeae274fc30d924c6762cbb7a392f3b32 Question, are these user-defined copy-constructor and copy-assignment operators actually needed, and if yes, should the move operators be specified as well? \r\n\r\n<details><summary>Rationale</summary><p>\r\n\r\nPer https://en.cppreference.com/w/cpp/language/rule_of_three#rule-of-five, \"Because the presence of a user-defined destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the [move constructor](https://en.cppreference.com/w/cpp/language/move_constructor) and the [move assignment operator](https://en.cppreference.com/w/cpp/language/move_operator), any class for which move semantics are desirable, has to declare all five special member functions. Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity.\"\r\n\r\n</p></details>\r\n",
      "created_at": "2023-01-25T17:57:15Z",
      "updated_at": "2023-01-25T21:50:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086981056",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086981056"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 296,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086988389",
      "pull_request_review_id": 1269855171,
      "id": 1086988389,
      "node_id": "PRRC_kwDOABII585AyiBl",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;\n+\n+    template <class U>\n+    PoolAllocator(const PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& other) noexcept\n+        : m_resource(other.resource())\n+    {\n+    }\n+\n+    /**\n+     * The rebind struct here is mandatory because we use non type template arguments for\n+     * PoolAllocator. See https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+    };\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        return static_cast<T*>(m_resource->Allocate(n * sizeof(T), alignof(T)));\n+    }\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    void deallocate(T* p, size_t n) noexcept\n+    {\n+        m_resource->Deallocate(p, n * sizeof(T), alignof(T));\n+    }\n+\n+    ResourceType* resource() const noexcept\n+    {\n+        return m_resource;\n+    }\n+};\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator==(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{\n+    return a.resource() == b.resource();\n+}\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator!=(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{",
      "path": "src/support/allocators/pool.h",
      "position": 345,
      "original_position": 354,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/commit/2bbe0f8eeae274fc30d924c6762cbb7a392f3b32 Noting that these two `==` and `!=` template methods don't appear to be otherwise used in this PR.",
      "created_at": "2023-01-25T18:02:41Z",
      "updated_at": "2023-01-25T21:50:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086988389",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086988389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087172548",
      "pull_request_review_id": 1269855171,
      "id": 1087172548,
      "node_id": "PRRC_kwDOABII585AzO_E",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128\n+            std::size_t size = (InsecureRandRange(2000) / alignment + 1) * alignment; // multiple of alignment\n+            void* ptr = resource.Allocate(size, alignment);\n+            BOOST_TEST(ptr != nullptr);\n+            BOOST_TEST((reinterpret_cast<uintptr_t>(ptr) & (alignment - 1)) == 0);\n+            ptr_size_alignment.push_back({ptr, size, alignment});\n+        } else {\n+            // deallocate a random item\n+            auto& x = ptr_size_alignment[InsecureRandRange(ptr_size_alignment.size())];\n+            resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+            x = ptr_size_alignment.back();\n+            ptr_size_alignment.pop_back();\n+        }\n+    }\n+\n+    // deallocate all the rest\n+    for (auto const& x : ptr_size_alignment) {\n+        resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(memusage_test)\n+{\n+    auto std_map = std::unordered_map<int, int>{};\n+\n+    using Map = std::unordered_map<int,\n+                                   int,\n+                                   std::hash<int>,\n+                                   std::equal_to<int>,\n+                                   PoolAllocator<std::pair<const int, int>,\n+                                                 sizeof(std::pair<const int, int>) + sizeof(void*) * 4,\n+                                                 alignof(void*)>>;\n+    auto resource = Map::allocator_type::ResourceType(1024);\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    {\n+        auto resource_map = Map{0, std::hash<int>{}, std::equal_to<int>{}, &resource};\n+\n+        // can't have the same resource usage\n+        BOOST_TEST(memusage::DynamicUsage(std_map) != memusage::DynamicUsage(resource_map));\n+\n+        for (size_t i = 0; i < 10000; ++i) {\n+            std_map[i];\n+            resource_map[i];\n+        }\n+\n+        // Eventually the resource_map should have a much lower memory usage because it has less malloc overhead\n+        BOOST_TEST(memusage::DynamicUsage(resource_map) <= memusage::DynamicUsage(std_map) * 90 / 100);",
      "path": "src/test/pool_tests.cpp",
      "position": 184,
      "original_position": 170,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice. (In practice on my particular system, `86 / 100` is the lowest value that passes.)",
      "created_at": "2023-01-25T21:07:15Z",
      "updated_at": "2023-01-25T21:50:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1087172548",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087172548"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 184,
      "original_line": 184,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089264098",
      "pull_request_review_id": 1273173146,
      "id": 1089264098,
      "node_id": "PRRC_kwDOABII585A7Nni",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 225,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32",
      "in_reply_to_id": 1084564591,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nice find, I'll change the `if`",
      "created_at": "2023-01-27T18:02:27Z",
      "updated_at": "2023-01-27T18:02:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089264098",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089264098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089267866",
      "pull_request_review_id": 1273179379,
      "id": 1089267866,
      "node_id": "PRRC_kwDOABII585A7Oia",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 261,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1085963632,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, this is unused; I originally used this in the `operator==`. I'll remove it",
      "created_at": "2023-01-27T18:06:59Z",
      "updated_at": "2023-01-27T18:07:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089267866",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089267866"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089285815",
      "pull_request_review_id": 1273216602,
      "id": 1089285815,
      "node_id": "PRRC_kwDOABII585A7S63",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 117,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1085967553,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "right, also the .get() is no more",
      "created_at": "2023-01-27T18:26:03Z",
      "updated_at": "2023-01-27T18:26:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089285815",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089285815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089290030",
      "pull_request_review_id": 1273228793,
      "id": 1089290030,
      "node_id": "PRRC_kwDOABII585A7T8u",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 105,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1085970688,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It should be `n*ELEM_ALIGN_BYTES`",
      "created_at": "2023-01-27T18:31:02Z",
      "updated_at": "2023-01-27T18:31:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089290030",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089290030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089291634",
      "pull_request_review_id": 1273232771,
      "id": 1089291634,
      "node_id": "PRRC_kwDOABII585A7UVy",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128\n+            std::size_t size = (InsecureRandRange(2000) / alignment + 1) * alignment; // multiple of alignment\n+            void* ptr = resource.Allocate(size, alignment);\n+            BOOST_TEST(ptr != nullptr);\n+            BOOST_TEST((reinterpret_cast<uintptr_t>(ptr) & (alignment - 1)) == 0);\n+            ptr_size_alignment.push_back({ptr, size, alignment});\n+        } else {\n+            // deallocate a random item\n+            auto& x = ptr_size_alignment[InsecureRandRange(ptr_size_alignment.size())];\n+            resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+            x = ptr_size_alignment.back();\n+            ptr_size_alignment.pop_back();\n+        }\n+    }\n+\n+    // deallocate all the rest\n+    for (auto const& x : ptr_size_alignment) {\n+        resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(memusage_test)\n+{\n+    auto std_map = std::unordered_map<int, int>{};\n+\n+    using Map = std::unordered_map<int,\n+                                   int,\n+                                   std::hash<int>,\n+                                   std::equal_to<int>,\n+                                   PoolAllocator<std::pair<const int, int>,\n+                                                 sizeof(std::pair<const int, int>) + sizeof(void*) * 4,\n+                                                 alignof(void*)>>;\n+    auto resource = Map::allocator_type::ResourceType(1024);\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    {\n+        auto resource_map = Map{0, std::hash<int>{}, std::equal_to<int>{}, &resource};\n+\n+        // can't have the same resource usage\n+        BOOST_TEST(memusage::DynamicUsage(std_map) != memusage::DynamicUsage(resource_map));\n+\n+        for (size_t i = 0; i < 10000; ++i) {\n+            std_map[i];\n+            resource_map[i];\n+        }\n+\n+        // Eventually the resource_map should have a much lower memory usage because it has less malloc overhead\n+        BOOST_TEST(memusage::DynamicUsage(resource_map) <= memusage::DynamicUsage(std_map) * 90 / 100);",
      "path": "src/test/pool_tests.cpp",
      "position": 184,
      "original_position": 170,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1087172548,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the savings are a bit less than 86/100 on 32bit due to 32bit alignment, that's why I have the number a bit on the high side here",
      "created_at": "2023-01-27T18:32:56Z",
      "updated_at": "2023-01-27T18:32:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089291634",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089291634"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 184,
      "original_line": 184,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089308331",
      "pull_request_review_id": 1273277158,
      "id": 1089308331,
      "node_id": "PRRC_kwDOABII585A7Yar",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;\n+\n+    template <class U>\n+    PoolAllocator(const PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& other) noexcept\n+        : m_resource(other.resource())\n+    {\n+    }\n+\n+    /**\n+     * The rebind struct here is mandatory because we use non type template arguments for\n+     * PoolAllocator. See https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+    };\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        return static_cast<T*>(m_resource->Allocate(n * sizeof(T), alignof(T)));\n+    }\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    void deallocate(T* p, size_t n) noexcept\n+    {\n+        m_resource->Deallocate(p, n * sizeof(T), alignof(T));\n+    }\n+\n+    ResourceType* resource() const noexcept\n+    {\n+        return m_resource;\n+    }\n+};\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator==(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{\n+    return a.resource() == b.resource();\n+}\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator!=(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{",
      "path": "src/support/allocators/pool.h",
      "position": 345,
      "original_position": 354,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1086988389,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's not actually used anywhere currently, but this is needed when move-assigning containers that use the allocator. The containers need to check in a move-assignment if the allocators `operator==` returns true or false, and if they return true it means that both containers use the same resource and they can just destroy lhs and then move the pointers of rhs to lhs without copying elements. When they don't compare equal when the resource is different, all the objects in rhs need to be recreated.\r\n\r\nThe best explanation that I found for this stuff is this post from Howard Hinnant (he wrote `std::chrono` among other things) : https://stackoverflow.com/a/27472502/48181",
      "created_at": "2023-01-27T18:52:43Z",
      "updated_at": "2023-01-27T18:52:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089308331",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089308331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089464988",
      "pull_request_review_id": 1273528688,
      "id": 1089464988,
      "node_id": "PRRC_kwDOABII585A7-qc",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "path": "src/support/allocators/pool.h",
      "position": 296,
      "original_position": 305,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1086981056,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Moving is useless for this class, as all it holds is a pointer as member variable. Copying and moving a pointer is the same.",
      "created_at": "2023-01-27T21:45:25Z",
      "updated_at": "2023-01-27T21:45:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089464988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089464988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 296,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089475233",
      "pull_request_review_id": 1273544582,
      "id": 1089475233,
      "node_id": "PRRC_kwDOABII585A8BKh",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "path": "src/support/allocators/pool.h",
      "position": 296,
      "original_position": 305,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1086981056,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks. I wondered if the move constructor is used, because while this branch compiles for me (Clang 15 on ARM64) with the move assignment disabled (`PoolAllocator& operator=(PoolAllocator&&) noexcept = delete;`), it doesn't build with the move constructor disabled (`PoolAllocator(PoolAllocator&&) noexcept = delete;`).\r\n\r\n```\r\n./coins.h:230:33: note: in instantiation of member function 'std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher, std::equal_to<COutPoint>, PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>, 128, 8>>::unordered_map' requested here\r\n    mutable CCoinsMap cacheCoins{0, CCoinsMap::hasher{}, CCoinsMap::key_equal{}, &m_cache_coins_memory_resource};\r\n                                ^\r\n./support/allocators/pool.h:297:5: note: 'PoolAllocator' has been explicitly marked deleted here\r\n    PoolAllocator(PoolAllocator&&) noexcept = delete;\r\n    ^\r\n1 error generated.\r\n```",
      "created_at": "2023-01-27T21:59:55Z",
      "updated_at": "2023-01-27T21:59:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089475233",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089475233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 296,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646554",
      "pull_request_review_id": 1273801553,
      "id": 1089646554,
      "node_id": "PRRC_kwDOABII585A8q_a",
      "diff_hunk": "@@ -112,6 +112,7 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/pool_tests.cpp \\",
      "path": "src/Makefile.test.include",
      "position": null,
      "original_position": 4,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1083220507,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at": "2023-01-28T05:19:16Z",
      "updated_at": "2023-01-28T05:19:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646554",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646554"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646562",
      "pull_request_review_id": 1273801557,
      "id": 1089646562,
      "node_id": "PRRC_kwDOABII585A8q_i",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 225,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32",
      "in_reply_to_id": 1084564591,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at": "2023-01-28T05:19:22Z",
      "updated_at": "2023-01-28T05:19:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646562",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646562"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646577",
      "pull_request_review_id": 1273801564,
      "id": 1089646577,
      "node_id": "PRRC_kwDOABII585A8q_x",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 261,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1085963632,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at": "2023-01-28T05:19:28Z",
      "updated_at": "2023-01-28T05:19:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646577",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646584",
      "pull_request_review_id": 1273801573,
      "id": 1089646584,
      "node_id": "PRRC_kwDOABII585A8q_4",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 117,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1085967553,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at": "2023-01-28T05:19:35Z",
      "updated_at": "2023-01-28T05:19:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646584",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646608",
      "pull_request_review_id": 1273801589,
      "id": 1089646608,
      "node_id": "PRRC_kwDOABII585A8rAQ",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 105,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1085970688,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at": "2023-01-28T05:19:42Z",
      "updated_at": "2023-01-28T05:19:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646608",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089647580",
      "pull_request_review_id": 1273802345,
      "id": 1089647580,
      "node_id": "PRRC_kwDOABII585A8rPc",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "path": "src/support/allocators/pool.h",
      "position": 296,
      "original_position": 305,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "in_reply_to_id": 1086981056,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the problem with adding the `PoolAllocator(PoolAllocator&&) noexcept = delete;` is that it makes the function available for overload resolution, but if its chosen the compilation fails https://stackoverflow.com/a/35406415/48181",
      "created_at": "2023-01-28T05:23:43Z",
      "updated_at": "2023-01-28T05:23:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089647580",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089647580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 296,
      "original_line": 296,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117323095",
      "pull_request_review_id": 1313921906,
      "id": 1117323095,
      "node_id": "PRRC_kwDOABII585CmP9X",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 118,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "john-moffett",
        "id": 116917595,
        "node_id": "U_kgDOBvgFWw",
        "avatar_url": "https://avatars.githubusercontent.com/u/116917595?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/john-moffett",
        "html_url": "https://github.com/john-moffett",
        "followers_url": "https://api.github.com/users/john-moffett/followers",
        "following_url": "https://api.github.com/users/john-moffett/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/john-moffett/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/john-moffett/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/john-moffett/subscriptions",
        "organizations_url": "https://api.github.com/users/john-moffett/orgs",
        "repos_url": "https://api.github.com/users/john-moffett/repos",
        "events_url": "https://api.github.com/users/john-moffett/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/john-moffett/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`m_untouched_memory_end` now called `m_available_memory_end`",
      "created_at": "2023-02-24T17:01:36Z",
      "updated_at": "2023-02-24T17:12:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1117323095",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117323095"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117328292",
      "pull_request_review_id": 1313921906,
      "id": 1117328292,
      "node_id": "PRRC_kwDOABII585CmROk",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.",
      "path": "src/support/allocators/pool.h",
      "position": null,
      "original_position": 155,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "john-moffett",
        "id": 116917595,
        "node_id": "U_kgDOBvgFWw",
        "avatar_url": "https://avatars.githubusercontent.com/u/116917595?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/john-moffett",
        "html_url": "https://github.com/john-moffett",
        "followers_url": "https://api.github.com/users/john-moffett/followers",
        "following_url": "https://api.github.com/users/john-moffett/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/john-moffett/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/john-moffett/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/john-moffett/subscriptions",
        "organizations_url": "https://api.github.com/users/john-moffett/orgs",
        "repos_url": "https://api.github.com/users/john-moffett/repos",
        "events_url": "https://api.github.com/users/john-moffett/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/john-moffett/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Extra \"is\" after \"memory\".",
      "created_at": "2023-02-24T17:04:53Z",
      "updated_at": "2023-02-24T17:12:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1117328292",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117328292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124914676",
      "pull_request_review_id": 1324475821,
      "id": 1124914676,
      "node_id": "PRRC_kwDOABII585DDNX0",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");",
      "path": "src/support/allocators/pool.h",
      "position": 91,
      "original_position": 91,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this condition is guaranteed by the other static assertions, but this expression seems incorrect. In general, `A & (B-1) == 0` doesn't mean that A is a multiple of B, does it? If A=8 and B=3, then `8 & (3-1)` is zero, but 8 isn't a multiple of 3. If A=8, B=4, then `8 & (4-1)` is also zero, so we get the correct result (8 is a multiple of 4), but it's kind of by accident. To state it differently, if `MAX_BLOCK_SIZE_BYTES` is some large power of 2 (which is guaranteed above), then in binary it's `1000...0`, so ANDing with any smaller value will always produce zero.\r\n\r\nMaybe this is better:\r\n```suggestion\r\n    static_assert((MAX_BLOCK_SIZE_BYTES % ELEM_ALIGN_BYTES) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\r\n```\r\n",
      "created_at": "2023-03-03T19:18:22Z",
      "updated_at": "2023-03-04T08:12:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1124914676",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124914676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 91,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125417231",
      "pull_request_review_id": 1324475821,
      "id": 1125417231,
      "node_id": "PRRC_kwDOABII585DFIEP",
      "diff_hunk": "@@ -131,7 +132,15 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+using CCoinsMap = std::unordered_map<COutPoint,\n+                                     CCoinsCacheEntry,\n+                                     SaltedOutpointHasher,\n+                                     std::equal_to<COutPoint>,\n+                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,\n+                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4,",
      "path": "src/coins.h",
      "position": 26,
      "original_position": 18,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't understand the purpose of adding `sizeof(void*) * 4`; could you leave a brief comment if you get the chance? (Unless I'm just being clueless!)",
      "created_at": "2023-03-04T08:09:04Z",
      "updated_at": "2023-03-04T08:12:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1125417231",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125417231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 148,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443783",
      "pull_request_review_id": 1324997430,
      "id": 1125443783,
      "node_id": "PRRC_kwDOABII585DFOjH",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");",
      "path": "src/support/allocators/pool.h",
      "position": 91,
      "original_position": 91,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1124914676,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In line 89 there is an assert that `ELEM_ALIGN_BYTES` is multiple of 2:\r\n```cpp\r\nstatic_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\r\n```\r\nSo given that line 91 should make sense, `ELEM_ALIGN_BYTES - 1` becomes a bitmask and actually asserts that `MAX_BLOCK_SIZE_BYTES` is multiple of `ELEM_ALIGN_BYTES`. But right, on its own that assert wouldn't be enough and using `%` is probably a bit more clear.",
      "created_at": "2023-03-04T11:10:04Z",
      "updated_at": "2023-03-04T11:10:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1125443783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 91,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443786",
      "pull_request_review_id": 1324997436,
      "id": 1125443786,
      "node_id": "PRRC_kwDOABII585DFOjK",
      "diff_hunk": "@@ -131,7 +132,15 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+using CCoinsMap = std::unordered_map<COutPoint,\n+                                     CCoinsCacheEntry,\n+                                     SaltedOutpointHasher,\n+                                     std::equal_to<COutPoint>,\n+                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,\n+                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4,",
      "path": "src/coins.h",
      "position": 26,
      "original_position": 18,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1125417231,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Posting here now, I can add this as a comment later: \r\n\r\nThe value here determines the maximum bytes that the `PoolAllocator` supports. When bigger blocks are allocated, this is just forwarded to `new`.\r\n\r\nThe thing with `sizeof(void*) * 4` is, it is not enough to just support up to sizes of the `std::pair<const COutPoint, CCoinsCacheEntry>`, because the different implementations of `std::unordered_map` use more memory for each node. Most implementations wrap the std::pair into a struct that contains a single pointer, so they can link them in a single linked list. But not all; e.g. Microsoft's STL uses a double linked list. Also libstd++ and libc++ wrap the pair differently, which can lead to different memory usage due to alignement, and some might store the hash value as well; depending on if the hash'es `operator()` is `noexcept` or not. All in all, correctly determining the size used for allocation is really hard and brittle because this depends on a lot of implementation details.\r\n\r\nSo with adding 4 * the size of a pointer we err on the safe side; and nodes can surely be allocated with all implementions of std::unordered_map. `m_free_lists` might be a bit larger than it needs to be and have a few pointers that never hold a freelist, but at least we can be sure that `std::unordered_map` nodes are actually allocated with the pool.",
      "created_at": "2023-03-04T11:10:05Z",
      "updated_at": "2023-03-05T08:30:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1125443786",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443786"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 148,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128581100",
      "pull_request_review_id": 1329522422,
      "id": 1128581100,
      "node_id": "PRRC_kwDOABII585DRMfs",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>",
      "path": "src/support/allocators/pool.h",
      "position": 69,
      "original_position": 69,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why is `std::size_t` preferred over `size_t` within this file?",
      "created_at": "2023-03-07T20:59:16Z",
      "updated_at": "2023-03-08T15:18:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1128581100",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128581100"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 69,
      "original_line": 69,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128596813",
      "pull_request_review_id": 1329522422,
      "id": 1128596813,
      "node_id": "PRRC_kwDOABII585DRQVN",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);",
      "path": "src/support/allocators/pool.h",
      "position": 156,
      "original_position": 156,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Possibly related to https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1084564591, the first time this runs, both `m_available_memory_it` and `m_available_memory_end` are `nullptr`; is it UB to pass these to `std::distance()`? I think it's okay, just wanted to raise as a possible concern. You could do something like\r\n```suggestion\r\n        size_t remaining_available_bytes = m_available_memory_it ? std::distance(m_available_memory_it, m_available_memory_end) : 0;\r\n```",
      "created_at": "2023-03-07T21:13:46Z",
      "updated_at": "2023-03-08T15:18:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1128596813",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128596813"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 156,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129602006",
      "pull_request_review_id": 1329522422,
      "id": 1129602006,
      "node_id": "PRRC_kwDOABII585DVFvW",
      "diff_hunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <support/allocators/pool.h>\n+\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    size_t batch_size = 5000;\n+\n+    // make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.\n+    // do this at least 10 times so we get reasonable accurate results\n+\n+    bench.batch(batch_size).minEpochIterations(10).run([&] {\n+        auto rng = ankerl::nanobench::Rng(1234);\n+        for (size_t i = 0; i < batch_size; ++i) {\n+            map[rng()];\n+        }\n+        map.clear();\n+    });",
      "path": "src/bench/pool.cpp",
      "position": 24,
      "original_position": 24,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This benchmark doesn't re-use memory (add to freelist then remove from freelist); maybe it would be better if it did because that's what happens with the real coins cache, maybe something like this:\r\n\r\n<details>\r\n<summary>patch</summary>\r\n\r\n```diff\r\n-    size_t batch_size = 5000;\r\n+    // The steady-state size of the map will be half of this value;\r\n+    // power-of-2 to avoid expensive mod operation during benchmark.\r\n+    constexpr size_t batch_size = 1 << 13;\r\n \r\n     // make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.\r\n     // do this at least 10 times so we get reasonable accurate results\r\n \r\n     bench.batch(batch_size).minEpochIterations(10).run([&] {\r\n         auto rng = ankerl::nanobench::Rng(1234);\r\n-        for (size_t i = 0; i < batch_size; ++i) {\r\n-            map[rng()];\r\n+        for (size_t i = 0; i < batch_size * 10; ++i) {\r\n+            uint64_t r{rng()};\r\n+            // if the map has few entries, more likely add an entry, else delete\r\n+            if ((r & (batch_size-1)) < map.size()) {\r\n+                map.erase(map.begin());\r\n+            } else {\r\n+                map[r];\r\n+            }\r\n         }\r\n         map.clear();\r\n     });\r\n```\r\n</details>\r\n\r\nI don't think it matters which entry we delete, since `map.begin()` could return any entry. Deleting a truly random entry gets more complicated, and I don't think it changes the performance significantly. The loop iterates `batch_size * 10` instead of `batch_size` so we reach steady-state (about equal numbers of insertions and deletions).",
      "created_at": "2023-03-08T15:15:44Z",
      "updated_at": "2023-03-08T15:18:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129602006",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129602006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": 13,
      "original_start_line": 13,
      "start_side": "RIGHT",
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129641656",
      "pull_request_review_id": 1330928582,
      "id": 1129641656,
      "node_id": "PRRC_kwDOABII585DVPa4",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);",
      "path": "src/support/allocators/pool.h",
      "position": 156,
      "original_position": 156,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1128596813,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is explicitly defined in the standard here, in 5.1: http://eel.is/c++draft/expr.add#5",
      "created_at": "2023-03-08T15:41:04Z",
      "updated_at": "2023-03-08T15:41:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129641656",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129641656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 156,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129645169",
      "pull_request_review_id": 1330932760,
      "id": 1129645169,
      "node_id": "PRRC_kwDOABII585DVQRx",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>",
      "path": "src/support/allocators/pool.h",
      "position": 69,
      "original_position": 69,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1128581100,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No real reason. Technically in C++ I believe `std::size_t` should be preferred, especially when using includes like `<cstddef>` instead of `<stddef.h>`. I personally usually use just `size_t` everywhere and never had a compile problem.",
      "created_at": "2023-03-08T15:43:20Z",
      "updated_at": "2023-03-08T15:43:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129645169",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129645169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 69,
      "original_line": 69,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129650014",
      "pull_request_review_id": 1330938802,
      "id": 1129650014,
      "node_id": "PRRC_kwDOABII585DVRde",
      "diff_hunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <support/allocators/pool.h>\n+\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    size_t batch_size = 5000;\n+\n+    // make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.\n+    // do this at least 10 times so we get reasonable accurate results\n+\n+    bench.batch(batch_size).minEpochIterations(10).run([&] {\n+        auto rng = ankerl::nanobench::Rng(1234);\n+        for (size_t i = 0; i < batch_size; ++i) {\n+            map[rng()];\n+        }\n+        map.clear();\n+    });",
      "path": "src/bench/pool.cpp",
      "position": 24,
      "original_position": 24,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1129602006,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually it does reuse memory, when calling `map.clear()` all of the entries of the map are deallocated and thus the `pool_resource` gets them and puts them into the freelist. The memory is only ever released in the destructor of `pool_resource`",
      "created_at": "2023-03-08T15:46:30Z",
      "updated_at": "2023-03-08T15:47:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129650014",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129650014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": 13,
      "original_start_line": 13,
      "start_side": "RIGHT",
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129703688",
      "pull_request_review_id": 1331004938,
      "id": 1129703688,
      "node_id": "PRRC_kwDOABII585DVekI",
      "diff_hunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <support/allocators/pool.h>\n+\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    size_t batch_size = 5000;\n+\n+    // make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.\n+    // do this at least 10 times so we get reasonable accurate results\n+\n+    bench.batch(batch_size).minEpochIterations(10).run([&] {\n+        auto rng = ankerl::nanobench::Rng(1234);\n+        for (size_t i = 0; i < batch_size; ++i) {\n+            map[rng()];\n+        }\n+        map.clear();\n+    });",
      "path": "src/bench/pool.cpp",
      "position": 24,
      "original_position": 24,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1129602006,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's a good point, I hadn't noticed that. But perhaps it's good to make the load more realistic to get better benchmarking results. I'm assuming that when UTXOs become spent TXOs during block validation, they're removed from this unordered_map, but maybe that's not true? Just seems like doing many interleaving allocations and deallocations would be more realistic, but maybe not. But this suggestion is non-blocking.\r\n\r\nIn case anyone is wondering, I observed that the benchmark does cause allocations (and deallocations) that are too large for the pool, and these are for the hash bucket arrays. (I'm sure the fuzzer does that too, so far I've run only the benchmark.)",
      "created_at": "2023-03-08T16:17:58Z",
      "updated_at": "2023-03-08T16:17:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129703688",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129703688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": 13,
      "original_start_line": 13,
      "start_side": "RIGHT",
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144023009",
      "pull_request_review_id": 1351433045,
      "id": 1144023009,
      "node_id": "PRRC_kwDOABII585EMGfh",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            assert(free_block.ptr == chunk_ptr_remaining);                   // ensure addresses match\n+            assert(free_block.size <= chunk_size_remaining);                 // ensure we no overflow",
      "path": "src/test/util/poolresourcetester.h",
      "position": null,
      "original_position": 116,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n            assert(free_block.size <= chunk_size_remaining);                 // ensure no overflow\r\n```",
      "created_at": "2023-03-21T21:48:20Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144023009",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144023009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 116,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025036",
      "pull_request_review_id": 1351433045,
      "id": 1144025036,
      "node_id": "PRRC_kwDOABII585EMG_M",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 121,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n            std::size_t alignment = std::size_t{1} << InsecureRandRange(8);           // 1, 2, ..., 128\r\n```",
      "created_at": "2023-03-21T21:51:08Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144025036",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025036"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025651",
      "pull_request_review_id": 1351433045,
      "id": 1144025651,
      "node_id": "PRRC_kwDOABII585EMHIz",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {",
      "path": "src/test/util/poolresourcetester.h",
      "position": null,
      "original_position": 95,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        for (const std::byte* ptr : resource.m_allocated_chunks) {\r\n```",
      "created_at": "2023-03-21T21:52:02Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144025651",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144026131",
      "pull_request_review_id": 1351433045,
      "id": 1144026131,
      "node_id": "PRRC_kwDOABII585EMHQT",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            assert(free_block.ptr == chunk_ptr_remaining);                   // ensure addresses match\n+            assert(free_block.size <= chunk_size_remaining);                 // ensure we no overflow\n+            assert((free_block.ptr & (resource.ELEM_ALIGN_BYTES - 1)) == 0); // ensure correct alignment\n+            chunk_ptr_remaining += free_block.size;\n+            chunk_size_remaining -= free_block.size;\n+        }\n+        assert(chunk_ptr_remaining == chunks.back().ptr + chunks.back().size); // ensure we are t the end of the chunks",
      "path": "src/test/util/poolresourcetester.h",
      "position": null,
      "original_position": 121,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, this would test slightly more\r\n```suggestion\r\n        assert(chunk_ptr_remaining == chunk_it->ptr + chunk_it->size); // ensure we are at the end of the chunks\r\n        ++chunk_it;\r\n        assert(chunk_it == chunks.end());\r\n```",
      "created_at": "2023-03-21T21:52:37Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144026131",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144026131"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144046537",
      "pull_request_review_id": 1351433045,
      "id": 1144046537,
      "node_id": "PRRC_kwDOABII585EMMPJ",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }",
      "path": "src/test/util/poolresourcetester.h",
      "position": 85,
      "original_position": 85,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Probably not important, but if a bug caused a cycle in a freelist, I think the test would allocate an unbounded amount of memory (pushing to `free_blocks`), which would be not a nice way to fail. I think you could calculate an upper bound of the number of free blocks (number of chunks times chunk size divided by this free list's blocksize), then assert if the number of iterations exceeds that number.",
      "created_at": "2023-03-21T22:20:54Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144046537",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144046537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": 82,
      "original_start_line": 82,
      "start_side": "RIGHT",
      "line": 85,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144070292",
      "pull_request_review_id": 1351433045,
      "id": 1144070292,
      "node_id": "PRRC_kwDOABII585EMSCU",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 40,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, and would this make the test too specific? I don't think so, but something to consider.\r\n```suggestion\r\n    void* b = resource.Allocate(8, 1);\r\n    BOOST_TEST(block == b);\r\n```",
      "created_at": "2023-03-21T22:59:58Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144070292",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144070292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144072741",
      "pull_request_review_id": 1351433045,
      "id": 1144072741,
      "node_id": "PRRC_kwDOABII585EMSol",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 50,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // can't use resource because alignment is too big, allocate system memory\r\n    b = resource.Allocate(8, 16);\r\n    BOOST_TEST(block == b);\r\n    block = b;\r\n```",
      "created_at": "2023-03-21T23:04:47Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144072741",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144072741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": 49,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144076687",
      "pull_request_review_id": 1351433045,
      "id": 1144076687,
      "node_id": "PRRC_kwDOABII585EMTmP",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);",
      "path": "src/test/pool_tests.cpp",
      "position": 64,
      "original_position": 61,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    // can't use resource because size is too big, allocate system memory\r\n    b = resource.Allocate(16, 8);\r\n    BOOST_TEST(block != b);\r\n    block = b;\r\n\r\n```",
      "created_at": "2023-03-21T23:12:24Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144076687",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144076687"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": 63,
      "original_start_line": 60,
      "start_side": "RIGHT",
      "line": 64,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144079597",
      "pull_request_review_id": 1351433045,
      "id": 1144079597,
      "node_id": "PRRC_kwDOABII585EMUTt",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 76,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`counts` is unused",
      "created_at": "2023-03-21T23:18:14Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144079597",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144079597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144084403",
      "pull_request_review_id": 1351433045,
      "id": 1144084403,
      "node_id": "PRRC_kwDOABII585EMVez",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        // set each byte to num_bytes\r\n```",
      "created_at": "2023-03-21T23:26:43Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144084403",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144084403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100307",
      "pull_request_review_id": 1351433045,
      "id": 1144100307,
      "node_id": "PRRC_kwDOABII585EMZXT",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "path": "src/test/pool_tests.cpp",
      "position": 86,
      "original_position": 72,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This test doesn't allocate zero bytes, it allocates 1 to n bytes. It seems like zero-byte allocations should be allowed. See comments below.",
      "created_at": "2023-03-21T23:59:59Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144100307",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100854",
      "pull_request_review_id": 1351433045,
      "id": 1144100854,
      "node_id": "PRRC_kwDOABII585EMZf2",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 83,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If we want to test zero-length allocations (but requires a change to `Deallocate()`, see comment there).\r\n```suggestion\r\n    for (uint8_t num_bytes = 0; num_bytes < num_allocs; ++num_bytes) {\r\n```",
      "created_at": "2023-03-22T00:01:12Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144100854",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144101007",
      "pull_request_review_id": 1351433045,
      "id": 1144101007,
      "node_id": "PRRC_kwDOABII585EMZiP",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If we want to test zero-length allocations (but requires a change to `Deallocate()`, see comment there).\r\n```suggestion\r\n    uint8_t val = 0;\r\n```",
      "created_at": "2023-03-22T00:01:34Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144101007",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144101007"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144103123",
      "pull_request_review_id": 1351433045,
      "id": 1144103123,
      "node_id": "PRRC_kwDOABII585EMaDT",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const std::ptrdiff_t round_bytes = static_cast<std::ptrdiff_t>(num_alignments * ELEM_ALIGN_BYTES);\n+            if (round_bytes > m_available_memory_end - m_available_memory_it) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);",
      "path": "src/support/allocators/pool.h",
      "position": 247,
      "original_position": 247,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This allows zero-byte allocations, which I think is supported by the standard allocator, so we should too (right?) I benchmarked this change and there was no difference, but my benchmark setup is not very good, so that should definitely be tested.\r\n```suggestion\r\n            if (bytes > 0) {\r\n                const std::size_t num_alignments = NumElemAlignBytes(bytes);\r\n                // put the memory block into the linked list. We can placement construct the FreeList\r\n                // into the memory since we can be sure the alignment is correct.\r\n                PlacementAddToList(p, m_free_lists[num_alignments]);\r\n            }\r\n```",
      "created_at": "2023-03-22T00:06:46Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144103123",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144103123"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": 244,
      "original_start_line": 244,
      "start_side": "RIGHT",
      "line": 247,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144123098",
      "pull_request_review_id": 1351433045,
      "id": 1144123098,
      "node_id": "PRRC_kwDOABII585EMe7a",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128\n+            std::size_t size = (InsecureRandRange(2000) / alignment + 1) * alignment; // multiple of alignment",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 122,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This change will cause the pool resource allocator to be used much more often (since the max block size is 128).\r\n```suggestion\r\n            std::size_t size = (InsecureRandRange(200) / alignment + 1) * alignment;  // multiple of alignment\r\n```",
      "created_at": "2023-03-22T00:53:33Z",
      "updated_at": "2023-03-22T01:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144123098",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144123098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145197139",
      "pull_request_review_id": 1353164917,
      "id": 1145197139,
      "node_id": "PRRC_kwDOABII585EQlJT",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 50,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144072741,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That here would be `BOOST_TEST(block != b)`, because since `b` now has to come from the `::operator new` and not from the freelist",
      "created_at": "2023-03-22T17:42:03Z",
      "updated_at": "2023-03-22T17:42:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145197139",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145197139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": 49,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145200479",
      "pull_request_review_id": 1353169975,
      "id": 1145200479,
      "node_id": "PRRC_kwDOABII585EQl9f",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);",
      "path": "src/test/pool_tests.cpp",
      "position": 64,
      "original_position": 61,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144076687,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "With the above change, if I'm not mistaken I don't think it's safe to check for `BOOST_TEST(block != b)` here too. This too calls `::operator new`, and because the previous memory was deallocated already, it might give out the same block of memory, depending on however malloc is implemented",
      "created_at": "2023-03-22T17:45:14Z",
      "updated_at": "2023-03-22T17:45:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145200479",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145200479"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": 63,
      "original_start_line": 60,
      "start_side": "RIGHT",
      "line": 64,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145236261",
      "pull_request_review_id": 1353221884,
      "id": 1145236261,
      "node_id": "PRRC_kwDOABII585EQusl",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "path": "src/test/pool_tests.cpp",
      "position": 86,
      "original_position": 72,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144100307,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "After having a closer look, you are right that currently allocating & freeing 0 bytes does not work with the resource. But I think I can't allow allocating 0 bytes with the resource at all, because when allocating multple 0 bytes it would always give out the same pointer, and the standard says that this is not allowed: https://cplusplus.github.io/LWG/issue9\r\n\r\nSo I think the best solution is to just add a `bytes > 0` condition to `IsFreeListUsable`, so that `::operator new` will be used in that case.",
      "created_at": "2023-03-22T18:17:48Z",
      "updated_at": "2023-03-22T18:17:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145236261",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145236261"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145435338",
      "pull_request_review_id": 1353515008,
      "id": 1145435338,
      "node_id": "PRRC_kwDOABII585ERfTK",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "path": "src/test/pool_tests.cpp",
      "position": 86,
      "original_position": 72,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144100307,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Alternatively, just round up size 0 to be at least 1 alignment?",
      "created_at": "2023-03-22T21:38:42Z",
      "updated_at": "2023-03-22T21:43:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145435338",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145435338"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145478812",
      "pull_request_review_id": 1353572550,
      "id": 1145478812,
      "node_id": "PRRC_kwDOABII585ERp6c",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "path": "src/test/pool_tests.cpp",
      "position": 86,
      "original_position": 72,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144100307,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@martinus, good catch!\r\n@sipa, good idea, this does seem to work (hope this is what you meant):\r\n```\r\n     [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\r\n     {\r\n-        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\r\n+        return bytes > 0 ? ((bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES) : 1;\r\n     }\r\n```\r\nBenchmark results are identical for me, but this should be confirmed.",
      "created_at": "2023-03-22T22:40:34Z",
      "updated_at": "2023-03-22T22:40:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145478812",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145478812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145490940",
      "pull_request_review_id": 1353605999,
      "id": 1145490940,
      "node_id": "PRRC_kwDOABII585ERs38",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "path": "src/test/pool_tests.cpp",
      "position": 86,
      "original_position": 72,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144100307,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, or even:\r\n\r\n```c++\r\nreturn (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES + (bytes == 0);\r\n```\r\n\r\nwhich might be a minuscule amount faster.",
      "created_at": "2023-03-22T23:01:16Z",
      "updated_at": "2023-03-22T23:01:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145490940",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145490940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146502076",
      "pull_request_review_id": 1355086199,
      "id": 1146502076,
      "node_id": "PRRC_kwDOABII585EVju8",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "path": "src/test/pool_tests.cpp",
      "position": 86,
      "original_position": 72,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144100307,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's clever! They generate similar code, but this first way is slightly less code https://godbolt.org/z/Pz77TTEd8\r\n```\r\nint f(int bytes)\r\n{\r\n    return bytes > 0 ? (bytes+8-1)/8 : 1;\r\n}\r\n```\r\n\r\nOr https://godbolt.org/z/adzasoPad\r\n```\r\nint f(int bytes)\r\n{\r\n    return (bytes+8-1)/8 + (bytes == 0);\r\n}\r\n```\r\nThat's using x86-64 gcc 11.3; results are similar for x86-64 clang 16.0.0.",
      "created_at": "2023-03-23T17:02:37Z",
      "updated_at": "2023-03-23T17:02:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1146502076",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146502076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146560809",
      "pull_request_review_id": 1355173295,
      "id": 1146560809,
      "node_id": "PRRC_kwDOABII585EVyEp",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "path": "src/test/pool_tests.cpp",
      "position": 86,
      "original_position": 72,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144100307,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The code generation is a bit different when you use unsigned types, then the `+ (bytes == 0)` version is the shortedst for me. In my microbenchmark the `+ (bytes == 0)` is also fastest, but in practice its most likely irrelevant",
      "created_at": "2023-03-23T17:37:12Z",
      "updated_at": "2023-03-23T17:37:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1146560809",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146560809"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146653864",
      "pull_request_review_id": 1355311138,
      "id": 1146653864,
      "node_id": "PRRC_kwDOABII585EWIyo",
      "diff_hunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        ┌───┐                                ┌───┐  ┌────────────-------──────┐\n+ *        │   │  blocks                        │   ├─►│    262144 B             │\n+ *        │   │  ┌─────┐  ┌─────┐              └─┬─┘  └────────────-------──────┘\n+ *        │ 1 ├─►│ 8 B ├─►│ 8 B │                │\n+ *        │   │  └─────┘  └─────┘                :\n+ *        │   │                                  │\n+ *        │   │  ┌─────┐  ┌─────┐  ┌─────┐       ▼\n+ *        │ 2 ├─►│16 B ├─►│16 B ├─►│16 B │     ┌───┐  ┌─────────────────────────┐\n+ *        │   │  └─────┘  └─────┘  └─────┘     │   ├─►│          ▲              │ ▲\n+ *        │   │                                └───┘  └──────────┬──────────────┘ │\n+ *        │ . │                                                  │    m_available_memory_end\n+ *        │ . │                                         m_available_memory_it\n+ *        │ . │\n+ *        │   │\n+ *        │   │\n+ *        │16 │\n+ *        └───┘\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const std::ptrdiff_t round_bytes = static_cast<std::ptrdiff_t>(num_alignments * ELEM_ALIGN_BYTES);\n+            if (round_bytes > m_available_memory_end - m_available_memory_it) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);",
      "path": "src/support/allocators/pool.h",
      "position": 247,
      "original_position": 247,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144103123,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll implement the ` + (bytes == 0)` for NumElemAlignBytes",
      "created_at": "2023-03-23T18:30:28Z",
      "updated_at": "2023-03-23T18:30:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1146653864",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146653864"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": 244,
      "original_start_line": 244,
      "start_side": "RIGHT",
      "line": 247,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147123753",
      "pull_request_review_id": 1356009221,
      "id": 1147123753,
      "node_id": "PRRC_kwDOABII585EX7gp",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }",
      "path": "src/test/util/poolresourcetester.h",
      "position": 85,
      "original_position": 85,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144046537,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've left that out on purpose, I didn't want to complicate this code any further. So far this case never happened",
      "created_at": "2023-03-24T05:09:44Z",
      "updated_at": "2023-03-24T05:09:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147123753",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147123753"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": 82,
      "original_start_line": 82,
      "start_side": "RIGHT",
      "line": 85,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147124025",
      "pull_request_review_id": 1356009620,
      "id": 1147124025,
      "node_id": "PRRC_kwDOABII585EX7k5",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "path": "src/test/pool_tests.cpp",
      "position": 86,
      "original_position": 72,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144100307,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've implemented the `+ (bytes == 0)` version in 9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at": "2023-03-24T05:10:24Z",
      "updated_at": "2023-03-24T05:10:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147124025",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147124025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852238",
      "pull_request_review_id": 1357116645,
      "id": 1147852238,
      "node_id": "PRRC_kwDOABII585EatXO",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "path": "src/test/pool_tests.cpp",
      "position": 86,
      "original_position": 72,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144100307,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> The code generation is a bit different when you use unsigned types, then the `+ (bytes == 0)` version is the shortedst for me. In my microbenchmark the `+ (bytes == 0)` is also fastest, but in practice its most likely irrelevant\r\n\r\nYes, it seems to be one instruction shorter after updating @LarryRuane's examples (thanks for doing them) to `size_t` and checking with gcc 12.2 and clang 16.",
      "created_at": "2023-03-24T17:03:47Z",
      "updated_at": "2023-03-24T17:03:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147852238",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852238"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 86,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852733",
      "pull_request_review_id": 1357117819,
      "id": 1147852733,
      "node_id": "PRRC_kwDOABII585Eate9",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);",
      "path": "src/test/pool_tests.cpp",
      "position": null,
      "original_position": 50,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1144072741,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(Only if you have to retouch, or maybe in a follow-up), perhaps add this comment:\r\n\r\n```cpp\r\nBOOST_TEST(b != block); // as `b` has to come from `::operator new` and not from the freelist",
      "created_at": "2023-03-24T17:04:18Z",
      "updated_at": "2023-03-24T17:04:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147852733",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": 49,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422138",
      "pull_request_review_id": 1738642653,
      "id": 1398422138,
      "node_id": "PRRC_kwDOABII585TWjp6",
      "diff_hunk": "@@ -131,7 +132,15 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+using CCoinsMap = std::unordered_map<COutPoint,\n+                                     CCoinsCacheEntry,\n+                                     SaltedOutpointHasher,\n+                                     std::equal_to<COutPoint>,\n+                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,\n+                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4,",
      "path": "src/coins.h",
      "position": 26,
      "original_position": 18,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1125417231,
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@martinus\r\n\r\nCould assessing of the `std::unordered_map::node_type` improve this heuristic?",
      "created_at": "2023-11-19T15:34:19Z",
      "updated_at": "2023-11-19T15:34:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1398422138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 148,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422857",
      "pull_request_review_id": 1738643496,
      "id": 1398422857,
      "node_id": "PRRC_kwDOABII585TWj1J",
      "diff_hunk": "@@ -131,7 +132,15 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+using CCoinsMap = std::unordered_map<COutPoint,\n+                                     CCoinsCacheEntry,\n+                                     SaltedOutpointHasher,\n+                                     std::equal_to<COutPoint>,\n+                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,\n+                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4,",
      "path": "src/coins.h",
      "position": 26,
      "original_position": 18,
      "commit_id": "9f947fc3d4b779f017332135323b34e8f216f613",
      "original_commit_id": "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "in_reply_to_id": 1125417231,
      "user": {
        "login": "martinus",
        "id": 14386,
        "node_id": "MDQ6VXNlcjE0Mzg2",
        "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martinus",
        "html_url": "https://github.com/martinus",
        "followers_url": "https://api.github.com/users/martinus/followers",
        "following_url": "https://api.github.com/users/martinus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/martinus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/martinus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
        "organizations_url": "https://api.github.com/users/martinus/orgs",
        "repos_url": "https://api.github.com/users/martinus/repos",
        "events_url": "https://api.github.com/users/martinus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/martinus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@hebasto Unfortunately not, I actually wanted to use this but learned that this is actually just the type of the node handle which more or less is just a pointer to the data. The actual type of the node used for allocation is not exposed by the standard. If it were, it would make the pool implementation quite a bit simpler",
      "created_at": "2023-11-19T15:38:35Z",
      "updated_at": "2023-11-19T15:38:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1398422857",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422857"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 148,
      "original_line": 148,
      "side": "RIGHT"
    }
  ]
}